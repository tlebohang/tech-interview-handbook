
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Account
 * 
 */
export type Account = {
  id: string
  userId: string
  type: string
  provider: string
  providerAccountId: string
  refresh_token: string | null
  access_token: string | null
  expires_at: number | null
  token_type: string | null
  scope: string | null
  id_token: string | null
  session_state: string | null
}

/**
 * Model Session
 * 
 */
export type Session = {
  id: string
  sessionToken: string
  userId: string
  expires: Date
}

/**
 * Model User
 * 
 */
export type User = {
  id: string
  name: string | null
  email: string | null
  emailVerified: Date | null
  image: string | null
}

/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = {
  identifier: string
  token: string
  expires: Date
}

/**
 * Model Todo
 * 
 */
export type Todo = {
  id: string
  userId: string
  text: string
  status: TodoStatus
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Company
 * 
 */
export type Company = {
  id: string
  name: string
  slug: string
  description: string | null
  logoUrl: string | null
  website: string | null
  ranking: number | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Country
 * 
 */
export type Country = {
  id: string
  name: string
  code: string
  ranking: number | null
}

/**
 * Model State
 * 
 */
export type State = {
  id: string
  name: string
  countryId: string
}

/**
 * Model City
 * 
 */
export type City = {
  id: string
  name: string
  stateId: string
  ranking: number | null
}

/**
 * Model ResumesResume
 * 
 */
export type ResumesResume = {
  id: string
  userId: string
  title: string
  role: string
  experience: string
  locationId: string
  url: string
  additionalInfo: string | null
  isResolved: boolean
  createdAt: Date
  updatedAt: Date
}

/**
 * Model ResumesStar
 * 
 */
export type ResumesStar = {
  id: string
  userId: string
  resumeId: string
  createdAt: Date
}

/**
 * Model ResumesComment
 * 
 */
export type ResumesComment = {
  id: string
  userId: string
  resumeId: string
  parentId: string | null
  description: string
  section: ResumesSection
  createdAt: Date
  updatedAt: Date
}

/**
 * Model ResumesCommentVote
 * 
 */
export type ResumesCommentVote = {
  id: string
  userId: string
  commentId: string
  value: Vote
  createdAt: Date
  updatedAt: Date
}

/**
 * Model OffersProfile
 * 
 */
export type OffersProfile = {
  id: string
  profileName: string
  createdAt: Date
  editToken: string
}

/**
 * Model OffersAdmin
 * 
 */
export type OffersAdmin = {
  id: string
  userId: string
}

/**
 * Model OffersBackground
 * 
 */
export type OffersBackground = {
  id: string
  totalYoe: number
  offersProfileId: string
}

/**
 * Model OffersSpecificYoe
 * 
 */
export type OffersSpecificYoe = {
  id: string
  yoe: number
  domain: string
  backgroundId: string
}

/**
 * Model OffersExperience
 * 
 */
export type OffersExperience = {
  id: string
  companyId: string | null
  jobType: JobType | null
  title: string | null
  durationInMonths: number | null
  cityId: string | null
  level: string | null
  totalCompensationId: string | null
  monthlySalaryId: string | null
  backgroundId: string
}

/**
 * Model OffersCurrency
 * 
 */
export type OffersCurrency = {
  id: string
  createdAt: Date
  updatedAt: Date
  value: number
  currency: string
  baseValue: number
  baseCurrency: string
}

/**
 * Model OffersEducation
 * 
 */
export type OffersEducation = {
  id: string
  type: string | null
  field: string | null
  school: string | null
  startDate: Date | null
  endDate: Date | null
  backgroundId: string
}

/**
 * Model OffersReply
 * 
 */
export type OffersReply = {
  id: string
  createdAt: Date
  message: string
  replyingToId: string | null
  profileId: string
  userId: string | null
}

/**
 * Model OffersOffer
 * 
 */
export type OffersOffer = {
  id: string
  profileId: string
  companyId: string
  cityId: string
  monthYearReceived: Date
  negotiationStrategy: string
  comments: string
  jobType: JobType
  offersInternId: string | null
  offersFullTimeId: string | null
}

/**
 * Model OffersIntern
 * 
 */
export type OffersIntern = {
  id: string
  title: string
  internshipCycle: string
  startYear: number
  monthlySalaryId: string
}

/**
 * Model OffersFullTime
 * 
 */
export type OffersFullTime = {
  id: string
  title: string
  level: string
  totalCompensationId: string
  baseSalaryId: string | null
  bonusId: string | null
  stocksId: string | null
}

/**
 * Model OffersAnalysis
 * 
 */
export type OffersAnalysis = {
  id: string
  createdAt: Date
  updatedAt: Date
  profileId: string
  offerId: string
  overallAnalysisUnitId: string
}

/**
 * Model OffersAnalysisUnit
 * 
 */
export type OffersAnalysisUnit = {
  id: string
  analysedOfferId: string
  percentile: number
  noOfSimilarOffers: number
}

/**
 * Model QuestionsQuestion
 * 
 */
export type QuestionsQuestion = {
  id: string
  userId: string | null
  content: string
  questionType: QuestionsQuestionType
  lastSeenAt: Date | null
  upvotes: number
  numEncounters: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model QuestionsQuestionEncounter
 * 
 */
export type QuestionsQuestionEncounter = {
  id: string
  questionId: string
  userId: string | null
  companyId: string | null
  countryId: string | null
  stateId: string | null
  cityId: string | null
  role: string
  seenAt: Date
  createdAt: Date
  updatedAt: Date
}

/**
 * Model QuestionsQuestionVote
 * 
 */
export type QuestionsQuestionVote = {
  id: string
  questionId: string
  userId: string | null
  vote: Vote
  createdAt: Date
  updatedAt: Date
}

/**
 * Model QuestionsQuestionComment
 * 
 */
export type QuestionsQuestionComment = {
  id: string
  questionId: string
  userId: string | null
  upvotes: number
  content: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model QuestionsQuestionCommentVote
 * 
 */
export type QuestionsQuestionCommentVote = {
  id: string
  questionCommentId: string
  userId: string | null
  vote: Vote
  createdAt: Date
  updatedAt: Date
}

/**
 * Model QuestionsAnswer
 * 
 */
export type QuestionsAnswer = {
  id: string
  questionId: string
  userId: string | null
  content: string
  upvotes: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model QuestionsAnswerVote
 * 
 */
export type QuestionsAnswerVote = {
  id: string
  answerId: string
  userId: string | null
  vote: Vote
  createdAt: Date
  updatedAt: Date
}

/**
 * Model QuestionsAnswerComment
 * 
 */
export type QuestionsAnswerComment = {
  id: string
  answerId: string
  userId: string | null
  content: string
  upvotes: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model QuestionsAnswerCommentVote
 * 
 */
export type QuestionsAnswerCommentVote = {
  id: string
  answerCommentId: string
  userId: string | null
  vote: Vote
  createdAt: Date
  updatedAt: Date
}

/**
 * Model QuestionsList
 * 
 */
export type QuestionsList = {
  id: string
  userId: string
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model QuestionsListQuestionEntry
 * 
 */
export type QuestionsListQuestionEntry = {
  id: string
  listId: string
  questionId: string
  createdAt: Date
  updatedAt: Date
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const JobType: {
  INTERN: 'INTERN',
  FULLTIME: 'FULLTIME'
};

export type JobType = (typeof JobType)[keyof typeof JobType]


export const QuestionsQuestionType: {
  CODING: 'CODING',
  SYSTEM_DESIGN: 'SYSTEM_DESIGN',
  BEHAVIORAL: 'BEHAVIORAL',
  THEORY: 'THEORY'
};

export type QuestionsQuestionType = (typeof QuestionsQuestionType)[keyof typeof QuestionsQuestionType]


export const ResumesSection: {
  GENERAL: 'GENERAL',
  EDUCATION: 'EDUCATION',
  EXPERIENCE: 'EXPERIENCE',
  PROJECTS: 'PROJECTS',
  SKILLS: 'SKILLS'
};

export type ResumesSection = (typeof ResumesSection)[keyof typeof ResumesSection]


export const TodoStatus: {
  INCOMPLETE: 'INCOMPLETE',
  COMPLETE: 'COMPLETE'
};

export type TodoStatus = (typeof TodoStatus)[keyof typeof TodoStatus]


export const Vote: {
  UPVOTE: 'UPVOTE',
  DOWNVOTE: 'DOWNVOTE'
};

export type Vote = (typeof Vote)[keyof typeof Vote]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>;

  $transaction<R>(fn: (prisma: Prisma.TransactionClient) => Promise<R>, options?: {maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel}): Promise<R>;

      /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<GlobalReject>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<GlobalReject>;

  /**
   * `prisma.todo`: Exposes CRUD operations for the **Todo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Todos
    * const todos = await prisma.todo.findMany()
    * ```
    */
  get todo(): Prisma.TodoDelegate<GlobalReject>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<GlobalReject>;

  /**
   * `prisma.country`: Exposes CRUD operations for the **Country** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.country.findMany()
    * ```
    */
  get country(): Prisma.CountryDelegate<GlobalReject>;

  /**
   * `prisma.state`: Exposes CRUD operations for the **State** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more States
    * const states = await prisma.state.findMany()
    * ```
    */
  get state(): Prisma.StateDelegate<GlobalReject>;

  /**
   * `prisma.city`: Exposes CRUD operations for the **City** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.city.findMany()
    * ```
    */
  get city(): Prisma.CityDelegate<GlobalReject>;

  /**
   * `prisma.resumesResume`: Exposes CRUD operations for the **ResumesResume** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResumesResumes
    * const resumesResumes = await prisma.resumesResume.findMany()
    * ```
    */
  get resumesResume(): Prisma.ResumesResumeDelegate<GlobalReject>;

  /**
   * `prisma.resumesStar`: Exposes CRUD operations for the **ResumesStar** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResumesStars
    * const resumesStars = await prisma.resumesStar.findMany()
    * ```
    */
  get resumesStar(): Prisma.ResumesStarDelegate<GlobalReject>;

  /**
   * `prisma.resumesComment`: Exposes CRUD operations for the **ResumesComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResumesComments
    * const resumesComments = await prisma.resumesComment.findMany()
    * ```
    */
  get resumesComment(): Prisma.ResumesCommentDelegate<GlobalReject>;

  /**
   * `prisma.resumesCommentVote`: Exposes CRUD operations for the **ResumesCommentVote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResumesCommentVotes
    * const resumesCommentVotes = await prisma.resumesCommentVote.findMany()
    * ```
    */
  get resumesCommentVote(): Prisma.ResumesCommentVoteDelegate<GlobalReject>;

  /**
   * `prisma.offersProfile`: Exposes CRUD operations for the **OffersProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OffersProfiles
    * const offersProfiles = await prisma.offersProfile.findMany()
    * ```
    */
  get offersProfile(): Prisma.OffersProfileDelegate<GlobalReject>;

  /**
   * `prisma.offersAdmin`: Exposes CRUD operations for the **OffersAdmin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OffersAdmins
    * const offersAdmins = await prisma.offersAdmin.findMany()
    * ```
    */
  get offersAdmin(): Prisma.OffersAdminDelegate<GlobalReject>;

  /**
   * `prisma.offersBackground`: Exposes CRUD operations for the **OffersBackground** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OffersBackgrounds
    * const offersBackgrounds = await prisma.offersBackground.findMany()
    * ```
    */
  get offersBackground(): Prisma.OffersBackgroundDelegate<GlobalReject>;

  /**
   * `prisma.offersSpecificYoe`: Exposes CRUD operations for the **OffersSpecificYoe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OffersSpecificYoes
    * const offersSpecificYoes = await prisma.offersSpecificYoe.findMany()
    * ```
    */
  get offersSpecificYoe(): Prisma.OffersSpecificYoeDelegate<GlobalReject>;

  /**
   * `prisma.offersExperience`: Exposes CRUD operations for the **OffersExperience** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OffersExperiences
    * const offersExperiences = await prisma.offersExperience.findMany()
    * ```
    */
  get offersExperience(): Prisma.OffersExperienceDelegate<GlobalReject>;

  /**
   * `prisma.offersCurrency`: Exposes CRUD operations for the **OffersCurrency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OffersCurrencies
    * const offersCurrencies = await prisma.offersCurrency.findMany()
    * ```
    */
  get offersCurrency(): Prisma.OffersCurrencyDelegate<GlobalReject>;

  /**
   * `prisma.offersEducation`: Exposes CRUD operations for the **OffersEducation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OffersEducations
    * const offersEducations = await prisma.offersEducation.findMany()
    * ```
    */
  get offersEducation(): Prisma.OffersEducationDelegate<GlobalReject>;

  /**
   * `prisma.offersReply`: Exposes CRUD operations for the **OffersReply** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OffersReplies
    * const offersReplies = await prisma.offersReply.findMany()
    * ```
    */
  get offersReply(): Prisma.OffersReplyDelegate<GlobalReject>;

  /**
   * `prisma.offersOffer`: Exposes CRUD operations for the **OffersOffer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OffersOffers
    * const offersOffers = await prisma.offersOffer.findMany()
    * ```
    */
  get offersOffer(): Prisma.OffersOfferDelegate<GlobalReject>;

  /**
   * `prisma.offersIntern`: Exposes CRUD operations for the **OffersIntern** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OffersInterns
    * const offersInterns = await prisma.offersIntern.findMany()
    * ```
    */
  get offersIntern(): Prisma.OffersInternDelegate<GlobalReject>;

  /**
   * `prisma.offersFullTime`: Exposes CRUD operations for the **OffersFullTime** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OffersFullTimes
    * const offersFullTimes = await prisma.offersFullTime.findMany()
    * ```
    */
  get offersFullTime(): Prisma.OffersFullTimeDelegate<GlobalReject>;

  /**
   * `prisma.offersAnalysis`: Exposes CRUD operations for the **OffersAnalysis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OffersAnalyses
    * const offersAnalyses = await prisma.offersAnalysis.findMany()
    * ```
    */
  get offersAnalysis(): Prisma.OffersAnalysisDelegate<GlobalReject>;

  /**
   * `prisma.offersAnalysisUnit`: Exposes CRUD operations for the **OffersAnalysisUnit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OffersAnalysisUnits
    * const offersAnalysisUnits = await prisma.offersAnalysisUnit.findMany()
    * ```
    */
  get offersAnalysisUnit(): Prisma.OffersAnalysisUnitDelegate<GlobalReject>;

  /**
   * `prisma.questionsQuestion`: Exposes CRUD operations for the **QuestionsQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionsQuestions
    * const questionsQuestions = await prisma.questionsQuestion.findMany()
    * ```
    */
  get questionsQuestion(): Prisma.QuestionsQuestionDelegate<GlobalReject>;

  /**
   * `prisma.questionsQuestionEncounter`: Exposes CRUD operations for the **QuestionsQuestionEncounter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionsQuestionEncounters
    * const questionsQuestionEncounters = await prisma.questionsQuestionEncounter.findMany()
    * ```
    */
  get questionsQuestionEncounter(): Prisma.QuestionsQuestionEncounterDelegate<GlobalReject>;

  /**
   * `prisma.questionsQuestionVote`: Exposes CRUD operations for the **QuestionsQuestionVote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionsQuestionVotes
    * const questionsQuestionVotes = await prisma.questionsQuestionVote.findMany()
    * ```
    */
  get questionsQuestionVote(): Prisma.QuestionsQuestionVoteDelegate<GlobalReject>;

  /**
   * `prisma.questionsQuestionComment`: Exposes CRUD operations for the **QuestionsQuestionComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionsQuestionComments
    * const questionsQuestionComments = await prisma.questionsQuestionComment.findMany()
    * ```
    */
  get questionsQuestionComment(): Prisma.QuestionsQuestionCommentDelegate<GlobalReject>;

  /**
   * `prisma.questionsQuestionCommentVote`: Exposes CRUD operations for the **QuestionsQuestionCommentVote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionsQuestionCommentVotes
    * const questionsQuestionCommentVotes = await prisma.questionsQuestionCommentVote.findMany()
    * ```
    */
  get questionsQuestionCommentVote(): Prisma.QuestionsQuestionCommentVoteDelegate<GlobalReject>;

  /**
   * `prisma.questionsAnswer`: Exposes CRUD operations for the **QuestionsAnswer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionsAnswers
    * const questionsAnswers = await prisma.questionsAnswer.findMany()
    * ```
    */
  get questionsAnswer(): Prisma.QuestionsAnswerDelegate<GlobalReject>;

  /**
   * `prisma.questionsAnswerVote`: Exposes CRUD operations for the **QuestionsAnswerVote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionsAnswerVotes
    * const questionsAnswerVotes = await prisma.questionsAnswerVote.findMany()
    * ```
    */
  get questionsAnswerVote(): Prisma.QuestionsAnswerVoteDelegate<GlobalReject>;

  /**
   * `prisma.questionsAnswerComment`: Exposes CRUD operations for the **QuestionsAnswerComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionsAnswerComments
    * const questionsAnswerComments = await prisma.questionsAnswerComment.findMany()
    * ```
    */
  get questionsAnswerComment(): Prisma.QuestionsAnswerCommentDelegate<GlobalReject>;

  /**
   * `prisma.questionsAnswerCommentVote`: Exposes CRUD operations for the **QuestionsAnswerCommentVote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionsAnswerCommentVotes
    * const questionsAnswerCommentVotes = await prisma.questionsAnswerCommentVote.findMany()
    * ```
    */
  get questionsAnswerCommentVote(): Prisma.QuestionsAnswerCommentVoteDelegate<GlobalReject>;

  /**
   * `prisma.questionsList`: Exposes CRUD operations for the **QuestionsList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionsLists
    * const questionsLists = await prisma.questionsList.findMany()
    * ```
    */
  get questionsList(): Prisma.QuestionsListDelegate<GlobalReject>;

  /**
   * `prisma.questionsListQuestionEntry`: Exposes CRUD operations for the **QuestionsListQuestionEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionsListQuestionEntries
    * const questionsListQuestionEntries = await prisma.questionsListQuestionEntry.findMany()
    * ```
    */
  get questionsListQuestionEntry(): Prisma.QuestionsListQuestionEntryDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export import Metrics = runtime.Metrics
  export import Metric = runtime.Metric
  export import MetricHistogram = runtime.MetricHistogram
  export import MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
   * Prisma Client JS version: 4.4.0
   * Query Engine version: f352a33b70356f46311da8b00d83386dd9f145d6
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export import FieldRef = runtime.FieldRef

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Account: 'Account',
    Session: 'Session',
    User: 'User',
    VerificationToken: 'VerificationToken',
    Todo: 'Todo',
    Company: 'Company',
    Country: 'Country',
    State: 'State',
    City: 'City',
    ResumesResume: 'ResumesResume',
    ResumesStar: 'ResumesStar',
    ResumesComment: 'ResumesComment',
    ResumesCommentVote: 'ResumesCommentVote',
    OffersProfile: 'OffersProfile',
    OffersAdmin: 'OffersAdmin',
    OffersBackground: 'OffersBackground',
    OffersSpecificYoe: 'OffersSpecificYoe',
    OffersExperience: 'OffersExperience',
    OffersCurrency: 'OffersCurrency',
    OffersEducation: 'OffersEducation',
    OffersReply: 'OffersReply',
    OffersOffer: 'OffersOffer',
    OffersIntern: 'OffersIntern',
    OffersFullTime: 'OffersFullTime',
    OffersAnalysis: 'OffersAnalysis',
    OffersAnalysisUnit: 'OffersAnalysisUnit',
    QuestionsQuestion: 'QuestionsQuestion',
    QuestionsQuestionEncounter: 'QuestionsQuestionEncounter',
    QuestionsQuestionVote: 'QuestionsQuestionVote',
    QuestionsQuestionComment: 'QuestionsQuestionComment',
    QuestionsQuestionCommentVote: 'QuestionsQuestionCommentVote',
    QuestionsAnswer: 'QuestionsAnswer',
    QuestionsAnswerVote: 'QuestionsAnswerVote',
    QuestionsAnswerComment: 'QuestionsAnswerComment',
    QuestionsAnswerCommentVote: 'QuestionsAnswerCommentVote',
    QuestionsList: 'QuestionsList',
    QuestionsListQuestionEntry: 'QuestionsListQuestionEntry'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;


  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<PrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    accounts: number
    sessions: number
    todos: number
    resumesResumes: number
    resumesStars: number
    resumesComments: number
    resumesCommentVotes: number
    questionsQuestions: number
    questionsQuestionEncounters: number
    questionsQuestionVotes: number
    questionsQuestionComments: number
    questionsQuestionCommentVotes: number
    questionsAnswers: number
    questionsAnswerVotes: number
    questionsAnswerComments: number
    questionsAnswerCommentVotes: number
    OffersProfile: number
    offersDiscussion: number
    questionsLists: number
  }

  export type UserCountOutputTypeSelect = {
    accounts?: boolean
    sessions?: boolean
    todos?: boolean
    resumesResumes?: boolean
    resumesStars?: boolean
    resumesComments?: boolean
    resumesCommentVotes?: boolean
    questionsQuestions?: boolean
    questionsQuestionEncounters?: boolean
    questionsQuestionVotes?: boolean
    questionsQuestionComments?: boolean
    questionsQuestionCommentVotes?: boolean
    questionsAnswers?: boolean
    questionsAnswerVotes?: boolean
    questionsAnswerComments?: boolean
    questionsAnswerCommentVotes?: boolean
    OffersProfile?: boolean
    offersDiscussion?: boolean
    questionsLists?: boolean
  }

  export type UserCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UserCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UserCountOutputType
    : S extends undefined
    ? never
    : S extends UserCountOutputTypeArgs
    ?'include' extends U
    ? UserCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
    : UserCountOutputType
  : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     * 
    **/
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type CompanyCountOutputType
   */


  export type CompanyCountOutputType = {
    questionsQuestionEncounter: number
    OffersExperience: number
    OffersOffer: number
  }

  export type CompanyCountOutputTypeSelect = {
    questionsQuestionEncounter?: boolean
    OffersExperience?: boolean
    OffersOffer?: boolean
  }

  export type CompanyCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CompanyCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CompanyCountOutputType
    : S extends undefined
    ? never
    : S extends CompanyCountOutputTypeArgs
    ?'include' extends U
    ? CompanyCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CompanyCountOutputType ? CompanyCountOutputType[P] : never
  } 
    : CompanyCountOutputType
  : CompanyCountOutputType




  // Custom InputTypes

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     * 
    **/
    select?: CompanyCountOutputTypeSelect | null
  }



  /**
   * Count Type CountryCountOutputType
   */


  export type CountryCountOutputType = {
    states: number
    questionsQuestionEncounters: number
    ResumesResume: number
  }

  export type CountryCountOutputTypeSelect = {
    states?: boolean
    questionsQuestionEncounters?: boolean
    ResumesResume?: boolean
  }

  export type CountryCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CountryCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CountryCountOutputType
    : S extends undefined
    ? never
    : S extends CountryCountOutputTypeArgs
    ?'include' extends U
    ? CountryCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CountryCountOutputType ? CountryCountOutputType[P] : never
  } 
    : CountryCountOutputType
  : CountryCountOutputType




  // Custom InputTypes

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CountryCountOutputType
     * 
    **/
    select?: CountryCountOutputTypeSelect | null
  }



  /**
   * Count Type StateCountOutputType
   */


  export type StateCountOutputType = {
    cities: number
    questionsQuestionEncounters: number
  }

  export type StateCountOutputTypeSelect = {
    cities?: boolean
    questionsQuestionEncounters?: boolean
  }

  export type StateCountOutputTypeGetPayload<
    S extends boolean | null | undefined | StateCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? StateCountOutputType
    : S extends undefined
    ? never
    : S extends StateCountOutputTypeArgs
    ?'include' extends U
    ? StateCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof StateCountOutputType ? StateCountOutputType[P] : never
  } 
    : StateCountOutputType
  : StateCountOutputType




  // Custom InputTypes

  /**
   * StateCountOutputType without action
   */
  export type StateCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the StateCountOutputType
     * 
    **/
    select?: StateCountOutputTypeSelect | null
  }



  /**
   * Count Type CityCountOutputType
   */


  export type CityCountOutputType = {
    questionsQuestionEncounters: number
    OffersExperience: number
    OffersOffer: number
  }

  export type CityCountOutputTypeSelect = {
    questionsQuestionEncounters?: boolean
    OffersExperience?: boolean
    OffersOffer?: boolean
  }

  export type CityCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CityCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CityCountOutputType
    : S extends undefined
    ? never
    : S extends CityCountOutputTypeArgs
    ?'include' extends U
    ? CityCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CityCountOutputType ? CityCountOutputType[P] : never
  } 
    : CityCountOutputType
  : CityCountOutputType




  // Custom InputTypes

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CityCountOutputType
     * 
    **/
    select?: CityCountOutputTypeSelect | null
  }



  /**
   * Count Type ResumesResumeCountOutputType
   */


  export type ResumesResumeCountOutputType = {
    stars: number
    comments: number
  }

  export type ResumesResumeCountOutputTypeSelect = {
    stars?: boolean
    comments?: boolean
  }

  export type ResumesResumeCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ResumesResumeCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ResumesResumeCountOutputType
    : S extends undefined
    ? never
    : S extends ResumesResumeCountOutputTypeArgs
    ?'include' extends U
    ? ResumesResumeCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ResumesResumeCountOutputType ? ResumesResumeCountOutputType[P] : never
  } 
    : ResumesResumeCountOutputType
  : ResumesResumeCountOutputType




  // Custom InputTypes

  /**
   * ResumesResumeCountOutputType without action
   */
  export type ResumesResumeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ResumesResumeCountOutputType
     * 
    **/
    select?: ResumesResumeCountOutputTypeSelect | null
  }



  /**
   * Count Type ResumesCommentCountOutputType
   */


  export type ResumesCommentCountOutputType = {
    votes: number
    children: number
  }

  export type ResumesCommentCountOutputTypeSelect = {
    votes?: boolean
    children?: boolean
  }

  export type ResumesCommentCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ResumesCommentCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ResumesCommentCountOutputType
    : S extends undefined
    ? never
    : S extends ResumesCommentCountOutputTypeArgs
    ?'include' extends U
    ? ResumesCommentCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ResumesCommentCountOutputType ? ResumesCommentCountOutputType[P] : never
  } 
    : ResumesCommentCountOutputType
  : ResumesCommentCountOutputType




  // Custom InputTypes

  /**
   * ResumesCommentCountOutputType without action
   */
  export type ResumesCommentCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ResumesCommentCountOutputType
     * 
    **/
    select?: ResumesCommentCountOutputTypeSelect | null
  }



  /**
   * Count Type OffersProfileCountOutputType
   */


  export type OffersProfileCountOutputType = {
    discussion: number
    offers: number
    users: number
  }

  export type OffersProfileCountOutputTypeSelect = {
    discussion?: boolean
    offers?: boolean
    users?: boolean
  }

  export type OffersProfileCountOutputTypeGetPayload<
    S extends boolean | null | undefined | OffersProfileCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? OffersProfileCountOutputType
    : S extends undefined
    ? never
    : S extends OffersProfileCountOutputTypeArgs
    ?'include' extends U
    ? OffersProfileCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof OffersProfileCountOutputType ? OffersProfileCountOutputType[P] : never
  } 
    : OffersProfileCountOutputType
  : OffersProfileCountOutputType




  // Custom InputTypes

  /**
   * OffersProfileCountOutputType without action
   */
  export type OffersProfileCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OffersProfileCountOutputType
     * 
    **/
    select?: OffersProfileCountOutputTypeSelect | null
  }



  /**
   * Count Type OffersBackgroundCountOutputType
   */


  export type OffersBackgroundCountOutputType = {
    specificYoes: number
    experiences: number
    educations: number
  }

  export type OffersBackgroundCountOutputTypeSelect = {
    specificYoes?: boolean
    experiences?: boolean
    educations?: boolean
  }

  export type OffersBackgroundCountOutputTypeGetPayload<
    S extends boolean | null | undefined | OffersBackgroundCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? OffersBackgroundCountOutputType
    : S extends undefined
    ? never
    : S extends OffersBackgroundCountOutputTypeArgs
    ?'include' extends U
    ? OffersBackgroundCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof OffersBackgroundCountOutputType ? OffersBackgroundCountOutputType[P] : never
  } 
    : OffersBackgroundCountOutputType
  : OffersBackgroundCountOutputType




  // Custom InputTypes

  /**
   * OffersBackgroundCountOutputType without action
   */
  export type OffersBackgroundCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OffersBackgroundCountOutputType
     * 
    **/
    select?: OffersBackgroundCountOutputTypeSelect | null
  }



  /**
   * Count Type OffersReplyCountOutputType
   */


  export type OffersReplyCountOutputType = {
    replies: number
  }

  export type OffersReplyCountOutputTypeSelect = {
    replies?: boolean
  }

  export type OffersReplyCountOutputTypeGetPayload<
    S extends boolean | null | undefined | OffersReplyCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? OffersReplyCountOutputType
    : S extends undefined
    ? never
    : S extends OffersReplyCountOutputTypeArgs
    ?'include' extends U
    ? OffersReplyCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof OffersReplyCountOutputType ? OffersReplyCountOutputType[P] : never
  } 
    : OffersReplyCountOutputType
  : OffersReplyCountOutputType




  // Custom InputTypes

  /**
   * OffersReplyCountOutputType without action
   */
  export type OffersReplyCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OffersReplyCountOutputType
     * 
    **/
    select?: OffersReplyCountOutputTypeSelect | null
  }



  /**
   * Count Type OffersOfferCountOutputType
   */


  export type OffersOfferCountOutputType = {
    offersAnalysisUnit: number
    OffersAnalysisUnit: number
  }

  export type OffersOfferCountOutputTypeSelect = {
    offersAnalysisUnit?: boolean
    OffersAnalysisUnit?: boolean
  }

  export type OffersOfferCountOutputTypeGetPayload<
    S extends boolean | null | undefined | OffersOfferCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? OffersOfferCountOutputType
    : S extends undefined
    ? never
    : S extends OffersOfferCountOutputTypeArgs
    ?'include' extends U
    ? OffersOfferCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof OffersOfferCountOutputType ? OffersOfferCountOutputType[P] : never
  } 
    : OffersOfferCountOutputType
  : OffersOfferCountOutputType




  // Custom InputTypes

  /**
   * OffersOfferCountOutputType without action
   */
  export type OffersOfferCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OffersOfferCountOutputType
     * 
    **/
    select?: OffersOfferCountOutputTypeSelect | null
  }



  /**
   * Count Type OffersAnalysisCountOutputType
   */


  export type OffersAnalysisCountOutputType = {
    companyAnalysis: number
  }

  export type OffersAnalysisCountOutputTypeSelect = {
    companyAnalysis?: boolean
  }

  export type OffersAnalysisCountOutputTypeGetPayload<
    S extends boolean | null | undefined | OffersAnalysisCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? OffersAnalysisCountOutputType
    : S extends undefined
    ? never
    : S extends OffersAnalysisCountOutputTypeArgs
    ?'include' extends U
    ? OffersAnalysisCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof OffersAnalysisCountOutputType ? OffersAnalysisCountOutputType[P] : never
  } 
    : OffersAnalysisCountOutputType
  : OffersAnalysisCountOutputType




  // Custom InputTypes

  /**
   * OffersAnalysisCountOutputType without action
   */
  export type OffersAnalysisCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OffersAnalysisCountOutputType
     * 
    **/
    select?: OffersAnalysisCountOutputTypeSelect | null
  }



  /**
   * Count Type OffersAnalysisUnitCountOutputType
   */


  export type OffersAnalysisUnitCountOutputType = {
    topSimilarOffers: number
    offersAnalysisOverall: number
    offersAnalysisCompany: number
  }

  export type OffersAnalysisUnitCountOutputTypeSelect = {
    topSimilarOffers?: boolean
    offersAnalysisOverall?: boolean
    offersAnalysisCompany?: boolean
  }

  export type OffersAnalysisUnitCountOutputTypeGetPayload<
    S extends boolean | null | undefined | OffersAnalysisUnitCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? OffersAnalysisUnitCountOutputType
    : S extends undefined
    ? never
    : S extends OffersAnalysisUnitCountOutputTypeArgs
    ?'include' extends U
    ? OffersAnalysisUnitCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof OffersAnalysisUnitCountOutputType ? OffersAnalysisUnitCountOutputType[P] : never
  } 
    : OffersAnalysisUnitCountOutputType
  : OffersAnalysisUnitCountOutputType




  // Custom InputTypes

  /**
   * OffersAnalysisUnitCountOutputType without action
   */
  export type OffersAnalysisUnitCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OffersAnalysisUnitCountOutputType
     * 
    **/
    select?: OffersAnalysisUnitCountOutputTypeSelect | null
  }



  /**
   * Count Type QuestionsQuestionCountOutputType
   */


  export type QuestionsQuestionCountOutputType = {
    encounters: number
    votes: number
    comments: number
    answers: number
    questionsListQuestionEntries: number
  }

  export type QuestionsQuestionCountOutputTypeSelect = {
    encounters?: boolean
    votes?: boolean
    comments?: boolean
    answers?: boolean
    questionsListQuestionEntries?: boolean
  }

  export type QuestionsQuestionCountOutputTypeGetPayload<
    S extends boolean | null | undefined | QuestionsQuestionCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? QuestionsQuestionCountOutputType
    : S extends undefined
    ? never
    : S extends QuestionsQuestionCountOutputTypeArgs
    ?'include' extends U
    ? QuestionsQuestionCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof QuestionsQuestionCountOutputType ? QuestionsQuestionCountOutputType[P] : never
  } 
    : QuestionsQuestionCountOutputType
  : QuestionsQuestionCountOutputType




  // Custom InputTypes

  /**
   * QuestionsQuestionCountOutputType without action
   */
  export type QuestionsQuestionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the QuestionsQuestionCountOutputType
     * 
    **/
    select?: QuestionsQuestionCountOutputTypeSelect | null
  }



  /**
   * Count Type QuestionsQuestionCommentCountOutputType
   */


  export type QuestionsQuestionCommentCountOutputType = {
    votes: number
  }

  export type QuestionsQuestionCommentCountOutputTypeSelect = {
    votes?: boolean
  }

  export type QuestionsQuestionCommentCountOutputTypeGetPayload<
    S extends boolean | null | undefined | QuestionsQuestionCommentCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? QuestionsQuestionCommentCountOutputType
    : S extends undefined
    ? never
    : S extends QuestionsQuestionCommentCountOutputTypeArgs
    ?'include' extends U
    ? QuestionsQuestionCommentCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof QuestionsQuestionCommentCountOutputType ? QuestionsQuestionCommentCountOutputType[P] : never
  } 
    : QuestionsQuestionCommentCountOutputType
  : QuestionsQuestionCommentCountOutputType




  // Custom InputTypes

  /**
   * QuestionsQuestionCommentCountOutputType without action
   */
  export type QuestionsQuestionCommentCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the QuestionsQuestionCommentCountOutputType
     * 
    **/
    select?: QuestionsQuestionCommentCountOutputTypeSelect | null
  }



  /**
   * Count Type QuestionsAnswerCountOutputType
   */


  export type QuestionsAnswerCountOutputType = {
    votes: number
    comments: number
  }

  export type QuestionsAnswerCountOutputTypeSelect = {
    votes?: boolean
    comments?: boolean
  }

  export type QuestionsAnswerCountOutputTypeGetPayload<
    S extends boolean | null | undefined | QuestionsAnswerCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? QuestionsAnswerCountOutputType
    : S extends undefined
    ? never
    : S extends QuestionsAnswerCountOutputTypeArgs
    ?'include' extends U
    ? QuestionsAnswerCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof QuestionsAnswerCountOutputType ? QuestionsAnswerCountOutputType[P] : never
  } 
    : QuestionsAnswerCountOutputType
  : QuestionsAnswerCountOutputType




  // Custom InputTypes

  /**
   * QuestionsAnswerCountOutputType without action
   */
  export type QuestionsAnswerCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the QuestionsAnswerCountOutputType
     * 
    **/
    select?: QuestionsAnswerCountOutputTypeSelect | null
  }



  /**
   * Count Type QuestionsAnswerCommentCountOutputType
   */


  export type QuestionsAnswerCommentCountOutputType = {
    votes: number
  }

  export type QuestionsAnswerCommentCountOutputTypeSelect = {
    votes?: boolean
  }

  export type QuestionsAnswerCommentCountOutputTypeGetPayload<
    S extends boolean | null | undefined | QuestionsAnswerCommentCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? QuestionsAnswerCommentCountOutputType
    : S extends undefined
    ? never
    : S extends QuestionsAnswerCommentCountOutputTypeArgs
    ?'include' extends U
    ? QuestionsAnswerCommentCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof QuestionsAnswerCommentCountOutputType ? QuestionsAnswerCommentCountOutputType[P] : never
  } 
    : QuestionsAnswerCommentCountOutputType
  : QuestionsAnswerCommentCountOutputType




  // Custom InputTypes

  /**
   * QuestionsAnswerCommentCountOutputType without action
   */
  export type QuestionsAnswerCommentCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the QuestionsAnswerCommentCountOutputType
     * 
    **/
    select?: QuestionsAnswerCommentCountOutputTypeSelect | null
  }



  /**
   * Count Type QuestionsListCountOutputType
   */


  export type QuestionsListCountOutputType = {
    questionEntries: number
  }

  export type QuestionsListCountOutputTypeSelect = {
    questionEntries?: boolean
  }

  export type QuestionsListCountOutputTypeGetPayload<
    S extends boolean | null | undefined | QuestionsListCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? QuestionsListCountOutputType
    : S extends undefined
    ? never
    : S extends QuestionsListCountOutputTypeArgs
    ?'include' extends U
    ? QuestionsListCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof QuestionsListCountOutputType ? QuestionsListCountOutputType[P] : never
  } 
    : QuestionsListCountOutputType
  : QuestionsListCountOutputType




  // Custom InputTypes

  /**
   * QuestionsListCountOutputType without action
   */
  export type QuestionsListCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the QuestionsListCountOutputType
     * 
    **/
    select?: QuestionsListCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Account
   */


  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs = {
    /**
     * Filter which Account to aggregate.
     * 
    **/
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs = {
    where?: AccountWhereInput
    orderBy?: Enumerable<AccountOrderByWithAggregationInput>
    by: Array<AccountScalarFieldEnum>
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }


  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserArgs
  }

  export type AccountInclude = {
    user?: boolean | UserArgs
  }

  export type AccountGetPayload<
    S extends boolean | null | undefined | AccountArgs,
    U = keyof S
      > = S extends true
        ? Account
    : S extends undefined
    ? never
    : S extends AccountArgs | AccountFindManyArgs
    ?'include' extends U
    ? Account  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Account ? Account[P] : never
  } 
    : Account
  : Account


  type AccountCountArgs = Merge<
    Omit<AccountFindManyArgs, 'select' | 'include'> & {
      select?: AccountCountAggregateInputType | true
    }
  >

  export interface AccountDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AccountFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Account'> extends True ? CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>> : CheckSelect<T, Prisma__AccountClient<Account | null, null>, Prisma__AccountClient<AccountGetPayload<T> | null, null>>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AccountFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Account'> extends True ? CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>> : CheckSelect<T, Prisma__AccountClient<Account | null, null>, Prisma__AccountClient<AccountGetPayload<T> | null, null>>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AccountFindManyArgs>(
      args?: SelectSubset<T, AccountFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Account>>, PrismaPromise<Array<AccountGetPayload<T>>>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
    **/
    create<T extends AccountCreateArgs>(
      args: SelectSubset<T, AccountCreateArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Create many Accounts.
     *     @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     *     @example
     *     // Create many Accounts
     *     const account = await prisma.account.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AccountCreateManyArgs>(
      args?: SelectSubset<T, AccountCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
    **/
    delete<T extends AccountDeleteArgs>(
      args: SelectSubset<T, AccountDeleteArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountUpdateArgs>(
      args: SelectSubset<T, AccountUpdateArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountDeleteManyArgs>(
      args?: SelectSubset<T, AccountDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountUpdateManyArgs>(
      args: SelectSubset<T, AccountUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
    **/
    upsert<T extends AccountUpsertArgs>(
      args: SelectSubset<T, AccountUpsertArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Find one Account that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AccountFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Find the first Account that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AccountFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AccountClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Account base type for findUnique actions
   */
  export type AccountFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * Filter, which Account to fetch.
     * 
    **/
    where: AccountWhereUniqueInput
  }

  /**
   * Account: findUnique
   */
  export interface AccountFindUniqueArgs extends AccountFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Account base type for findFirst actions
   */
  export type AccountFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * Filter, which Account to fetch.
     * 
    **/
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     * 
    **/
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     * 
    **/
    distinct?: Enumerable<AccountScalarFieldEnum>
  }

  /**
   * Account: findFirst
   */
  export interface AccountFindFirstArgs extends AccountFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Account findMany
   */
  export type AccountFindManyArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * Filter, which Accounts to fetch.
     * 
    **/
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     * 
    **/
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AccountScalarFieldEnum>
  }


  /**
   * Account create
   */
  export type AccountCreateArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * The data needed to create a Account.
     * 
    **/
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }


  /**
   * Account createMany
   */
  export type AccountCreateManyArgs = {
    /**
     * The data used to create many Accounts.
     * 
    **/
    data: Enumerable<AccountCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Account update
   */
  export type AccountUpdateArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * The data needed to update a Account.
     * 
    **/
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     * 
    **/
    where: AccountWhereUniqueInput
  }


  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs = {
    /**
     * The data used to update Accounts.
     * 
    **/
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     * 
    **/
    where?: AccountWhereInput
  }


  /**
   * Account upsert
   */
  export type AccountUpsertArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * The filter to search for the Account to update in case it exists.
     * 
    **/
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     * 
    **/
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }


  /**
   * Account delete
   */
  export type AccountDeleteArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * Filter which Account to delete.
     * 
    **/
    where: AccountWhereUniqueInput
  }


  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs = {
    /**
     * Filter which Accounts to delete
     * 
    **/
    where?: AccountWhereInput
  }


  /**
   * Account: findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs = AccountFindUniqueArgsBase
      

  /**
   * Account: findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs = AccountFindFirstArgsBase
      

  /**
   * Account without action
   */
  export type AccountArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
  }



  /**
   * Model Session
   */


  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs = {
    /**
     * Filter which Session to aggregate.
     * 
    **/
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     * 
    **/
    orderBy?: Enumerable<SessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs = {
    where?: SessionWhereInput
    orderBy?: Enumerable<SessionOrderByWithAggregationInput>
    by: Array<SessionScalarFieldEnum>
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }


  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserArgs
  }

  export type SessionInclude = {
    user?: boolean | UserArgs
  }

  export type SessionGetPayload<
    S extends boolean | null | undefined | SessionArgs,
    U = keyof S
      > = S extends true
        ? Session
    : S extends undefined
    ? never
    : S extends SessionArgs | SessionFindManyArgs
    ?'include' extends U
    ? Session  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Session ? Session[P] : never
  } 
    : Session
  : Session


  type SessionCountArgs = Merge<
    Omit<SessionFindManyArgs, 'select' | 'include'> & {
      select?: SessionCountAggregateInputType | true
    }
  >

  export interface SessionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SessionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SessionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Session'> extends True ? CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>> : CheckSelect<T, Prisma__SessionClient<Session | null, null>, Prisma__SessionClient<SessionGetPayload<T> | null, null>>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SessionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SessionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Session'> extends True ? CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>> : CheckSelect<T, Prisma__SessionClient<Session | null, null>, Prisma__SessionClient<SessionGetPayload<T> | null, null>>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SessionFindManyArgs>(
      args?: SelectSubset<T, SessionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Session>>, PrismaPromise<Array<SessionGetPayload<T>>>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
    **/
    create<T extends SessionCreateArgs>(
      args: SelectSubset<T, SessionCreateArgs>
    ): CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>>

    /**
     * Create many Sessions.
     *     @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     *     @example
     *     // Create many Sessions
     *     const session = await prisma.session.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SessionCreateManyArgs>(
      args?: SelectSubset<T, SessionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
    **/
    delete<T extends SessionDeleteArgs>(
      args: SelectSubset<T, SessionDeleteArgs>
    ): CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SessionUpdateArgs>(
      args: SelectSubset<T, SessionUpdateArgs>
    ): CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SessionDeleteManyArgs>(
      args?: SelectSubset<T, SessionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SessionUpdateManyArgs>(
      args: SelectSubset<T, SessionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
    **/
    upsert<T extends SessionUpsertArgs>(
      args: SelectSubset<T, SessionUpsertArgs>
    ): CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>>

    /**
     * Find one Session that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SessionFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>>

    /**
     * Find the first Session that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SessionFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>>

    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SessionClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Session base type for findUnique actions
   */
  export type SessionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * Filter, which Session to fetch.
     * 
    **/
    where: SessionWhereUniqueInput
  }

  /**
   * Session: findUnique
   */
  export interface SessionFindUniqueArgs extends SessionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Session base type for findFirst actions
   */
  export type SessionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * Filter, which Session to fetch.
     * 
    **/
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     * 
    **/
    orderBy?: Enumerable<SessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     * 
    **/
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     * 
    **/
    distinct?: Enumerable<SessionScalarFieldEnum>
  }

  /**
   * Session: findFirst
   */
  export interface SessionFindFirstArgs extends SessionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Session findMany
   */
  export type SessionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * Filter, which Sessions to fetch.
     * 
    **/
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     * 
    **/
    orderBy?: Enumerable<SessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     * 
    **/
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SessionScalarFieldEnum>
  }


  /**
   * Session create
   */
  export type SessionCreateArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * The data needed to create a Session.
     * 
    **/
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }


  /**
   * Session createMany
   */
  export type SessionCreateManyArgs = {
    /**
     * The data used to create many Sessions.
     * 
    **/
    data: Enumerable<SessionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Session update
   */
  export type SessionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * The data needed to update a Session.
     * 
    **/
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     * 
    **/
    where: SessionWhereUniqueInput
  }


  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs = {
    /**
     * The data used to update Sessions.
     * 
    **/
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     * 
    **/
    where?: SessionWhereInput
  }


  /**
   * Session upsert
   */
  export type SessionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * The filter to search for the Session to update in case it exists.
     * 
    **/
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     * 
    **/
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }


  /**
   * Session delete
   */
  export type SessionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * Filter which Session to delete.
     * 
    **/
    where: SessionWhereUniqueInput
  }


  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs = {
    /**
     * Filter which Sessions to delete
     * 
    **/
    where?: SessionWhereInput
  }


  /**
   * Session: findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs = SessionFindUniqueArgsBase
      

  /**
   * Session: findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs = SessionFindFirstArgsBase
      

  /**
   * Session without action
   */
  export type SessionArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    accounts?: boolean | AccountFindManyArgs
    sessions?: boolean | SessionFindManyArgs
    todos?: boolean | TodoFindManyArgs
    resumesResumes?: boolean | ResumesResumeFindManyArgs
    resumesStars?: boolean | ResumesStarFindManyArgs
    resumesComments?: boolean | ResumesCommentFindManyArgs
    resumesCommentVotes?: boolean | ResumesCommentVoteFindManyArgs
    questionsQuestions?: boolean | QuestionsQuestionFindManyArgs
    questionsQuestionEncounters?: boolean | QuestionsQuestionEncounterFindManyArgs
    questionsQuestionVotes?: boolean | QuestionsQuestionVoteFindManyArgs
    questionsQuestionComments?: boolean | QuestionsQuestionCommentFindManyArgs
    questionsQuestionCommentVotes?: boolean | QuestionsQuestionCommentVoteFindManyArgs
    questionsAnswers?: boolean | QuestionsAnswerFindManyArgs
    questionsAnswerVotes?: boolean | QuestionsAnswerVoteFindManyArgs
    questionsAnswerComments?: boolean | QuestionsAnswerCommentFindManyArgs
    questionsAnswerCommentVotes?: boolean | QuestionsAnswerCommentVoteFindManyArgs
    OffersProfile?: boolean | OffersProfileFindManyArgs
    offersDiscussion?: boolean | OffersReplyFindManyArgs
    questionsLists?: boolean | QuestionsListFindManyArgs
    OffersAdmin?: boolean | OffersAdminArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserInclude = {
    accounts?: boolean | AccountFindManyArgs
    sessions?: boolean | SessionFindManyArgs
    todos?: boolean | TodoFindManyArgs
    resumesResumes?: boolean | ResumesResumeFindManyArgs
    resumesStars?: boolean | ResumesStarFindManyArgs
    resumesComments?: boolean | ResumesCommentFindManyArgs
    resumesCommentVotes?: boolean | ResumesCommentVoteFindManyArgs
    questionsQuestions?: boolean | QuestionsQuestionFindManyArgs
    questionsQuestionEncounters?: boolean | QuestionsQuestionEncounterFindManyArgs
    questionsQuestionVotes?: boolean | QuestionsQuestionVoteFindManyArgs
    questionsQuestionComments?: boolean | QuestionsQuestionCommentFindManyArgs
    questionsQuestionCommentVotes?: boolean | QuestionsQuestionCommentVoteFindManyArgs
    questionsAnswers?: boolean | QuestionsAnswerFindManyArgs
    questionsAnswerVotes?: boolean | QuestionsAnswerVoteFindManyArgs
    questionsAnswerComments?: boolean | QuestionsAnswerCommentFindManyArgs
    questionsAnswerCommentVotes?: boolean | QuestionsAnswerCommentVoteFindManyArgs
    OffersProfile?: boolean | OffersProfileFindManyArgs
    offersDiscussion?: boolean | OffersReplyFindManyArgs
    questionsLists?: boolean | QuestionsListFindManyArgs
    OffersAdmin?: boolean | OffersAdminArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]:
        P extends 'accounts' ? Array < AccountGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'sessions' ? Array < SessionGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'todos' ? Array < TodoGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'resumesResumes' ? Array < ResumesResumeGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'resumesStars' ? Array < ResumesStarGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'resumesComments' ? Array < ResumesCommentGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'resumesCommentVotes' ? Array < ResumesCommentVoteGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'questionsQuestions' ? Array < QuestionsQuestionGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'questionsQuestionEncounters' ? Array < QuestionsQuestionEncounterGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'questionsQuestionVotes' ? Array < QuestionsQuestionVoteGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'questionsQuestionComments' ? Array < QuestionsQuestionCommentGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'questionsQuestionCommentVotes' ? Array < QuestionsQuestionCommentVoteGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'questionsAnswers' ? Array < QuestionsAnswerGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'questionsAnswerVotes' ? Array < QuestionsAnswerVoteGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'questionsAnswerComments' ? Array < QuestionsAnswerCommentGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'questionsAnswerCommentVotes' ? Array < QuestionsAnswerCommentVoteGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'OffersProfile' ? Array < OffersProfileGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'offersDiscussion' ? Array < OffersReplyGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'questionsLists' ? Array < QuestionsListGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'OffersAdmin' ? OffersAdminGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends '_count' ? UserCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'accounts' ? Array < AccountGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'sessions' ? Array < SessionGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'todos' ? Array < TodoGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'resumesResumes' ? Array < ResumesResumeGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'resumesStars' ? Array < ResumesStarGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'resumesComments' ? Array < ResumesCommentGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'resumesCommentVotes' ? Array < ResumesCommentVoteGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'questionsQuestions' ? Array < QuestionsQuestionGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'questionsQuestionEncounters' ? Array < QuestionsQuestionEncounterGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'questionsQuestionVotes' ? Array < QuestionsQuestionVoteGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'questionsQuestionComments' ? Array < QuestionsQuestionCommentGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'questionsQuestionCommentVotes' ? Array < QuestionsQuestionCommentVoteGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'questionsAnswers' ? Array < QuestionsAnswerGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'questionsAnswerVotes' ? Array < QuestionsAnswerVoteGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'questionsAnswerComments' ? Array < QuestionsAnswerCommentGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'questionsAnswerCommentVotes' ? Array < QuestionsAnswerCommentVoteGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'OffersProfile' ? Array < OffersProfileGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'offersDiscussion' ? Array < OffersReplyGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'questionsLists' ? Array < QuestionsListGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'OffersAdmin' ? OffersAdminGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends '_count' ? UserCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof User ? User[P] : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null, null>, Prisma__UserClient<UserGetPayload<T> | null, null>>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null, null>, Prisma__UserClient<UserGetPayload<T> | null, null>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Find one User that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    accounts<T extends AccountFindManyArgs = {}>(args?: Subset<T, AccountFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Account>| Null>, PrismaPromise<Array<AccountGetPayload<T>>| Null>>;

    sessions<T extends SessionFindManyArgs = {}>(args?: Subset<T, SessionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Session>| Null>, PrismaPromise<Array<SessionGetPayload<T>>| Null>>;

    todos<T extends TodoFindManyArgs = {}>(args?: Subset<T, TodoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Todo>| Null>, PrismaPromise<Array<TodoGetPayload<T>>| Null>>;

    resumesResumes<T extends ResumesResumeFindManyArgs = {}>(args?: Subset<T, ResumesResumeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ResumesResume>| Null>, PrismaPromise<Array<ResumesResumeGetPayload<T>>| Null>>;

    resumesStars<T extends ResumesStarFindManyArgs = {}>(args?: Subset<T, ResumesStarFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ResumesStar>| Null>, PrismaPromise<Array<ResumesStarGetPayload<T>>| Null>>;

    resumesComments<T extends ResumesCommentFindManyArgs = {}>(args?: Subset<T, ResumesCommentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ResumesComment>| Null>, PrismaPromise<Array<ResumesCommentGetPayload<T>>| Null>>;

    resumesCommentVotes<T extends ResumesCommentVoteFindManyArgs = {}>(args?: Subset<T, ResumesCommentVoteFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ResumesCommentVote>| Null>, PrismaPromise<Array<ResumesCommentVoteGetPayload<T>>| Null>>;

    questionsQuestions<T extends QuestionsQuestionFindManyArgs = {}>(args?: Subset<T, QuestionsQuestionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<QuestionsQuestion>| Null>, PrismaPromise<Array<QuestionsQuestionGetPayload<T>>| Null>>;

    questionsQuestionEncounters<T extends QuestionsQuestionEncounterFindManyArgs = {}>(args?: Subset<T, QuestionsQuestionEncounterFindManyArgs>): CheckSelect<T, PrismaPromise<Array<QuestionsQuestionEncounter>| Null>, PrismaPromise<Array<QuestionsQuestionEncounterGetPayload<T>>| Null>>;

    questionsQuestionVotes<T extends QuestionsQuestionVoteFindManyArgs = {}>(args?: Subset<T, QuestionsQuestionVoteFindManyArgs>): CheckSelect<T, PrismaPromise<Array<QuestionsQuestionVote>| Null>, PrismaPromise<Array<QuestionsQuestionVoteGetPayload<T>>| Null>>;

    questionsQuestionComments<T extends QuestionsQuestionCommentFindManyArgs = {}>(args?: Subset<T, QuestionsQuestionCommentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<QuestionsQuestionComment>| Null>, PrismaPromise<Array<QuestionsQuestionCommentGetPayload<T>>| Null>>;

    questionsQuestionCommentVotes<T extends QuestionsQuestionCommentVoteFindManyArgs = {}>(args?: Subset<T, QuestionsQuestionCommentVoteFindManyArgs>): CheckSelect<T, PrismaPromise<Array<QuestionsQuestionCommentVote>| Null>, PrismaPromise<Array<QuestionsQuestionCommentVoteGetPayload<T>>| Null>>;

    questionsAnswers<T extends QuestionsAnswerFindManyArgs = {}>(args?: Subset<T, QuestionsAnswerFindManyArgs>): CheckSelect<T, PrismaPromise<Array<QuestionsAnswer>| Null>, PrismaPromise<Array<QuestionsAnswerGetPayload<T>>| Null>>;

    questionsAnswerVotes<T extends QuestionsAnswerVoteFindManyArgs = {}>(args?: Subset<T, QuestionsAnswerVoteFindManyArgs>): CheckSelect<T, PrismaPromise<Array<QuestionsAnswerVote>| Null>, PrismaPromise<Array<QuestionsAnswerVoteGetPayload<T>>| Null>>;

    questionsAnswerComments<T extends QuestionsAnswerCommentFindManyArgs = {}>(args?: Subset<T, QuestionsAnswerCommentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<QuestionsAnswerComment>| Null>, PrismaPromise<Array<QuestionsAnswerCommentGetPayload<T>>| Null>>;

    questionsAnswerCommentVotes<T extends QuestionsAnswerCommentVoteFindManyArgs = {}>(args?: Subset<T, QuestionsAnswerCommentVoteFindManyArgs>): CheckSelect<T, PrismaPromise<Array<QuestionsAnswerCommentVote>| Null>, PrismaPromise<Array<QuestionsAnswerCommentVoteGetPayload<T>>| Null>>;

    OffersProfile<T extends OffersProfileFindManyArgs = {}>(args?: Subset<T, OffersProfileFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OffersProfile>| Null>, PrismaPromise<Array<OffersProfileGetPayload<T>>| Null>>;

    offersDiscussion<T extends OffersReplyFindManyArgs = {}>(args?: Subset<T, OffersReplyFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OffersReply>| Null>, PrismaPromise<Array<OffersReplyGetPayload<T>>| Null>>;

    questionsLists<T extends QuestionsListFindManyArgs = {}>(args?: Subset<T, QuestionsListFindManyArgs>): CheckSelect<T, PrismaPromise<Array<QuestionsList>| Null>, PrismaPromise<Array<QuestionsListGetPayload<T>>| Null>>;

    OffersAdmin<T extends OffersAdminArgs = {}>(args?: Subset<T, OffersAdminArgs>): CheckSelect<T, Prisma__OffersAdminClient<OffersAdmin | Null>, Prisma__OffersAdminClient<OffersAdminGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }

  /**
   * User: findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User: findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     * 
    **/
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     * 
    **/
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User: findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = UserFindUniqueArgsBase
      

  /**
   * User: findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = UserFindFirstArgsBase
      

  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
  }



  /**
   * Model VerificationToken
   */


  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs = {
    /**
     * Filter which VerificationToken to aggregate.
     * 
    **/
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     * 
    **/
    orderBy?: Enumerable<VerificationTokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs = {
    where?: VerificationTokenWhereInput
    orderBy?: Enumerable<VerificationTokenOrderByWithAggregationInput>
    by: Array<VerificationTokenScalarFieldEnum>
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }


  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = PrismaPromise<
    Array<
      PickArray<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenGetPayload<
    S extends boolean | null | undefined | VerificationTokenArgs,
    U = keyof S
      > = S extends true
        ? VerificationToken
    : S extends undefined
    ? never
    : S extends VerificationTokenArgs | VerificationTokenFindManyArgs
    ?'include' extends U
    ? VerificationToken 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof VerificationToken ? VerificationToken[P] : never
  } 
    : VerificationToken
  : VerificationToken


  type VerificationTokenCountArgs = Merge<
    Omit<VerificationTokenFindManyArgs, 'select' | 'include'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }
  >

  export interface VerificationTokenDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VerificationTokenFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VerificationTokenFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'VerificationToken'> extends True ? CheckSelect<T, Prisma__VerificationTokenClient<VerificationToken>, Prisma__VerificationTokenClient<VerificationTokenGetPayload<T>>> : CheckSelect<T, Prisma__VerificationTokenClient<VerificationToken | null, null>, Prisma__VerificationTokenClient<VerificationTokenGetPayload<T> | null, null>>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VerificationTokenFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VerificationTokenFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'VerificationToken'> extends True ? CheckSelect<T, Prisma__VerificationTokenClient<VerificationToken>, Prisma__VerificationTokenClient<VerificationTokenGetPayload<T>>> : CheckSelect<T, Prisma__VerificationTokenClient<VerificationToken | null, null>, Prisma__VerificationTokenClient<VerificationTokenGetPayload<T> | null, null>>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
    **/
    findMany<T extends VerificationTokenFindManyArgs>(
      args?: SelectSubset<T, VerificationTokenFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<VerificationToken>>, PrismaPromise<Array<VerificationTokenGetPayload<T>>>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
    **/
    create<T extends VerificationTokenCreateArgs>(
      args: SelectSubset<T, VerificationTokenCreateArgs>
    ): CheckSelect<T, Prisma__VerificationTokenClient<VerificationToken>, Prisma__VerificationTokenClient<VerificationTokenGetPayload<T>>>

    /**
     * Create many VerificationTokens.
     *     @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     *     @example
     *     // Create many VerificationTokens
     *     const verificationToken = await prisma.verificationToken.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VerificationTokenCreateManyArgs>(
      args?: SelectSubset<T, VerificationTokenCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
    **/
    delete<T extends VerificationTokenDeleteArgs>(
      args: SelectSubset<T, VerificationTokenDeleteArgs>
    ): CheckSelect<T, Prisma__VerificationTokenClient<VerificationToken>, Prisma__VerificationTokenClient<VerificationTokenGetPayload<T>>>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VerificationTokenUpdateArgs>(
      args: SelectSubset<T, VerificationTokenUpdateArgs>
    ): CheckSelect<T, Prisma__VerificationTokenClient<VerificationToken>, Prisma__VerificationTokenClient<VerificationTokenGetPayload<T>>>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VerificationTokenDeleteManyArgs>(
      args?: SelectSubset<T, VerificationTokenDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VerificationTokenUpdateManyArgs>(
      args: SelectSubset<T, VerificationTokenUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
    **/
    upsert<T extends VerificationTokenUpsertArgs>(
      args: SelectSubset<T, VerificationTokenUpsertArgs>
    ): CheckSelect<T, Prisma__VerificationTokenClient<VerificationToken>, Prisma__VerificationTokenClient<VerificationTokenGetPayload<T>>>

    /**
     * Find one VerificationToken that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__VerificationTokenClient<VerificationToken>, Prisma__VerificationTokenClient<VerificationTokenGetPayload<T>>>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(
      args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__VerificationTokenClient<VerificationToken>, Prisma__VerificationTokenClient<VerificationTokenGetPayload<T>>>

    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VerificationTokenClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * VerificationToken base type for findUnique actions
   */
  export type VerificationTokenFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the VerificationToken
     * 
    **/
    select?: VerificationTokenSelect | null
    /**
     * Filter, which VerificationToken to fetch.
     * 
    **/
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken: findUnique
   */
  export interface VerificationTokenFindUniqueArgs extends VerificationTokenFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * VerificationToken base type for findFirst actions
   */
  export type VerificationTokenFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the VerificationToken
     * 
    **/
    select?: VerificationTokenSelect | null
    /**
     * Filter, which VerificationToken to fetch.
     * 
    **/
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     * 
    **/
    orderBy?: Enumerable<VerificationTokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     * 
    **/
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     * 
    **/
    distinct?: Enumerable<VerificationTokenScalarFieldEnum>
  }

  /**
   * VerificationToken: findFirst
   */
  export interface VerificationTokenFindFirstArgs extends VerificationTokenFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs = {
    /**
     * Select specific fields to fetch from the VerificationToken
     * 
    **/
    select?: VerificationTokenSelect | null
    /**
     * Filter, which VerificationTokens to fetch.
     * 
    **/
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     * 
    **/
    orderBy?: Enumerable<VerificationTokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     * 
    **/
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     * 
    **/
    skip?: number
    distinct?: Enumerable<VerificationTokenScalarFieldEnum>
  }


  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs = {
    /**
     * Select specific fields to fetch from the VerificationToken
     * 
    **/
    select?: VerificationTokenSelect | null
    /**
     * The data needed to create a VerificationToken.
     * 
    **/
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }


  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs = {
    /**
     * The data used to create many VerificationTokens.
     * 
    **/
    data: Enumerable<VerificationTokenCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs = {
    /**
     * Select specific fields to fetch from the VerificationToken
     * 
    **/
    select?: VerificationTokenSelect | null
    /**
     * The data needed to update a VerificationToken.
     * 
    **/
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     * 
    **/
    where: VerificationTokenWhereUniqueInput
  }


  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs = {
    /**
     * The data used to update VerificationTokens.
     * 
    **/
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     * 
    **/
    where?: VerificationTokenWhereInput
  }


  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs = {
    /**
     * Select specific fields to fetch from the VerificationToken
     * 
    **/
    select?: VerificationTokenSelect | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     * 
    **/
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     * 
    **/
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }


  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs = {
    /**
     * Select specific fields to fetch from the VerificationToken
     * 
    **/
    select?: VerificationTokenSelect | null
    /**
     * Filter which VerificationToken to delete.
     * 
    **/
    where: VerificationTokenWhereUniqueInput
  }


  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs = {
    /**
     * Filter which VerificationTokens to delete
     * 
    **/
    where?: VerificationTokenWhereInput
  }


  /**
   * VerificationToken: findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs = VerificationTokenFindUniqueArgsBase
      

  /**
   * VerificationToken: findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs = VerificationTokenFindFirstArgsBase
      

  /**
   * VerificationToken without action
   */
  export type VerificationTokenArgs = {
    /**
     * Select specific fields to fetch from the VerificationToken
     * 
    **/
    select?: VerificationTokenSelect | null
  }



  /**
   * Model Todo
   */


  export type AggregateTodo = {
    _count: TodoCountAggregateOutputType | null
    _min: TodoMinAggregateOutputType | null
    _max: TodoMaxAggregateOutputType | null
  }

  export type TodoMinAggregateOutputType = {
    id: string | null
    userId: string | null
    text: string | null
    status: TodoStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TodoMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    text: string | null
    status: TodoStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TodoCountAggregateOutputType = {
    id: number
    userId: number
    text: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TodoMinAggregateInputType = {
    id?: true
    userId?: true
    text?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TodoMaxAggregateInputType = {
    id?: true
    userId?: true
    text?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TodoCountAggregateInputType = {
    id?: true
    userId?: true
    text?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TodoAggregateArgs = {
    /**
     * Filter which Todo to aggregate.
     * 
    **/
    where?: TodoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Todos to fetch.
     * 
    **/
    orderBy?: Enumerable<TodoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TodoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Todos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Todos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Todos
    **/
    _count?: true | TodoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TodoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TodoMaxAggregateInputType
  }

  export type GetTodoAggregateType<T extends TodoAggregateArgs> = {
        [P in keyof T & keyof AggregateTodo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTodo[P]>
      : GetScalarType<T[P], AggregateTodo[P]>
  }




  export type TodoGroupByArgs = {
    where?: TodoWhereInput
    orderBy?: Enumerable<TodoOrderByWithAggregationInput>
    by: Array<TodoScalarFieldEnum>
    having?: TodoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TodoCountAggregateInputType | true
    _min?: TodoMinAggregateInputType
    _max?: TodoMaxAggregateInputType
  }


  export type TodoGroupByOutputType = {
    id: string
    userId: string
    text: string
    status: TodoStatus
    createdAt: Date
    updatedAt: Date
    _count: TodoCountAggregateOutputType | null
    _min: TodoMinAggregateOutputType | null
    _max: TodoMaxAggregateOutputType | null
  }

  type GetTodoGroupByPayload<T extends TodoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TodoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TodoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TodoGroupByOutputType[P]>
            : GetScalarType<T[P], TodoGroupByOutputType[P]>
        }
      >
    >


  export type TodoSelect = {
    id?: boolean
    userId?: boolean
    text?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs
  }

  export type TodoInclude = {
    user?: boolean | UserArgs
  }

  export type TodoGetPayload<
    S extends boolean | null | undefined | TodoArgs,
    U = keyof S
      > = S extends true
        ? Todo
    : S extends undefined
    ? never
    : S extends TodoArgs | TodoFindManyArgs
    ?'include' extends U
    ? Todo  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Todo ? Todo[P] : never
  } 
    : Todo
  : Todo


  type TodoCountArgs = Merge<
    Omit<TodoFindManyArgs, 'select' | 'include'> & {
      select?: TodoCountAggregateInputType | true
    }
  >

  export interface TodoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Todo that matches the filter.
     * @param {TodoFindUniqueArgs} args - Arguments to find a Todo
     * @example
     * // Get one Todo
     * const todo = await prisma.todo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TodoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TodoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Todo'> extends True ? CheckSelect<T, Prisma__TodoClient<Todo>, Prisma__TodoClient<TodoGetPayload<T>>> : CheckSelect<T, Prisma__TodoClient<Todo | null, null>, Prisma__TodoClient<TodoGetPayload<T> | null, null>>

    /**
     * Find the first Todo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoFindFirstArgs} args - Arguments to find a Todo
     * @example
     * // Get one Todo
     * const todo = await prisma.todo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TodoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TodoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Todo'> extends True ? CheckSelect<T, Prisma__TodoClient<Todo>, Prisma__TodoClient<TodoGetPayload<T>>> : CheckSelect<T, Prisma__TodoClient<Todo | null, null>, Prisma__TodoClient<TodoGetPayload<T> | null, null>>

    /**
     * Find zero or more Todos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Todos
     * const todos = await prisma.todo.findMany()
     * 
     * // Get first 10 Todos
     * const todos = await prisma.todo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const todoWithIdOnly = await prisma.todo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TodoFindManyArgs>(
      args?: SelectSubset<T, TodoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Todo>>, PrismaPromise<Array<TodoGetPayload<T>>>>

    /**
     * Create a Todo.
     * @param {TodoCreateArgs} args - Arguments to create a Todo.
     * @example
     * // Create one Todo
     * const Todo = await prisma.todo.create({
     *   data: {
     *     // ... data to create a Todo
     *   }
     * })
     * 
    **/
    create<T extends TodoCreateArgs>(
      args: SelectSubset<T, TodoCreateArgs>
    ): CheckSelect<T, Prisma__TodoClient<Todo>, Prisma__TodoClient<TodoGetPayload<T>>>

    /**
     * Create many Todos.
     *     @param {TodoCreateManyArgs} args - Arguments to create many Todos.
     *     @example
     *     // Create many Todos
     *     const todo = await prisma.todo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TodoCreateManyArgs>(
      args?: SelectSubset<T, TodoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Todo.
     * @param {TodoDeleteArgs} args - Arguments to delete one Todo.
     * @example
     * // Delete one Todo
     * const Todo = await prisma.todo.delete({
     *   where: {
     *     // ... filter to delete one Todo
     *   }
     * })
     * 
    **/
    delete<T extends TodoDeleteArgs>(
      args: SelectSubset<T, TodoDeleteArgs>
    ): CheckSelect<T, Prisma__TodoClient<Todo>, Prisma__TodoClient<TodoGetPayload<T>>>

    /**
     * Update one Todo.
     * @param {TodoUpdateArgs} args - Arguments to update one Todo.
     * @example
     * // Update one Todo
     * const todo = await prisma.todo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TodoUpdateArgs>(
      args: SelectSubset<T, TodoUpdateArgs>
    ): CheckSelect<T, Prisma__TodoClient<Todo>, Prisma__TodoClient<TodoGetPayload<T>>>

    /**
     * Delete zero or more Todos.
     * @param {TodoDeleteManyArgs} args - Arguments to filter Todos to delete.
     * @example
     * // Delete a few Todos
     * const { count } = await prisma.todo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TodoDeleteManyArgs>(
      args?: SelectSubset<T, TodoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Todos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Todos
     * const todo = await prisma.todo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TodoUpdateManyArgs>(
      args: SelectSubset<T, TodoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Todo.
     * @param {TodoUpsertArgs} args - Arguments to update or create a Todo.
     * @example
     * // Update or create a Todo
     * const todo = await prisma.todo.upsert({
     *   create: {
     *     // ... data to create a Todo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Todo we want to update
     *   }
     * })
    **/
    upsert<T extends TodoUpsertArgs>(
      args: SelectSubset<T, TodoUpsertArgs>
    ): CheckSelect<T, Prisma__TodoClient<Todo>, Prisma__TodoClient<TodoGetPayload<T>>>

    /**
     * Find one Todo that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {TodoFindUniqueOrThrowArgs} args - Arguments to find a Todo
     * @example
     * // Get one Todo
     * const todo = await prisma.todo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TodoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TodoFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__TodoClient<Todo>, Prisma__TodoClient<TodoGetPayload<T>>>

    /**
     * Find the first Todo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoFindFirstOrThrowArgs} args - Arguments to find a Todo
     * @example
     * // Get one Todo
     * const todo = await prisma.todo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TodoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TodoFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__TodoClient<Todo>, Prisma__TodoClient<TodoGetPayload<T>>>

    /**
     * Count the number of Todos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoCountArgs} args - Arguments to filter Todos to count.
     * @example
     * // Count the number of Todos
     * const count = await prisma.todo.count({
     *   where: {
     *     // ... the filter for the Todos we want to count
     *   }
     * })
    **/
    count<T extends TodoCountArgs>(
      args?: Subset<T, TodoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TodoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Todo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TodoAggregateArgs>(args: Subset<T, TodoAggregateArgs>): PrismaPromise<GetTodoAggregateType<T>>

    /**
     * Group by Todo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TodoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TodoGroupByArgs['orderBy'] }
        : { orderBy?: TodoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TodoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTodoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Todo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TodoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Todo base type for findUnique actions
   */
  export type TodoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Todo
     * 
    **/
    select?: TodoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TodoInclude | null
    /**
     * Filter, which Todo to fetch.
     * 
    **/
    where: TodoWhereUniqueInput
  }

  /**
   * Todo: findUnique
   */
  export interface TodoFindUniqueArgs extends TodoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Todo base type for findFirst actions
   */
  export type TodoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Todo
     * 
    **/
    select?: TodoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TodoInclude | null
    /**
     * Filter, which Todo to fetch.
     * 
    **/
    where?: TodoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Todos to fetch.
     * 
    **/
    orderBy?: Enumerable<TodoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Todos.
     * 
    **/
    cursor?: TodoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Todos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Todos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Todos.
     * 
    **/
    distinct?: Enumerable<TodoScalarFieldEnum>
  }

  /**
   * Todo: findFirst
   */
  export interface TodoFindFirstArgs extends TodoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Todo findMany
   */
  export type TodoFindManyArgs = {
    /**
     * Select specific fields to fetch from the Todo
     * 
    **/
    select?: TodoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TodoInclude | null
    /**
     * Filter, which Todos to fetch.
     * 
    **/
    where?: TodoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Todos to fetch.
     * 
    **/
    orderBy?: Enumerable<TodoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Todos.
     * 
    **/
    cursor?: TodoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Todos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Todos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TodoScalarFieldEnum>
  }


  /**
   * Todo create
   */
  export type TodoCreateArgs = {
    /**
     * Select specific fields to fetch from the Todo
     * 
    **/
    select?: TodoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TodoInclude | null
    /**
     * The data needed to create a Todo.
     * 
    **/
    data: XOR<TodoCreateInput, TodoUncheckedCreateInput>
  }


  /**
   * Todo createMany
   */
  export type TodoCreateManyArgs = {
    /**
     * The data used to create many Todos.
     * 
    **/
    data: Enumerable<TodoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Todo update
   */
  export type TodoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Todo
     * 
    **/
    select?: TodoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TodoInclude | null
    /**
     * The data needed to update a Todo.
     * 
    **/
    data: XOR<TodoUpdateInput, TodoUncheckedUpdateInput>
    /**
     * Choose, which Todo to update.
     * 
    **/
    where: TodoWhereUniqueInput
  }


  /**
   * Todo updateMany
   */
  export type TodoUpdateManyArgs = {
    /**
     * The data used to update Todos.
     * 
    **/
    data: XOR<TodoUpdateManyMutationInput, TodoUncheckedUpdateManyInput>
    /**
     * Filter which Todos to update
     * 
    **/
    where?: TodoWhereInput
  }


  /**
   * Todo upsert
   */
  export type TodoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Todo
     * 
    **/
    select?: TodoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TodoInclude | null
    /**
     * The filter to search for the Todo to update in case it exists.
     * 
    **/
    where: TodoWhereUniqueInput
    /**
     * In case the Todo found by the `where` argument doesn't exist, create a new Todo with this data.
     * 
    **/
    create: XOR<TodoCreateInput, TodoUncheckedCreateInput>
    /**
     * In case the Todo was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TodoUpdateInput, TodoUncheckedUpdateInput>
  }


  /**
   * Todo delete
   */
  export type TodoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Todo
     * 
    **/
    select?: TodoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TodoInclude | null
    /**
     * Filter which Todo to delete.
     * 
    **/
    where: TodoWhereUniqueInput
  }


  /**
   * Todo deleteMany
   */
  export type TodoDeleteManyArgs = {
    /**
     * Filter which Todos to delete
     * 
    **/
    where?: TodoWhereInput
  }


  /**
   * Todo: findUniqueOrThrow
   */
  export type TodoFindUniqueOrThrowArgs = TodoFindUniqueArgsBase
      

  /**
   * Todo: findFirstOrThrow
   */
  export type TodoFindFirstOrThrowArgs = TodoFindFirstArgsBase
      

  /**
   * Todo without action
   */
  export type TodoArgs = {
    /**
     * Select specific fields to fetch from the Todo
     * 
    **/
    select?: TodoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TodoInclude | null
  }



  /**
   * Model Company
   */


  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyAvgAggregateOutputType = {
    ranking: number | null
  }

  export type CompanySumAggregateOutputType = {
    ranking: number | null
  }

  export type CompanyMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    logoUrl: string | null
    website: string | null
    ranking: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    logoUrl: string | null
    website: string | null
    ranking: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    logoUrl: number
    website: number
    ranking: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyAvgAggregateInputType = {
    ranking?: true
  }

  export type CompanySumAggregateInputType = {
    ranking?: true
  }

  export type CompanyMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    logoUrl?: true
    website?: true
    ranking?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    logoUrl?: true
    website?: true
    ranking?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    logoUrl?: true
    website?: true
    ranking?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyAggregateArgs = {
    /**
     * Filter which Company to aggregate.
     * 
    **/
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     * 
    **/
    orderBy?: Enumerable<CompanyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs = {
    where?: CompanyWhereInput
    orderBy?: Enumerable<CompanyOrderByWithAggregationInput>
    by: Array<CompanyScalarFieldEnum>
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _avg?: CompanyAvgAggregateInputType
    _sum?: CompanySumAggregateInputType
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }


  export type CompanyGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    logoUrl: string | null
    website: string | null
    ranking: number | null
    createdAt: Date
    updatedAt: Date
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    logoUrl?: boolean
    website?: boolean
    ranking?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    questionsQuestionEncounter?: boolean | QuestionsQuestionEncounterFindManyArgs
    OffersExperience?: boolean | OffersExperienceFindManyArgs
    OffersOffer?: boolean | OffersOfferFindManyArgs
    _count?: boolean | CompanyCountOutputTypeArgs
  }

  export type CompanyInclude = {
    questionsQuestionEncounter?: boolean | QuestionsQuestionEncounterFindManyArgs
    OffersExperience?: boolean | OffersExperienceFindManyArgs
    OffersOffer?: boolean | OffersOfferFindManyArgs
    _count?: boolean | CompanyCountOutputTypeArgs
  }

  export type CompanyGetPayload<
    S extends boolean | null | undefined | CompanyArgs,
    U = keyof S
      > = S extends true
        ? Company
    : S extends undefined
    ? never
    : S extends CompanyArgs | CompanyFindManyArgs
    ?'include' extends U
    ? Company  & {
    [P in TrueKeys<S['include']>]:
        P extends 'questionsQuestionEncounter' ? Array < QuestionsQuestionEncounterGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'OffersExperience' ? Array < OffersExperienceGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'OffersOffer' ? Array < OffersOfferGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? CompanyCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'questionsQuestionEncounter' ? Array < QuestionsQuestionEncounterGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'OffersExperience' ? Array < OffersExperienceGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'OffersOffer' ? Array < OffersOfferGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? CompanyCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Company ? Company[P] : never
  } 
    : Company
  : Company


  type CompanyCountArgs = Merge<
    Omit<CompanyFindManyArgs, 'select' | 'include'> & {
      select?: CompanyCountAggregateInputType | true
    }
  >

  export interface CompanyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CompanyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CompanyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Company'> extends True ? CheckSelect<T, Prisma__CompanyClient<Company>, Prisma__CompanyClient<CompanyGetPayload<T>>> : CheckSelect<T, Prisma__CompanyClient<Company | null, null>, Prisma__CompanyClient<CompanyGetPayload<T> | null, null>>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CompanyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CompanyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Company'> extends True ? CheckSelect<T, Prisma__CompanyClient<Company>, Prisma__CompanyClient<CompanyGetPayload<T>>> : CheckSelect<T, Prisma__CompanyClient<Company | null, null>, Prisma__CompanyClient<CompanyGetPayload<T> | null, null>>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CompanyFindManyArgs>(
      args?: SelectSubset<T, CompanyFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Company>>, PrismaPromise<Array<CompanyGetPayload<T>>>>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
    **/
    create<T extends CompanyCreateArgs>(
      args: SelectSubset<T, CompanyCreateArgs>
    ): CheckSelect<T, Prisma__CompanyClient<Company>, Prisma__CompanyClient<CompanyGetPayload<T>>>

    /**
     * Create many Companies.
     *     @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     *     @example
     *     // Create many Companies
     *     const company = await prisma.company.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CompanyCreateManyArgs>(
      args?: SelectSubset<T, CompanyCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
    **/
    delete<T extends CompanyDeleteArgs>(
      args: SelectSubset<T, CompanyDeleteArgs>
    ): CheckSelect<T, Prisma__CompanyClient<Company>, Prisma__CompanyClient<CompanyGetPayload<T>>>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CompanyUpdateArgs>(
      args: SelectSubset<T, CompanyUpdateArgs>
    ): CheckSelect<T, Prisma__CompanyClient<Company>, Prisma__CompanyClient<CompanyGetPayload<T>>>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CompanyDeleteManyArgs>(
      args?: SelectSubset<T, CompanyDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CompanyUpdateManyArgs>(
      args: SelectSubset<T, CompanyUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
    **/
    upsert<T extends CompanyUpsertArgs>(
      args: SelectSubset<T, CompanyUpsertArgs>
    ): CheckSelect<T, Prisma__CompanyClient<Company>, Prisma__CompanyClient<CompanyGetPayload<T>>>

    /**
     * Find one Company that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CompanyFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__CompanyClient<Company>, Prisma__CompanyClient<CompanyGetPayload<T>>>

    /**
     * Find the first Company that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CompanyFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__CompanyClient<Company>, Prisma__CompanyClient<CompanyGetPayload<T>>>

    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CompanyClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    questionsQuestionEncounter<T extends QuestionsQuestionEncounterFindManyArgs = {}>(args?: Subset<T, QuestionsQuestionEncounterFindManyArgs>): CheckSelect<T, PrismaPromise<Array<QuestionsQuestionEncounter>| Null>, PrismaPromise<Array<QuestionsQuestionEncounterGetPayload<T>>| Null>>;

    OffersExperience<T extends OffersExperienceFindManyArgs = {}>(args?: Subset<T, OffersExperienceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OffersExperience>| Null>, PrismaPromise<Array<OffersExperienceGetPayload<T>>| Null>>;

    OffersOffer<T extends OffersOfferFindManyArgs = {}>(args?: Subset<T, OffersOfferFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OffersOffer>| Null>, PrismaPromise<Array<OffersOfferGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Company base type for findUnique actions
   */
  export type CompanyFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Company
     * 
    **/
    select?: CompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CompanyInclude | null
    /**
     * Filter, which Company to fetch.
     * 
    **/
    where: CompanyWhereUniqueInput
  }

  /**
   * Company: findUnique
   */
  export interface CompanyFindUniqueArgs extends CompanyFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Company base type for findFirst actions
   */
  export type CompanyFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Company
     * 
    **/
    select?: CompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CompanyInclude | null
    /**
     * Filter, which Company to fetch.
     * 
    **/
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     * 
    **/
    orderBy?: Enumerable<CompanyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     * 
    **/
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     * 
    **/
    distinct?: Enumerable<CompanyScalarFieldEnum>
  }

  /**
   * Company: findFirst
   */
  export interface CompanyFindFirstArgs extends CompanyFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs = {
    /**
     * Select specific fields to fetch from the Company
     * 
    **/
    select?: CompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CompanyInclude | null
    /**
     * Filter, which Companies to fetch.
     * 
    **/
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     * 
    **/
    orderBy?: Enumerable<CompanyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     * 
    **/
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CompanyScalarFieldEnum>
  }


  /**
   * Company create
   */
  export type CompanyCreateArgs = {
    /**
     * Select specific fields to fetch from the Company
     * 
    **/
    select?: CompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CompanyInclude | null
    /**
     * The data needed to create a Company.
     * 
    **/
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }


  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs = {
    /**
     * The data used to create many Companies.
     * 
    **/
    data: Enumerable<CompanyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Company update
   */
  export type CompanyUpdateArgs = {
    /**
     * Select specific fields to fetch from the Company
     * 
    **/
    select?: CompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CompanyInclude | null
    /**
     * The data needed to update a Company.
     * 
    **/
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     * 
    **/
    where: CompanyWhereUniqueInput
  }


  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs = {
    /**
     * The data used to update Companies.
     * 
    **/
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     * 
    **/
    where?: CompanyWhereInput
  }


  /**
   * Company upsert
   */
  export type CompanyUpsertArgs = {
    /**
     * Select specific fields to fetch from the Company
     * 
    **/
    select?: CompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CompanyInclude | null
    /**
     * The filter to search for the Company to update in case it exists.
     * 
    **/
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     * 
    **/
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }


  /**
   * Company delete
   */
  export type CompanyDeleteArgs = {
    /**
     * Select specific fields to fetch from the Company
     * 
    **/
    select?: CompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CompanyInclude | null
    /**
     * Filter which Company to delete.
     * 
    **/
    where: CompanyWhereUniqueInput
  }


  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs = {
    /**
     * Filter which Companies to delete
     * 
    **/
    where?: CompanyWhereInput
  }


  /**
   * Company: findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs = CompanyFindUniqueArgsBase
      

  /**
   * Company: findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs = CompanyFindFirstArgsBase
      

  /**
   * Company without action
   */
  export type CompanyArgs = {
    /**
     * Select specific fields to fetch from the Company
     * 
    **/
    select?: CompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CompanyInclude | null
  }



  /**
   * Model Country
   */


  export type AggregateCountry = {
    _count: CountryCountAggregateOutputType | null
    _avg: CountryAvgAggregateOutputType | null
    _sum: CountrySumAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  export type CountryAvgAggregateOutputType = {
    ranking: number | null
  }

  export type CountrySumAggregateOutputType = {
    ranking: number | null
  }

  export type CountryMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    ranking: number | null
  }

  export type CountryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    ranking: number | null
  }

  export type CountryCountAggregateOutputType = {
    id: number
    name: number
    code: number
    ranking: number
    _all: number
  }


  export type CountryAvgAggregateInputType = {
    ranking?: true
  }

  export type CountrySumAggregateInputType = {
    ranking?: true
  }

  export type CountryMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    ranking?: true
  }

  export type CountryMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    ranking?: true
  }

  export type CountryCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    ranking?: true
    _all?: true
  }

  export type CountryAggregateArgs = {
    /**
     * Filter which Country to aggregate.
     * 
    **/
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     * 
    **/
    orderBy?: Enumerable<CountryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Countries
    **/
    _count?: true | CountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CountryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CountrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountryMaxAggregateInputType
  }

  export type GetCountryAggregateType<T extends CountryAggregateArgs> = {
        [P in keyof T & keyof AggregateCountry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountry[P]>
      : GetScalarType<T[P], AggregateCountry[P]>
  }




  export type CountryGroupByArgs = {
    where?: CountryWhereInput
    orderBy?: Enumerable<CountryOrderByWithAggregationInput>
    by: Array<CountryScalarFieldEnum>
    having?: CountryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountryCountAggregateInputType | true
    _avg?: CountryAvgAggregateInputType
    _sum?: CountrySumAggregateInputType
    _min?: CountryMinAggregateInputType
    _max?: CountryMaxAggregateInputType
  }


  export type CountryGroupByOutputType = {
    id: string
    name: string
    code: string
    ranking: number | null
    _count: CountryCountAggregateOutputType | null
    _avg: CountryAvgAggregateOutputType | null
    _sum: CountrySumAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  type GetCountryGroupByPayload<T extends CountryGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CountryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountryGroupByOutputType[P]>
            : GetScalarType<T[P], CountryGroupByOutputType[P]>
        }
      >
    >


  export type CountrySelect = {
    id?: boolean
    name?: boolean
    code?: boolean
    ranking?: boolean
    states?: boolean | StateFindManyArgs
    questionsQuestionEncounters?: boolean | QuestionsQuestionEncounterFindManyArgs
    ResumesResume?: boolean | ResumesResumeFindManyArgs
    _count?: boolean | CountryCountOutputTypeArgs
  }

  export type CountryInclude = {
    states?: boolean | StateFindManyArgs
    questionsQuestionEncounters?: boolean | QuestionsQuestionEncounterFindManyArgs
    ResumesResume?: boolean | ResumesResumeFindManyArgs
    _count?: boolean | CountryCountOutputTypeArgs
  }

  export type CountryGetPayload<
    S extends boolean | null | undefined | CountryArgs,
    U = keyof S
      > = S extends true
        ? Country
    : S extends undefined
    ? never
    : S extends CountryArgs | CountryFindManyArgs
    ?'include' extends U
    ? Country  & {
    [P in TrueKeys<S['include']>]:
        P extends 'states' ? Array < StateGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'questionsQuestionEncounters' ? Array < QuestionsQuestionEncounterGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'ResumesResume' ? Array < ResumesResumeGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? CountryCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'states' ? Array < StateGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'questionsQuestionEncounters' ? Array < QuestionsQuestionEncounterGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'ResumesResume' ? Array < ResumesResumeGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? CountryCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Country ? Country[P] : never
  } 
    : Country
  : Country


  type CountryCountArgs = Merge<
    Omit<CountryFindManyArgs, 'select' | 'include'> & {
      select?: CountryCountAggregateInputType | true
    }
  >

  export interface CountryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Country that matches the filter.
     * @param {CountryFindUniqueArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CountryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CountryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Country'> extends True ? CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>> : CheckSelect<T, Prisma__CountryClient<Country | null, null>, Prisma__CountryClient<CountryGetPayload<T> | null, null>>

    /**
     * Find the first Country that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CountryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CountryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Country'> extends True ? CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>> : CheckSelect<T, Prisma__CountryClient<Country | null, null>, Prisma__CountryClient<CountryGetPayload<T> | null, null>>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.country.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.country.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const countryWithIdOnly = await prisma.country.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CountryFindManyArgs>(
      args?: SelectSubset<T, CountryFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Country>>, PrismaPromise<Array<CountryGetPayload<T>>>>

    /**
     * Create a Country.
     * @param {CountryCreateArgs} args - Arguments to create a Country.
     * @example
     * // Create one Country
     * const Country = await prisma.country.create({
     *   data: {
     *     // ... data to create a Country
     *   }
     * })
     * 
    **/
    create<T extends CountryCreateArgs>(
      args: SelectSubset<T, CountryCreateArgs>
    ): CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>>

    /**
     * Create many Countries.
     *     @param {CountryCreateManyArgs} args - Arguments to create many Countries.
     *     @example
     *     // Create many Countries
     *     const country = await prisma.country.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CountryCreateManyArgs>(
      args?: SelectSubset<T, CountryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Country.
     * @param {CountryDeleteArgs} args - Arguments to delete one Country.
     * @example
     * // Delete one Country
     * const Country = await prisma.country.delete({
     *   where: {
     *     // ... filter to delete one Country
     *   }
     * })
     * 
    **/
    delete<T extends CountryDeleteArgs>(
      args: SelectSubset<T, CountryDeleteArgs>
    ): CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>>

    /**
     * Update one Country.
     * @param {CountryUpdateArgs} args - Arguments to update one Country.
     * @example
     * // Update one Country
     * const country = await prisma.country.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CountryUpdateArgs>(
      args: SelectSubset<T, CountryUpdateArgs>
    ): CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>>

    /**
     * Delete zero or more Countries.
     * @param {CountryDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.country.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CountryDeleteManyArgs>(
      args?: SelectSubset<T, CountryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CountryUpdateManyArgs>(
      args: SelectSubset<T, CountryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Country.
     * @param {CountryUpsertArgs} args - Arguments to update or create a Country.
     * @example
     * // Update or create a Country
     * const country = await prisma.country.upsert({
     *   create: {
     *     // ... data to create a Country
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Country we want to update
     *   }
     * })
    **/
    upsert<T extends CountryUpsertArgs>(
      args: SelectSubset<T, CountryUpsertArgs>
    ): CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>>

    /**
     * Find one Country that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {CountryFindUniqueOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CountryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CountryFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>>

    /**
     * Find the first Country that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CountryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CountryFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>>

    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.country.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends CountryCountArgs>(
      args?: Subset<T, CountryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountryAggregateArgs>(args: Subset<T, CountryAggregateArgs>): PrismaPromise<GetCountryAggregateType<T>>

    /**
     * Group by Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountryGroupByArgs['orderBy'] }
        : { orderBy?: CountryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountryGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Country.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CountryClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    states<T extends StateFindManyArgs = {}>(args?: Subset<T, StateFindManyArgs>): CheckSelect<T, PrismaPromise<Array<State>| Null>, PrismaPromise<Array<StateGetPayload<T>>| Null>>;

    questionsQuestionEncounters<T extends QuestionsQuestionEncounterFindManyArgs = {}>(args?: Subset<T, QuestionsQuestionEncounterFindManyArgs>): CheckSelect<T, PrismaPromise<Array<QuestionsQuestionEncounter>| Null>, PrismaPromise<Array<QuestionsQuestionEncounterGetPayload<T>>| Null>>;

    ResumesResume<T extends ResumesResumeFindManyArgs = {}>(args?: Subset<T, ResumesResumeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ResumesResume>| Null>, PrismaPromise<Array<ResumesResumeGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Country base type for findUnique actions
   */
  export type CountryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Country
     * 
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CountryInclude | null
    /**
     * Filter, which Country to fetch.
     * 
    **/
    where: CountryWhereUniqueInput
  }

  /**
   * Country: findUnique
   */
  export interface CountryFindUniqueArgs extends CountryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Country base type for findFirst actions
   */
  export type CountryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Country
     * 
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CountryInclude | null
    /**
     * Filter, which Country to fetch.
     * 
    **/
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     * 
    **/
    orderBy?: Enumerable<CountryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     * 
    **/
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     * 
    **/
    distinct?: Enumerable<CountryScalarFieldEnum>
  }

  /**
   * Country: findFirst
   */
  export interface CountryFindFirstArgs extends CountryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Country findMany
   */
  export type CountryFindManyArgs = {
    /**
     * Select specific fields to fetch from the Country
     * 
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CountryInclude | null
    /**
     * Filter, which Countries to fetch.
     * 
    **/
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     * 
    **/
    orderBy?: Enumerable<CountryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Countries.
     * 
    **/
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CountryScalarFieldEnum>
  }


  /**
   * Country create
   */
  export type CountryCreateArgs = {
    /**
     * Select specific fields to fetch from the Country
     * 
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CountryInclude | null
    /**
     * The data needed to create a Country.
     * 
    **/
    data: XOR<CountryCreateInput, CountryUncheckedCreateInput>
  }


  /**
   * Country createMany
   */
  export type CountryCreateManyArgs = {
    /**
     * The data used to create many Countries.
     * 
    **/
    data: Enumerable<CountryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Country update
   */
  export type CountryUpdateArgs = {
    /**
     * Select specific fields to fetch from the Country
     * 
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CountryInclude | null
    /**
     * The data needed to update a Country.
     * 
    **/
    data: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
    /**
     * Choose, which Country to update.
     * 
    **/
    where: CountryWhereUniqueInput
  }


  /**
   * Country updateMany
   */
  export type CountryUpdateManyArgs = {
    /**
     * The data used to update Countries.
     * 
    **/
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     * 
    **/
    where?: CountryWhereInput
  }


  /**
   * Country upsert
   */
  export type CountryUpsertArgs = {
    /**
     * Select specific fields to fetch from the Country
     * 
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CountryInclude | null
    /**
     * The filter to search for the Country to update in case it exists.
     * 
    **/
    where: CountryWhereUniqueInput
    /**
     * In case the Country found by the `where` argument doesn't exist, create a new Country with this data.
     * 
    **/
    create: XOR<CountryCreateInput, CountryUncheckedCreateInput>
    /**
     * In case the Country was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
  }


  /**
   * Country delete
   */
  export type CountryDeleteArgs = {
    /**
     * Select specific fields to fetch from the Country
     * 
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CountryInclude | null
    /**
     * Filter which Country to delete.
     * 
    **/
    where: CountryWhereUniqueInput
  }


  /**
   * Country deleteMany
   */
  export type CountryDeleteManyArgs = {
    /**
     * Filter which Countries to delete
     * 
    **/
    where?: CountryWhereInput
  }


  /**
   * Country: findUniqueOrThrow
   */
  export type CountryFindUniqueOrThrowArgs = CountryFindUniqueArgsBase
      

  /**
   * Country: findFirstOrThrow
   */
  export type CountryFindFirstOrThrowArgs = CountryFindFirstArgsBase
      

  /**
   * Country without action
   */
  export type CountryArgs = {
    /**
     * Select specific fields to fetch from the Country
     * 
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CountryInclude | null
  }



  /**
   * Model State
   */


  export type AggregateState = {
    _count: StateCountAggregateOutputType | null
    _min: StateMinAggregateOutputType | null
    _max: StateMaxAggregateOutputType | null
  }

  export type StateMinAggregateOutputType = {
    id: string | null
    name: string | null
    countryId: string | null
  }

  export type StateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    countryId: string | null
  }

  export type StateCountAggregateOutputType = {
    id: number
    name: number
    countryId: number
    _all: number
  }


  export type StateMinAggregateInputType = {
    id?: true
    name?: true
    countryId?: true
  }

  export type StateMaxAggregateInputType = {
    id?: true
    name?: true
    countryId?: true
  }

  export type StateCountAggregateInputType = {
    id?: true
    name?: true
    countryId?: true
    _all?: true
  }

  export type StateAggregateArgs = {
    /**
     * Filter which State to aggregate.
     * 
    **/
    where?: StateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
     * 
    **/
    orderBy?: Enumerable<StateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: StateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned States
    **/
    _count?: true | StateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StateMaxAggregateInputType
  }

  export type GetStateAggregateType<T extends StateAggregateArgs> = {
        [P in keyof T & keyof AggregateState]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateState[P]>
      : GetScalarType<T[P], AggregateState[P]>
  }




  export type StateGroupByArgs = {
    where?: StateWhereInput
    orderBy?: Enumerable<StateOrderByWithAggregationInput>
    by: Array<StateScalarFieldEnum>
    having?: StateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StateCountAggregateInputType | true
    _min?: StateMinAggregateInputType
    _max?: StateMaxAggregateInputType
  }


  export type StateGroupByOutputType = {
    id: string
    name: string
    countryId: string
    _count: StateCountAggregateOutputType | null
    _min: StateMinAggregateOutputType | null
    _max: StateMaxAggregateOutputType | null
  }

  type GetStateGroupByPayload<T extends StateGroupByArgs> = PrismaPromise<
    Array<
      PickArray<StateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StateGroupByOutputType[P]>
            : GetScalarType<T[P], StateGroupByOutputType[P]>
        }
      >
    >


  export type StateSelect = {
    id?: boolean
    name?: boolean
    countryId?: boolean
    cities?: boolean | CityFindManyArgs
    country?: boolean | CountryArgs
    questionsQuestionEncounters?: boolean | QuestionsQuestionEncounterFindManyArgs
    _count?: boolean | StateCountOutputTypeArgs
  }

  export type StateInclude = {
    cities?: boolean | CityFindManyArgs
    country?: boolean | CountryArgs
    questionsQuestionEncounters?: boolean | QuestionsQuestionEncounterFindManyArgs
    _count?: boolean | StateCountOutputTypeArgs
  }

  export type StateGetPayload<
    S extends boolean | null | undefined | StateArgs,
    U = keyof S
      > = S extends true
        ? State
    : S extends undefined
    ? never
    : S extends StateArgs | StateFindManyArgs
    ?'include' extends U
    ? State  & {
    [P in TrueKeys<S['include']>]:
        P extends 'cities' ? Array < CityGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'country' ? CountryGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'questionsQuestionEncounters' ? Array < QuestionsQuestionEncounterGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? StateCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'cities' ? Array < CityGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'country' ? CountryGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'questionsQuestionEncounters' ? Array < QuestionsQuestionEncounterGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? StateCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof State ? State[P] : never
  } 
    : State
  : State


  type StateCountArgs = Merge<
    Omit<StateFindManyArgs, 'select' | 'include'> & {
      select?: StateCountAggregateInputType | true
    }
  >

  export interface StateDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one State that matches the filter.
     * @param {StateFindUniqueArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StateFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StateFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'State'> extends True ? CheckSelect<T, Prisma__StateClient<State>, Prisma__StateClient<StateGetPayload<T>>> : CheckSelect<T, Prisma__StateClient<State | null, null>, Prisma__StateClient<StateGetPayload<T> | null, null>>

    /**
     * Find the first State that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateFindFirstArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StateFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StateFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'State'> extends True ? CheckSelect<T, Prisma__StateClient<State>, Prisma__StateClient<StateGetPayload<T>>> : CheckSelect<T, Prisma__StateClient<State | null, null>, Prisma__StateClient<StateGetPayload<T> | null, null>>

    /**
     * Find zero or more States that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all States
     * const states = await prisma.state.findMany()
     * 
     * // Get first 10 States
     * const states = await prisma.state.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stateWithIdOnly = await prisma.state.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StateFindManyArgs>(
      args?: SelectSubset<T, StateFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<State>>, PrismaPromise<Array<StateGetPayload<T>>>>

    /**
     * Create a State.
     * @param {StateCreateArgs} args - Arguments to create a State.
     * @example
     * // Create one State
     * const State = await prisma.state.create({
     *   data: {
     *     // ... data to create a State
     *   }
     * })
     * 
    **/
    create<T extends StateCreateArgs>(
      args: SelectSubset<T, StateCreateArgs>
    ): CheckSelect<T, Prisma__StateClient<State>, Prisma__StateClient<StateGetPayload<T>>>

    /**
     * Create many States.
     *     @param {StateCreateManyArgs} args - Arguments to create many States.
     *     @example
     *     // Create many States
     *     const state = await prisma.state.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StateCreateManyArgs>(
      args?: SelectSubset<T, StateCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a State.
     * @param {StateDeleteArgs} args - Arguments to delete one State.
     * @example
     * // Delete one State
     * const State = await prisma.state.delete({
     *   where: {
     *     // ... filter to delete one State
     *   }
     * })
     * 
    **/
    delete<T extends StateDeleteArgs>(
      args: SelectSubset<T, StateDeleteArgs>
    ): CheckSelect<T, Prisma__StateClient<State>, Prisma__StateClient<StateGetPayload<T>>>

    /**
     * Update one State.
     * @param {StateUpdateArgs} args - Arguments to update one State.
     * @example
     * // Update one State
     * const state = await prisma.state.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StateUpdateArgs>(
      args: SelectSubset<T, StateUpdateArgs>
    ): CheckSelect<T, Prisma__StateClient<State>, Prisma__StateClient<StateGetPayload<T>>>

    /**
     * Delete zero or more States.
     * @param {StateDeleteManyArgs} args - Arguments to filter States to delete.
     * @example
     * // Delete a few States
     * const { count } = await prisma.state.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StateDeleteManyArgs>(
      args?: SelectSubset<T, StateDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more States.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many States
     * const state = await prisma.state.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StateUpdateManyArgs>(
      args: SelectSubset<T, StateUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one State.
     * @param {StateUpsertArgs} args - Arguments to update or create a State.
     * @example
     * // Update or create a State
     * const state = await prisma.state.upsert({
     *   create: {
     *     // ... data to create a State
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the State we want to update
     *   }
     * })
    **/
    upsert<T extends StateUpsertArgs>(
      args: SelectSubset<T, StateUpsertArgs>
    ): CheckSelect<T, Prisma__StateClient<State>, Prisma__StateClient<StateGetPayload<T>>>

    /**
     * Find one State that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {StateFindUniqueOrThrowArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StateFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, StateFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__StateClient<State>, Prisma__StateClient<StateGetPayload<T>>>

    /**
     * Find the first State that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateFindFirstOrThrowArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StateFindFirstOrThrowArgs>(
      args?: SelectSubset<T, StateFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__StateClient<State>, Prisma__StateClient<StateGetPayload<T>>>

    /**
     * Count the number of States.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateCountArgs} args - Arguments to filter States to count.
     * @example
     * // Count the number of States
     * const count = await prisma.state.count({
     *   where: {
     *     // ... the filter for the States we want to count
     *   }
     * })
    **/
    count<T extends StateCountArgs>(
      args?: Subset<T, StateCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a State.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StateAggregateArgs>(args: Subset<T, StateAggregateArgs>): PrismaPromise<GetStateAggregateType<T>>

    /**
     * Group by State.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StateGroupByArgs['orderBy'] }
        : { orderBy?: StateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStateGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for State.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StateClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    cities<T extends CityFindManyArgs = {}>(args?: Subset<T, CityFindManyArgs>): CheckSelect<T, PrismaPromise<Array<City>| Null>, PrismaPromise<Array<CityGetPayload<T>>| Null>>;

    country<T extends CountryArgs = {}>(args?: Subset<T, CountryArgs>): CheckSelect<T, Prisma__CountryClient<Country | Null>, Prisma__CountryClient<CountryGetPayload<T> | Null>>;

    questionsQuestionEncounters<T extends QuestionsQuestionEncounterFindManyArgs = {}>(args?: Subset<T, QuestionsQuestionEncounterFindManyArgs>): CheckSelect<T, PrismaPromise<Array<QuestionsQuestionEncounter>| Null>, PrismaPromise<Array<QuestionsQuestionEncounterGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * State base type for findUnique actions
   */
  export type StateFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the State
     * 
    **/
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StateInclude | null
    /**
     * Filter, which State to fetch.
     * 
    **/
    where: StateWhereUniqueInput
  }

  /**
   * State: findUnique
   */
  export interface StateFindUniqueArgs extends StateFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * State base type for findFirst actions
   */
  export type StateFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the State
     * 
    **/
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StateInclude | null
    /**
     * Filter, which State to fetch.
     * 
    **/
    where?: StateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
     * 
    **/
    orderBy?: Enumerable<StateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for States.
     * 
    **/
    cursor?: StateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of States.
     * 
    **/
    distinct?: Enumerable<StateScalarFieldEnum>
  }

  /**
   * State: findFirst
   */
  export interface StateFindFirstArgs extends StateFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * State findMany
   */
  export type StateFindManyArgs = {
    /**
     * Select specific fields to fetch from the State
     * 
    **/
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StateInclude | null
    /**
     * Filter, which States to fetch.
     * 
    **/
    where?: StateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
     * 
    **/
    orderBy?: Enumerable<StateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing States.
     * 
    **/
    cursor?: StateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StateScalarFieldEnum>
  }


  /**
   * State create
   */
  export type StateCreateArgs = {
    /**
     * Select specific fields to fetch from the State
     * 
    **/
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StateInclude | null
    /**
     * The data needed to create a State.
     * 
    **/
    data: XOR<StateCreateInput, StateUncheckedCreateInput>
  }


  /**
   * State createMany
   */
  export type StateCreateManyArgs = {
    /**
     * The data used to create many States.
     * 
    **/
    data: Enumerable<StateCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * State update
   */
  export type StateUpdateArgs = {
    /**
     * Select specific fields to fetch from the State
     * 
    **/
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StateInclude | null
    /**
     * The data needed to update a State.
     * 
    **/
    data: XOR<StateUpdateInput, StateUncheckedUpdateInput>
    /**
     * Choose, which State to update.
     * 
    **/
    where: StateWhereUniqueInput
  }


  /**
   * State updateMany
   */
  export type StateUpdateManyArgs = {
    /**
     * The data used to update States.
     * 
    **/
    data: XOR<StateUpdateManyMutationInput, StateUncheckedUpdateManyInput>
    /**
     * Filter which States to update
     * 
    **/
    where?: StateWhereInput
  }


  /**
   * State upsert
   */
  export type StateUpsertArgs = {
    /**
     * Select specific fields to fetch from the State
     * 
    **/
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StateInclude | null
    /**
     * The filter to search for the State to update in case it exists.
     * 
    **/
    where: StateWhereUniqueInput
    /**
     * In case the State found by the `where` argument doesn't exist, create a new State with this data.
     * 
    **/
    create: XOR<StateCreateInput, StateUncheckedCreateInput>
    /**
     * In case the State was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<StateUpdateInput, StateUncheckedUpdateInput>
  }


  /**
   * State delete
   */
  export type StateDeleteArgs = {
    /**
     * Select specific fields to fetch from the State
     * 
    **/
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StateInclude | null
    /**
     * Filter which State to delete.
     * 
    **/
    where: StateWhereUniqueInput
  }


  /**
   * State deleteMany
   */
  export type StateDeleteManyArgs = {
    /**
     * Filter which States to delete
     * 
    **/
    where?: StateWhereInput
  }


  /**
   * State: findUniqueOrThrow
   */
  export type StateFindUniqueOrThrowArgs = StateFindUniqueArgsBase
      

  /**
   * State: findFirstOrThrow
   */
  export type StateFindFirstOrThrowArgs = StateFindFirstArgsBase
      

  /**
   * State without action
   */
  export type StateArgs = {
    /**
     * Select specific fields to fetch from the State
     * 
    **/
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StateInclude | null
  }



  /**
   * Model City
   */


  export type AggregateCity = {
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  export type CityAvgAggregateOutputType = {
    ranking: number | null
  }

  export type CitySumAggregateOutputType = {
    ranking: number | null
  }

  export type CityMinAggregateOutputType = {
    id: string | null
    name: string | null
    stateId: string | null
    ranking: number | null
  }

  export type CityMaxAggregateOutputType = {
    id: string | null
    name: string | null
    stateId: string | null
    ranking: number | null
  }

  export type CityCountAggregateOutputType = {
    id: number
    name: number
    stateId: number
    ranking: number
    _all: number
  }


  export type CityAvgAggregateInputType = {
    ranking?: true
  }

  export type CitySumAggregateInputType = {
    ranking?: true
  }

  export type CityMinAggregateInputType = {
    id?: true
    name?: true
    stateId?: true
    ranking?: true
  }

  export type CityMaxAggregateInputType = {
    id?: true
    name?: true
    stateId?: true
    ranking?: true
  }

  export type CityCountAggregateInputType = {
    id?: true
    name?: true
    stateId?: true
    ranking?: true
    _all?: true
  }

  export type CityAggregateArgs = {
    /**
     * Filter which City to aggregate.
     * 
    **/
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     * 
    **/
    orderBy?: Enumerable<CityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cities
    **/
    _count?: true | CityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CityMaxAggregateInputType
  }

  export type GetCityAggregateType<T extends CityAggregateArgs> = {
        [P in keyof T & keyof AggregateCity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCity[P]>
      : GetScalarType<T[P], AggregateCity[P]>
  }




  export type CityGroupByArgs = {
    where?: CityWhereInput
    orderBy?: Enumerable<CityOrderByWithAggregationInput>
    by: Array<CityScalarFieldEnum>
    having?: CityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CityCountAggregateInputType | true
    _avg?: CityAvgAggregateInputType
    _sum?: CitySumAggregateInputType
    _min?: CityMinAggregateInputType
    _max?: CityMaxAggregateInputType
  }


  export type CityGroupByOutputType = {
    id: string
    name: string
    stateId: string
    ranking: number | null
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  type GetCityGroupByPayload<T extends CityGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CityGroupByOutputType[P]>
            : GetScalarType<T[P], CityGroupByOutputType[P]>
        }
      >
    >


  export type CitySelect = {
    id?: boolean
    name?: boolean
    stateId?: boolean
    ranking?: boolean
    state?: boolean | StateArgs
    questionsQuestionEncounters?: boolean | QuestionsQuestionEncounterFindManyArgs
    OffersExperience?: boolean | OffersExperienceFindManyArgs
    OffersOffer?: boolean | OffersOfferFindManyArgs
    _count?: boolean | CityCountOutputTypeArgs
  }

  export type CityInclude = {
    state?: boolean | StateArgs
    questionsQuestionEncounters?: boolean | QuestionsQuestionEncounterFindManyArgs
    OffersExperience?: boolean | OffersExperienceFindManyArgs
    OffersOffer?: boolean | OffersOfferFindManyArgs
    _count?: boolean | CityCountOutputTypeArgs
  }

  export type CityGetPayload<
    S extends boolean | null | undefined | CityArgs,
    U = keyof S
      > = S extends true
        ? City
    : S extends undefined
    ? never
    : S extends CityArgs | CityFindManyArgs
    ?'include' extends U
    ? City  & {
    [P in TrueKeys<S['include']>]:
        P extends 'state' ? StateGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'questionsQuestionEncounters' ? Array < QuestionsQuestionEncounterGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'OffersExperience' ? Array < OffersExperienceGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'OffersOffer' ? Array < OffersOfferGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? CityCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'state' ? StateGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'questionsQuestionEncounters' ? Array < QuestionsQuestionEncounterGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'OffersExperience' ? Array < OffersExperienceGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'OffersOffer' ? Array < OffersOfferGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? CityCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof City ? City[P] : never
  } 
    : City
  : City


  type CityCountArgs = Merge<
    Omit<CityFindManyArgs, 'select' | 'include'> & {
      select?: CityCountAggregateInputType | true
    }
  >

  export interface CityDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one City that matches the filter.
     * @param {CityFindUniqueArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CityFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CityFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'City'> extends True ? CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>> : CheckSelect<T, Prisma__CityClient<City | null, null>, Prisma__CityClient<CityGetPayload<T> | null, null>>

    /**
     * Find the first City that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CityFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CityFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'City'> extends True ? CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>> : CheckSelect<T, Prisma__CityClient<City | null, null>, Prisma__CityClient<CityGetPayload<T> | null, null>>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.city.findMany()
     * 
     * // Get first 10 Cities
     * const cities = await prisma.city.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cityWithIdOnly = await prisma.city.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CityFindManyArgs>(
      args?: SelectSubset<T, CityFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<City>>, PrismaPromise<Array<CityGetPayload<T>>>>

    /**
     * Create a City.
     * @param {CityCreateArgs} args - Arguments to create a City.
     * @example
     * // Create one City
     * const City = await prisma.city.create({
     *   data: {
     *     // ... data to create a City
     *   }
     * })
     * 
    **/
    create<T extends CityCreateArgs>(
      args: SelectSubset<T, CityCreateArgs>
    ): CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>>

    /**
     * Create many Cities.
     *     @param {CityCreateManyArgs} args - Arguments to create many Cities.
     *     @example
     *     // Create many Cities
     *     const city = await prisma.city.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CityCreateManyArgs>(
      args?: SelectSubset<T, CityCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a City.
     * @param {CityDeleteArgs} args - Arguments to delete one City.
     * @example
     * // Delete one City
     * const City = await prisma.city.delete({
     *   where: {
     *     // ... filter to delete one City
     *   }
     * })
     * 
    **/
    delete<T extends CityDeleteArgs>(
      args: SelectSubset<T, CityDeleteArgs>
    ): CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>>

    /**
     * Update one City.
     * @param {CityUpdateArgs} args - Arguments to update one City.
     * @example
     * // Update one City
     * const city = await prisma.city.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CityUpdateArgs>(
      args: SelectSubset<T, CityUpdateArgs>
    ): CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>>

    /**
     * Delete zero or more Cities.
     * @param {CityDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.city.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CityDeleteManyArgs>(
      args?: SelectSubset<T, CityDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CityUpdateManyArgs>(
      args: SelectSubset<T, CityUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one City.
     * @param {CityUpsertArgs} args - Arguments to update or create a City.
     * @example
     * // Update or create a City
     * const city = await prisma.city.upsert({
     *   create: {
     *     // ... data to create a City
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the City we want to update
     *   }
     * })
    **/
    upsert<T extends CityUpsertArgs>(
      args: SelectSubset<T, CityUpsertArgs>
    ): CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>>

    /**
     * Find one City that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {CityFindUniqueOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CityFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CityFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>>

    /**
     * Find the first City that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CityFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CityFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>>

    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.city.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends CityCountArgs>(
      args?: Subset<T, CityCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CityAggregateArgs>(args: Subset<T, CityAggregateArgs>): PrismaPromise<GetCityAggregateType<T>>

    /**
     * Group by City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CityGroupByArgs['orderBy'] }
        : { orderBy?: CityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCityGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for City.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CityClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    state<T extends StateArgs = {}>(args?: Subset<T, StateArgs>): CheckSelect<T, Prisma__StateClient<State | Null>, Prisma__StateClient<StateGetPayload<T> | Null>>;

    questionsQuestionEncounters<T extends QuestionsQuestionEncounterFindManyArgs = {}>(args?: Subset<T, QuestionsQuestionEncounterFindManyArgs>): CheckSelect<T, PrismaPromise<Array<QuestionsQuestionEncounter>| Null>, PrismaPromise<Array<QuestionsQuestionEncounterGetPayload<T>>| Null>>;

    OffersExperience<T extends OffersExperienceFindManyArgs = {}>(args?: Subset<T, OffersExperienceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OffersExperience>| Null>, PrismaPromise<Array<OffersExperienceGetPayload<T>>| Null>>;

    OffersOffer<T extends OffersOfferFindManyArgs = {}>(args?: Subset<T, OffersOfferFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OffersOffer>| Null>, PrismaPromise<Array<OffersOfferGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * City base type for findUnique actions
   */
  export type CityFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * Filter, which City to fetch.
     * 
    **/
    where: CityWhereUniqueInput
  }

  /**
   * City: findUnique
   */
  export interface CityFindUniqueArgs extends CityFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * City base type for findFirst actions
   */
  export type CityFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * Filter, which City to fetch.
     * 
    **/
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     * 
    **/
    orderBy?: Enumerable<CityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     * 
    **/
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     * 
    **/
    distinct?: Enumerable<CityScalarFieldEnum>
  }

  /**
   * City: findFirst
   */
  export interface CityFindFirstArgs extends CityFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * City findMany
   */
  export type CityFindManyArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * Filter, which Cities to fetch.
     * 
    **/
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     * 
    **/
    orderBy?: Enumerable<CityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cities.
     * 
    **/
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CityScalarFieldEnum>
  }


  /**
   * City create
   */
  export type CityCreateArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * The data needed to create a City.
     * 
    **/
    data: XOR<CityCreateInput, CityUncheckedCreateInput>
  }


  /**
   * City createMany
   */
  export type CityCreateManyArgs = {
    /**
     * The data used to create many Cities.
     * 
    **/
    data: Enumerable<CityCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * City update
   */
  export type CityUpdateArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * The data needed to update a City.
     * 
    **/
    data: XOR<CityUpdateInput, CityUncheckedUpdateInput>
    /**
     * Choose, which City to update.
     * 
    **/
    where: CityWhereUniqueInput
  }


  /**
   * City updateMany
   */
  export type CityUpdateManyArgs = {
    /**
     * The data used to update Cities.
     * 
    **/
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    /**
     * Filter which Cities to update
     * 
    **/
    where?: CityWhereInput
  }


  /**
   * City upsert
   */
  export type CityUpsertArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * The filter to search for the City to update in case it exists.
     * 
    **/
    where: CityWhereUniqueInput
    /**
     * In case the City found by the `where` argument doesn't exist, create a new City with this data.
     * 
    **/
    create: XOR<CityCreateInput, CityUncheckedCreateInput>
    /**
     * In case the City was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CityUpdateInput, CityUncheckedUpdateInput>
  }


  /**
   * City delete
   */
  export type CityDeleteArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * Filter which City to delete.
     * 
    **/
    where: CityWhereUniqueInput
  }


  /**
   * City deleteMany
   */
  export type CityDeleteManyArgs = {
    /**
     * Filter which Cities to delete
     * 
    **/
    where?: CityWhereInput
  }


  /**
   * City: findUniqueOrThrow
   */
  export type CityFindUniqueOrThrowArgs = CityFindUniqueArgsBase
      

  /**
   * City: findFirstOrThrow
   */
  export type CityFindFirstOrThrowArgs = CityFindFirstArgsBase
      

  /**
   * City without action
   */
  export type CityArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
  }



  /**
   * Model ResumesResume
   */


  export type AggregateResumesResume = {
    _count: ResumesResumeCountAggregateOutputType | null
    _min: ResumesResumeMinAggregateOutputType | null
    _max: ResumesResumeMaxAggregateOutputType | null
  }

  export type ResumesResumeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    role: string | null
    experience: string | null
    locationId: string | null
    url: string | null
    additionalInfo: string | null
    isResolved: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResumesResumeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    role: string | null
    experience: string | null
    locationId: string | null
    url: string | null
    additionalInfo: string | null
    isResolved: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResumesResumeCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    role: number
    experience: number
    locationId: number
    url: number
    additionalInfo: number
    isResolved: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ResumesResumeMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    role?: true
    experience?: true
    locationId?: true
    url?: true
    additionalInfo?: true
    isResolved?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResumesResumeMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    role?: true
    experience?: true
    locationId?: true
    url?: true
    additionalInfo?: true
    isResolved?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResumesResumeCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    role?: true
    experience?: true
    locationId?: true
    url?: true
    additionalInfo?: true
    isResolved?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ResumesResumeAggregateArgs = {
    /**
     * Filter which ResumesResume to aggregate.
     * 
    **/
    where?: ResumesResumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumesResumes to fetch.
     * 
    **/
    orderBy?: Enumerable<ResumesResumeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ResumesResumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumesResumes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumesResumes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResumesResumes
    **/
    _count?: true | ResumesResumeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResumesResumeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResumesResumeMaxAggregateInputType
  }

  export type GetResumesResumeAggregateType<T extends ResumesResumeAggregateArgs> = {
        [P in keyof T & keyof AggregateResumesResume]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResumesResume[P]>
      : GetScalarType<T[P], AggregateResumesResume[P]>
  }




  export type ResumesResumeGroupByArgs = {
    where?: ResumesResumeWhereInput
    orderBy?: Enumerable<ResumesResumeOrderByWithAggregationInput>
    by: Array<ResumesResumeScalarFieldEnum>
    having?: ResumesResumeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResumesResumeCountAggregateInputType | true
    _min?: ResumesResumeMinAggregateInputType
    _max?: ResumesResumeMaxAggregateInputType
  }


  export type ResumesResumeGroupByOutputType = {
    id: string
    userId: string
    title: string
    role: string
    experience: string
    locationId: string
    url: string
    additionalInfo: string | null
    isResolved: boolean
    createdAt: Date
    updatedAt: Date
    _count: ResumesResumeCountAggregateOutputType | null
    _min: ResumesResumeMinAggregateOutputType | null
    _max: ResumesResumeMaxAggregateOutputType | null
  }

  type GetResumesResumeGroupByPayload<T extends ResumesResumeGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ResumesResumeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResumesResumeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResumesResumeGroupByOutputType[P]>
            : GetScalarType<T[P], ResumesResumeGroupByOutputType[P]>
        }
      >
    >


  export type ResumesResumeSelect = {
    id?: boolean
    userId?: boolean
    title?: boolean
    role?: boolean
    experience?: boolean
    locationId?: boolean
    url?: boolean
    additionalInfo?: boolean
    isResolved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs
    location?: boolean | CountryArgs
    stars?: boolean | ResumesStarFindManyArgs
    comments?: boolean | ResumesCommentFindManyArgs
    _count?: boolean | ResumesResumeCountOutputTypeArgs
  }

  export type ResumesResumeInclude = {
    user?: boolean | UserArgs
    location?: boolean | CountryArgs
    stars?: boolean | ResumesStarFindManyArgs
    comments?: boolean | ResumesCommentFindManyArgs
    _count?: boolean | ResumesResumeCountOutputTypeArgs
  }

  export type ResumesResumeGetPayload<
    S extends boolean | null | undefined | ResumesResumeArgs,
    U = keyof S
      > = S extends true
        ? ResumesResume
    : S extends undefined
    ? never
    : S extends ResumesResumeArgs | ResumesResumeFindManyArgs
    ?'include' extends U
    ? ResumesResume  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'location' ? CountryGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'stars' ? Array < ResumesStarGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'comments' ? Array < ResumesCommentGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? ResumesResumeCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'location' ? CountryGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'stars' ? Array < ResumesStarGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'comments' ? Array < ResumesCommentGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? ResumesResumeCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof ResumesResume ? ResumesResume[P] : never
  } 
    : ResumesResume
  : ResumesResume


  type ResumesResumeCountArgs = Merge<
    Omit<ResumesResumeFindManyArgs, 'select' | 'include'> & {
      select?: ResumesResumeCountAggregateInputType | true
    }
  >

  export interface ResumesResumeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one ResumesResume that matches the filter.
     * @param {ResumesResumeFindUniqueArgs} args - Arguments to find a ResumesResume
     * @example
     * // Get one ResumesResume
     * const resumesResume = await prisma.resumesResume.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ResumesResumeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ResumesResumeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ResumesResume'> extends True ? CheckSelect<T, Prisma__ResumesResumeClient<ResumesResume>, Prisma__ResumesResumeClient<ResumesResumeGetPayload<T>>> : CheckSelect<T, Prisma__ResumesResumeClient<ResumesResume | null, null>, Prisma__ResumesResumeClient<ResumesResumeGetPayload<T> | null, null>>

    /**
     * Find the first ResumesResume that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumesResumeFindFirstArgs} args - Arguments to find a ResumesResume
     * @example
     * // Get one ResumesResume
     * const resumesResume = await prisma.resumesResume.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ResumesResumeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ResumesResumeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ResumesResume'> extends True ? CheckSelect<T, Prisma__ResumesResumeClient<ResumesResume>, Prisma__ResumesResumeClient<ResumesResumeGetPayload<T>>> : CheckSelect<T, Prisma__ResumesResumeClient<ResumesResume | null, null>, Prisma__ResumesResumeClient<ResumesResumeGetPayload<T> | null, null>>

    /**
     * Find zero or more ResumesResumes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumesResumeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResumesResumes
     * const resumesResumes = await prisma.resumesResume.findMany()
     * 
     * // Get first 10 ResumesResumes
     * const resumesResumes = await prisma.resumesResume.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resumesResumeWithIdOnly = await prisma.resumesResume.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ResumesResumeFindManyArgs>(
      args?: SelectSubset<T, ResumesResumeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ResumesResume>>, PrismaPromise<Array<ResumesResumeGetPayload<T>>>>

    /**
     * Create a ResumesResume.
     * @param {ResumesResumeCreateArgs} args - Arguments to create a ResumesResume.
     * @example
     * // Create one ResumesResume
     * const ResumesResume = await prisma.resumesResume.create({
     *   data: {
     *     // ... data to create a ResumesResume
     *   }
     * })
     * 
    **/
    create<T extends ResumesResumeCreateArgs>(
      args: SelectSubset<T, ResumesResumeCreateArgs>
    ): CheckSelect<T, Prisma__ResumesResumeClient<ResumesResume>, Prisma__ResumesResumeClient<ResumesResumeGetPayload<T>>>

    /**
     * Create many ResumesResumes.
     *     @param {ResumesResumeCreateManyArgs} args - Arguments to create many ResumesResumes.
     *     @example
     *     // Create many ResumesResumes
     *     const resumesResume = await prisma.resumesResume.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ResumesResumeCreateManyArgs>(
      args?: SelectSubset<T, ResumesResumeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ResumesResume.
     * @param {ResumesResumeDeleteArgs} args - Arguments to delete one ResumesResume.
     * @example
     * // Delete one ResumesResume
     * const ResumesResume = await prisma.resumesResume.delete({
     *   where: {
     *     // ... filter to delete one ResumesResume
     *   }
     * })
     * 
    **/
    delete<T extends ResumesResumeDeleteArgs>(
      args: SelectSubset<T, ResumesResumeDeleteArgs>
    ): CheckSelect<T, Prisma__ResumesResumeClient<ResumesResume>, Prisma__ResumesResumeClient<ResumesResumeGetPayload<T>>>

    /**
     * Update one ResumesResume.
     * @param {ResumesResumeUpdateArgs} args - Arguments to update one ResumesResume.
     * @example
     * // Update one ResumesResume
     * const resumesResume = await prisma.resumesResume.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ResumesResumeUpdateArgs>(
      args: SelectSubset<T, ResumesResumeUpdateArgs>
    ): CheckSelect<T, Prisma__ResumesResumeClient<ResumesResume>, Prisma__ResumesResumeClient<ResumesResumeGetPayload<T>>>

    /**
     * Delete zero or more ResumesResumes.
     * @param {ResumesResumeDeleteManyArgs} args - Arguments to filter ResumesResumes to delete.
     * @example
     * // Delete a few ResumesResumes
     * const { count } = await prisma.resumesResume.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ResumesResumeDeleteManyArgs>(
      args?: SelectSubset<T, ResumesResumeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResumesResumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumesResumeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResumesResumes
     * const resumesResume = await prisma.resumesResume.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ResumesResumeUpdateManyArgs>(
      args: SelectSubset<T, ResumesResumeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ResumesResume.
     * @param {ResumesResumeUpsertArgs} args - Arguments to update or create a ResumesResume.
     * @example
     * // Update or create a ResumesResume
     * const resumesResume = await prisma.resumesResume.upsert({
     *   create: {
     *     // ... data to create a ResumesResume
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResumesResume we want to update
     *   }
     * })
    **/
    upsert<T extends ResumesResumeUpsertArgs>(
      args: SelectSubset<T, ResumesResumeUpsertArgs>
    ): CheckSelect<T, Prisma__ResumesResumeClient<ResumesResume>, Prisma__ResumesResumeClient<ResumesResumeGetPayload<T>>>

    /**
     * Find one ResumesResume that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ResumesResumeFindUniqueOrThrowArgs} args - Arguments to find a ResumesResume
     * @example
     * // Get one ResumesResume
     * const resumesResume = await prisma.resumesResume.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ResumesResumeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ResumesResumeFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ResumesResumeClient<ResumesResume>, Prisma__ResumesResumeClient<ResumesResumeGetPayload<T>>>

    /**
     * Find the first ResumesResume that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumesResumeFindFirstOrThrowArgs} args - Arguments to find a ResumesResume
     * @example
     * // Get one ResumesResume
     * const resumesResume = await prisma.resumesResume.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ResumesResumeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ResumesResumeFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ResumesResumeClient<ResumesResume>, Prisma__ResumesResumeClient<ResumesResumeGetPayload<T>>>

    /**
     * Count the number of ResumesResumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumesResumeCountArgs} args - Arguments to filter ResumesResumes to count.
     * @example
     * // Count the number of ResumesResumes
     * const count = await prisma.resumesResume.count({
     *   where: {
     *     // ... the filter for the ResumesResumes we want to count
     *   }
     * })
    **/
    count<T extends ResumesResumeCountArgs>(
      args?: Subset<T, ResumesResumeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResumesResumeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResumesResume.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumesResumeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResumesResumeAggregateArgs>(args: Subset<T, ResumesResumeAggregateArgs>): PrismaPromise<GetResumesResumeAggregateType<T>>

    /**
     * Group by ResumesResume.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumesResumeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResumesResumeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResumesResumeGroupByArgs['orderBy'] }
        : { orderBy?: ResumesResumeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResumesResumeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResumesResumeGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ResumesResume.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ResumesResumeClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    location<T extends CountryArgs = {}>(args?: Subset<T, CountryArgs>): CheckSelect<T, Prisma__CountryClient<Country | Null>, Prisma__CountryClient<CountryGetPayload<T> | Null>>;

    stars<T extends ResumesStarFindManyArgs = {}>(args?: Subset<T, ResumesStarFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ResumesStar>| Null>, PrismaPromise<Array<ResumesStarGetPayload<T>>| Null>>;

    comments<T extends ResumesCommentFindManyArgs = {}>(args?: Subset<T, ResumesCommentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ResumesComment>| Null>, PrismaPromise<Array<ResumesCommentGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ResumesResume base type for findUnique actions
   */
  export type ResumesResumeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ResumesResume
     * 
    **/
    select?: ResumesResumeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ResumesResumeInclude | null
    /**
     * Filter, which ResumesResume to fetch.
     * 
    **/
    where: ResumesResumeWhereUniqueInput
  }

  /**
   * ResumesResume: findUnique
   */
  export interface ResumesResumeFindUniqueArgs extends ResumesResumeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ResumesResume base type for findFirst actions
   */
  export type ResumesResumeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ResumesResume
     * 
    **/
    select?: ResumesResumeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ResumesResumeInclude | null
    /**
     * Filter, which ResumesResume to fetch.
     * 
    **/
    where?: ResumesResumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumesResumes to fetch.
     * 
    **/
    orderBy?: Enumerable<ResumesResumeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResumesResumes.
     * 
    **/
    cursor?: ResumesResumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumesResumes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumesResumes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResumesResumes.
     * 
    **/
    distinct?: Enumerable<ResumesResumeScalarFieldEnum>
  }

  /**
   * ResumesResume: findFirst
   */
  export interface ResumesResumeFindFirstArgs extends ResumesResumeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ResumesResume findMany
   */
  export type ResumesResumeFindManyArgs = {
    /**
     * Select specific fields to fetch from the ResumesResume
     * 
    **/
    select?: ResumesResumeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ResumesResumeInclude | null
    /**
     * Filter, which ResumesResumes to fetch.
     * 
    **/
    where?: ResumesResumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumesResumes to fetch.
     * 
    **/
    orderBy?: Enumerable<ResumesResumeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResumesResumes.
     * 
    **/
    cursor?: ResumesResumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumesResumes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumesResumes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ResumesResumeScalarFieldEnum>
  }


  /**
   * ResumesResume create
   */
  export type ResumesResumeCreateArgs = {
    /**
     * Select specific fields to fetch from the ResumesResume
     * 
    **/
    select?: ResumesResumeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ResumesResumeInclude | null
    /**
     * The data needed to create a ResumesResume.
     * 
    **/
    data: XOR<ResumesResumeCreateInput, ResumesResumeUncheckedCreateInput>
  }


  /**
   * ResumesResume createMany
   */
  export type ResumesResumeCreateManyArgs = {
    /**
     * The data used to create many ResumesResumes.
     * 
    **/
    data: Enumerable<ResumesResumeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ResumesResume update
   */
  export type ResumesResumeUpdateArgs = {
    /**
     * Select specific fields to fetch from the ResumesResume
     * 
    **/
    select?: ResumesResumeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ResumesResumeInclude | null
    /**
     * The data needed to update a ResumesResume.
     * 
    **/
    data: XOR<ResumesResumeUpdateInput, ResumesResumeUncheckedUpdateInput>
    /**
     * Choose, which ResumesResume to update.
     * 
    **/
    where: ResumesResumeWhereUniqueInput
  }


  /**
   * ResumesResume updateMany
   */
  export type ResumesResumeUpdateManyArgs = {
    /**
     * The data used to update ResumesResumes.
     * 
    **/
    data: XOR<ResumesResumeUpdateManyMutationInput, ResumesResumeUncheckedUpdateManyInput>
    /**
     * Filter which ResumesResumes to update
     * 
    **/
    where?: ResumesResumeWhereInput
  }


  /**
   * ResumesResume upsert
   */
  export type ResumesResumeUpsertArgs = {
    /**
     * Select specific fields to fetch from the ResumesResume
     * 
    **/
    select?: ResumesResumeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ResumesResumeInclude | null
    /**
     * The filter to search for the ResumesResume to update in case it exists.
     * 
    **/
    where: ResumesResumeWhereUniqueInput
    /**
     * In case the ResumesResume found by the `where` argument doesn't exist, create a new ResumesResume with this data.
     * 
    **/
    create: XOR<ResumesResumeCreateInput, ResumesResumeUncheckedCreateInput>
    /**
     * In case the ResumesResume was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ResumesResumeUpdateInput, ResumesResumeUncheckedUpdateInput>
  }


  /**
   * ResumesResume delete
   */
  export type ResumesResumeDeleteArgs = {
    /**
     * Select specific fields to fetch from the ResumesResume
     * 
    **/
    select?: ResumesResumeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ResumesResumeInclude | null
    /**
     * Filter which ResumesResume to delete.
     * 
    **/
    where: ResumesResumeWhereUniqueInput
  }


  /**
   * ResumesResume deleteMany
   */
  export type ResumesResumeDeleteManyArgs = {
    /**
     * Filter which ResumesResumes to delete
     * 
    **/
    where?: ResumesResumeWhereInput
  }


  /**
   * ResumesResume: findUniqueOrThrow
   */
  export type ResumesResumeFindUniqueOrThrowArgs = ResumesResumeFindUniqueArgsBase
      

  /**
   * ResumesResume: findFirstOrThrow
   */
  export type ResumesResumeFindFirstOrThrowArgs = ResumesResumeFindFirstArgsBase
      

  /**
   * ResumesResume without action
   */
  export type ResumesResumeArgs = {
    /**
     * Select specific fields to fetch from the ResumesResume
     * 
    **/
    select?: ResumesResumeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ResumesResumeInclude | null
  }



  /**
   * Model ResumesStar
   */


  export type AggregateResumesStar = {
    _count: ResumesStarCountAggregateOutputType | null
    _min: ResumesStarMinAggregateOutputType | null
    _max: ResumesStarMaxAggregateOutputType | null
  }

  export type ResumesStarMinAggregateOutputType = {
    id: string | null
    userId: string | null
    resumeId: string | null
    createdAt: Date | null
  }

  export type ResumesStarMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    resumeId: string | null
    createdAt: Date | null
  }

  export type ResumesStarCountAggregateOutputType = {
    id: number
    userId: number
    resumeId: number
    createdAt: number
    _all: number
  }


  export type ResumesStarMinAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    createdAt?: true
  }

  export type ResumesStarMaxAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    createdAt?: true
  }

  export type ResumesStarCountAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    createdAt?: true
    _all?: true
  }

  export type ResumesStarAggregateArgs = {
    /**
     * Filter which ResumesStar to aggregate.
     * 
    **/
    where?: ResumesStarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumesStars to fetch.
     * 
    **/
    orderBy?: Enumerable<ResumesStarOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ResumesStarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumesStars from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumesStars.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResumesStars
    **/
    _count?: true | ResumesStarCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResumesStarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResumesStarMaxAggregateInputType
  }

  export type GetResumesStarAggregateType<T extends ResumesStarAggregateArgs> = {
        [P in keyof T & keyof AggregateResumesStar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResumesStar[P]>
      : GetScalarType<T[P], AggregateResumesStar[P]>
  }




  export type ResumesStarGroupByArgs = {
    where?: ResumesStarWhereInput
    orderBy?: Enumerable<ResumesStarOrderByWithAggregationInput>
    by: Array<ResumesStarScalarFieldEnum>
    having?: ResumesStarScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResumesStarCountAggregateInputType | true
    _min?: ResumesStarMinAggregateInputType
    _max?: ResumesStarMaxAggregateInputType
  }


  export type ResumesStarGroupByOutputType = {
    id: string
    userId: string
    resumeId: string
    createdAt: Date
    _count: ResumesStarCountAggregateOutputType | null
    _min: ResumesStarMinAggregateOutputType | null
    _max: ResumesStarMaxAggregateOutputType | null
  }

  type GetResumesStarGroupByPayload<T extends ResumesStarGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ResumesStarGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResumesStarGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResumesStarGroupByOutputType[P]>
            : GetScalarType<T[P], ResumesStarGroupByOutputType[P]>
        }
      >
    >


  export type ResumesStarSelect = {
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    createdAt?: boolean
    resume?: boolean | ResumesResumeArgs
    user?: boolean | UserArgs
  }

  export type ResumesStarInclude = {
    resume?: boolean | ResumesResumeArgs
    user?: boolean | UserArgs
  }

  export type ResumesStarGetPayload<
    S extends boolean | null | undefined | ResumesStarArgs,
    U = keyof S
      > = S extends true
        ? ResumesStar
    : S extends undefined
    ? never
    : S extends ResumesStarArgs | ResumesStarFindManyArgs
    ?'include' extends U
    ? ResumesStar  & {
    [P in TrueKeys<S['include']>]:
        P extends 'resume' ? ResumesResumeGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'resume' ? ResumesResumeGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof ResumesStar ? ResumesStar[P] : never
  } 
    : ResumesStar
  : ResumesStar


  type ResumesStarCountArgs = Merge<
    Omit<ResumesStarFindManyArgs, 'select' | 'include'> & {
      select?: ResumesStarCountAggregateInputType | true
    }
  >

  export interface ResumesStarDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one ResumesStar that matches the filter.
     * @param {ResumesStarFindUniqueArgs} args - Arguments to find a ResumesStar
     * @example
     * // Get one ResumesStar
     * const resumesStar = await prisma.resumesStar.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ResumesStarFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ResumesStarFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ResumesStar'> extends True ? CheckSelect<T, Prisma__ResumesStarClient<ResumesStar>, Prisma__ResumesStarClient<ResumesStarGetPayload<T>>> : CheckSelect<T, Prisma__ResumesStarClient<ResumesStar | null, null>, Prisma__ResumesStarClient<ResumesStarGetPayload<T> | null, null>>

    /**
     * Find the first ResumesStar that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumesStarFindFirstArgs} args - Arguments to find a ResumesStar
     * @example
     * // Get one ResumesStar
     * const resumesStar = await prisma.resumesStar.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ResumesStarFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ResumesStarFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ResumesStar'> extends True ? CheckSelect<T, Prisma__ResumesStarClient<ResumesStar>, Prisma__ResumesStarClient<ResumesStarGetPayload<T>>> : CheckSelect<T, Prisma__ResumesStarClient<ResumesStar | null, null>, Prisma__ResumesStarClient<ResumesStarGetPayload<T> | null, null>>

    /**
     * Find zero or more ResumesStars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumesStarFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResumesStars
     * const resumesStars = await prisma.resumesStar.findMany()
     * 
     * // Get first 10 ResumesStars
     * const resumesStars = await prisma.resumesStar.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resumesStarWithIdOnly = await prisma.resumesStar.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ResumesStarFindManyArgs>(
      args?: SelectSubset<T, ResumesStarFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ResumesStar>>, PrismaPromise<Array<ResumesStarGetPayload<T>>>>

    /**
     * Create a ResumesStar.
     * @param {ResumesStarCreateArgs} args - Arguments to create a ResumesStar.
     * @example
     * // Create one ResumesStar
     * const ResumesStar = await prisma.resumesStar.create({
     *   data: {
     *     // ... data to create a ResumesStar
     *   }
     * })
     * 
    **/
    create<T extends ResumesStarCreateArgs>(
      args: SelectSubset<T, ResumesStarCreateArgs>
    ): CheckSelect<T, Prisma__ResumesStarClient<ResumesStar>, Prisma__ResumesStarClient<ResumesStarGetPayload<T>>>

    /**
     * Create many ResumesStars.
     *     @param {ResumesStarCreateManyArgs} args - Arguments to create many ResumesStars.
     *     @example
     *     // Create many ResumesStars
     *     const resumesStar = await prisma.resumesStar.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ResumesStarCreateManyArgs>(
      args?: SelectSubset<T, ResumesStarCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ResumesStar.
     * @param {ResumesStarDeleteArgs} args - Arguments to delete one ResumesStar.
     * @example
     * // Delete one ResumesStar
     * const ResumesStar = await prisma.resumesStar.delete({
     *   where: {
     *     // ... filter to delete one ResumesStar
     *   }
     * })
     * 
    **/
    delete<T extends ResumesStarDeleteArgs>(
      args: SelectSubset<T, ResumesStarDeleteArgs>
    ): CheckSelect<T, Prisma__ResumesStarClient<ResumesStar>, Prisma__ResumesStarClient<ResumesStarGetPayload<T>>>

    /**
     * Update one ResumesStar.
     * @param {ResumesStarUpdateArgs} args - Arguments to update one ResumesStar.
     * @example
     * // Update one ResumesStar
     * const resumesStar = await prisma.resumesStar.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ResumesStarUpdateArgs>(
      args: SelectSubset<T, ResumesStarUpdateArgs>
    ): CheckSelect<T, Prisma__ResumesStarClient<ResumesStar>, Prisma__ResumesStarClient<ResumesStarGetPayload<T>>>

    /**
     * Delete zero or more ResumesStars.
     * @param {ResumesStarDeleteManyArgs} args - Arguments to filter ResumesStars to delete.
     * @example
     * // Delete a few ResumesStars
     * const { count } = await prisma.resumesStar.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ResumesStarDeleteManyArgs>(
      args?: SelectSubset<T, ResumesStarDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResumesStars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumesStarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResumesStars
     * const resumesStar = await prisma.resumesStar.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ResumesStarUpdateManyArgs>(
      args: SelectSubset<T, ResumesStarUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ResumesStar.
     * @param {ResumesStarUpsertArgs} args - Arguments to update or create a ResumesStar.
     * @example
     * // Update or create a ResumesStar
     * const resumesStar = await prisma.resumesStar.upsert({
     *   create: {
     *     // ... data to create a ResumesStar
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResumesStar we want to update
     *   }
     * })
    **/
    upsert<T extends ResumesStarUpsertArgs>(
      args: SelectSubset<T, ResumesStarUpsertArgs>
    ): CheckSelect<T, Prisma__ResumesStarClient<ResumesStar>, Prisma__ResumesStarClient<ResumesStarGetPayload<T>>>

    /**
     * Find one ResumesStar that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ResumesStarFindUniqueOrThrowArgs} args - Arguments to find a ResumesStar
     * @example
     * // Get one ResumesStar
     * const resumesStar = await prisma.resumesStar.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ResumesStarFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ResumesStarFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ResumesStarClient<ResumesStar>, Prisma__ResumesStarClient<ResumesStarGetPayload<T>>>

    /**
     * Find the first ResumesStar that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumesStarFindFirstOrThrowArgs} args - Arguments to find a ResumesStar
     * @example
     * // Get one ResumesStar
     * const resumesStar = await prisma.resumesStar.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ResumesStarFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ResumesStarFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ResumesStarClient<ResumesStar>, Prisma__ResumesStarClient<ResumesStarGetPayload<T>>>

    /**
     * Count the number of ResumesStars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumesStarCountArgs} args - Arguments to filter ResumesStars to count.
     * @example
     * // Count the number of ResumesStars
     * const count = await prisma.resumesStar.count({
     *   where: {
     *     // ... the filter for the ResumesStars we want to count
     *   }
     * })
    **/
    count<T extends ResumesStarCountArgs>(
      args?: Subset<T, ResumesStarCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResumesStarCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResumesStar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumesStarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResumesStarAggregateArgs>(args: Subset<T, ResumesStarAggregateArgs>): PrismaPromise<GetResumesStarAggregateType<T>>

    /**
     * Group by ResumesStar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumesStarGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResumesStarGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResumesStarGroupByArgs['orderBy'] }
        : { orderBy?: ResumesStarGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResumesStarGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResumesStarGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ResumesStar.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ResumesStarClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    resume<T extends ResumesResumeArgs = {}>(args?: Subset<T, ResumesResumeArgs>): CheckSelect<T, Prisma__ResumesResumeClient<ResumesResume | Null>, Prisma__ResumesResumeClient<ResumesResumeGetPayload<T> | Null>>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ResumesStar base type for findUnique actions
   */
  export type ResumesStarFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ResumesStar
     * 
    **/
    select?: ResumesStarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ResumesStarInclude | null
    /**
     * Filter, which ResumesStar to fetch.
     * 
    **/
    where: ResumesStarWhereUniqueInput
  }

  /**
   * ResumesStar: findUnique
   */
  export interface ResumesStarFindUniqueArgs extends ResumesStarFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ResumesStar base type for findFirst actions
   */
  export type ResumesStarFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ResumesStar
     * 
    **/
    select?: ResumesStarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ResumesStarInclude | null
    /**
     * Filter, which ResumesStar to fetch.
     * 
    **/
    where?: ResumesStarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumesStars to fetch.
     * 
    **/
    orderBy?: Enumerable<ResumesStarOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResumesStars.
     * 
    **/
    cursor?: ResumesStarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumesStars from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumesStars.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResumesStars.
     * 
    **/
    distinct?: Enumerable<ResumesStarScalarFieldEnum>
  }

  /**
   * ResumesStar: findFirst
   */
  export interface ResumesStarFindFirstArgs extends ResumesStarFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ResumesStar findMany
   */
  export type ResumesStarFindManyArgs = {
    /**
     * Select specific fields to fetch from the ResumesStar
     * 
    **/
    select?: ResumesStarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ResumesStarInclude | null
    /**
     * Filter, which ResumesStars to fetch.
     * 
    **/
    where?: ResumesStarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumesStars to fetch.
     * 
    **/
    orderBy?: Enumerable<ResumesStarOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResumesStars.
     * 
    **/
    cursor?: ResumesStarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumesStars from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumesStars.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ResumesStarScalarFieldEnum>
  }


  /**
   * ResumesStar create
   */
  export type ResumesStarCreateArgs = {
    /**
     * Select specific fields to fetch from the ResumesStar
     * 
    **/
    select?: ResumesStarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ResumesStarInclude | null
    /**
     * The data needed to create a ResumesStar.
     * 
    **/
    data: XOR<ResumesStarCreateInput, ResumesStarUncheckedCreateInput>
  }


  /**
   * ResumesStar createMany
   */
  export type ResumesStarCreateManyArgs = {
    /**
     * The data used to create many ResumesStars.
     * 
    **/
    data: Enumerable<ResumesStarCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ResumesStar update
   */
  export type ResumesStarUpdateArgs = {
    /**
     * Select specific fields to fetch from the ResumesStar
     * 
    **/
    select?: ResumesStarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ResumesStarInclude | null
    /**
     * The data needed to update a ResumesStar.
     * 
    **/
    data: XOR<ResumesStarUpdateInput, ResumesStarUncheckedUpdateInput>
    /**
     * Choose, which ResumesStar to update.
     * 
    **/
    where: ResumesStarWhereUniqueInput
  }


  /**
   * ResumesStar updateMany
   */
  export type ResumesStarUpdateManyArgs = {
    /**
     * The data used to update ResumesStars.
     * 
    **/
    data: XOR<ResumesStarUpdateManyMutationInput, ResumesStarUncheckedUpdateManyInput>
    /**
     * Filter which ResumesStars to update
     * 
    **/
    where?: ResumesStarWhereInput
  }


  /**
   * ResumesStar upsert
   */
  export type ResumesStarUpsertArgs = {
    /**
     * Select specific fields to fetch from the ResumesStar
     * 
    **/
    select?: ResumesStarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ResumesStarInclude | null
    /**
     * The filter to search for the ResumesStar to update in case it exists.
     * 
    **/
    where: ResumesStarWhereUniqueInput
    /**
     * In case the ResumesStar found by the `where` argument doesn't exist, create a new ResumesStar with this data.
     * 
    **/
    create: XOR<ResumesStarCreateInput, ResumesStarUncheckedCreateInput>
    /**
     * In case the ResumesStar was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ResumesStarUpdateInput, ResumesStarUncheckedUpdateInput>
  }


  /**
   * ResumesStar delete
   */
  export type ResumesStarDeleteArgs = {
    /**
     * Select specific fields to fetch from the ResumesStar
     * 
    **/
    select?: ResumesStarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ResumesStarInclude | null
    /**
     * Filter which ResumesStar to delete.
     * 
    **/
    where: ResumesStarWhereUniqueInput
  }


  /**
   * ResumesStar deleteMany
   */
  export type ResumesStarDeleteManyArgs = {
    /**
     * Filter which ResumesStars to delete
     * 
    **/
    where?: ResumesStarWhereInput
  }


  /**
   * ResumesStar: findUniqueOrThrow
   */
  export type ResumesStarFindUniqueOrThrowArgs = ResumesStarFindUniqueArgsBase
      

  /**
   * ResumesStar: findFirstOrThrow
   */
  export type ResumesStarFindFirstOrThrowArgs = ResumesStarFindFirstArgsBase
      

  /**
   * ResumesStar without action
   */
  export type ResumesStarArgs = {
    /**
     * Select specific fields to fetch from the ResumesStar
     * 
    **/
    select?: ResumesStarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ResumesStarInclude | null
  }



  /**
   * Model ResumesComment
   */


  export type AggregateResumesComment = {
    _count: ResumesCommentCountAggregateOutputType | null
    _min: ResumesCommentMinAggregateOutputType | null
    _max: ResumesCommentMaxAggregateOutputType | null
  }

  export type ResumesCommentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    resumeId: string | null
    parentId: string | null
    description: string | null
    section: ResumesSection | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResumesCommentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    resumeId: string | null
    parentId: string | null
    description: string | null
    section: ResumesSection | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResumesCommentCountAggregateOutputType = {
    id: number
    userId: number
    resumeId: number
    parentId: number
    description: number
    section: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ResumesCommentMinAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    parentId?: true
    description?: true
    section?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResumesCommentMaxAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    parentId?: true
    description?: true
    section?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResumesCommentCountAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    parentId?: true
    description?: true
    section?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ResumesCommentAggregateArgs = {
    /**
     * Filter which ResumesComment to aggregate.
     * 
    **/
    where?: ResumesCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumesComments to fetch.
     * 
    **/
    orderBy?: Enumerable<ResumesCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ResumesCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumesComments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumesComments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResumesComments
    **/
    _count?: true | ResumesCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResumesCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResumesCommentMaxAggregateInputType
  }

  export type GetResumesCommentAggregateType<T extends ResumesCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateResumesComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResumesComment[P]>
      : GetScalarType<T[P], AggregateResumesComment[P]>
  }




  export type ResumesCommentGroupByArgs = {
    where?: ResumesCommentWhereInput
    orderBy?: Enumerable<ResumesCommentOrderByWithAggregationInput>
    by: Array<ResumesCommentScalarFieldEnum>
    having?: ResumesCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResumesCommentCountAggregateInputType | true
    _min?: ResumesCommentMinAggregateInputType
    _max?: ResumesCommentMaxAggregateInputType
  }


  export type ResumesCommentGroupByOutputType = {
    id: string
    userId: string
    resumeId: string
    parentId: string | null
    description: string
    section: ResumesSection
    createdAt: Date
    updatedAt: Date
    _count: ResumesCommentCountAggregateOutputType | null
    _min: ResumesCommentMinAggregateOutputType | null
    _max: ResumesCommentMaxAggregateOutputType | null
  }

  type GetResumesCommentGroupByPayload<T extends ResumesCommentGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ResumesCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResumesCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResumesCommentGroupByOutputType[P]>
            : GetScalarType<T[P], ResumesCommentGroupByOutputType[P]>
        }
      >
    >


  export type ResumesCommentSelect = {
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    parentId?: boolean
    description?: boolean
    section?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resume?: boolean | ResumesResumeArgs
    votes?: boolean | ResumesCommentVoteFindManyArgs
    user?: boolean | UserArgs
    parent?: boolean | ResumesCommentArgs
    children?: boolean | ResumesCommentFindManyArgs
    _count?: boolean | ResumesCommentCountOutputTypeArgs
  }

  export type ResumesCommentInclude = {
    resume?: boolean | ResumesResumeArgs
    votes?: boolean | ResumesCommentVoteFindManyArgs
    user?: boolean | UserArgs
    parent?: boolean | ResumesCommentArgs
    children?: boolean | ResumesCommentFindManyArgs
    _count?: boolean | ResumesCommentCountOutputTypeArgs
  }

  export type ResumesCommentGetPayload<
    S extends boolean | null | undefined | ResumesCommentArgs,
    U = keyof S
      > = S extends true
        ? ResumesComment
    : S extends undefined
    ? never
    : S extends ResumesCommentArgs | ResumesCommentFindManyArgs
    ?'include' extends U
    ? ResumesComment  & {
    [P in TrueKeys<S['include']>]:
        P extends 'resume' ? ResumesResumeGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'votes' ? Array < ResumesCommentVoteGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'parent' ? ResumesCommentGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'children' ? Array < ResumesCommentGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? ResumesCommentCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'resume' ? ResumesResumeGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'votes' ? Array < ResumesCommentVoteGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'parent' ? ResumesCommentGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'children' ? Array < ResumesCommentGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? ResumesCommentCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof ResumesComment ? ResumesComment[P] : never
  } 
    : ResumesComment
  : ResumesComment


  type ResumesCommentCountArgs = Merge<
    Omit<ResumesCommentFindManyArgs, 'select' | 'include'> & {
      select?: ResumesCommentCountAggregateInputType | true
    }
  >

  export interface ResumesCommentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one ResumesComment that matches the filter.
     * @param {ResumesCommentFindUniqueArgs} args - Arguments to find a ResumesComment
     * @example
     * // Get one ResumesComment
     * const resumesComment = await prisma.resumesComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ResumesCommentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ResumesCommentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ResumesComment'> extends True ? CheckSelect<T, Prisma__ResumesCommentClient<ResumesComment>, Prisma__ResumesCommentClient<ResumesCommentGetPayload<T>>> : CheckSelect<T, Prisma__ResumesCommentClient<ResumesComment | null, null>, Prisma__ResumesCommentClient<ResumesCommentGetPayload<T> | null, null>>

    /**
     * Find the first ResumesComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumesCommentFindFirstArgs} args - Arguments to find a ResumesComment
     * @example
     * // Get one ResumesComment
     * const resumesComment = await prisma.resumesComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ResumesCommentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ResumesCommentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ResumesComment'> extends True ? CheckSelect<T, Prisma__ResumesCommentClient<ResumesComment>, Prisma__ResumesCommentClient<ResumesCommentGetPayload<T>>> : CheckSelect<T, Prisma__ResumesCommentClient<ResumesComment | null, null>, Prisma__ResumesCommentClient<ResumesCommentGetPayload<T> | null, null>>

    /**
     * Find zero or more ResumesComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumesCommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResumesComments
     * const resumesComments = await prisma.resumesComment.findMany()
     * 
     * // Get first 10 ResumesComments
     * const resumesComments = await prisma.resumesComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resumesCommentWithIdOnly = await prisma.resumesComment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ResumesCommentFindManyArgs>(
      args?: SelectSubset<T, ResumesCommentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ResumesComment>>, PrismaPromise<Array<ResumesCommentGetPayload<T>>>>

    /**
     * Create a ResumesComment.
     * @param {ResumesCommentCreateArgs} args - Arguments to create a ResumesComment.
     * @example
     * // Create one ResumesComment
     * const ResumesComment = await prisma.resumesComment.create({
     *   data: {
     *     // ... data to create a ResumesComment
     *   }
     * })
     * 
    **/
    create<T extends ResumesCommentCreateArgs>(
      args: SelectSubset<T, ResumesCommentCreateArgs>
    ): CheckSelect<T, Prisma__ResumesCommentClient<ResumesComment>, Prisma__ResumesCommentClient<ResumesCommentGetPayload<T>>>

    /**
     * Create many ResumesComments.
     *     @param {ResumesCommentCreateManyArgs} args - Arguments to create many ResumesComments.
     *     @example
     *     // Create many ResumesComments
     *     const resumesComment = await prisma.resumesComment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ResumesCommentCreateManyArgs>(
      args?: SelectSubset<T, ResumesCommentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ResumesComment.
     * @param {ResumesCommentDeleteArgs} args - Arguments to delete one ResumesComment.
     * @example
     * // Delete one ResumesComment
     * const ResumesComment = await prisma.resumesComment.delete({
     *   where: {
     *     // ... filter to delete one ResumesComment
     *   }
     * })
     * 
    **/
    delete<T extends ResumesCommentDeleteArgs>(
      args: SelectSubset<T, ResumesCommentDeleteArgs>
    ): CheckSelect<T, Prisma__ResumesCommentClient<ResumesComment>, Prisma__ResumesCommentClient<ResumesCommentGetPayload<T>>>

    /**
     * Update one ResumesComment.
     * @param {ResumesCommentUpdateArgs} args - Arguments to update one ResumesComment.
     * @example
     * // Update one ResumesComment
     * const resumesComment = await prisma.resumesComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ResumesCommentUpdateArgs>(
      args: SelectSubset<T, ResumesCommentUpdateArgs>
    ): CheckSelect<T, Prisma__ResumesCommentClient<ResumesComment>, Prisma__ResumesCommentClient<ResumesCommentGetPayload<T>>>

    /**
     * Delete zero or more ResumesComments.
     * @param {ResumesCommentDeleteManyArgs} args - Arguments to filter ResumesComments to delete.
     * @example
     * // Delete a few ResumesComments
     * const { count } = await prisma.resumesComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ResumesCommentDeleteManyArgs>(
      args?: SelectSubset<T, ResumesCommentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResumesComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumesCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResumesComments
     * const resumesComment = await prisma.resumesComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ResumesCommentUpdateManyArgs>(
      args: SelectSubset<T, ResumesCommentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ResumesComment.
     * @param {ResumesCommentUpsertArgs} args - Arguments to update or create a ResumesComment.
     * @example
     * // Update or create a ResumesComment
     * const resumesComment = await prisma.resumesComment.upsert({
     *   create: {
     *     // ... data to create a ResumesComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResumesComment we want to update
     *   }
     * })
    **/
    upsert<T extends ResumesCommentUpsertArgs>(
      args: SelectSubset<T, ResumesCommentUpsertArgs>
    ): CheckSelect<T, Prisma__ResumesCommentClient<ResumesComment>, Prisma__ResumesCommentClient<ResumesCommentGetPayload<T>>>

    /**
     * Find one ResumesComment that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ResumesCommentFindUniqueOrThrowArgs} args - Arguments to find a ResumesComment
     * @example
     * // Get one ResumesComment
     * const resumesComment = await prisma.resumesComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ResumesCommentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ResumesCommentFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ResumesCommentClient<ResumesComment>, Prisma__ResumesCommentClient<ResumesCommentGetPayload<T>>>

    /**
     * Find the first ResumesComment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumesCommentFindFirstOrThrowArgs} args - Arguments to find a ResumesComment
     * @example
     * // Get one ResumesComment
     * const resumesComment = await prisma.resumesComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ResumesCommentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ResumesCommentFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ResumesCommentClient<ResumesComment>, Prisma__ResumesCommentClient<ResumesCommentGetPayload<T>>>

    /**
     * Count the number of ResumesComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumesCommentCountArgs} args - Arguments to filter ResumesComments to count.
     * @example
     * // Count the number of ResumesComments
     * const count = await prisma.resumesComment.count({
     *   where: {
     *     // ... the filter for the ResumesComments we want to count
     *   }
     * })
    **/
    count<T extends ResumesCommentCountArgs>(
      args?: Subset<T, ResumesCommentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResumesCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResumesComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumesCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResumesCommentAggregateArgs>(args: Subset<T, ResumesCommentAggregateArgs>): PrismaPromise<GetResumesCommentAggregateType<T>>

    /**
     * Group by ResumesComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumesCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResumesCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResumesCommentGroupByArgs['orderBy'] }
        : { orderBy?: ResumesCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResumesCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResumesCommentGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ResumesComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ResumesCommentClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    resume<T extends ResumesResumeArgs = {}>(args?: Subset<T, ResumesResumeArgs>): CheckSelect<T, Prisma__ResumesResumeClient<ResumesResume | Null>, Prisma__ResumesResumeClient<ResumesResumeGetPayload<T> | Null>>;

    votes<T extends ResumesCommentVoteFindManyArgs = {}>(args?: Subset<T, ResumesCommentVoteFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ResumesCommentVote>| Null>, PrismaPromise<Array<ResumesCommentVoteGetPayload<T>>| Null>>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    parent<T extends ResumesCommentArgs = {}>(args?: Subset<T, ResumesCommentArgs>): CheckSelect<T, Prisma__ResumesCommentClient<ResumesComment | Null>, Prisma__ResumesCommentClient<ResumesCommentGetPayload<T> | Null>>;

    children<T extends ResumesCommentFindManyArgs = {}>(args?: Subset<T, ResumesCommentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ResumesComment>| Null>, PrismaPromise<Array<ResumesCommentGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ResumesComment base type for findUnique actions
   */
  export type ResumesCommentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ResumesComment
     * 
    **/
    select?: ResumesCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ResumesCommentInclude | null
    /**
     * Filter, which ResumesComment to fetch.
     * 
    **/
    where: ResumesCommentWhereUniqueInput
  }

  /**
   * ResumesComment: findUnique
   */
  export interface ResumesCommentFindUniqueArgs extends ResumesCommentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ResumesComment base type for findFirst actions
   */
  export type ResumesCommentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ResumesComment
     * 
    **/
    select?: ResumesCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ResumesCommentInclude | null
    /**
     * Filter, which ResumesComment to fetch.
     * 
    **/
    where?: ResumesCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumesComments to fetch.
     * 
    **/
    orderBy?: Enumerable<ResumesCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResumesComments.
     * 
    **/
    cursor?: ResumesCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumesComments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumesComments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResumesComments.
     * 
    **/
    distinct?: Enumerable<ResumesCommentScalarFieldEnum>
  }

  /**
   * ResumesComment: findFirst
   */
  export interface ResumesCommentFindFirstArgs extends ResumesCommentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ResumesComment findMany
   */
  export type ResumesCommentFindManyArgs = {
    /**
     * Select specific fields to fetch from the ResumesComment
     * 
    **/
    select?: ResumesCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ResumesCommentInclude | null
    /**
     * Filter, which ResumesComments to fetch.
     * 
    **/
    where?: ResumesCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumesComments to fetch.
     * 
    **/
    orderBy?: Enumerable<ResumesCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResumesComments.
     * 
    **/
    cursor?: ResumesCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumesComments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumesComments.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ResumesCommentScalarFieldEnum>
  }


  /**
   * ResumesComment create
   */
  export type ResumesCommentCreateArgs = {
    /**
     * Select specific fields to fetch from the ResumesComment
     * 
    **/
    select?: ResumesCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ResumesCommentInclude | null
    /**
     * The data needed to create a ResumesComment.
     * 
    **/
    data: XOR<ResumesCommentCreateInput, ResumesCommentUncheckedCreateInput>
  }


  /**
   * ResumesComment createMany
   */
  export type ResumesCommentCreateManyArgs = {
    /**
     * The data used to create many ResumesComments.
     * 
    **/
    data: Enumerable<ResumesCommentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ResumesComment update
   */
  export type ResumesCommentUpdateArgs = {
    /**
     * Select specific fields to fetch from the ResumesComment
     * 
    **/
    select?: ResumesCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ResumesCommentInclude | null
    /**
     * The data needed to update a ResumesComment.
     * 
    **/
    data: XOR<ResumesCommentUpdateInput, ResumesCommentUncheckedUpdateInput>
    /**
     * Choose, which ResumesComment to update.
     * 
    **/
    where: ResumesCommentWhereUniqueInput
  }


  /**
   * ResumesComment updateMany
   */
  export type ResumesCommentUpdateManyArgs = {
    /**
     * The data used to update ResumesComments.
     * 
    **/
    data: XOR<ResumesCommentUpdateManyMutationInput, ResumesCommentUncheckedUpdateManyInput>
    /**
     * Filter which ResumesComments to update
     * 
    **/
    where?: ResumesCommentWhereInput
  }


  /**
   * ResumesComment upsert
   */
  export type ResumesCommentUpsertArgs = {
    /**
     * Select specific fields to fetch from the ResumesComment
     * 
    **/
    select?: ResumesCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ResumesCommentInclude | null
    /**
     * The filter to search for the ResumesComment to update in case it exists.
     * 
    **/
    where: ResumesCommentWhereUniqueInput
    /**
     * In case the ResumesComment found by the `where` argument doesn't exist, create a new ResumesComment with this data.
     * 
    **/
    create: XOR<ResumesCommentCreateInput, ResumesCommentUncheckedCreateInput>
    /**
     * In case the ResumesComment was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ResumesCommentUpdateInput, ResumesCommentUncheckedUpdateInput>
  }


  /**
   * ResumesComment delete
   */
  export type ResumesCommentDeleteArgs = {
    /**
     * Select specific fields to fetch from the ResumesComment
     * 
    **/
    select?: ResumesCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ResumesCommentInclude | null
    /**
     * Filter which ResumesComment to delete.
     * 
    **/
    where: ResumesCommentWhereUniqueInput
  }


  /**
   * ResumesComment deleteMany
   */
  export type ResumesCommentDeleteManyArgs = {
    /**
     * Filter which ResumesComments to delete
     * 
    **/
    where?: ResumesCommentWhereInput
  }


  /**
   * ResumesComment: findUniqueOrThrow
   */
  export type ResumesCommentFindUniqueOrThrowArgs = ResumesCommentFindUniqueArgsBase
      

  /**
   * ResumesComment: findFirstOrThrow
   */
  export type ResumesCommentFindFirstOrThrowArgs = ResumesCommentFindFirstArgsBase
      

  /**
   * ResumesComment without action
   */
  export type ResumesCommentArgs = {
    /**
     * Select specific fields to fetch from the ResumesComment
     * 
    **/
    select?: ResumesCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ResumesCommentInclude | null
  }



  /**
   * Model ResumesCommentVote
   */


  export type AggregateResumesCommentVote = {
    _count: ResumesCommentVoteCountAggregateOutputType | null
    _min: ResumesCommentVoteMinAggregateOutputType | null
    _max: ResumesCommentVoteMaxAggregateOutputType | null
  }

  export type ResumesCommentVoteMinAggregateOutputType = {
    id: string | null
    userId: string | null
    commentId: string | null
    value: Vote | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResumesCommentVoteMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    commentId: string | null
    value: Vote | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResumesCommentVoteCountAggregateOutputType = {
    id: number
    userId: number
    commentId: number
    value: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ResumesCommentVoteMinAggregateInputType = {
    id?: true
    userId?: true
    commentId?: true
    value?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResumesCommentVoteMaxAggregateInputType = {
    id?: true
    userId?: true
    commentId?: true
    value?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResumesCommentVoteCountAggregateInputType = {
    id?: true
    userId?: true
    commentId?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ResumesCommentVoteAggregateArgs = {
    /**
     * Filter which ResumesCommentVote to aggregate.
     * 
    **/
    where?: ResumesCommentVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumesCommentVotes to fetch.
     * 
    **/
    orderBy?: Enumerable<ResumesCommentVoteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ResumesCommentVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumesCommentVotes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumesCommentVotes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResumesCommentVotes
    **/
    _count?: true | ResumesCommentVoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResumesCommentVoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResumesCommentVoteMaxAggregateInputType
  }

  export type GetResumesCommentVoteAggregateType<T extends ResumesCommentVoteAggregateArgs> = {
        [P in keyof T & keyof AggregateResumesCommentVote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResumesCommentVote[P]>
      : GetScalarType<T[P], AggregateResumesCommentVote[P]>
  }




  export type ResumesCommentVoteGroupByArgs = {
    where?: ResumesCommentVoteWhereInput
    orderBy?: Enumerable<ResumesCommentVoteOrderByWithAggregationInput>
    by: Array<ResumesCommentVoteScalarFieldEnum>
    having?: ResumesCommentVoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResumesCommentVoteCountAggregateInputType | true
    _min?: ResumesCommentVoteMinAggregateInputType
    _max?: ResumesCommentVoteMaxAggregateInputType
  }


  export type ResumesCommentVoteGroupByOutputType = {
    id: string
    userId: string
    commentId: string
    value: Vote
    createdAt: Date
    updatedAt: Date
    _count: ResumesCommentVoteCountAggregateOutputType | null
    _min: ResumesCommentVoteMinAggregateOutputType | null
    _max: ResumesCommentVoteMaxAggregateOutputType | null
  }

  type GetResumesCommentVoteGroupByPayload<T extends ResumesCommentVoteGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ResumesCommentVoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResumesCommentVoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResumesCommentVoteGroupByOutputType[P]>
            : GetScalarType<T[P], ResumesCommentVoteGroupByOutputType[P]>
        }
      >
    >


  export type ResumesCommentVoteSelect = {
    id?: boolean
    userId?: boolean
    commentId?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comment?: boolean | ResumesCommentArgs
    user?: boolean | UserArgs
  }

  export type ResumesCommentVoteInclude = {
    comment?: boolean | ResumesCommentArgs
    user?: boolean | UserArgs
  }

  export type ResumesCommentVoteGetPayload<
    S extends boolean | null | undefined | ResumesCommentVoteArgs,
    U = keyof S
      > = S extends true
        ? ResumesCommentVote
    : S extends undefined
    ? never
    : S extends ResumesCommentVoteArgs | ResumesCommentVoteFindManyArgs
    ?'include' extends U
    ? ResumesCommentVote  & {
    [P in TrueKeys<S['include']>]:
        P extends 'comment' ? ResumesCommentGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'comment' ? ResumesCommentGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof ResumesCommentVote ? ResumesCommentVote[P] : never
  } 
    : ResumesCommentVote
  : ResumesCommentVote


  type ResumesCommentVoteCountArgs = Merge<
    Omit<ResumesCommentVoteFindManyArgs, 'select' | 'include'> & {
      select?: ResumesCommentVoteCountAggregateInputType | true
    }
  >

  export interface ResumesCommentVoteDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one ResumesCommentVote that matches the filter.
     * @param {ResumesCommentVoteFindUniqueArgs} args - Arguments to find a ResumesCommentVote
     * @example
     * // Get one ResumesCommentVote
     * const resumesCommentVote = await prisma.resumesCommentVote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ResumesCommentVoteFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ResumesCommentVoteFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ResumesCommentVote'> extends True ? CheckSelect<T, Prisma__ResumesCommentVoteClient<ResumesCommentVote>, Prisma__ResumesCommentVoteClient<ResumesCommentVoteGetPayload<T>>> : CheckSelect<T, Prisma__ResumesCommentVoteClient<ResumesCommentVote | null, null>, Prisma__ResumesCommentVoteClient<ResumesCommentVoteGetPayload<T> | null, null>>

    /**
     * Find the first ResumesCommentVote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumesCommentVoteFindFirstArgs} args - Arguments to find a ResumesCommentVote
     * @example
     * // Get one ResumesCommentVote
     * const resumesCommentVote = await prisma.resumesCommentVote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ResumesCommentVoteFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ResumesCommentVoteFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ResumesCommentVote'> extends True ? CheckSelect<T, Prisma__ResumesCommentVoteClient<ResumesCommentVote>, Prisma__ResumesCommentVoteClient<ResumesCommentVoteGetPayload<T>>> : CheckSelect<T, Prisma__ResumesCommentVoteClient<ResumesCommentVote | null, null>, Prisma__ResumesCommentVoteClient<ResumesCommentVoteGetPayload<T> | null, null>>

    /**
     * Find zero or more ResumesCommentVotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumesCommentVoteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResumesCommentVotes
     * const resumesCommentVotes = await prisma.resumesCommentVote.findMany()
     * 
     * // Get first 10 ResumesCommentVotes
     * const resumesCommentVotes = await prisma.resumesCommentVote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resumesCommentVoteWithIdOnly = await prisma.resumesCommentVote.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ResumesCommentVoteFindManyArgs>(
      args?: SelectSubset<T, ResumesCommentVoteFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ResumesCommentVote>>, PrismaPromise<Array<ResumesCommentVoteGetPayload<T>>>>

    /**
     * Create a ResumesCommentVote.
     * @param {ResumesCommentVoteCreateArgs} args - Arguments to create a ResumesCommentVote.
     * @example
     * // Create one ResumesCommentVote
     * const ResumesCommentVote = await prisma.resumesCommentVote.create({
     *   data: {
     *     // ... data to create a ResumesCommentVote
     *   }
     * })
     * 
    **/
    create<T extends ResumesCommentVoteCreateArgs>(
      args: SelectSubset<T, ResumesCommentVoteCreateArgs>
    ): CheckSelect<T, Prisma__ResumesCommentVoteClient<ResumesCommentVote>, Prisma__ResumesCommentVoteClient<ResumesCommentVoteGetPayload<T>>>

    /**
     * Create many ResumesCommentVotes.
     *     @param {ResumesCommentVoteCreateManyArgs} args - Arguments to create many ResumesCommentVotes.
     *     @example
     *     // Create many ResumesCommentVotes
     *     const resumesCommentVote = await prisma.resumesCommentVote.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ResumesCommentVoteCreateManyArgs>(
      args?: SelectSubset<T, ResumesCommentVoteCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ResumesCommentVote.
     * @param {ResumesCommentVoteDeleteArgs} args - Arguments to delete one ResumesCommentVote.
     * @example
     * // Delete one ResumesCommentVote
     * const ResumesCommentVote = await prisma.resumesCommentVote.delete({
     *   where: {
     *     // ... filter to delete one ResumesCommentVote
     *   }
     * })
     * 
    **/
    delete<T extends ResumesCommentVoteDeleteArgs>(
      args: SelectSubset<T, ResumesCommentVoteDeleteArgs>
    ): CheckSelect<T, Prisma__ResumesCommentVoteClient<ResumesCommentVote>, Prisma__ResumesCommentVoteClient<ResumesCommentVoteGetPayload<T>>>

    /**
     * Update one ResumesCommentVote.
     * @param {ResumesCommentVoteUpdateArgs} args - Arguments to update one ResumesCommentVote.
     * @example
     * // Update one ResumesCommentVote
     * const resumesCommentVote = await prisma.resumesCommentVote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ResumesCommentVoteUpdateArgs>(
      args: SelectSubset<T, ResumesCommentVoteUpdateArgs>
    ): CheckSelect<T, Prisma__ResumesCommentVoteClient<ResumesCommentVote>, Prisma__ResumesCommentVoteClient<ResumesCommentVoteGetPayload<T>>>

    /**
     * Delete zero or more ResumesCommentVotes.
     * @param {ResumesCommentVoteDeleteManyArgs} args - Arguments to filter ResumesCommentVotes to delete.
     * @example
     * // Delete a few ResumesCommentVotes
     * const { count } = await prisma.resumesCommentVote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ResumesCommentVoteDeleteManyArgs>(
      args?: SelectSubset<T, ResumesCommentVoteDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResumesCommentVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumesCommentVoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResumesCommentVotes
     * const resumesCommentVote = await prisma.resumesCommentVote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ResumesCommentVoteUpdateManyArgs>(
      args: SelectSubset<T, ResumesCommentVoteUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ResumesCommentVote.
     * @param {ResumesCommentVoteUpsertArgs} args - Arguments to update or create a ResumesCommentVote.
     * @example
     * // Update or create a ResumesCommentVote
     * const resumesCommentVote = await prisma.resumesCommentVote.upsert({
     *   create: {
     *     // ... data to create a ResumesCommentVote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResumesCommentVote we want to update
     *   }
     * })
    **/
    upsert<T extends ResumesCommentVoteUpsertArgs>(
      args: SelectSubset<T, ResumesCommentVoteUpsertArgs>
    ): CheckSelect<T, Prisma__ResumesCommentVoteClient<ResumesCommentVote>, Prisma__ResumesCommentVoteClient<ResumesCommentVoteGetPayload<T>>>

    /**
     * Find one ResumesCommentVote that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ResumesCommentVoteFindUniqueOrThrowArgs} args - Arguments to find a ResumesCommentVote
     * @example
     * // Get one ResumesCommentVote
     * const resumesCommentVote = await prisma.resumesCommentVote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ResumesCommentVoteFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ResumesCommentVoteFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ResumesCommentVoteClient<ResumesCommentVote>, Prisma__ResumesCommentVoteClient<ResumesCommentVoteGetPayload<T>>>

    /**
     * Find the first ResumesCommentVote that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumesCommentVoteFindFirstOrThrowArgs} args - Arguments to find a ResumesCommentVote
     * @example
     * // Get one ResumesCommentVote
     * const resumesCommentVote = await prisma.resumesCommentVote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ResumesCommentVoteFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ResumesCommentVoteFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ResumesCommentVoteClient<ResumesCommentVote>, Prisma__ResumesCommentVoteClient<ResumesCommentVoteGetPayload<T>>>

    /**
     * Count the number of ResumesCommentVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumesCommentVoteCountArgs} args - Arguments to filter ResumesCommentVotes to count.
     * @example
     * // Count the number of ResumesCommentVotes
     * const count = await prisma.resumesCommentVote.count({
     *   where: {
     *     // ... the filter for the ResumesCommentVotes we want to count
     *   }
     * })
    **/
    count<T extends ResumesCommentVoteCountArgs>(
      args?: Subset<T, ResumesCommentVoteCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResumesCommentVoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResumesCommentVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumesCommentVoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResumesCommentVoteAggregateArgs>(args: Subset<T, ResumesCommentVoteAggregateArgs>): PrismaPromise<GetResumesCommentVoteAggregateType<T>>

    /**
     * Group by ResumesCommentVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumesCommentVoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResumesCommentVoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResumesCommentVoteGroupByArgs['orderBy'] }
        : { orderBy?: ResumesCommentVoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResumesCommentVoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResumesCommentVoteGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ResumesCommentVote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ResumesCommentVoteClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    comment<T extends ResumesCommentArgs = {}>(args?: Subset<T, ResumesCommentArgs>): CheckSelect<T, Prisma__ResumesCommentClient<ResumesComment | Null>, Prisma__ResumesCommentClient<ResumesCommentGetPayload<T> | Null>>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ResumesCommentVote base type for findUnique actions
   */
  export type ResumesCommentVoteFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ResumesCommentVote
     * 
    **/
    select?: ResumesCommentVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ResumesCommentVoteInclude | null
    /**
     * Filter, which ResumesCommentVote to fetch.
     * 
    **/
    where: ResumesCommentVoteWhereUniqueInput
  }

  /**
   * ResumesCommentVote: findUnique
   */
  export interface ResumesCommentVoteFindUniqueArgs extends ResumesCommentVoteFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ResumesCommentVote base type for findFirst actions
   */
  export type ResumesCommentVoteFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ResumesCommentVote
     * 
    **/
    select?: ResumesCommentVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ResumesCommentVoteInclude | null
    /**
     * Filter, which ResumesCommentVote to fetch.
     * 
    **/
    where?: ResumesCommentVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumesCommentVotes to fetch.
     * 
    **/
    orderBy?: Enumerable<ResumesCommentVoteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResumesCommentVotes.
     * 
    **/
    cursor?: ResumesCommentVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumesCommentVotes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumesCommentVotes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResumesCommentVotes.
     * 
    **/
    distinct?: Enumerable<ResumesCommentVoteScalarFieldEnum>
  }

  /**
   * ResumesCommentVote: findFirst
   */
  export interface ResumesCommentVoteFindFirstArgs extends ResumesCommentVoteFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ResumesCommentVote findMany
   */
  export type ResumesCommentVoteFindManyArgs = {
    /**
     * Select specific fields to fetch from the ResumesCommentVote
     * 
    **/
    select?: ResumesCommentVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ResumesCommentVoteInclude | null
    /**
     * Filter, which ResumesCommentVotes to fetch.
     * 
    **/
    where?: ResumesCommentVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumesCommentVotes to fetch.
     * 
    **/
    orderBy?: Enumerable<ResumesCommentVoteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResumesCommentVotes.
     * 
    **/
    cursor?: ResumesCommentVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumesCommentVotes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumesCommentVotes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ResumesCommentVoteScalarFieldEnum>
  }


  /**
   * ResumesCommentVote create
   */
  export type ResumesCommentVoteCreateArgs = {
    /**
     * Select specific fields to fetch from the ResumesCommentVote
     * 
    **/
    select?: ResumesCommentVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ResumesCommentVoteInclude | null
    /**
     * The data needed to create a ResumesCommentVote.
     * 
    **/
    data: XOR<ResumesCommentVoteCreateInput, ResumesCommentVoteUncheckedCreateInput>
  }


  /**
   * ResumesCommentVote createMany
   */
  export type ResumesCommentVoteCreateManyArgs = {
    /**
     * The data used to create many ResumesCommentVotes.
     * 
    **/
    data: Enumerable<ResumesCommentVoteCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ResumesCommentVote update
   */
  export type ResumesCommentVoteUpdateArgs = {
    /**
     * Select specific fields to fetch from the ResumesCommentVote
     * 
    **/
    select?: ResumesCommentVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ResumesCommentVoteInclude | null
    /**
     * The data needed to update a ResumesCommentVote.
     * 
    **/
    data: XOR<ResumesCommentVoteUpdateInput, ResumesCommentVoteUncheckedUpdateInput>
    /**
     * Choose, which ResumesCommentVote to update.
     * 
    **/
    where: ResumesCommentVoteWhereUniqueInput
  }


  /**
   * ResumesCommentVote updateMany
   */
  export type ResumesCommentVoteUpdateManyArgs = {
    /**
     * The data used to update ResumesCommentVotes.
     * 
    **/
    data: XOR<ResumesCommentVoteUpdateManyMutationInput, ResumesCommentVoteUncheckedUpdateManyInput>
    /**
     * Filter which ResumesCommentVotes to update
     * 
    **/
    where?: ResumesCommentVoteWhereInput
  }


  /**
   * ResumesCommentVote upsert
   */
  export type ResumesCommentVoteUpsertArgs = {
    /**
     * Select specific fields to fetch from the ResumesCommentVote
     * 
    **/
    select?: ResumesCommentVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ResumesCommentVoteInclude | null
    /**
     * The filter to search for the ResumesCommentVote to update in case it exists.
     * 
    **/
    where: ResumesCommentVoteWhereUniqueInput
    /**
     * In case the ResumesCommentVote found by the `where` argument doesn't exist, create a new ResumesCommentVote with this data.
     * 
    **/
    create: XOR<ResumesCommentVoteCreateInput, ResumesCommentVoteUncheckedCreateInput>
    /**
     * In case the ResumesCommentVote was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ResumesCommentVoteUpdateInput, ResumesCommentVoteUncheckedUpdateInput>
  }


  /**
   * ResumesCommentVote delete
   */
  export type ResumesCommentVoteDeleteArgs = {
    /**
     * Select specific fields to fetch from the ResumesCommentVote
     * 
    **/
    select?: ResumesCommentVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ResumesCommentVoteInclude | null
    /**
     * Filter which ResumesCommentVote to delete.
     * 
    **/
    where: ResumesCommentVoteWhereUniqueInput
  }


  /**
   * ResumesCommentVote deleteMany
   */
  export type ResumesCommentVoteDeleteManyArgs = {
    /**
     * Filter which ResumesCommentVotes to delete
     * 
    **/
    where?: ResumesCommentVoteWhereInput
  }


  /**
   * ResumesCommentVote: findUniqueOrThrow
   */
  export type ResumesCommentVoteFindUniqueOrThrowArgs = ResumesCommentVoteFindUniqueArgsBase
      

  /**
   * ResumesCommentVote: findFirstOrThrow
   */
  export type ResumesCommentVoteFindFirstOrThrowArgs = ResumesCommentVoteFindFirstArgsBase
      

  /**
   * ResumesCommentVote without action
   */
  export type ResumesCommentVoteArgs = {
    /**
     * Select specific fields to fetch from the ResumesCommentVote
     * 
    **/
    select?: ResumesCommentVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ResumesCommentVoteInclude | null
  }



  /**
   * Model OffersProfile
   */


  export type AggregateOffersProfile = {
    _count: OffersProfileCountAggregateOutputType | null
    _min: OffersProfileMinAggregateOutputType | null
    _max: OffersProfileMaxAggregateOutputType | null
  }

  export type OffersProfileMinAggregateOutputType = {
    id: string | null
    profileName: string | null
    createdAt: Date | null
    editToken: string | null
  }

  export type OffersProfileMaxAggregateOutputType = {
    id: string | null
    profileName: string | null
    createdAt: Date | null
    editToken: string | null
  }

  export type OffersProfileCountAggregateOutputType = {
    id: number
    profileName: number
    createdAt: number
    editToken: number
    _all: number
  }


  export type OffersProfileMinAggregateInputType = {
    id?: true
    profileName?: true
    createdAt?: true
    editToken?: true
  }

  export type OffersProfileMaxAggregateInputType = {
    id?: true
    profileName?: true
    createdAt?: true
    editToken?: true
  }

  export type OffersProfileCountAggregateInputType = {
    id?: true
    profileName?: true
    createdAt?: true
    editToken?: true
    _all?: true
  }

  export type OffersProfileAggregateArgs = {
    /**
     * Filter which OffersProfile to aggregate.
     * 
    **/
    where?: OffersProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffersProfiles to fetch.
     * 
    **/
    orderBy?: Enumerable<OffersProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OffersProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffersProfiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffersProfiles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OffersProfiles
    **/
    _count?: true | OffersProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OffersProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OffersProfileMaxAggregateInputType
  }

  export type GetOffersProfileAggregateType<T extends OffersProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateOffersProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOffersProfile[P]>
      : GetScalarType<T[P], AggregateOffersProfile[P]>
  }




  export type OffersProfileGroupByArgs = {
    where?: OffersProfileWhereInput
    orderBy?: Enumerable<OffersProfileOrderByWithAggregationInput>
    by: Array<OffersProfileScalarFieldEnum>
    having?: OffersProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OffersProfileCountAggregateInputType | true
    _min?: OffersProfileMinAggregateInputType
    _max?: OffersProfileMaxAggregateInputType
  }


  export type OffersProfileGroupByOutputType = {
    id: string
    profileName: string
    createdAt: Date
    editToken: string
    _count: OffersProfileCountAggregateOutputType | null
    _min: OffersProfileMinAggregateOutputType | null
    _max: OffersProfileMaxAggregateOutputType | null
  }

  type GetOffersProfileGroupByPayload<T extends OffersProfileGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OffersProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OffersProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OffersProfileGroupByOutputType[P]>
            : GetScalarType<T[P], OffersProfileGroupByOutputType[P]>
        }
      >
    >


  export type OffersProfileSelect = {
    id?: boolean
    profileName?: boolean
    createdAt?: boolean
    background?: boolean | OffersBackgroundArgs
    editToken?: boolean
    discussion?: boolean | OffersReplyFindManyArgs
    offers?: boolean | OffersOfferFindManyArgs
    users?: boolean | UserFindManyArgs
    analysis?: boolean | OffersAnalysisArgs
    _count?: boolean | OffersProfileCountOutputTypeArgs
  }

  export type OffersProfileInclude = {
    background?: boolean | OffersBackgroundArgs
    discussion?: boolean | OffersReplyFindManyArgs
    offers?: boolean | OffersOfferFindManyArgs
    users?: boolean | UserFindManyArgs
    analysis?: boolean | OffersAnalysisArgs
    _count?: boolean | OffersProfileCountOutputTypeArgs
  }

  export type OffersProfileGetPayload<
    S extends boolean | null | undefined | OffersProfileArgs,
    U = keyof S
      > = S extends true
        ? OffersProfile
    : S extends undefined
    ? never
    : S extends OffersProfileArgs | OffersProfileFindManyArgs
    ?'include' extends U
    ? OffersProfile  & {
    [P in TrueKeys<S['include']>]:
        P extends 'background' ? OffersBackgroundGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'discussion' ? Array < OffersReplyGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'offers' ? Array < OffersOfferGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'users' ? Array < UserGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'analysis' ? OffersAnalysisGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends '_count' ? OffersProfileCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'background' ? OffersBackgroundGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'discussion' ? Array < OffersReplyGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'offers' ? Array < OffersOfferGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'users' ? Array < UserGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'analysis' ? OffersAnalysisGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends '_count' ? OffersProfileCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof OffersProfile ? OffersProfile[P] : never
  } 
    : OffersProfile
  : OffersProfile


  type OffersProfileCountArgs = Merge<
    Omit<OffersProfileFindManyArgs, 'select' | 'include'> & {
      select?: OffersProfileCountAggregateInputType | true
    }
  >

  export interface OffersProfileDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one OffersProfile that matches the filter.
     * @param {OffersProfileFindUniqueArgs} args - Arguments to find a OffersProfile
     * @example
     * // Get one OffersProfile
     * const offersProfile = await prisma.offersProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OffersProfileFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OffersProfileFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OffersProfile'> extends True ? CheckSelect<T, Prisma__OffersProfileClient<OffersProfile>, Prisma__OffersProfileClient<OffersProfileGetPayload<T>>> : CheckSelect<T, Prisma__OffersProfileClient<OffersProfile | null, null>, Prisma__OffersProfileClient<OffersProfileGetPayload<T> | null, null>>

    /**
     * Find the first OffersProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersProfileFindFirstArgs} args - Arguments to find a OffersProfile
     * @example
     * // Get one OffersProfile
     * const offersProfile = await prisma.offersProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OffersProfileFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OffersProfileFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OffersProfile'> extends True ? CheckSelect<T, Prisma__OffersProfileClient<OffersProfile>, Prisma__OffersProfileClient<OffersProfileGetPayload<T>>> : CheckSelect<T, Prisma__OffersProfileClient<OffersProfile | null, null>, Prisma__OffersProfileClient<OffersProfileGetPayload<T> | null, null>>

    /**
     * Find zero or more OffersProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersProfileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OffersProfiles
     * const offersProfiles = await prisma.offersProfile.findMany()
     * 
     * // Get first 10 OffersProfiles
     * const offersProfiles = await prisma.offersProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offersProfileWithIdOnly = await prisma.offersProfile.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OffersProfileFindManyArgs>(
      args?: SelectSubset<T, OffersProfileFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<OffersProfile>>, PrismaPromise<Array<OffersProfileGetPayload<T>>>>

    /**
     * Create a OffersProfile.
     * @param {OffersProfileCreateArgs} args - Arguments to create a OffersProfile.
     * @example
     * // Create one OffersProfile
     * const OffersProfile = await prisma.offersProfile.create({
     *   data: {
     *     // ... data to create a OffersProfile
     *   }
     * })
     * 
    **/
    create<T extends OffersProfileCreateArgs>(
      args: SelectSubset<T, OffersProfileCreateArgs>
    ): CheckSelect<T, Prisma__OffersProfileClient<OffersProfile>, Prisma__OffersProfileClient<OffersProfileGetPayload<T>>>

    /**
     * Create many OffersProfiles.
     *     @param {OffersProfileCreateManyArgs} args - Arguments to create many OffersProfiles.
     *     @example
     *     // Create many OffersProfiles
     *     const offersProfile = await prisma.offersProfile.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OffersProfileCreateManyArgs>(
      args?: SelectSubset<T, OffersProfileCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a OffersProfile.
     * @param {OffersProfileDeleteArgs} args - Arguments to delete one OffersProfile.
     * @example
     * // Delete one OffersProfile
     * const OffersProfile = await prisma.offersProfile.delete({
     *   where: {
     *     // ... filter to delete one OffersProfile
     *   }
     * })
     * 
    **/
    delete<T extends OffersProfileDeleteArgs>(
      args: SelectSubset<T, OffersProfileDeleteArgs>
    ): CheckSelect<T, Prisma__OffersProfileClient<OffersProfile>, Prisma__OffersProfileClient<OffersProfileGetPayload<T>>>

    /**
     * Update one OffersProfile.
     * @param {OffersProfileUpdateArgs} args - Arguments to update one OffersProfile.
     * @example
     * // Update one OffersProfile
     * const offersProfile = await prisma.offersProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OffersProfileUpdateArgs>(
      args: SelectSubset<T, OffersProfileUpdateArgs>
    ): CheckSelect<T, Prisma__OffersProfileClient<OffersProfile>, Prisma__OffersProfileClient<OffersProfileGetPayload<T>>>

    /**
     * Delete zero or more OffersProfiles.
     * @param {OffersProfileDeleteManyArgs} args - Arguments to filter OffersProfiles to delete.
     * @example
     * // Delete a few OffersProfiles
     * const { count } = await prisma.offersProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OffersProfileDeleteManyArgs>(
      args?: SelectSubset<T, OffersProfileDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more OffersProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OffersProfiles
     * const offersProfile = await prisma.offersProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OffersProfileUpdateManyArgs>(
      args: SelectSubset<T, OffersProfileUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one OffersProfile.
     * @param {OffersProfileUpsertArgs} args - Arguments to update or create a OffersProfile.
     * @example
     * // Update or create a OffersProfile
     * const offersProfile = await prisma.offersProfile.upsert({
     *   create: {
     *     // ... data to create a OffersProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OffersProfile we want to update
     *   }
     * })
    **/
    upsert<T extends OffersProfileUpsertArgs>(
      args: SelectSubset<T, OffersProfileUpsertArgs>
    ): CheckSelect<T, Prisma__OffersProfileClient<OffersProfile>, Prisma__OffersProfileClient<OffersProfileGetPayload<T>>>

    /**
     * Find one OffersProfile that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {OffersProfileFindUniqueOrThrowArgs} args - Arguments to find a OffersProfile
     * @example
     * // Get one OffersProfile
     * const offersProfile = await prisma.offersProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OffersProfileFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OffersProfileFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__OffersProfileClient<OffersProfile>, Prisma__OffersProfileClient<OffersProfileGetPayload<T>>>

    /**
     * Find the first OffersProfile that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersProfileFindFirstOrThrowArgs} args - Arguments to find a OffersProfile
     * @example
     * // Get one OffersProfile
     * const offersProfile = await prisma.offersProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OffersProfileFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OffersProfileFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__OffersProfileClient<OffersProfile>, Prisma__OffersProfileClient<OffersProfileGetPayload<T>>>

    /**
     * Count the number of OffersProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersProfileCountArgs} args - Arguments to filter OffersProfiles to count.
     * @example
     * // Count the number of OffersProfiles
     * const count = await prisma.offersProfile.count({
     *   where: {
     *     // ... the filter for the OffersProfiles we want to count
     *   }
     * })
    **/
    count<T extends OffersProfileCountArgs>(
      args?: Subset<T, OffersProfileCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OffersProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OffersProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OffersProfileAggregateArgs>(args: Subset<T, OffersProfileAggregateArgs>): PrismaPromise<GetOffersProfileAggregateType<T>>

    /**
     * Group by OffersProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OffersProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OffersProfileGroupByArgs['orderBy'] }
        : { orderBy?: OffersProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OffersProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOffersProfileGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for OffersProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OffersProfileClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    background<T extends OffersBackgroundArgs = {}>(args?: Subset<T, OffersBackgroundArgs>): CheckSelect<T, Prisma__OffersBackgroundClient<OffersBackground | Null>, Prisma__OffersBackgroundClient<OffersBackgroundGetPayload<T> | Null>>;

    discussion<T extends OffersReplyFindManyArgs = {}>(args?: Subset<T, OffersReplyFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OffersReply>| Null>, PrismaPromise<Array<OffersReplyGetPayload<T>>| Null>>;

    offers<T extends OffersOfferFindManyArgs = {}>(args?: Subset<T, OffersOfferFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OffersOffer>| Null>, PrismaPromise<Array<OffersOfferGetPayload<T>>| Null>>;

    users<T extends UserFindManyArgs = {}>(args?: Subset<T, UserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<User>| Null>, PrismaPromise<Array<UserGetPayload<T>>| Null>>;

    analysis<T extends OffersAnalysisArgs = {}>(args?: Subset<T, OffersAnalysisArgs>): CheckSelect<T, Prisma__OffersAnalysisClient<OffersAnalysis | Null>, Prisma__OffersAnalysisClient<OffersAnalysisGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * OffersProfile base type for findUnique actions
   */
  export type OffersProfileFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the OffersProfile
     * 
    **/
    select?: OffersProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersProfileInclude | null
    /**
     * Filter, which OffersProfile to fetch.
     * 
    **/
    where: OffersProfileWhereUniqueInput
  }

  /**
   * OffersProfile: findUnique
   */
  export interface OffersProfileFindUniqueArgs extends OffersProfileFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OffersProfile base type for findFirst actions
   */
  export type OffersProfileFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the OffersProfile
     * 
    **/
    select?: OffersProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersProfileInclude | null
    /**
     * Filter, which OffersProfile to fetch.
     * 
    **/
    where?: OffersProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffersProfiles to fetch.
     * 
    **/
    orderBy?: Enumerable<OffersProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OffersProfiles.
     * 
    **/
    cursor?: OffersProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffersProfiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffersProfiles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OffersProfiles.
     * 
    **/
    distinct?: Enumerable<OffersProfileScalarFieldEnum>
  }

  /**
   * OffersProfile: findFirst
   */
  export interface OffersProfileFindFirstArgs extends OffersProfileFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OffersProfile findMany
   */
  export type OffersProfileFindManyArgs = {
    /**
     * Select specific fields to fetch from the OffersProfile
     * 
    **/
    select?: OffersProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersProfileInclude | null
    /**
     * Filter, which OffersProfiles to fetch.
     * 
    **/
    where?: OffersProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffersProfiles to fetch.
     * 
    **/
    orderBy?: Enumerable<OffersProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OffersProfiles.
     * 
    **/
    cursor?: OffersProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffersProfiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffersProfiles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OffersProfileScalarFieldEnum>
  }


  /**
   * OffersProfile create
   */
  export type OffersProfileCreateArgs = {
    /**
     * Select specific fields to fetch from the OffersProfile
     * 
    **/
    select?: OffersProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersProfileInclude | null
    /**
     * The data needed to create a OffersProfile.
     * 
    **/
    data: XOR<OffersProfileCreateInput, OffersProfileUncheckedCreateInput>
  }


  /**
   * OffersProfile createMany
   */
  export type OffersProfileCreateManyArgs = {
    /**
     * The data used to create many OffersProfiles.
     * 
    **/
    data: Enumerable<OffersProfileCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OffersProfile update
   */
  export type OffersProfileUpdateArgs = {
    /**
     * Select specific fields to fetch from the OffersProfile
     * 
    **/
    select?: OffersProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersProfileInclude | null
    /**
     * The data needed to update a OffersProfile.
     * 
    **/
    data: XOR<OffersProfileUpdateInput, OffersProfileUncheckedUpdateInput>
    /**
     * Choose, which OffersProfile to update.
     * 
    **/
    where: OffersProfileWhereUniqueInput
  }


  /**
   * OffersProfile updateMany
   */
  export type OffersProfileUpdateManyArgs = {
    /**
     * The data used to update OffersProfiles.
     * 
    **/
    data: XOR<OffersProfileUpdateManyMutationInput, OffersProfileUncheckedUpdateManyInput>
    /**
     * Filter which OffersProfiles to update
     * 
    **/
    where?: OffersProfileWhereInput
  }


  /**
   * OffersProfile upsert
   */
  export type OffersProfileUpsertArgs = {
    /**
     * Select specific fields to fetch from the OffersProfile
     * 
    **/
    select?: OffersProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersProfileInclude | null
    /**
     * The filter to search for the OffersProfile to update in case it exists.
     * 
    **/
    where: OffersProfileWhereUniqueInput
    /**
     * In case the OffersProfile found by the `where` argument doesn't exist, create a new OffersProfile with this data.
     * 
    **/
    create: XOR<OffersProfileCreateInput, OffersProfileUncheckedCreateInput>
    /**
     * In case the OffersProfile was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OffersProfileUpdateInput, OffersProfileUncheckedUpdateInput>
  }


  /**
   * OffersProfile delete
   */
  export type OffersProfileDeleteArgs = {
    /**
     * Select specific fields to fetch from the OffersProfile
     * 
    **/
    select?: OffersProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersProfileInclude | null
    /**
     * Filter which OffersProfile to delete.
     * 
    **/
    where: OffersProfileWhereUniqueInput
  }


  /**
   * OffersProfile deleteMany
   */
  export type OffersProfileDeleteManyArgs = {
    /**
     * Filter which OffersProfiles to delete
     * 
    **/
    where?: OffersProfileWhereInput
  }


  /**
   * OffersProfile: findUniqueOrThrow
   */
  export type OffersProfileFindUniqueOrThrowArgs = OffersProfileFindUniqueArgsBase
      

  /**
   * OffersProfile: findFirstOrThrow
   */
  export type OffersProfileFindFirstOrThrowArgs = OffersProfileFindFirstArgsBase
      

  /**
   * OffersProfile without action
   */
  export type OffersProfileArgs = {
    /**
     * Select specific fields to fetch from the OffersProfile
     * 
    **/
    select?: OffersProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersProfileInclude | null
  }



  /**
   * Model OffersAdmin
   */


  export type AggregateOffersAdmin = {
    _count: OffersAdminCountAggregateOutputType | null
    _min: OffersAdminMinAggregateOutputType | null
    _max: OffersAdminMaxAggregateOutputType | null
  }

  export type OffersAdminMinAggregateOutputType = {
    id: string | null
    userId: string | null
  }

  export type OffersAdminMaxAggregateOutputType = {
    id: string | null
    userId: string | null
  }

  export type OffersAdminCountAggregateOutputType = {
    id: number
    userId: number
    _all: number
  }


  export type OffersAdminMinAggregateInputType = {
    id?: true
    userId?: true
  }

  export type OffersAdminMaxAggregateInputType = {
    id?: true
    userId?: true
  }

  export type OffersAdminCountAggregateInputType = {
    id?: true
    userId?: true
    _all?: true
  }

  export type OffersAdminAggregateArgs = {
    /**
     * Filter which OffersAdmin to aggregate.
     * 
    **/
    where?: OffersAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffersAdmins to fetch.
     * 
    **/
    orderBy?: Enumerable<OffersAdminOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OffersAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffersAdmins from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffersAdmins.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OffersAdmins
    **/
    _count?: true | OffersAdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OffersAdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OffersAdminMaxAggregateInputType
  }

  export type GetOffersAdminAggregateType<T extends OffersAdminAggregateArgs> = {
        [P in keyof T & keyof AggregateOffersAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOffersAdmin[P]>
      : GetScalarType<T[P], AggregateOffersAdmin[P]>
  }




  export type OffersAdminGroupByArgs = {
    where?: OffersAdminWhereInput
    orderBy?: Enumerable<OffersAdminOrderByWithAggregationInput>
    by: Array<OffersAdminScalarFieldEnum>
    having?: OffersAdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OffersAdminCountAggregateInputType | true
    _min?: OffersAdminMinAggregateInputType
    _max?: OffersAdminMaxAggregateInputType
  }


  export type OffersAdminGroupByOutputType = {
    id: string
    userId: string
    _count: OffersAdminCountAggregateOutputType | null
    _min: OffersAdminMinAggregateOutputType | null
    _max: OffersAdminMaxAggregateOutputType | null
  }

  type GetOffersAdminGroupByPayload<T extends OffersAdminGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OffersAdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OffersAdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OffersAdminGroupByOutputType[P]>
            : GetScalarType<T[P], OffersAdminGroupByOutputType[P]>
        }
      >
    >


  export type OffersAdminSelect = {
    id?: boolean
    userId?: boolean
    user?: boolean | UserArgs
  }

  export type OffersAdminInclude = {
    user?: boolean | UserArgs
  }

  export type OffersAdminGetPayload<
    S extends boolean | null | undefined | OffersAdminArgs,
    U = keyof S
      > = S extends true
        ? OffersAdmin
    : S extends undefined
    ? never
    : S extends OffersAdminArgs | OffersAdminFindManyArgs
    ?'include' extends U
    ? OffersAdmin  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof OffersAdmin ? OffersAdmin[P] : never
  } 
    : OffersAdmin
  : OffersAdmin


  type OffersAdminCountArgs = Merge<
    Omit<OffersAdminFindManyArgs, 'select' | 'include'> & {
      select?: OffersAdminCountAggregateInputType | true
    }
  >

  export interface OffersAdminDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one OffersAdmin that matches the filter.
     * @param {OffersAdminFindUniqueArgs} args - Arguments to find a OffersAdmin
     * @example
     * // Get one OffersAdmin
     * const offersAdmin = await prisma.offersAdmin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OffersAdminFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OffersAdminFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OffersAdmin'> extends True ? CheckSelect<T, Prisma__OffersAdminClient<OffersAdmin>, Prisma__OffersAdminClient<OffersAdminGetPayload<T>>> : CheckSelect<T, Prisma__OffersAdminClient<OffersAdmin | null, null>, Prisma__OffersAdminClient<OffersAdminGetPayload<T> | null, null>>

    /**
     * Find the first OffersAdmin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersAdminFindFirstArgs} args - Arguments to find a OffersAdmin
     * @example
     * // Get one OffersAdmin
     * const offersAdmin = await prisma.offersAdmin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OffersAdminFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OffersAdminFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OffersAdmin'> extends True ? CheckSelect<T, Prisma__OffersAdminClient<OffersAdmin>, Prisma__OffersAdminClient<OffersAdminGetPayload<T>>> : CheckSelect<T, Prisma__OffersAdminClient<OffersAdmin | null, null>, Prisma__OffersAdminClient<OffersAdminGetPayload<T> | null, null>>

    /**
     * Find zero or more OffersAdmins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersAdminFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OffersAdmins
     * const offersAdmins = await prisma.offersAdmin.findMany()
     * 
     * // Get first 10 OffersAdmins
     * const offersAdmins = await prisma.offersAdmin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offersAdminWithIdOnly = await prisma.offersAdmin.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OffersAdminFindManyArgs>(
      args?: SelectSubset<T, OffersAdminFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<OffersAdmin>>, PrismaPromise<Array<OffersAdminGetPayload<T>>>>

    /**
     * Create a OffersAdmin.
     * @param {OffersAdminCreateArgs} args - Arguments to create a OffersAdmin.
     * @example
     * // Create one OffersAdmin
     * const OffersAdmin = await prisma.offersAdmin.create({
     *   data: {
     *     // ... data to create a OffersAdmin
     *   }
     * })
     * 
    **/
    create<T extends OffersAdminCreateArgs>(
      args: SelectSubset<T, OffersAdminCreateArgs>
    ): CheckSelect<T, Prisma__OffersAdminClient<OffersAdmin>, Prisma__OffersAdminClient<OffersAdminGetPayload<T>>>

    /**
     * Create many OffersAdmins.
     *     @param {OffersAdminCreateManyArgs} args - Arguments to create many OffersAdmins.
     *     @example
     *     // Create many OffersAdmins
     *     const offersAdmin = await prisma.offersAdmin.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OffersAdminCreateManyArgs>(
      args?: SelectSubset<T, OffersAdminCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a OffersAdmin.
     * @param {OffersAdminDeleteArgs} args - Arguments to delete one OffersAdmin.
     * @example
     * // Delete one OffersAdmin
     * const OffersAdmin = await prisma.offersAdmin.delete({
     *   where: {
     *     // ... filter to delete one OffersAdmin
     *   }
     * })
     * 
    **/
    delete<T extends OffersAdminDeleteArgs>(
      args: SelectSubset<T, OffersAdminDeleteArgs>
    ): CheckSelect<T, Prisma__OffersAdminClient<OffersAdmin>, Prisma__OffersAdminClient<OffersAdminGetPayload<T>>>

    /**
     * Update one OffersAdmin.
     * @param {OffersAdminUpdateArgs} args - Arguments to update one OffersAdmin.
     * @example
     * // Update one OffersAdmin
     * const offersAdmin = await prisma.offersAdmin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OffersAdminUpdateArgs>(
      args: SelectSubset<T, OffersAdminUpdateArgs>
    ): CheckSelect<T, Prisma__OffersAdminClient<OffersAdmin>, Prisma__OffersAdminClient<OffersAdminGetPayload<T>>>

    /**
     * Delete zero or more OffersAdmins.
     * @param {OffersAdminDeleteManyArgs} args - Arguments to filter OffersAdmins to delete.
     * @example
     * // Delete a few OffersAdmins
     * const { count } = await prisma.offersAdmin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OffersAdminDeleteManyArgs>(
      args?: SelectSubset<T, OffersAdminDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more OffersAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersAdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OffersAdmins
     * const offersAdmin = await prisma.offersAdmin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OffersAdminUpdateManyArgs>(
      args: SelectSubset<T, OffersAdminUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one OffersAdmin.
     * @param {OffersAdminUpsertArgs} args - Arguments to update or create a OffersAdmin.
     * @example
     * // Update or create a OffersAdmin
     * const offersAdmin = await prisma.offersAdmin.upsert({
     *   create: {
     *     // ... data to create a OffersAdmin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OffersAdmin we want to update
     *   }
     * })
    **/
    upsert<T extends OffersAdminUpsertArgs>(
      args: SelectSubset<T, OffersAdminUpsertArgs>
    ): CheckSelect<T, Prisma__OffersAdminClient<OffersAdmin>, Prisma__OffersAdminClient<OffersAdminGetPayload<T>>>

    /**
     * Find one OffersAdmin that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {OffersAdminFindUniqueOrThrowArgs} args - Arguments to find a OffersAdmin
     * @example
     * // Get one OffersAdmin
     * const offersAdmin = await prisma.offersAdmin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OffersAdminFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OffersAdminFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__OffersAdminClient<OffersAdmin>, Prisma__OffersAdminClient<OffersAdminGetPayload<T>>>

    /**
     * Find the first OffersAdmin that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersAdminFindFirstOrThrowArgs} args - Arguments to find a OffersAdmin
     * @example
     * // Get one OffersAdmin
     * const offersAdmin = await prisma.offersAdmin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OffersAdminFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OffersAdminFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__OffersAdminClient<OffersAdmin>, Prisma__OffersAdminClient<OffersAdminGetPayload<T>>>

    /**
     * Count the number of OffersAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersAdminCountArgs} args - Arguments to filter OffersAdmins to count.
     * @example
     * // Count the number of OffersAdmins
     * const count = await prisma.offersAdmin.count({
     *   where: {
     *     // ... the filter for the OffersAdmins we want to count
     *   }
     * })
    **/
    count<T extends OffersAdminCountArgs>(
      args?: Subset<T, OffersAdminCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OffersAdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OffersAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersAdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OffersAdminAggregateArgs>(args: Subset<T, OffersAdminAggregateArgs>): PrismaPromise<GetOffersAdminAggregateType<T>>

    /**
     * Group by OffersAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersAdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OffersAdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OffersAdminGroupByArgs['orderBy'] }
        : { orderBy?: OffersAdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OffersAdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOffersAdminGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for OffersAdmin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OffersAdminClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * OffersAdmin base type for findUnique actions
   */
  export type OffersAdminFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the OffersAdmin
     * 
    **/
    select?: OffersAdminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersAdminInclude | null
    /**
     * Filter, which OffersAdmin to fetch.
     * 
    **/
    where: OffersAdminWhereUniqueInput
  }

  /**
   * OffersAdmin: findUnique
   */
  export interface OffersAdminFindUniqueArgs extends OffersAdminFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OffersAdmin base type for findFirst actions
   */
  export type OffersAdminFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the OffersAdmin
     * 
    **/
    select?: OffersAdminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersAdminInclude | null
    /**
     * Filter, which OffersAdmin to fetch.
     * 
    **/
    where?: OffersAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffersAdmins to fetch.
     * 
    **/
    orderBy?: Enumerable<OffersAdminOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OffersAdmins.
     * 
    **/
    cursor?: OffersAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffersAdmins from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffersAdmins.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OffersAdmins.
     * 
    **/
    distinct?: Enumerable<OffersAdminScalarFieldEnum>
  }

  /**
   * OffersAdmin: findFirst
   */
  export interface OffersAdminFindFirstArgs extends OffersAdminFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OffersAdmin findMany
   */
  export type OffersAdminFindManyArgs = {
    /**
     * Select specific fields to fetch from the OffersAdmin
     * 
    **/
    select?: OffersAdminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersAdminInclude | null
    /**
     * Filter, which OffersAdmins to fetch.
     * 
    **/
    where?: OffersAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffersAdmins to fetch.
     * 
    **/
    orderBy?: Enumerable<OffersAdminOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OffersAdmins.
     * 
    **/
    cursor?: OffersAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffersAdmins from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffersAdmins.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OffersAdminScalarFieldEnum>
  }


  /**
   * OffersAdmin create
   */
  export type OffersAdminCreateArgs = {
    /**
     * Select specific fields to fetch from the OffersAdmin
     * 
    **/
    select?: OffersAdminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersAdminInclude | null
    /**
     * The data needed to create a OffersAdmin.
     * 
    **/
    data: XOR<OffersAdminCreateInput, OffersAdminUncheckedCreateInput>
  }


  /**
   * OffersAdmin createMany
   */
  export type OffersAdminCreateManyArgs = {
    /**
     * The data used to create many OffersAdmins.
     * 
    **/
    data: Enumerable<OffersAdminCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OffersAdmin update
   */
  export type OffersAdminUpdateArgs = {
    /**
     * Select specific fields to fetch from the OffersAdmin
     * 
    **/
    select?: OffersAdminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersAdminInclude | null
    /**
     * The data needed to update a OffersAdmin.
     * 
    **/
    data: XOR<OffersAdminUpdateInput, OffersAdminUncheckedUpdateInput>
    /**
     * Choose, which OffersAdmin to update.
     * 
    **/
    where: OffersAdminWhereUniqueInput
  }


  /**
   * OffersAdmin updateMany
   */
  export type OffersAdminUpdateManyArgs = {
    /**
     * The data used to update OffersAdmins.
     * 
    **/
    data: XOR<OffersAdminUpdateManyMutationInput, OffersAdminUncheckedUpdateManyInput>
    /**
     * Filter which OffersAdmins to update
     * 
    **/
    where?: OffersAdminWhereInput
  }


  /**
   * OffersAdmin upsert
   */
  export type OffersAdminUpsertArgs = {
    /**
     * Select specific fields to fetch from the OffersAdmin
     * 
    **/
    select?: OffersAdminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersAdminInclude | null
    /**
     * The filter to search for the OffersAdmin to update in case it exists.
     * 
    **/
    where: OffersAdminWhereUniqueInput
    /**
     * In case the OffersAdmin found by the `where` argument doesn't exist, create a new OffersAdmin with this data.
     * 
    **/
    create: XOR<OffersAdminCreateInput, OffersAdminUncheckedCreateInput>
    /**
     * In case the OffersAdmin was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OffersAdminUpdateInput, OffersAdminUncheckedUpdateInput>
  }


  /**
   * OffersAdmin delete
   */
  export type OffersAdminDeleteArgs = {
    /**
     * Select specific fields to fetch from the OffersAdmin
     * 
    **/
    select?: OffersAdminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersAdminInclude | null
    /**
     * Filter which OffersAdmin to delete.
     * 
    **/
    where: OffersAdminWhereUniqueInput
  }


  /**
   * OffersAdmin deleteMany
   */
  export type OffersAdminDeleteManyArgs = {
    /**
     * Filter which OffersAdmins to delete
     * 
    **/
    where?: OffersAdminWhereInput
  }


  /**
   * OffersAdmin: findUniqueOrThrow
   */
  export type OffersAdminFindUniqueOrThrowArgs = OffersAdminFindUniqueArgsBase
      

  /**
   * OffersAdmin: findFirstOrThrow
   */
  export type OffersAdminFindFirstOrThrowArgs = OffersAdminFindFirstArgsBase
      

  /**
   * OffersAdmin without action
   */
  export type OffersAdminArgs = {
    /**
     * Select specific fields to fetch from the OffersAdmin
     * 
    **/
    select?: OffersAdminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersAdminInclude | null
  }



  /**
   * Model OffersBackground
   */


  export type AggregateOffersBackground = {
    _count: OffersBackgroundCountAggregateOutputType | null
    _avg: OffersBackgroundAvgAggregateOutputType | null
    _sum: OffersBackgroundSumAggregateOutputType | null
    _min: OffersBackgroundMinAggregateOutputType | null
    _max: OffersBackgroundMaxAggregateOutputType | null
  }

  export type OffersBackgroundAvgAggregateOutputType = {
    totalYoe: number | null
  }

  export type OffersBackgroundSumAggregateOutputType = {
    totalYoe: number | null
  }

  export type OffersBackgroundMinAggregateOutputType = {
    id: string | null
    totalYoe: number | null
    offersProfileId: string | null
  }

  export type OffersBackgroundMaxAggregateOutputType = {
    id: string | null
    totalYoe: number | null
    offersProfileId: string | null
  }

  export type OffersBackgroundCountAggregateOutputType = {
    id: number
    totalYoe: number
    offersProfileId: number
    _all: number
  }


  export type OffersBackgroundAvgAggregateInputType = {
    totalYoe?: true
  }

  export type OffersBackgroundSumAggregateInputType = {
    totalYoe?: true
  }

  export type OffersBackgroundMinAggregateInputType = {
    id?: true
    totalYoe?: true
    offersProfileId?: true
  }

  export type OffersBackgroundMaxAggregateInputType = {
    id?: true
    totalYoe?: true
    offersProfileId?: true
  }

  export type OffersBackgroundCountAggregateInputType = {
    id?: true
    totalYoe?: true
    offersProfileId?: true
    _all?: true
  }

  export type OffersBackgroundAggregateArgs = {
    /**
     * Filter which OffersBackground to aggregate.
     * 
    **/
    where?: OffersBackgroundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffersBackgrounds to fetch.
     * 
    **/
    orderBy?: Enumerable<OffersBackgroundOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OffersBackgroundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffersBackgrounds from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffersBackgrounds.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OffersBackgrounds
    **/
    _count?: true | OffersBackgroundCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OffersBackgroundAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OffersBackgroundSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OffersBackgroundMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OffersBackgroundMaxAggregateInputType
  }

  export type GetOffersBackgroundAggregateType<T extends OffersBackgroundAggregateArgs> = {
        [P in keyof T & keyof AggregateOffersBackground]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOffersBackground[P]>
      : GetScalarType<T[P], AggregateOffersBackground[P]>
  }




  export type OffersBackgroundGroupByArgs = {
    where?: OffersBackgroundWhereInput
    orderBy?: Enumerable<OffersBackgroundOrderByWithAggregationInput>
    by: Array<OffersBackgroundScalarFieldEnum>
    having?: OffersBackgroundScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OffersBackgroundCountAggregateInputType | true
    _avg?: OffersBackgroundAvgAggregateInputType
    _sum?: OffersBackgroundSumAggregateInputType
    _min?: OffersBackgroundMinAggregateInputType
    _max?: OffersBackgroundMaxAggregateInputType
  }


  export type OffersBackgroundGroupByOutputType = {
    id: string
    totalYoe: number
    offersProfileId: string
    _count: OffersBackgroundCountAggregateOutputType | null
    _avg: OffersBackgroundAvgAggregateOutputType | null
    _sum: OffersBackgroundSumAggregateOutputType | null
    _min: OffersBackgroundMinAggregateOutputType | null
    _max: OffersBackgroundMaxAggregateOutputType | null
  }

  type GetOffersBackgroundGroupByPayload<T extends OffersBackgroundGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OffersBackgroundGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OffersBackgroundGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OffersBackgroundGroupByOutputType[P]>
            : GetScalarType<T[P], OffersBackgroundGroupByOutputType[P]>
        }
      >
    >


  export type OffersBackgroundSelect = {
    id?: boolean
    totalYoe?: boolean
    specificYoes?: boolean | OffersSpecificYoeFindManyArgs
    experiences?: boolean | OffersExperienceFindManyArgs
    educations?: boolean | OffersEducationFindManyArgs
    profile?: boolean | OffersProfileArgs
    offersProfileId?: boolean
    _count?: boolean | OffersBackgroundCountOutputTypeArgs
  }

  export type OffersBackgroundInclude = {
    specificYoes?: boolean | OffersSpecificYoeFindManyArgs
    experiences?: boolean | OffersExperienceFindManyArgs
    educations?: boolean | OffersEducationFindManyArgs
    profile?: boolean | OffersProfileArgs
    _count?: boolean | OffersBackgroundCountOutputTypeArgs
  }

  export type OffersBackgroundGetPayload<
    S extends boolean | null | undefined | OffersBackgroundArgs,
    U = keyof S
      > = S extends true
        ? OffersBackground
    : S extends undefined
    ? never
    : S extends OffersBackgroundArgs | OffersBackgroundFindManyArgs
    ?'include' extends U
    ? OffersBackground  & {
    [P in TrueKeys<S['include']>]:
        P extends 'specificYoes' ? Array < OffersSpecificYoeGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'experiences' ? Array < OffersExperienceGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'educations' ? Array < OffersEducationGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'profile' ? OffersProfileGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends '_count' ? OffersBackgroundCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'specificYoes' ? Array < OffersSpecificYoeGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'experiences' ? Array < OffersExperienceGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'educations' ? Array < OffersEducationGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'profile' ? OffersProfileGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends '_count' ? OffersBackgroundCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof OffersBackground ? OffersBackground[P] : never
  } 
    : OffersBackground
  : OffersBackground


  type OffersBackgroundCountArgs = Merge<
    Omit<OffersBackgroundFindManyArgs, 'select' | 'include'> & {
      select?: OffersBackgroundCountAggregateInputType | true
    }
  >

  export interface OffersBackgroundDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one OffersBackground that matches the filter.
     * @param {OffersBackgroundFindUniqueArgs} args - Arguments to find a OffersBackground
     * @example
     * // Get one OffersBackground
     * const offersBackground = await prisma.offersBackground.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OffersBackgroundFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OffersBackgroundFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OffersBackground'> extends True ? CheckSelect<T, Prisma__OffersBackgroundClient<OffersBackground>, Prisma__OffersBackgroundClient<OffersBackgroundGetPayload<T>>> : CheckSelect<T, Prisma__OffersBackgroundClient<OffersBackground | null, null>, Prisma__OffersBackgroundClient<OffersBackgroundGetPayload<T> | null, null>>

    /**
     * Find the first OffersBackground that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersBackgroundFindFirstArgs} args - Arguments to find a OffersBackground
     * @example
     * // Get one OffersBackground
     * const offersBackground = await prisma.offersBackground.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OffersBackgroundFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OffersBackgroundFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OffersBackground'> extends True ? CheckSelect<T, Prisma__OffersBackgroundClient<OffersBackground>, Prisma__OffersBackgroundClient<OffersBackgroundGetPayload<T>>> : CheckSelect<T, Prisma__OffersBackgroundClient<OffersBackground | null, null>, Prisma__OffersBackgroundClient<OffersBackgroundGetPayload<T> | null, null>>

    /**
     * Find zero or more OffersBackgrounds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersBackgroundFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OffersBackgrounds
     * const offersBackgrounds = await prisma.offersBackground.findMany()
     * 
     * // Get first 10 OffersBackgrounds
     * const offersBackgrounds = await prisma.offersBackground.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offersBackgroundWithIdOnly = await prisma.offersBackground.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OffersBackgroundFindManyArgs>(
      args?: SelectSubset<T, OffersBackgroundFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<OffersBackground>>, PrismaPromise<Array<OffersBackgroundGetPayload<T>>>>

    /**
     * Create a OffersBackground.
     * @param {OffersBackgroundCreateArgs} args - Arguments to create a OffersBackground.
     * @example
     * // Create one OffersBackground
     * const OffersBackground = await prisma.offersBackground.create({
     *   data: {
     *     // ... data to create a OffersBackground
     *   }
     * })
     * 
    **/
    create<T extends OffersBackgroundCreateArgs>(
      args: SelectSubset<T, OffersBackgroundCreateArgs>
    ): CheckSelect<T, Prisma__OffersBackgroundClient<OffersBackground>, Prisma__OffersBackgroundClient<OffersBackgroundGetPayload<T>>>

    /**
     * Create many OffersBackgrounds.
     *     @param {OffersBackgroundCreateManyArgs} args - Arguments to create many OffersBackgrounds.
     *     @example
     *     // Create many OffersBackgrounds
     *     const offersBackground = await prisma.offersBackground.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OffersBackgroundCreateManyArgs>(
      args?: SelectSubset<T, OffersBackgroundCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a OffersBackground.
     * @param {OffersBackgroundDeleteArgs} args - Arguments to delete one OffersBackground.
     * @example
     * // Delete one OffersBackground
     * const OffersBackground = await prisma.offersBackground.delete({
     *   where: {
     *     // ... filter to delete one OffersBackground
     *   }
     * })
     * 
    **/
    delete<T extends OffersBackgroundDeleteArgs>(
      args: SelectSubset<T, OffersBackgroundDeleteArgs>
    ): CheckSelect<T, Prisma__OffersBackgroundClient<OffersBackground>, Prisma__OffersBackgroundClient<OffersBackgroundGetPayload<T>>>

    /**
     * Update one OffersBackground.
     * @param {OffersBackgroundUpdateArgs} args - Arguments to update one OffersBackground.
     * @example
     * // Update one OffersBackground
     * const offersBackground = await prisma.offersBackground.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OffersBackgroundUpdateArgs>(
      args: SelectSubset<T, OffersBackgroundUpdateArgs>
    ): CheckSelect<T, Prisma__OffersBackgroundClient<OffersBackground>, Prisma__OffersBackgroundClient<OffersBackgroundGetPayload<T>>>

    /**
     * Delete zero or more OffersBackgrounds.
     * @param {OffersBackgroundDeleteManyArgs} args - Arguments to filter OffersBackgrounds to delete.
     * @example
     * // Delete a few OffersBackgrounds
     * const { count } = await prisma.offersBackground.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OffersBackgroundDeleteManyArgs>(
      args?: SelectSubset<T, OffersBackgroundDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more OffersBackgrounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersBackgroundUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OffersBackgrounds
     * const offersBackground = await prisma.offersBackground.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OffersBackgroundUpdateManyArgs>(
      args: SelectSubset<T, OffersBackgroundUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one OffersBackground.
     * @param {OffersBackgroundUpsertArgs} args - Arguments to update or create a OffersBackground.
     * @example
     * // Update or create a OffersBackground
     * const offersBackground = await prisma.offersBackground.upsert({
     *   create: {
     *     // ... data to create a OffersBackground
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OffersBackground we want to update
     *   }
     * })
    **/
    upsert<T extends OffersBackgroundUpsertArgs>(
      args: SelectSubset<T, OffersBackgroundUpsertArgs>
    ): CheckSelect<T, Prisma__OffersBackgroundClient<OffersBackground>, Prisma__OffersBackgroundClient<OffersBackgroundGetPayload<T>>>

    /**
     * Find one OffersBackground that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {OffersBackgroundFindUniqueOrThrowArgs} args - Arguments to find a OffersBackground
     * @example
     * // Get one OffersBackground
     * const offersBackground = await prisma.offersBackground.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OffersBackgroundFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OffersBackgroundFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__OffersBackgroundClient<OffersBackground>, Prisma__OffersBackgroundClient<OffersBackgroundGetPayload<T>>>

    /**
     * Find the first OffersBackground that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersBackgroundFindFirstOrThrowArgs} args - Arguments to find a OffersBackground
     * @example
     * // Get one OffersBackground
     * const offersBackground = await prisma.offersBackground.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OffersBackgroundFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OffersBackgroundFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__OffersBackgroundClient<OffersBackground>, Prisma__OffersBackgroundClient<OffersBackgroundGetPayload<T>>>

    /**
     * Count the number of OffersBackgrounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersBackgroundCountArgs} args - Arguments to filter OffersBackgrounds to count.
     * @example
     * // Count the number of OffersBackgrounds
     * const count = await prisma.offersBackground.count({
     *   where: {
     *     // ... the filter for the OffersBackgrounds we want to count
     *   }
     * })
    **/
    count<T extends OffersBackgroundCountArgs>(
      args?: Subset<T, OffersBackgroundCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OffersBackgroundCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OffersBackground.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersBackgroundAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OffersBackgroundAggregateArgs>(args: Subset<T, OffersBackgroundAggregateArgs>): PrismaPromise<GetOffersBackgroundAggregateType<T>>

    /**
     * Group by OffersBackground.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersBackgroundGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OffersBackgroundGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OffersBackgroundGroupByArgs['orderBy'] }
        : { orderBy?: OffersBackgroundGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OffersBackgroundGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOffersBackgroundGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for OffersBackground.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OffersBackgroundClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    specificYoes<T extends OffersSpecificYoeFindManyArgs = {}>(args?: Subset<T, OffersSpecificYoeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OffersSpecificYoe>| Null>, PrismaPromise<Array<OffersSpecificYoeGetPayload<T>>| Null>>;

    experiences<T extends OffersExperienceFindManyArgs = {}>(args?: Subset<T, OffersExperienceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OffersExperience>| Null>, PrismaPromise<Array<OffersExperienceGetPayload<T>>| Null>>;

    educations<T extends OffersEducationFindManyArgs = {}>(args?: Subset<T, OffersEducationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OffersEducation>| Null>, PrismaPromise<Array<OffersEducationGetPayload<T>>| Null>>;

    profile<T extends OffersProfileArgs = {}>(args?: Subset<T, OffersProfileArgs>): CheckSelect<T, Prisma__OffersProfileClient<OffersProfile | Null>, Prisma__OffersProfileClient<OffersProfileGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * OffersBackground base type for findUnique actions
   */
  export type OffersBackgroundFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the OffersBackground
     * 
    **/
    select?: OffersBackgroundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersBackgroundInclude | null
    /**
     * Filter, which OffersBackground to fetch.
     * 
    **/
    where: OffersBackgroundWhereUniqueInput
  }

  /**
   * OffersBackground: findUnique
   */
  export interface OffersBackgroundFindUniqueArgs extends OffersBackgroundFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OffersBackground base type for findFirst actions
   */
  export type OffersBackgroundFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the OffersBackground
     * 
    **/
    select?: OffersBackgroundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersBackgroundInclude | null
    /**
     * Filter, which OffersBackground to fetch.
     * 
    **/
    where?: OffersBackgroundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffersBackgrounds to fetch.
     * 
    **/
    orderBy?: Enumerable<OffersBackgroundOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OffersBackgrounds.
     * 
    **/
    cursor?: OffersBackgroundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffersBackgrounds from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffersBackgrounds.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OffersBackgrounds.
     * 
    **/
    distinct?: Enumerable<OffersBackgroundScalarFieldEnum>
  }

  /**
   * OffersBackground: findFirst
   */
  export interface OffersBackgroundFindFirstArgs extends OffersBackgroundFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OffersBackground findMany
   */
  export type OffersBackgroundFindManyArgs = {
    /**
     * Select specific fields to fetch from the OffersBackground
     * 
    **/
    select?: OffersBackgroundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersBackgroundInclude | null
    /**
     * Filter, which OffersBackgrounds to fetch.
     * 
    **/
    where?: OffersBackgroundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffersBackgrounds to fetch.
     * 
    **/
    orderBy?: Enumerable<OffersBackgroundOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OffersBackgrounds.
     * 
    **/
    cursor?: OffersBackgroundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffersBackgrounds from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffersBackgrounds.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OffersBackgroundScalarFieldEnum>
  }


  /**
   * OffersBackground create
   */
  export type OffersBackgroundCreateArgs = {
    /**
     * Select specific fields to fetch from the OffersBackground
     * 
    **/
    select?: OffersBackgroundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersBackgroundInclude | null
    /**
     * The data needed to create a OffersBackground.
     * 
    **/
    data: XOR<OffersBackgroundCreateInput, OffersBackgroundUncheckedCreateInput>
  }


  /**
   * OffersBackground createMany
   */
  export type OffersBackgroundCreateManyArgs = {
    /**
     * The data used to create many OffersBackgrounds.
     * 
    **/
    data: Enumerable<OffersBackgroundCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OffersBackground update
   */
  export type OffersBackgroundUpdateArgs = {
    /**
     * Select specific fields to fetch from the OffersBackground
     * 
    **/
    select?: OffersBackgroundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersBackgroundInclude | null
    /**
     * The data needed to update a OffersBackground.
     * 
    **/
    data: XOR<OffersBackgroundUpdateInput, OffersBackgroundUncheckedUpdateInput>
    /**
     * Choose, which OffersBackground to update.
     * 
    **/
    where: OffersBackgroundWhereUniqueInput
  }


  /**
   * OffersBackground updateMany
   */
  export type OffersBackgroundUpdateManyArgs = {
    /**
     * The data used to update OffersBackgrounds.
     * 
    **/
    data: XOR<OffersBackgroundUpdateManyMutationInput, OffersBackgroundUncheckedUpdateManyInput>
    /**
     * Filter which OffersBackgrounds to update
     * 
    **/
    where?: OffersBackgroundWhereInput
  }


  /**
   * OffersBackground upsert
   */
  export type OffersBackgroundUpsertArgs = {
    /**
     * Select specific fields to fetch from the OffersBackground
     * 
    **/
    select?: OffersBackgroundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersBackgroundInclude | null
    /**
     * The filter to search for the OffersBackground to update in case it exists.
     * 
    **/
    where: OffersBackgroundWhereUniqueInput
    /**
     * In case the OffersBackground found by the `where` argument doesn't exist, create a new OffersBackground with this data.
     * 
    **/
    create: XOR<OffersBackgroundCreateInput, OffersBackgroundUncheckedCreateInput>
    /**
     * In case the OffersBackground was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OffersBackgroundUpdateInput, OffersBackgroundUncheckedUpdateInput>
  }


  /**
   * OffersBackground delete
   */
  export type OffersBackgroundDeleteArgs = {
    /**
     * Select specific fields to fetch from the OffersBackground
     * 
    **/
    select?: OffersBackgroundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersBackgroundInclude | null
    /**
     * Filter which OffersBackground to delete.
     * 
    **/
    where: OffersBackgroundWhereUniqueInput
  }


  /**
   * OffersBackground deleteMany
   */
  export type OffersBackgroundDeleteManyArgs = {
    /**
     * Filter which OffersBackgrounds to delete
     * 
    **/
    where?: OffersBackgroundWhereInput
  }


  /**
   * OffersBackground: findUniqueOrThrow
   */
  export type OffersBackgroundFindUniqueOrThrowArgs = OffersBackgroundFindUniqueArgsBase
      

  /**
   * OffersBackground: findFirstOrThrow
   */
  export type OffersBackgroundFindFirstOrThrowArgs = OffersBackgroundFindFirstArgsBase
      

  /**
   * OffersBackground without action
   */
  export type OffersBackgroundArgs = {
    /**
     * Select specific fields to fetch from the OffersBackground
     * 
    **/
    select?: OffersBackgroundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersBackgroundInclude | null
  }



  /**
   * Model OffersSpecificYoe
   */


  export type AggregateOffersSpecificYoe = {
    _count: OffersSpecificYoeCountAggregateOutputType | null
    _avg: OffersSpecificYoeAvgAggregateOutputType | null
    _sum: OffersSpecificYoeSumAggregateOutputType | null
    _min: OffersSpecificYoeMinAggregateOutputType | null
    _max: OffersSpecificYoeMaxAggregateOutputType | null
  }

  export type OffersSpecificYoeAvgAggregateOutputType = {
    yoe: number | null
  }

  export type OffersSpecificYoeSumAggregateOutputType = {
    yoe: number | null
  }

  export type OffersSpecificYoeMinAggregateOutputType = {
    id: string | null
    yoe: number | null
    domain: string | null
    backgroundId: string | null
  }

  export type OffersSpecificYoeMaxAggregateOutputType = {
    id: string | null
    yoe: number | null
    domain: string | null
    backgroundId: string | null
  }

  export type OffersSpecificYoeCountAggregateOutputType = {
    id: number
    yoe: number
    domain: number
    backgroundId: number
    _all: number
  }


  export type OffersSpecificYoeAvgAggregateInputType = {
    yoe?: true
  }

  export type OffersSpecificYoeSumAggregateInputType = {
    yoe?: true
  }

  export type OffersSpecificYoeMinAggregateInputType = {
    id?: true
    yoe?: true
    domain?: true
    backgroundId?: true
  }

  export type OffersSpecificYoeMaxAggregateInputType = {
    id?: true
    yoe?: true
    domain?: true
    backgroundId?: true
  }

  export type OffersSpecificYoeCountAggregateInputType = {
    id?: true
    yoe?: true
    domain?: true
    backgroundId?: true
    _all?: true
  }

  export type OffersSpecificYoeAggregateArgs = {
    /**
     * Filter which OffersSpecificYoe to aggregate.
     * 
    **/
    where?: OffersSpecificYoeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffersSpecificYoes to fetch.
     * 
    **/
    orderBy?: Enumerable<OffersSpecificYoeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OffersSpecificYoeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffersSpecificYoes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffersSpecificYoes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OffersSpecificYoes
    **/
    _count?: true | OffersSpecificYoeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OffersSpecificYoeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OffersSpecificYoeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OffersSpecificYoeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OffersSpecificYoeMaxAggregateInputType
  }

  export type GetOffersSpecificYoeAggregateType<T extends OffersSpecificYoeAggregateArgs> = {
        [P in keyof T & keyof AggregateOffersSpecificYoe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOffersSpecificYoe[P]>
      : GetScalarType<T[P], AggregateOffersSpecificYoe[P]>
  }




  export type OffersSpecificYoeGroupByArgs = {
    where?: OffersSpecificYoeWhereInput
    orderBy?: Enumerable<OffersSpecificYoeOrderByWithAggregationInput>
    by: Array<OffersSpecificYoeScalarFieldEnum>
    having?: OffersSpecificYoeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OffersSpecificYoeCountAggregateInputType | true
    _avg?: OffersSpecificYoeAvgAggregateInputType
    _sum?: OffersSpecificYoeSumAggregateInputType
    _min?: OffersSpecificYoeMinAggregateInputType
    _max?: OffersSpecificYoeMaxAggregateInputType
  }


  export type OffersSpecificYoeGroupByOutputType = {
    id: string
    yoe: number
    domain: string
    backgroundId: string
    _count: OffersSpecificYoeCountAggregateOutputType | null
    _avg: OffersSpecificYoeAvgAggregateOutputType | null
    _sum: OffersSpecificYoeSumAggregateOutputType | null
    _min: OffersSpecificYoeMinAggregateOutputType | null
    _max: OffersSpecificYoeMaxAggregateOutputType | null
  }

  type GetOffersSpecificYoeGroupByPayload<T extends OffersSpecificYoeGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OffersSpecificYoeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OffersSpecificYoeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OffersSpecificYoeGroupByOutputType[P]>
            : GetScalarType<T[P], OffersSpecificYoeGroupByOutputType[P]>
        }
      >
    >


  export type OffersSpecificYoeSelect = {
    id?: boolean
    yoe?: boolean
    domain?: boolean
    background?: boolean | OffersBackgroundArgs
    backgroundId?: boolean
  }

  export type OffersSpecificYoeInclude = {
    background?: boolean | OffersBackgroundArgs
  }

  export type OffersSpecificYoeGetPayload<
    S extends boolean | null | undefined | OffersSpecificYoeArgs,
    U = keyof S
      > = S extends true
        ? OffersSpecificYoe
    : S extends undefined
    ? never
    : S extends OffersSpecificYoeArgs | OffersSpecificYoeFindManyArgs
    ?'include' extends U
    ? OffersSpecificYoe  & {
    [P in TrueKeys<S['include']>]:
        P extends 'background' ? OffersBackgroundGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'background' ? OffersBackgroundGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof OffersSpecificYoe ? OffersSpecificYoe[P] : never
  } 
    : OffersSpecificYoe
  : OffersSpecificYoe


  type OffersSpecificYoeCountArgs = Merge<
    Omit<OffersSpecificYoeFindManyArgs, 'select' | 'include'> & {
      select?: OffersSpecificYoeCountAggregateInputType | true
    }
  >

  export interface OffersSpecificYoeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one OffersSpecificYoe that matches the filter.
     * @param {OffersSpecificYoeFindUniqueArgs} args - Arguments to find a OffersSpecificYoe
     * @example
     * // Get one OffersSpecificYoe
     * const offersSpecificYoe = await prisma.offersSpecificYoe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OffersSpecificYoeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OffersSpecificYoeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OffersSpecificYoe'> extends True ? CheckSelect<T, Prisma__OffersSpecificYoeClient<OffersSpecificYoe>, Prisma__OffersSpecificYoeClient<OffersSpecificYoeGetPayload<T>>> : CheckSelect<T, Prisma__OffersSpecificYoeClient<OffersSpecificYoe | null, null>, Prisma__OffersSpecificYoeClient<OffersSpecificYoeGetPayload<T> | null, null>>

    /**
     * Find the first OffersSpecificYoe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersSpecificYoeFindFirstArgs} args - Arguments to find a OffersSpecificYoe
     * @example
     * // Get one OffersSpecificYoe
     * const offersSpecificYoe = await prisma.offersSpecificYoe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OffersSpecificYoeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OffersSpecificYoeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OffersSpecificYoe'> extends True ? CheckSelect<T, Prisma__OffersSpecificYoeClient<OffersSpecificYoe>, Prisma__OffersSpecificYoeClient<OffersSpecificYoeGetPayload<T>>> : CheckSelect<T, Prisma__OffersSpecificYoeClient<OffersSpecificYoe | null, null>, Prisma__OffersSpecificYoeClient<OffersSpecificYoeGetPayload<T> | null, null>>

    /**
     * Find zero or more OffersSpecificYoes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersSpecificYoeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OffersSpecificYoes
     * const offersSpecificYoes = await prisma.offersSpecificYoe.findMany()
     * 
     * // Get first 10 OffersSpecificYoes
     * const offersSpecificYoes = await prisma.offersSpecificYoe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offersSpecificYoeWithIdOnly = await prisma.offersSpecificYoe.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OffersSpecificYoeFindManyArgs>(
      args?: SelectSubset<T, OffersSpecificYoeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<OffersSpecificYoe>>, PrismaPromise<Array<OffersSpecificYoeGetPayload<T>>>>

    /**
     * Create a OffersSpecificYoe.
     * @param {OffersSpecificYoeCreateArgs} args - Arguments to create a OffersSpecificYoe.
     * @example
     * // Create one OffersSpecificYoe
     * const OffersSpecificYoe = await prisma.offersSpecificYoe.create({
     *   data: {
     *     // ... data to create a OffersSpecificYoe
     *   }
     * })
     * 
    **/
    create<T extends OffersSpecificYoeCreateArgs>(
      args: SelectSubset<T, OffersSpecificYoeCreateArgs>
    ): CheckSelect<T, Prisma__OffersSpecificYoeClient<OffersSpecificYoe>, Prisma__OffersSpecificYoeClient<OffersSpecificYoeGetPayload<T>>>

    /**
     * Create many OffersSpecificYoes.
     *     @param {OffersSpecificYoeCreateManyArgs} args - Arguments to create many OffersSpecificYoes.
     *     @example
     *     // Create many OffersSpecificYoes
     *     const offersSpecificYoe = await prisma.offersSpecificYoe.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OffersSpecificYoeCreateManyArgs>(
      args?: SelectSubset<T, OffersSpecificYoeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a OffersSpecificYoe.
     * @param {OffersSpecificYoeDeleteArgs} args - Arguments to delete one OffersSpecificYoe.
     * @example
     * // Delete one OffersSpecificYoe
     * const OffersSpecificYoe = await prisma.offersSpecificYoe.delete({
     *   where: {
     *     // ... filter to delete one OffersSpecificYoe
     *   }
     * })
     * 
    **/
    delete<T extends OffersSpecificYoeDeleteArgs>(
      args: SelectSubset<T, OffersSpecificYoeDeleteArgs>
    ): CheckSelect<T, Prisma__OffersSpecificYoeClient<OffersSpecificYoe>, Prisma__OffersSpecificYoeClient<OffersSpecificYoeGetPayload<T>>>

    /**
     * Update one OffersSpecificYoe.
     * @param {OffersSpecificYoeUpdateArgs} args - Arguments to update one OffersSpecificYoe.
     * @example
     * // Update one OffersSpecificYoe
     * const offersSpecificYoe = await prisma.offersSpecificYoe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OffersSpecificYoeUpdateArgs>(
      args: SelectSubset<T, OffersSpecificYoeUpdateArgs>
    ): CheckSelect<T, Prisma__OffersSpecificYoeClient<OffersSpecificYoe>, Prisma__OffersSpecificYoeClient<OffersSpecificYoeGetPayload<T>>>

    /**
     * Delete zero or more OffersSpecificYoes.
     * @param {OffersSpecificYoeDeleteManyArgs} args - Arguments to filter OffersSpecificYoes to delete.
     * @example
     * // Delete a few OffersSpecificYoes
     * const { count } = await prisma.offersSpecificYoe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OffersSpecificYoeDeleteManyArgs>(
      args?: SelectSubset<T, OffersSpecificYoeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more OffersSpecificYoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersSpecificYoeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OffersSpecificYoes
     * const offersSpecificYoe = await prisma.offersSpecificYoe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OffersSpecificYoeUpdateManyArgs>(
      args: SelectSubset<T, OffersSpecificYoeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one OffersSpecificYoe.
     * @param {OffersSpecificYoeUpsertArgs} args - Arguments to update or create a OffersSpecificYoe.
     * @example
     * // Update or create a OffersSpecificYoe
     * const offersSpecificYoe = await prisma.offersSpecificYoe.upsert({
     *   create: {
     *     // ... data to create a OffersSpecificYoe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OffersSpecificYoe we want to update
     *   }
     * })
    **/
    upsert<T extends OffersSpecificYoeUpsertArgs>(
      args: SelectSubset<T, OffersSpecificYoeUpsertArgs>
    ): CheckSelect<T, Prisma__OffersSpecificYoeClient<OffersSpecificYoe>, Prisma__OffersSpecificYoeClient<OffersSpecificYoeGetPayload<T>>>

    /**
     * Find one OffersSpecificYoe that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {OffersSpecificYoeFindUniqueOrThrowArgs} args - Arguments to find a OffersSpecificYoe
     * @example
     * // Get one OffersSpecificYoe
     * const offersSpecificYoe = await prisma.offersSpecificYoe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OffersSpecificYoeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OffersSpecificYoeFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__OffersSpecificYoeClient<OffersSpecificYoe>, Prisma__OffersSpecificYoeClient<OffersSpecificYoeGetPayload<T>>>

    /**
     * Find the first OffersSpecificYoe that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersSpecificYoeFindFirstOrThrowArgs} args - Arguments to find a OffersSpecificYoe
     * @example
     * // Get one OffersSpecificYoe
     * const offersSpecificYoe = await prisma.offersSpecificYoe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OffersSpecificYoeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OffersSpecificYoeFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__OffersSpecificYoeClient<OffersSpecificYoe>, Prisma__OffersSpecificYoeClient<OffersSpecificYoeGetPayload<T>>>

    /**
     * Count the number of OffersSpecificYoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersSpecificYoeCountArgs} args - Arguments to filter OffersSpecificYoes to count.
     * @example
     * // Count the number of OffersSpecificYoes
     * const count = await prisma.offersSpecificYoe.count({
     *   where: {
     *     // ... the filter for the OffersSpecificYoes we want to count
     *   }
     * })
    **/
    count<T extends OffersSpecificYoeCountArgs>(
      args?: Subset<T, OffersSpecificYoeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OffersSpecificYoeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OffersSpecificYoe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersSpecificYoeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OffersSpecificYoeAggregateArgs>(args: Subset<T, OffersSpecificYoeAggregateArgs>): PrismaPromise<GetOffersSpecificYoeAggregateType<T>>

    /**
     * Group by OffersSpecificYoe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersSpecificYoeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OffersSpecificYoeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OffersSpecificYoeGroupByArgs['orderBy'] }
        : { orderBy?: OffersSpecificYoeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OffersSpecificYoeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOffersSpecificYoeGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for OffersSpecificYoe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OffersSpecificYoeClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    background<T extends OffersBackgroundArgs = {}>(args?: Subset<T, OffersBackgroundArgs>): CheckSelect<T, Prisma__OffersBackgroundClient<OffersBackground | Null>, Prisma__OffersBackgroundClient<OffersBackgroundGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * OffersSpecificYoe base type for findUnique actions
   */
  export type OffersSpecificYoeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the OffersSpecificYoe
     * 
    **/
    select?: OffersSpecificYoeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersSpecificYoeInclude | null
    /**
     * Filter, which OffersSpecificYoe to fetch.
     * 
    **/
    where: OffersSpecificYoeWhereUniqueInput
  }

  /**
   * OffersSpecificYoe: findUnique
   */
  export interface OffersSpecificYoeFindUniqueArgs extends OffersSpecificYoeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OffersSpecificYoe base type for findFirst actions
   */
  export type OffersSpecificYoeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the OffersSpecificYoe
     * 
    **/
    select?: OffersSpecificYoeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersSpecificYoeInclude | null
    /**
     * Filter, which OffersSpecificYoe to fetch.
     * 
    **/
    where?: OffersSpecificYoeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffersSpecificYoes to fetch.
     * 
    **/
    orderBy?: Enumerable<OffersSpecificYoeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OffersSpecificYoes.
     * 
    **/
    cursor?: OffersSpecificYoeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffersSpecificYoes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffersSpecificYoes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OffersSpecificYoes.
     * 
    **/
    distinct?: Enumerable<OffersSpecificYoeScalarFieldEnum>
  }

  /**
   * OffersSpecificYoe: findFirst
   */
  export interface OffersSpecificYoeFindFirstArgs extends OffersSpecificYoeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OffersSpecificYoe findMany
   */
  export type OffersSpecificYoeFindManyArgs = {
    /**
     * Select specific fields to fetch from the OffersSpecificYoe
     * 
    **/
    select?: OffersSpecificYoeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersSpecificYoeInclude | null
    /**
     * Filter, which OffersSpecificYoes to fetch.
     * 
    **/
    where?: OffersSpecificYoeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffersSpecificYoes to fetch.
     * 
    **/
    orderBy?: Enumerable<OffersSpecificYoeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OffersSpecificYoes.
     * 
    **/
    cursor?: OffersSpecificYoeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffersSpecificYoes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffersSpecificYoes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OffersSpecificYoeScalarFieldEnum>
  }


  /**
   * OffersSpecificYoe create
   */
  export type OffersSpecificYoeCreateArgs = {
    /**
     * Select specific fields to fetch from the OffersSpecificYoe
     * 
    **/
    select?: OffersSpecificYoeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersSpecificYoeInclude | null
    /**
     * The data needed to create a OffersSpecificYoe.
     * 
    **/
    data: XOR<OffersSpecificYoeCreateInput, OffersSpecificYoeUncheckedCreateInput>
  }


  /**
   * OffersSpecificYoe createMany
   */
  export type OffersSpecificYoeCreateManyArgs = {
    /**
     * The data used to create many OffersSpecificYoes.
     * 
    **/
    data: Enumerable<OffersSpecificYoeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OffersSpecificYoe update
   */
  export type OffersSpecificYoeUpdateArgs = {
    /**
     * Select specific fields to fetch from the OffersSpecificYoe
     * 
    **/
    select?: OffersSpecificYoeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersSpecificYoeInclude | null
    /**
     * The data needed to update a OffersSpecificYoe.
     * 
    **/
    data: XOR<OffersSpecificYoeUpdateInput, OffersSpecificYoeUncheckedUpdateInput>
    /**
     * Choose, which OffersSpecificYoe to update.
     * 
    **/
    where: OffersSpecificYoeWhereUniqueInput
  }


  /**
   * OffersSpecificYoe updateMany
   */
  export type OffersSpecificYoeUpdateManyArgs = {
    /**
     * The data used to update OffersSpecificYoes.
     * 
    **/
    data: XOR<OffersSpecificYoeUpdateManyMutationInput, OffersSpecificYoeUncheckedUpdateManyInput>
    /**
     * Filter which OffersSpecificYoes to update
     * 
    **/
    where?: OffersSpecificYoeWhereInput
  }


  /**
   * OffersSpecificYoe upsert
   */
  export type OffersSpecificYoeUpsertArgs = {
    /**
     * Select specific fields to fetch from the OffersSpecificYoe
     * 
    **/
    select?: OffersSpecificYoeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersSpecificYoeInclude | null
    /**
     * The filter to search for the OffersSpecificYoe to update in case it exists.
     * 
    **/
    where: OffersSpecificYoeWhereUniqueInput
    /**
     * In case the OffersSpecificYoe found by the `where` argument doesn't exist, create a new OffersSpecificYoe with this data.
     * 
    **/
    create: XOR<OffersSpecificYoeCreateInput, OffersSpecificYoeUncheckedCreateInput>
    /**
     * In case the OffersSpecificYoe was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OffersSpecificYoeUpdateInput, OffersSpecificYoeUncheckedUpdateInput>
  }


  /**
   * OffersSpecificYoe delete
   */
  export type OffersSpecificYoeDeleteArgs = {
    /**
     * Select specific fields to fetch from the OffersSpecificYoe
     * 
    **/
    select?: OffersSpecificYoeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersSpecificYoeInclude | null
    /**
     * Filter which OffersSpecificYoe to delete.
     * 
    **/
    where: OffersSpecificYoeWhereUniqueInput
  }


  /**
   * OffersSpecificYoe deleteMany
   */
  export type OffersSpecificYoeDeleteManyArgs = {
    /**
     * Filter which OffersSpecificYoes to delete
     * 
    **/
    where?: OffersSpecificYoeWhereInput
  }


  /**
   * OffersSpecificYoe: findUniqueOrThrow
   */
  export type OffersSpecificYoeFindUniqueOrThrowArgs = OffersSpecificYoeFindUniqueArgsBase
      

  /**
   * OffersSpecificYoe: findFirstOrThrow
   */
  export type OffersSpecificYoeFindFirstOrThrowArgs = OffersSpecificYoeFindFirstArgsBase
      

  /**
   * OffersSpecificYoe without action
   */
  export type OffersSpecificYoeArgs = {
    /**
     * Select specific fields to fetch from the OffersSpecificYoe
     * 
    **/
    select?: OffersSpecificYoeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersSpecificYoeInclude | null
  }



  /**
   * Model OffersExperience
   */


  export type AggregateOffersExperience = {
    _count: OffersExperienceCountAggregateOutputType | null
    _avg: OffersExperienceAvgAggregateOutputType | null
    _sum: OffersExperienceSumAggregateOutputType | null
    _min: OffersExperienceMinAggregateOutputType | null
    _max: OffersExperienceMaxAggregateOutputType | null
  }

  export type OffersExperienceAvgAggregateOutputType = {
    durationInMonths: number | null
  }

  export type OffersExperienceSumAggregateOutputType = {
    durationInMonths: number | null
  }

  export type OffersExperienceMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    jobType: JobType | null
    title: string | null
    durationInMonths: number | null
    cityId: string | null
    level: string | null
    totalCompensationId: string | null
    monthlySalaryId: string | null
    backgroundId: string | null
  }

  export type OffersExperienceMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    jobType: JobType | null
    title: string | null
    durationInMonths: number | null
    cityId: string | null
    level: string | null
    totalCompensationId: string | null
    monthlySalaryId: string | null
    backgroundId: string | null
  }

  export type OffersExperienceCountAggregateOutputType = {
    id: number
    companyId: number
    jobType: number
    title: number
    durationInMonths: number
    cityId: number
    level: number
    totalCompensationId: number
    monthlySalaryId: number
    backgroundId: number
    _all: number
  }


  export type OffersExperienceAvgAggregateInputType = {
    durationInMonths?: true
  }

  export type OffersExperienceSumAggregateInputType = {
    durationInMonths?: true
  }

  export type OffersExperienceMinAggregateInputType = {
    id?: true
    companyId?: true
    jobType?: true
    title?: true
    durationInMonths?: true
    cityId?: true
    level?: true
    totalCompensationId?: true
    monthlySalaryId?: true
    backgroundId?: true
  }

  export type OffersExperienceMaxAggregateInputType = {
    id?: true
    companyId?: true
    jobType?: true
    title?: true
    durationInMonths?: true
    cityId?: true
    level?: true
    totalCompensationId?: true
    monthlySalaryId?: true
    backgroundId?: true
  }

  export type OffersExperienceCountAggregateInputType = {
    id?: true
    companyId?: true
    jobType?: true
    title?: true
    durationInMonths?: true
    cityId?: true
    level?: true
    totalCompensationId?: true
    monthlySalaryId?: true
    backgroundId?: true
    _all?: true
  }

  export type OffersExperienceAggregateArgs = {
    /**
     * Filter which OffersExperience to aggregate.
     * 
    **/
    where?: OffersExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffersExperiences to fetch.
     * 
    **/
    orderBy?: Enumerable<OffersExperienceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OffersExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffersExperiences from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffersExperiences.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OffersExperiences
    **/
    _count?: true | OffersExperienceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OffersExperienceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OffersExperienceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OffersExperienceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OffersExperienceMaxAggregateInputType
  }

  export type GetOffersExperienceAggregateType<T extends OffersExperienceAggregateArgs> = {
        [P in keyof T & keyof AggregateOffersExperience]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOffersExperience[P]>
      : GetScalarType<T[P], AggregateOffersExperience[P]>
  }




  export type OffersExperienceGroupByArgs = {
    where?: OffersExperienceWhereInput
    orderBy?: Enumerable<OffersExperienceOrderByWithAggregationInput>
    by: Array<OffersExperienceScalarFieldEnum>
    having?: OffersExperienceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OffersExperienceCountAggregateInputType | true
    _avg?: OffersExperienceAvgAggregateInputType
    _sum?: OffersExperienceSumAggregateInputType
    _min?: OffersExperienceMinAggregateInputType
    _max?: OffersExperienceMaxAggregateInputType
  }


  export type OffersExperienceGroupByOutputType = {
    id: string
    companyId: string | null
    jobType: JobType | null
    title: string | null
    durationInMonths: number | null
    cityId: string | null
    level: string | null
    totalCompensationId: string | null
    monthlySalaryId: string | null
    backgroundId: string
    _count: OffersExperienceCountAggregateOutputType | null
    _avg: OffersExperienceAvgAggregateOutputType | null
    _sum: OffersExperienceSumAggregateOutputType | null
    _min: OffersExperienceMinAggregateOutputType | null
    _max: OffersExperienceMaxAggregateOutputType | null
  }

  type GetOffersExperienceGroupByPayload<T extends OffersExperienceGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OffersExperienceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OffersExperienceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OffersExperienceGroupByOutputType[P]>
            : GetScalarType<T[P], OffersExperienceGroupByOutputType[P]>
        }
      >
    >


  export type OffersExperienceSelect = {
    id?: boolean
    company?: boolean | CompanyArgs
    companyId?: boolean
    jobType?: boolean
    title?: boolean
    durationInMonths?: boolean
    location?: boolean | CityArgs
    cityId?: boolean
    level?: boolean
    totalCompensation?: boolean | OffersCurrencyArgs
    totalCompensationId?: boolean
    monthlySalary?: boolean | OffersCurrencyArgs
    monthlySalaryId?: boolean
    background?: boolean | OffersBackgroundArgs
    backgroundId?: boolean
  }

  export type OffersExperienceInclude = {
    company?: boolean | CompanyArgs
    location?: boolean | CityArgs
    totalCompensation?: boolean | OffersCurrencyArgs
    monthlySalary?: boolean | OffersCurrencyArgs
    background?: boolean | OffersBackgroundArgs
  }

  export type OffersExperienceGetPayload<
    S extends boolean | null | undefined | OffersExperienceArgs,
    U = keyof S
      > = S extends true
        ? OffersExperience
    : S extends undefined
    ? never
    : S extends OffersExperienceArgs | OffersExperienceFindManyArgs
    ?'include' extends U
    ? OffersExperience  & {
    [P in TrueKeys<S['include']>]:
        P extends 'company' ? CompanyGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'location' ? CityGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'totalCompensation' ? OffersCurrencyGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'monthlySalary' ? OffersCurrencyGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'background' ? OffersBackgroundGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'company' ? CompanyGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'location' ? CityGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'totalCompensation' ? OffersCurrencyGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'monthlySalary' ? OffersCurrencyGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'background' ? OffersBackgroundGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof OffersExperience ? OffersExperience[P] : never
  } 
    : OffersExperience
  : OffersExperience


  type OffersExperienceCountArgs = Merge<
    Omit<OffersExperienceFindManyArgs, 'select' | 'include'> & {
      select?: OffersExperienceCountAggregateInputType | true
    }
  >

  export interface OffersExperienceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one OffersExperience that matches the filter.
     * @param {OffersExperienceFindUniqueArgs} args - Arguments to find a OffersExperience
     * @example
     * // Get one OffersExperience
     * const offersExperience = await prisma.offersExperience.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OffersExperienceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OffersExperienceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OffersExperience'> extends True ? CheckSelect<T, Prisma__OffersExperienceClient<OffersExperience>, Prisma__OffersExperienceClient<OffersExperienceGetPayload<T>>> : CheckSelect<T, Prisma__OffersExperienceClient<OffersExperience | null, null>, Prisma__OffersExperienceClient<OffersExperienceGetPayload<T> | null, null>>

    /**
     * Find the first OffersExperience that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersExperienceFindFirstArgs} args - Arguments to find a OffersExperience
     * @example
     * // Get one OffersExperience
     * const offersExperience = await prisma.offersExperience.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OffersExperienceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OffersExperienceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OffersExperience'> extends True ? CheckSelect<T, Prisma__OffersExperienceClient<OffersExperience>, Prisma__OffersExperienceClient<OffersExperienceGetPayload<T>>> : CheckSelect<T, Prisma__OffersExperienceClient<OffersExperience | null, null>, Prisma__OffersExperienceClient<OffersExperienceGetPayload<T> | null, null>>

    /**
     * Find zero or more OffersExperiences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersExperienceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OffersExperiences
     * const offersExperiences = await prisma.offersExperience.findMany()
     * 
     * // Get first 10 OffersExperiences
     * const offersExperiences = await prisma.offersExperience.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offersExperienceWithIdOnly = await prisma.offersExperience.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OffersExperienceFindManyArgs>(
      args?: SelectSubset<T, OffersExperienceFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<OffersExperience>>, PrismaPromise<Array<OffersExperienceGetPayload<T>>>>

    /**
     * Create a OffersExperience.
     * @param {OffersExperienceCreateArgs} args - Arguments to create a OffersExperience.
     * @example
     * // Create one OffersExperience
     * const OffersExperience = await prisma.offersExperience.create({
     *   data: {
     *     // ... data to create a OffersExperience
     *   }
     * })
     * 
    **/
    create<T extends OffersExperienceCreateArgs>(
      args: SelectSubset<T, OffersExperienceCreateArgs>
    ): CheckSelect<T, Prisma__OffersExperienceClient<OffersExperience>, Prisma__OffersExperienceClient<OffersExperienceGetPayload<T>>>

    /**
     * Create many OffersExperiences.
     *     @param {OffersExperienceCreateManyArgs} args - Arguments to create many OffersExperiences.
     *     @example
     *     // Create many OffersExperiences
     *     const offersExperience = await prisma.offersExperience.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OffersExperienceCreateManyArgs>(
      args?: SelectSubset<T, OffersExperienceCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a OffersExperience.
     * @param {OffersExperienceDeleteArgs} args - Arguments to delete one OffersExperience.
     * @example
     * // Delete one OffersExperience
     * const OffersExperience = await prisma.offersExperience.delete({
     *   where: {
     *     // ... filter to delete one OffersExperience
     *   }
     * })
     * 
    **/
    delete<T extends OffersExperienceDeleteArgs>(
      args: SelectSubset<T, OffersExperienceDeleteArgs>
    ): CheckSelect<T, Prisma__OffersExperienceClient<OffersExperience>, Prisma__OffersExperienceClient<OffersExperienceGetPayload<T>>>

    /**
     * Update one OffersExperience.
     * @param {OffersExperienceUpdateArgs} args - Arguments to update one OffersExperience.
     * @example
     * // Update one OffersExperience
     * const offersExperience = await prisma.offersExperience.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OffersExperienceUpdateArgs>(
      args: SelectSubset<T, OffersExperienceUpdateArgs>
    ): CheckSelect<T, Prisma__OffersExperienceClient<OffersExperience>, Prisma__OffersExperienceClient<OffersExperienceGetPayload<T>>>

    /**
     * Delete zero or more OffersExperiences.
     * @param {OffersExperienceDeleteManyArgs} args - Arguments to filter OffersExperiences to delete.
     * @example
     * // Delete a few OffersExperiences
     * const { count } = await prisma.offersExperience.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OffersExperienceDeleteManyArgs>(
      args?: SelectSubset<T, OffersExperienceDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more OffersExperiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersExperienceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OffersExperiences
     * const offersExperience = await prisma.offersExperience.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OffersExperienceUpdateManyArgs>(
      args: SelectSubset<T, OffersExperienceUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one OffersExperience.
     * @param {OffersExperienceUpsertArgs} args - Arguments to update or create a OffersExperience.
     * @example
     * // Update or create a OffersExperience
     * const offersExperience = await prisma.offersExperience.upsert({
     *   create: {
     *     // ... data to create a OffersExperience
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OffersExperience we want to update
     *   }
     * })
    **/
    upsert<T extends OffersExperienceUpsertArgs>(
      args: SelectSubset<T, OffersExperienceUpsertArgs>
    ): CheckSelect<T, Prisma__OffersExperienceClient<OffersExperience>, Prisma__OffersExperienceClient<OffersExperienceGetPayload<T>>>

    /**
     * Find one OffersExperience that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {OffersExperienceFindUniqueOrThrowArgs} args - Arguments to find a OffersExperience
     * @example
     * // Get one OffersExperience
     * const offersExperience = await prisma.offersExperience.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OffersExperienceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OffersExperienceFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__OffersExperienceClient<OffersExperience>, Prisma__OffersExperienceClient<OffersExperienceGetPayload<T>>>

    /**
     * Find the first OffersExperience that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersExperienceFindFirstOrThrowArgs} args - Arguments to find a OffersExperience
     * @example
     * // Get one OffersExperience
     * const offersExperience = await prisma.offersExperience.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OffersExperienceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OffersExperienceFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__OffersExperienceClient<OffersExperience>, Prisma__OffersExperienceClient<OffersExperienceGetPayload<T>>>

    /**
     * Count the number of OffersExperiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersExperienceCountArgs} args - Arguments to filter OffersExperiences to count.
     * @example
     * // Count the number of OffersExperiences
     * const count = await prisma.offersExperience.count({
     *   where: {
     *     // ... the filter for the OffersExperiences we want to count
     *   }
     * })
    **/
    count<T extends OffersExperienceCountArgs>(
      args?: Subset<T, OffersExperienceCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OffersExperienceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OffersExperience.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersExperienceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OffersExperienceAggregateArgs>(args: Subset<T, OffersExperienceAggregateArgs>): PrismaPromise<GetOffersExperienceAggregateType<T>>

    /**
     * Group by OffersExperience.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersExperienceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OffersExperienceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OffersExperienceGroupByArgs['orderBy'] }
        : { orderBy?: OffersExperienceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OffersExperienceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOffersExperienceGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for OffersExperience.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OffersExperienceClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    company<T extends CompanyArgs = {}>(args?: Subset<T, CompanyArgs>): CheckSelect<T, Prisma__CompanyClient<Company | Null>, Prisma__CompanyClient<CompanyGetPayload<T> | Null>>;

    location<T extends CityArgs = {}>(args?: Subset<T, CityArgs>): CheckSelect<T, Prisma__CityClient<City | Null>, Prisma__CityClient<CityGetPayload<T> | Null>>;

    totalCompensation<T extends OffersCurrencyArgs = {}>(args?: Subset<T, OffersCurrencyArgs>): CheckSelect<T, Prisma__OffersCurrencyClient<OffersCurrency | Null>, Prisma__OffersCurrencyClient<OffersCurrencyGetPayload<T> | Null>>;

    monthlySalary<T extends OffersCurrencyArgs = {}>(args?: Subset<T, OffersCurrencyArgs>): CheckSelect<T, Prisma__OffersCurrencyClient<OffersCurrency | Null>, Prisma__OffersCurrencyClient<OffersCurrencyGetPayload<T> | Null>>;

    background<T extends OffersBackgroundArgs = {}>(args?: Subset<T, OffersBackgroundArgs>): CheckSelect<T, Prisma__OffersBackgroundClient<OffersBackground | Null>, Prisma__OffersBackgroundClient<OffersBackgroundGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * OffersExperience base type for findUnique actions
   */
  export type OffersExperienceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the OffersExperience
     * 
    **/
    select?: OffersExperienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersExperienceInclude | null
    /**
     * Filter, which OffersExperience to fetch.
     * 
    **/
    where: OffersExperienceWhereUniqueInput
  }

  /**
   * OffersExperience: findUnique
   */
  export interface OffersExperienceFindUniqueArgs extends OffersExperienceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OffersExperience base type for findFirst actions
   */
  export type OffersExperienceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the OffersExperience
     * 
    **/
    select?: OffersExperienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersExperienceInclude | null
    /**
     * Filter, which OffersExperience to fetch.
     * 
    **/
    where?: OffersExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffersExperiences to fetch.
     * 
    **/
    orderBy?: Enumerable<OffersExperienceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OffersExperiences.
     * 
    **/
    cursor?: OffersExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffersExperiences from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffersExperiences.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OffersExperiences.
     * 
    **/
    distinct?: Enumerable<OffersExperienceScalarFieldEnum>
  }

  /**
   * OffersExperience: findFirst
   */
  export interface OffersExperienceFindFirstArgs extends OffersExperienceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OffersExperience findMany
   */
  export type OffersExperienceFindManyArgs = {
    /**
     * Select specific fields to fetch from the OffersExperience
     * 
    **/
    select?: OffersExperienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersExperienceInclude | null
    /**
     * Filter, which OffersExperiences to fetch.
     * 
    **/
    where?: OffersExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffersExperiences to fetch.
     * 
    **/
    orderBy?: Enumerable<OffersExperienceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OffersExperiences.
     * 
    **/
    cursor?: OffersExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffersExperiences from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffersExperiences.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OffersExperienceScalarFieldEnum>
  }


  /**
   * OffersExperience create
   */
  export type OffersExperienceCreateArgs = {
    /**
     * Select specific fields to fetch from the OffersExperience
     * 
    **/
    select?: OffersExperienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersExperienceInclude | null
    /**
     * The data needed to create a OffersExperience.
     * 
    **/
    data: XOR<OffersExperienceCreateInput, OffersExperienceUncheckedCreateInput>
  }


  /**
   * OffersExperience createMany
   */
  export type OffersExperienceCreateManyArgs = {
    /**
     * The data used to create many OffersExperiences.
     * 
    **/
    data: Enumerable<OffersExperienceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OffersExperience update
   */
  export type OffersExperienceUpdateArgs = {
    /**
     * Select specific fields to fetch from the OffersExperience
     * 
    **/
    select?: OffersExperienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersExperienceInclude | null
    /**
     * The data needed to update a OffersExperience.
     * 
    **/
    data: XOR<OffersExperienceUpdateInput, OffersExperienceUncheckedUpdateInput>
    /**
     * Choose, which OffersExperience to update.
     * 
    **/
    where: OffersExperienceWhereUniqueInput
  }


  /**
   * OffersExperience updateMany
   */
  export type OffersExperienceUpdateManyArgs = {
    /**
     * The data used to update OffersExperiences.
     * 
    **/
    data: XOR<OffersExperienceUpdateManyMutationInput, OffersExperienceUncheckedUpdateManyInput>
    /**
     * Filter which OffersExperiences to update
     * 
    **/
    where?: OffersExperienceWhereInput
  }


  /**
   * OffersExperience upsert
   */
  export type OffersExperienceUpsertArgs = {
    /**
     * Select specific fields to fetch from the OffersExperience
     * 
    **/
    select?: OffersExperienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersExperienceInclude | null
    /**
     * The filter to search for the OffersExperience to update in case it exists.
     * 
    **/
    where: OffersExperienceWhereUniqueInput
    /**
     * In case the OffersExperience found by the `where` argument doesn't exist, create a new OffersExperience with this data.
     * 
    **/
    create: XOR<OffersExperienceCreateInput, OffersExperienceUncheckedCreateInput>
    /**
     * In case the OffersExperience was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OffersExperienceUpdateInput, OffersExperienceUncheckedUpdateInput>
  }


  /**
   * OffersExperience delete
   */
  export type OffersExperienceDeleteArgs = {
    /**
     * Select specific fields to fetch from the OffersExperience
     * 
    **/
    select?: OffersExperienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersExperienceInclude | null
    /**
     * Filter which OffersExperience to delete.
     * 
    **/
    where: OffersExperienceWhereUniqueInput
  }


  /**
   * OffersExperience deleteMany
   */
  export type OffersExperienceDeleteManyArgs = {
    /**
     * Filter which OffersExperiences to delete
     * 
    **/
    where?: OffersExperienceWhereInput
  }


  /**
   * OffersExperience: findUniqueOrThrow
   */
  export type OffersExperienceFindUniqueOrThrowArgs = OffersExperienceFindUniqueArgsBase
      

  /**
   * OffersExperience: findFirstOrThrow
   */
  export type OffersExperienceFindFirstOrThrowArgs = OffersExperienceFindFirstArgsBase
      

  /**
   * OffersExperience without action
   */
  export type OffersExperienceArgs = {
    /**
     * Select specific fields to fetch from the OffersExperience
     * 
    **/
    select?: OffersExperienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersExperienceInclude | null
  }



  /**
   * Model OffersCurrency
   */


  export type AggregateOffersCurrency = {
    _count: OffersCurrencyCountAggregateOutputType | null
    _avg: OffersCurrencyAvgAggregateOutputType | null
    _sum: OffersCurrencySumAggregateOutputType | null
    _min: OffersCurrencyMinAggregateOutputType | null
    _max: OffersCurrencyMaxAggregateOutputType | null
  }

  export type OffersCurrencyAvgAggregateOutputType = {
    value: number | null
    baseValue: number | null
  }

  export type OffersCurrencySumAggregateOutputType = {
    value: number | null
    baseValue: number | null
  }

  export type OffersCurrencyMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    value: number | null
    currency: string | null
    baseValue: number | null
    baseCurrency: string | null
  }

  export type OffersCurrencyMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    value: number | null
    currency: string | null
    baseValue: number | null
    baseCurrency: string | null
  }

  export type OffersCurrencyCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    value: number
    currency: number
    baseValue: number
    baseCurrency: number
    _all: number
  }


  export type OffersCurrencyAvgAggregateInputType = {
    value?: true
    baseValue?: true
  }

  export type OffersCurrencySumAggregateInputType = {
    value?: true
    baseValue?: true
  }

  export type OffersCurrencyMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    value?: true
    currency?: true
    baseValue?: true
    baseCurrency?: true
  }

  export type OffersCurrencyMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    value?: true
    currency?: true
    baseValue?: true
    baseCurrency?: true
  }

  export type OffersCurrencyCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    value?: true
    currency?: true
    baseValue?: true
    baseCurrency?: true
    _all?: true
  }

  export type OffersCurrencyAggregateArgs = {
    /**
     * Filter which OffersCurrency to aggregate.
     * 
    **/
    where?: OffersCurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffersCurrencies to fetch.
     * 
    **/
    orderBy?: Enumerable<OffersCurrencyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OffersCurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffersCurrencies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffersCurrencies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OffersCurrencies
    **/
    _count?: true | OffersCurrencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OffersCurrencyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OffersCurrencySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OffersCurrencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OffersCurrencyMaxAggregateInputType
  }

  export type GetOffersCurrencyAggregateType<T extends OffersCurrencyAggregateArgs> = {
        [P in keyof T & keyof AggregateOffersCurrency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOffersCurrency[P]>
      : GetScalarType<T[P], AggregateOffersCurrency[P]>
  }




  export type OffersCurrencyGroupByArgs = {
    where?: OffersCurrencyWhereInput
    orderBy?: Enumerable<OffersCurrencyOrderByWithAggregationInput>
    by: Array<OffersCurrencyScalarFieldEnum>
    having?: OffersCurrencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OffersCurrencyCountAggregateInputType | true
    _avg?: OffersCurrencyAvgAggregateInputType
    _sum?: OffersCurrencySumAggregateInputType
    _min?: OffersCurrencyMinAggregateInputType
    _max?: OffersCurrencyMaxAggregateInputType
  }


  export type OffersCurrencyGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    value: number
    currency: string
    baseValue: number
    baseCurrency: string
    _count: OffersCurrencyCountAggregateOutputType | null
    _avg: OffersCurrencyAvgAggregateOutputType | null
    _sum: OffersCurrencySumAggregateOutputType | null
    _min: OffersCurrencyMinAggregateOutputType | null
    _max: OffersCurrencyMaxAggregateOutputType | null
  }

  type GetOffersCurrencyGroupByPayload<T extends OffersCurrencyGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OffersCurrencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OffersCurrencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OffersCurrencyGroupByOutputType[P]>
            : GetScalarType<T[P], OffersCurrencyGroupByOutputType[P]>
        }
      >
    >


  export type OffersCurrencySelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    value?: boolean
    currency?: boolean
    baseValue?: boolean
    baseCurrency?: boolean
    OffersExperienceTotalCompensation?: boolean | OffersExperienceArgs
    OffersExperienceMonthlySalary?: boolean | OffersExperienceArgs
    OffersTotalCompensation?: boolean | OffersFullTimeArgs
    OffersBaseSalary?: boolean | OffersFullTimeArgs
    OffersBonus?: boolean | OffersFullTimeArgs
    OffersStocks?: boolean | OffersFullTimeArgs
    OffersMonthlySalary?: boolean | OffersInternArgs
  }

  export type OffersCurrencyInclude = {
    OffersExperienceTotalCompensation?: boolean | OffersExperienceArgs
    OffersExperienceMonthlySalary?: boolean | OffersExperienceArgs
    OffersTotalCompensation?: boolean | OffersFullTimeArgs
    OffersBaseSalary?: boolean | OffersFullTimeArgs
    OffersBonus?: boolean | OffersFullTimeArgs
    OffersStocks?: boolean | OffersFullTimeArgs
    OffersMonthlySalary?: boolean | OffersInternArgs
  }

  export type OffersCurrencyGetPayload<
    S extends boolean | null | undefined | OffersCurrencyArgs,
    U = keyof S
      > = S extends true
        ? OffersCurrency
    : S extends undefined
    ? never
    : S extends OffersCurrencyArgs | OffersCurrencyFindManyArgs
    ?'include' extends U
    ? OffersCurrency  & {
    [P in TrueKeys<S['include']>]:
        P extends 'OffersExperienceTotalCompensation' ? OffersExperienceGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'OffersExperienceMonthlySalary' ? OffersExperienceGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'OffersTotalCompensation' ? OffersFullTimeGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'OffersBaseSalary' ? OffersFullTimeGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'OffersBonus' ? OffersFullTimeGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'OffersStocks' ? OffersFullTimeGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'OffersMonthlySalary' ? OffersInternGetPayload<Exclude<S['include'], undefined | null>[P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'OffersExperienceTotalCompensation' ? OffersExperienceGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'OffersExperienceMonthlySalary' ? OffersExperienceGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'OffersTotalCompensation' ? OffersFullTimeGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'OffersBaseSalary' ? OffersFullTimeGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'OffersBonus' ? OffersFullTimeGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'OffersStocks' ? OffersFullTimeGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'OffersMonthlySalary' ? OffersInternGetPayload<Exclude<S['select'], undefined | null>[P]> | null :  P extends keyof OffersCurrency ? OffersCurrency[P] : never
  } 
    : OffersCurrency
  : OffersCurrency


  type OffersCurrencyCountArgs = Merge<
    Omit<OffersCurrencyFindManyArgs, 'select' | 'include'> & {
      select?: OffersCurrencyCountAggregateInputType | true
    }
  >

  export interface OffersCurrencyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one OffersCurrency that matches the filter.
     * @param {OffersCurrencyFindUniqueArgs} args - Arguments to find a OffersCurrency
     * @example
     * // Get one OffersCurrency
     * const offersCurrency = await prisma.offersCurrency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OffersCurrencyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OffersCurrencyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OffersCurrency'> extends True ? CheckSelect<T, Prisma__OffersCurrencyClient<OffersCurrency>, Prisma__OffersCurrencyClient<OffersCurrencyGetPayload<T>>> : CheckSelect<T, Prisma__OffersCurrencyClient<OffersCurrency | null, null>, Prisma__OffersCurrencyClient<OffersCurrencyGetPayload<T> | null, null>>

    /**
     * Find the first OffersCurrency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersCurrencyFindFirstArgs} args - Arguments to find a OffersCurrency
     * @example
     * // Get one OffersCurrency
     * const offersCurrency = await prisma.offersCurrency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OffersCurrencyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OffersCurrencyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OffersCurrency'> extends True ? CheckSelect<T, Prisma__OffersCurrencyClient<OffersCurrency>, Prisma__OffersCurrencyClient<OffersCurrencyGetPayload<T>>> : CheckSelect<T, Prisma__OffersCurrencyClient<OffersCurrency | null, null>, Prisma__OffersCurrencyClient<OffersCurrencyGetPayload<T> | null, null>>

    /**
     * Find zero or more OffersCurrencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersCurrencyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OffersCurrencies
     * const offersCurrencies = await prisma.offersCurrency.findMany()
     * 
     * // Get first 10 OffersCurrencies
     * const offersCurrencies = await prisma.offersCurrency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offersCurrencyWithIdOnly = await prisma.offersCurrency.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OffersCurrencyFindManyArgs>(
      args?: SelectSubset<T, OffersCurrencyFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<OffersCurrency>>, PrismaPromise<Array<OffersCurrencyGetPayload<T>>>>

    /**
     * Create a OffersCurrency.
     * @param {OffersCurrencyCreateArgs} args - Arguments to create a OffersCurrency.
     * @example
     * // Create one OffersCurrency
     * const OffersCurrency = await prisma.offersCurrency.create({
     *   data: {
     *     // ... data to create a OffersCurrency
     *   }
     * })
     * 
    **/
    create<T extends OffersCurrencyCreateArgs>(
      args: SelectSubset<T, OffersCurrencyCreateArgs>
    ): CheckSelect<T, Prisma__OffersCurrencyClient<OffersCurrency>, Prisma__OffersCurrencyClient<OffersCurrencyGetPayload<T>>>

    /**
     * Create many OffersCurrencies.
     *     @param {OffersCurrencyCreateManyArgs} args - Arguments to create many OffersCurrencies.
     *     @example
     *     // Create many OffersCurrencies
     *     const offersCurrency = await prisma.offersCurrency.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OffersCurrencyCreateManyArgs>(
      args?: SelectSubset<T, OffersCurrencyCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a OffersCurrency.
     * @param {OffersCurrencyDeleteArgs} args - Arguments to delete one OffersCurrency.
     * @example
     * // Delete one OffersCurrency
     * const OffersCurrency = await prisma.offersCurrency.delete({
     *   where: {
     *     // ... filter to delete one OffersCurrency
     *   }
     * })
     * 
    **/
    delete<T extends OffersCurrencyDeleteArgs>(
      args: SelectSubset<T, OffersCurrencyDeleteArgs>
    ): CheckSelect<T, Prisma__OffersCurrencyClient<OffersCurrency>, Prisma__OffersCurrencyClient<OffersCurrencyGetPayload<T>>>

    /**
     * Update one OffersCurrency.
     * @param {OffersCurrencyUpdateArgs} args - Arguments to update one OffersCurrency.
     * @example
     * // Update one OffersCurrency
     * const offersCurrency = await prisma.offersCurrency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OffersCurrencyUpdateArgs>(
      args: SelectSubset<T, OffersCurrencyUpdateArgs>
    ): CheckSelect<T, Prisma__OffersCurrencyClient<OffersCurrency>, Prisma__OffersCurrencyClient<OffersCurrencyGetPayload<T>>>

    /**
     * Delete zero or more OffersCurrencies.
     * @param {OffersCurrencyDeleteManyArgs} args - Arguments to filter OffersCurrencies to delete.
     * @example
     * // Delete a few OffersCurrencies
     * const { count } = await prisma.offersCurrency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OffersCurrencyDeleteManyArgs>(
      args?: SelectSubset<T, OffersCurrencyDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more OffersCurrencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersCurrencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OffersCurrencies
     * const offersCurrency = await prisma.offersCurrency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OffersCurrencyUpdateManyArgs>(
      args: SelectSubset<T, OffersCurrencyUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one OffersCurrency.
     * @param {OffersCurrencyUpsertArgs} args - Arguments to update or create a OffersCurrency.
     * @example
     * // Update or create a OffersCurrency
     * const offersCurrency = await prisma.offersCurrency.upsert({
     *   create: {
     *     // ... data to create a OffersCurrency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OffersCurrency we want to update
     *   }
     * })
    **/
    upsert<T extends OffersCurrencyUpsertArgs>(
      args: SelectSubset<T, OffersCurrencyUpsertArgs>
    ): CheckSelect<T, Prisma__OffersCurrencyClient<OffersCurrency>, Prisma__OffersCurrencyClient<OffersCurrencyGetPayload<T>>>

    /**
     * Find one OffersCurrency that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {OffersCurrencyFindUniqueOrThrowArgs} args - Arguments to find a OffersCurrency
     * @example
     * // Get one OffersCurrency
     * const offersCurrency = await prisma.offersCurrency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OffersCurrencyFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OffersCurrencyFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__OffersCurrencyClient<OffersCurrency>, Prisma__OffersCurrencyClient<OffersCurrencyGetPayload<T>>>

    /**
     * Find the first OffersCurrency that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersCurrencyFindFirstOrThrowArgs} args - Arguments to find a OffersCurrency
     * @example
     * // Get one OffersCurrency
     * const offersCurrency = await prisma.offersCurrency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OffersCurrencyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OffersCurrencyFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__OffersCurrencyClient<OffersCurrency>, Prisma__OffersCurrencyClient<OffersCurrencyGetPayload<T>>>

    /**
     * Count the number of OffersCurrencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersCurrencyCountArgs} args - Arguments to filter OffersCurrencies to count.
     * @example
     * // Count the number of OffersCurrencies
     * const count = await prisma.offersCurrency.count({
     *   where: {
     *     // ... the filter for the OffersCurrencies we want to count
     *   }
     * })
    **/
    count<T extends OffersCurrencyCountArgs>(
      args?: Subset<T, OffersCurrencyCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OffersCurrencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OffersCurrency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersCurrencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OffersCurrencyAggregateArgs>(args: Subset<T, OffersCurrencyAggregateArgs>): PrismaPromise<GetOffersCurrencyAggregateType<T>>

    /**
     * Group by OffersCurrency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersCurrencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OffersCurrencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OffersCurrencyGroupByArgs['orderBy'] }
        : { orderBy?: OffersCurrencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OffersCurrencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOffersCurrencyGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for OffersCurrency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OffersCurrencyClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    OffersExperienceTotalCompensation<T extends OffersExperienceArgs = {}>(args?: Subset<T, OffersExperienceArgs>): CheckSelect<T, Prisma__OffersExperienceClient<OffersExperience | Null>, Prisma__OffersExperienceClient<OffersExperienceGetPayload<T> | Null>>;

    OffersExperienceMonthlySalary<T extends OffersExperienceArgs = {}>(args?: Subset<T, OffersExperienceArgs>): CheckSelect<T, Prisma__OffersExperienceClient<OffersExperience | Null>, Prisma__OffersExperienceClient<OffersExperienceGetPayload<T> | Null>>;

    OffersTotalCompensation<T extends OffersFullTimeArgs = {}>(args?: Subset<T, OffersFullTimeArgs>): CheckSelect<T, Prisma__OffersFullTimeClient<OffersFullTime | Null>, Prisma__OffersFullTimeClient<OffersFullTimeGetPayload<T> | Null>>;

    OffersBaseSalary<T extends OffersFullTimeArgs = {}>(args?: Subset<T, OffersFullTimeArgs>): CheckSelect<T, Prisma__OffersFullTimeClient<OffersFullTime | Null>, Prisma__OffersFullTimeClient<OffersFullTimeGetPayload<T> | Null>>;

    OffersBonus<T extends OffersFullTimeArgs = {}>(args?: Subset<T, OffersFullTimeArgs>): CheckSelect<T, Prisma__OffersFullTimeClient<OffersFullTime | Null>, Prisma__OffersFullTimeClient<OffersFullTimeGetPayload<T> | Null>>;

    OffersStocks<T extends OffersFullTimeArgs = {}>(args?: Subset<T, OffersFullTimeArgs>): CheckSelect<T, Prisma__OffersFullTimeClient<OffersFullTime | Null>, Prisma__OffersFullTimeClient<OffersFullTimeGetPayload<T> | Null>>;

    OffersMonthlySalary<T extends OffersInternArgs = {}>(args?: Subset<T, OffersInternArgs>): CheckSelect<T, Prisma__OffersInternClient<OffersIntern | Null>, Prisma__OffersInternClient<OffersInternGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * OffersCurrency base type for findUnique actions
   */
  export type OffersCurrencyFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the OffersCurrency
     * 
    **/
    select?: OffersCurrencySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersCurrencyInclude | null
    /**
     * Filter, which OffersCurrency to fetch.
     * 
    **/
    where: OffersCurrencyWhereUniqueInput
  }

  /**
   * OffersCurrency: findUnique
   */
  export interface OffersCurrencyFindUniqueArgs extends OffersCurrencyFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OffersCurrency base type for findFirst actions
   */
  export type OffersCurrencyFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the OffersCurrency
     * 
    **/
    select?: OffersCurrencySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersCurrencyInclude | null
    /**
     * Filter, which OffersCurrency to fetch.
     * 
    **/
    where?: OffersCurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffersCurrencies to fetch.
     * 
    **/
    orderBy?: Enumerable<OffersCurrencyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OffersCurrencies.
     * 
    **/
    cursor?: OffersCurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffersCurrencies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffersCurrencies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OffersCurrencies.
     * 
    **/
    distinct?: Enumerable<OffersCurrencyScalarFieldEnum>
  }

  /**
   * OffersCurrency: findFirst
   */
  export interface OffersCurrencyFindFirstArgs extends OffersCurrencyFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OffersCurrency findMany
   */
  export type OffersCurrencyFindManyArgs = {
    /**
     * Select specific fields to fetch from the OffersCurrency
     * 
    **/
    select?: OffersCurrencySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersCurrencyInclude | null
    /**
     * Filter, which OffersCurrencies to fetch.
     * 
    **/
    where?: OffersCurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffersCurrencies to fetch.
     * 
    **/
    orderBy?: Enumerable<OffersCurrencyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OffersCurrencies.
     * 
    **/
    cursor?: OffersCurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffersCurrencies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffersCurrencies.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OffersCurrencyScalarFieldEnum>
  }


  /**
   * OffersCurrency create
   */
  export type OffersCurrencyCreateArgs = {
    /**
     * Select specific fields to fetch from the OffersCurrency
     * 
    **/
    select?: OffersCurrencySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersCurrencyInclude | null
    /**
     * The data needed to create a OffersCurrency.
     * 
    **/
    data: XOR<OffersCurrencyCreateInput, OffersCurrencyUncheckedCreateInput>
  }


  /**
   * OffersCurrency createMany
   */
  export type OffersCurrencyCreateManyArgs = {
    /**
     * The data used to create many OffersCurrencies.
     * 
    **/
    data: Enumerable<OffersCurrencyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OffersCurrency update
   */
  export type OffersCurrencyUpdateArgs = {
    /**
     * Select specific fields to fetch from the OffersCurrency
     * 
    **/
    select?: OffersCurrencySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersCurrencyInclude | null
    /**
     * The data needed to update a OffersCurrency.
     * 
    **/
    data: XOR<OffersCurrencyUpdateInput, OffersCurrencyUncheckedUpdateInput>
    /**
     * Choose, which OffersCurrency to update.
     * 
    **/
    where: OffersCurrencyWhereUniqueInput
  }


  /**
   * OffersCurrency updateMany
   */
  export type OffersCurrencyUpdateManyArgs = {
    /**
     * The data used to update OffersCurrencies.
     * 
    **/
    data: XOR<OffersCurrencyUpdateManyMutationInput, OffersCurrencyUncheckedUpdateManyInput>
    /**
     * Filter which OffersCurrencies to update
     * 
    **/
    where?: OffersCurrencyWhereInput
  }


  /**
   * OffersCurrency upsert
   */
  export type OffersCurrencyUpsertArgs = {
    /**
     * Select specific fields to fetch from the OffersCurrency
     * 
    **/
    select?: OffersCurrencySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersCurrencyInclude | null
    /**
     * The filter to search for the OffersCurrency to update in case it exists.
     * 
    **/
    where: OffersCurrencyWhereUniqueInput
    /**
     * In case the OffersCurrency found by the `where` argument doesn't exist, create a new OffersCurrency with this data.
     * 
    **/
    create: XOR<OffersCurrencyCreateInput, OffersCurrencyUncheckedCreateInput>
    /**
     * In case the OffersCurrency was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OffersCurrencyUpdateInput, OffersCurrencyUncheckedUpdateInput>
  }


  /**
   * OffersCurrency delete
   */
  export type OffersCurrencyDeleteArgs = {
    /**
     * Select specific fields to fetch from the OffersCurrency
     * 
    **/
    select?: OffersCurrencySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersCurrencyInclude | null
    /**
     * Filter which OffersCurrency to delete.
     * 
    **/
    where: OffersCurrencyWhereUniqueInput
  }


  /**
   * OffersCurrency deleteMany
   */
  export type OffersCurrencyDeleteManyArgs = {
    /**
     * Filter which OffersCurrencies to delete
     * 
    **/
    where?: OffersCurrencyWhereInput
  }


  /**
   * OffersCurrency: findUniqueOrThrow
   */
  export type OffersCurrencyFindUniqueOrThrowArgs = OffersCurrencyFindUniqueArgsBase
      

  /**
   * OffersCurrency: findFirstOrThrow
   */
  export type OffersCurrencyFindFirstOrThrowArgs = OffersCurrencyFindFirstArgsBase
      

  /**
   * OffersCurrency without action
   */
  export type OffersCurrencyArgs = {
    /**
     * Select specific fields to fetch from the OffersCurrency
     * 
    **/
    select?: OffersCurrencySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersCurrencyInclude | null
  }



  /**
   * Model OffersEducation
   */


  export type AggregateOffersEducation = {
    _count: OffersEducationCountAggregateOutputType | null
    _min: OffersEducationMinAggregateOutputType | null
    _max: OffersEducationMaxAggregateOutputType | null
  }

  export type OffersEducationMinAggregateOutputType = {
    id: string | null
    type: string | null
    field: string | null
    school: string | null
    startDate: Date | null
    endDate: Date | null
    backgroundId: string | null
  }

  export type OffersEducationMaxAggregateOutputType = {
    id: string | null
    type: string | null
    field: string | null
    school: string | null
    startDate: Date | null
    endDate: Date | null
    backgroundId: string | null
  }

  export type OffersEducationCountAggregateOutputType = {
    id: number
    type: number
    field: number
    school: number
    startDate: number
    endDate: number
    backgroundId: number
    _all: number
  }


  export type OffersEducationMinAggregateInputType = {
    id?: true
    type?: true
    field?: true
    school?: true
    startDate?: true
    endDate?: true
    backgroundId?: true
  }

  export type OffersEducationMaxAggregateInputType = {
    id?: true
    type?: true
    field?: true
    school?: true
    startDate?: true
    endDate?: true
    backgroundId?: true
  }

  export type OffersEducationCountAggregateInputType = {
    id?: true
    type?: true
    field?: true
    school?: true
    startDate?: true
    endDate?: true
    backgroundId?: true
    _all?: true
  }

  export type OffersEducationAggregateArgs = {
    /**
     * Filter which OffersEducation to aggregate.
     * 
    **/
    where?: OffersEducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffersEducations to fetch.
     * 
    **/
    orderBy?: Enumerable<OffersEducationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OffersEducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffersEducations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffersEducations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OffersEducations
    **/
    _count?: true | OffersEducationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OffersEducationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OffersEducationMaxAggregateInputType
  }

  export type GetOffersEducationAggregateType<T extends OffersEducationAggregateArgs> = {
        [P in keyof T & keyof AggregateOffersEducation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOffersEducation[P]>
      : GetScalarType<T[P], AggregateOffersEducation[P]>
  }




  export type OffersEducationGroupByArgs = {
    where?: OffersEducationWhereInput
    orderBy?: Enumerable<OffersEducationOrderByWithAggregationInput>
    by: Array<OffersEducationScalarFieldEnum>
    having?: OffersEducationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OffersEducationCountAggregateInputType | true
    _min?: OffersEducationMinAggregateInputType
    _max?: OffersEducationMaxAggregateInputType
  }


  export type OffersEducationGroupByOutputType = {
    id: string
    type: string | null
    field: string | null
    school: string | null
    startDate: Date | null
    endDate: Date | null
    backgroundId: string
    _count: OffersEducationCountAggregateOutputType | null
    _min: OffersEducationMinAggregateOutputType | null
    _max: OffersEducationMaxAggregateOutputType | null
  }

  type GetOffersEducationGroupByPayload<T extends OffersEducationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OffersEducationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OffersEducationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OffersEducationGroupByOutputType[P]>
            : GetScalarType<T[P], OffersEducationGroupByOutputType[P]>
        }
      >
    >


  export type OffersEducationSelect = {
    id?: boolean
    type?: boolean
    field?: boolean
    school?: boolean
    startDate?: boolean
    endDate?: boolean
    background?: boolean | OffersBackgroundArgs
    backgroundId?: boolean
  }

  export type OffersEducationInclude = {
    background?: boolean | OffersBackgroundArgs
  }

  export type OffersEducationGetPayload<
    S extends boolean | null | undefined | OffersEducationArgs,
    U = keyof S
      > = S extends true
        ? OffersEducation
    : S extends undefined
    ? never
    : S extends OffersEducationArgs | OffersEducationFindManyArgs
    ?'include' extends U
    ? OffersEducation  & {
    [P in TrueKeys<S['include']>]:
        P extends 'background' ? OffersBackgroundGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'background' ? OffersBackgroundGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof OffersEducation ? OffersEducation[P] : never
  } 
    : OffersEducation
  : OffersEducation


  type OffersEducationCountArgs = Merge<
    Omit<OffersEducationFindManyArgs, 'select' | 'include'> & {
      select?: OffersEducationCountAggregateInputType | true
    }
  >

  export interface OffersEducationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one OffersEducation that matches the filter.
     * @param {OffersEducationFindUniqueArgs} args - Arguments to find a OffersEducation
     * @example
     * // Get one OffersEducation
     * const offersEducation = await prisma.offersEducation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OffersEducationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OffersEducationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OffersEducation'> extends True ? CheckSelect<T, Prisma__OffersEducationClient<OffersEducation>, Prisma__OffersEducationClient<OffersEducationGetPayload<T>>> : CheckSelect<T, Prisma__OffersEducationClient<OffersEducation | null, null>, Prisma__OffersEducationClient<OffersEducationGetPayload<T> | null, null>>

    /**
     * Find the first OffersEducation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersEducationFindFirstArgs} args - Arguments to find a OffersEducation
     * @example
     * // Get one OffersEducation
     * const offersEducation = await prisma.offersEducation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OffersEducationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OffersEducationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OffersEducation'> extends True ? CheckSelect<T, Prisma__OffersEducationClient<OffersEducation>, Prisma__OffersEducationClient<OffersEducationGetPayload<T>>> : CheckSelect<T, Prisma__OffersEducationClient<OffersEducation | null, null>, Prisma__OffersEducationClient<OffersEducationGetPayload<T> | null, null>>

    /**
     * Find zero or more OffersEducations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersEducationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OffersEducations
     * const offersEducations = await prisma.offersEducation.findMany()
     * 
     * // Get first 10 OffersEducations
     * const offersEducations = await prisma.offersEducation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offersEducationWithIdOnly = await prisma.offersEducation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OffersEducationFindManyArgs>(
      args?: SelectSubset<T, OffersEducationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<OffersEducation>>, PrismaPromise<Array<OffersEducationGetPayload<T>>>>

    /**
     * Create a OffersEducation.
     * @param {OffersEducationCreateArgs} args - Arguments to create a OffersEducation.
     * @example
     * // Create one OffersEducation
     * const OffersEducation = await prisma.offersEducation.create({
     *   data: {
     *     // ... data to create a OffersEducation
     *   }
     * })
     * 
    **/
    create<T extends OffersEducationCreateArgs>(
      args: SelectSubset<T, OffersEducationCreateArgs>
    ): CheckSelect<T, Prisma__OffersEducationClient<OffersEducation>, Prisma__OffersEducationClient<OffersEducationGetPayload<T>>>

    /**
     * Create many OffersEducations.
     *     @param {OffersEducationCreateManyArgs} args - Arguments to create many OffersEducations.
     *     @example
     *     // Create many OffersEducations
     *     const offersEducation = await prisma.offersEducation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OffersEducationCreateManyArgs>(
      args?: SelectSubset<T, OffersEducationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a OffersEducation.
     * @param {OffersEducationDeleteArgs} args - Arguments to delete one OffersEducation.
     * @example
     * // Delete one OffersEducation
     * const OffersEducation = await prisma.offersEducation.delete({
     *   where: {
     *     // ... filter to delete one OffersEducation
     *   }
     * })
     * 
    **/
    delete<T extends OffersEducationDeleteArgs>(
      args: SelectSubset<T, OffersEducationDeleteArgs>
    ): CheckSelect<T, Prisma__OffersEducationClient<OffersEducation>, Prisma__OffersEducationClient<OffersEducationGetPayload<T>>>

    /**
     * Update one OffersEducation.
     * @param {OffersEducationUpdateArgs} args - Arguments to update one OffersEducation.
     * @example
     * // Update one OffersEducation
     * const offersEducation = await prisma.offersEducation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OffersEducationUpdateArgs>(
      args: SelectSubset<T, OffersEducationUpdateArgs>
    ): CheckSelect<T, Prisma__OffersEducationClient<OffersEducation>, Prisma__OffersEducationClient<OffersEducationGetPayload<T>>>

    /**
     * Delete zero or more OffersEducations.
     * @param {OffersEducationDeleteManyArgs} args - Arguments to filter OffersEducations to delete.
     * @example
     * // Delete a few OffersEducations
     * const { count } = await prisma.offersEducation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OffersEducationDeleteManyArgs>(
      args?: SelectSubset<T, OffersEducationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more OffersEducations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersEducationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OffersEducations
     * const offersEducation = await prisma.offersEducation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OffersEducationUpdateManyArgs>(
      args: SelectSubset<T, OffersEducationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one OffersEducation.
     * @param {OffersEducationUpsertArgs} args - Arguments to update or create a OffersEducation.
     * @example
     * // Update or create a OffersEducation
     * const offersEducation = await prisma.offersEducation.upsert({
     *   create: {
     *     // ... data to create a OffersEducation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OffersEducation we want to update
     *   }
     * })
    **/
    upsert<T extends OffersEducationUpsertArgs>(
      args: SelectSubset<T, OffersEducationUpsertArgs>
    ): CheckSelect<T, Prisma__OffersEducationClient<OffersEducation>, Prisma__OffersEducationClient<OffersEducationGetPayload<T>>>

    /**
     * Find one OffersEducation that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {OffersEducationFindUniqueOrThrowArgs} args - Arguments to find a OffersEducation
     * @example
     * // Get one OffersEducation
     * const offersEducation = await prisma.offersEducation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OffersEducationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OffersEducationFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__OffersEducationClient<OffersEducation>, Prisma__OffersEducationClient<OffersEducationGetPayload<T>>>

    /**
     * Find the first OffersEducation that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersEducationFindFirstOrThrowArgs} args - Arguments to find a OffersEducation
     * @example
     * // Get one OffersEducation
     * const offersEducation = await prisma.offersEducation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OffersEducationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OffersEducationFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__OffersEducationClient<OffersEducation>, Prisma__OffersEducationClient<OffersEducationGetPayload<T>>>

    /**
     * Count the number of OffersEducations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersEducationCountArgs} args - Arguments to filter OffersEducations to count.
     * @example
     * // Count the number of OffersEducations
     * const count = await prisma.offersEducation.count({
     *   where: {
     *     // ... the filter for the OffersEducations we want to count
     *   }
     * })
    **/
    count<T extends OffersEducationCountArgs>(
      args?: Subset<T, OffersEducationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OffersEducationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OffersEducation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersEducationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OffersEducationAggregateArgs>(args: Subset<T, OffersEducationAggregateArgs>): PrismaPromise<GetOffersEducationAggregateType<T>>

    /**
     * Group by OffersEducation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersEducationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OffersEducationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OffersEducationGroupByArgs['orderBy'] }
        : { orderBy?: OffersEducationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OffersEducationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOffersEducationGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for OffersEducation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OffersEducationClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    background<T extends OffersBackgroundArgs = {}>(args?: Subset<T, OffersBackgroundArgs>): CheckSelect<T, Prisma__OffersBackgroundClient<OffersBackground | Null>, Prisma__OffersBackgroundClient<OffersBackgroundGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * OffersEducation base type for findUnique actions
   */
  export type OffersEducationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the OffersEducation
     * 
    **/
    select?: OffersEducationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersEducationInclude | null
    /**
     * Filter, which OffersEducation to fetch.
     * 
    **/
    where: OffersEducationWhereUniqueInput
  }

  /**
   * OffersEducation: findUnique
   */
  export interface OffersEducationFindUniqueArgs extends OffersEducationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OffersEducation base type for findFirst actions
   */
  export type OffersEducationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the OffersEducation
     * 
    **/
    select?: OffersEducationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersEducationInclude | null
    /**
     * Filter, which OffersEducation to fetch.
     * 
    **/
    where?: OffersEducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffersEducations to fetch.
     * 
    **/
    orderBy?: Enumerable<OffersEducationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OffersEducations.
     * 
    **/
    cursor?: OffersEducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffersEducations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffersEducations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OffersEducations.
     * 
    **/
    distinct?: Enumerable<OffersEducationScalarFieldEnum>
  }

  /**
   * OffersEducation: findFirst
   */
  export interface OffersEducationFindFirstArgs extends OffersEducationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OffersEducation findMany
   */
  export type OffersEducationFindManyArgs = {
    /**
     * Select specific fields to fetch from the OffersEducation
     * 
    **/
    select?: OffersEducationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersEducationInclude | null
    /**
     * Filter, which OffersEducations to fetch.
     * 
    **/
    where?: OffersEducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffersEducations to fetch.
     * 
    **/
    orderBy?: Enumerable<OffersEducationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OffersEducations.
     * 
    **/
    cursor?: OffersEducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffersEducations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffersEducations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OffersEducationScalarFieldEnum>
  }


  /**
   * OffersEducation create
   */
  export type OffersEducationCreateArgs = {
    /**
     * Select specific fields to fetch from the OffersEducation
     * 
    **/
    select?: OffersEducationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersEducationInclude | null
    /**
     * The data needed to create a OffersEducation.
     * 
    **/
    data: XOR<OffersEducationCreateInput, OffersEducationUncheckedCreateInput>
  }


  /**
   * OffersEducation createMany
   */
  export type OffersEducationCreateManyArgs = {
    /**
     * The data used to create many OffersEducations.
     * 
    **/
    data: Enumerable<OffersEducationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OffersEducation update
   */
  export type OffersEducationUpdateArgs = {
    /**
     * Select specific fields to fetch from the OffersEducation
     * 
    **/
    select?: OffersEducationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersEducationInclude | null
    /**
     * The data needed to update a OffersEducation.
     * 
    **/
    data: XOR<OffersEducationUpdateInput, OffersEducationUncheckedUpdateInput>
    /**
     * Choose, which OffersEducation to update.
     * 
    **/
    where: OffersEducationWhereUniqueInput
  }


  /**
   * OffersEducation updateMany
   */
  export type OffersEducationUpdateManyArgs = {
    /**
     * The data used to update OffersEducations.
     * 
    **/
    data: XOR<OffersEducationUpdateManyMutationInput, OffersEducationUncheckedUpdateManyInput>
    /**
     * Filter which OffersEducations to update
     * 
    **/
    where?: OffersEducationWhereInput
  }


  /**
   * OffersEducation upsert
   */
  export type OffersEducationUpsertArgs = {
    /**
     * Select specific fields to fetch from the OffersEducation
     * 
    **/
    select?: OffersEducationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersEducationInclude | null
    /**
     * The filter to search for the OffersEducation to update in case it exists.
     * 
    **/
    where: OffersEducationWhereUniqueInput
    /**
     * In case the OffersEducation found by the `where` argument doesn't exist, create a new OffersEducation with this data.
     * 
    **/
    create: XOR<OffersEducationCreateInput, OffersEducationUncheckedCreateInput>
    /**
     * In case the OffersEducation was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OffersEducationUpdateInput, OffersEducationUncheckedUpdateInput>
  }


  /**
   * OffersEducation delete
   */
  export type OffersEducationDeleteArgs = {
    /**
     * Select specific fields to fetch from the OffersEducation
     * 
    **/
    select?: OffersEducationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersEducationInclude | null
    /**
     * Filter which OffersEducation to delete.
     * 
    **/
    where: OffersEducationWhereUniqueInput
  }


  /**
   * OffersEducation deleteMany
   */
  export type OffersEducationDeleteManyArgs = {
    /**
     * Filter which OffersEducations to delete
     * 
    **/
    where?: OffersEducationWhereInput
  }


  /**
   * OffersEducation: findUniqueOrThrow
   */
  export type OffersEducationFindUniqueOrThrowArgs = OffersEducationFindUniqueArgsBase
      

  /**
   * OffersEducation: findFirstOrThrow
   */
  export type OffersEducationFindFirstOrThrowArgs = OffersEducationFindFirstArgsBase
      

  /**
   * OffersEducation without action
   */
  export type OffersEducationArgs = {
    /**
     * Select specific fields to fetch from the OffersEducation
     * 
    **/
    select?: OffersEducationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersEducationInclude | null
  }



  /**
   * Model OffersReply
   */


  export type AggregateOffersReply = {
    _count: OffersReplyCountAggregateOutputType | null
    _min: OffersReplyMinAggregateOutputType | null
    _max: OffersReplyMaxAggregateOutputType | null
  }

  export type OffersReplyMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    message: string | null
    replyingToId: string | null
    profileId: string | null
    userId: string | null
  }

  export type OffersReplyMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    message: string | null
    replyingToId: string | null
    profileId: string | null
    userId: string | null
  }

  export type OffersReplyCountAggregateOutputType = {
    id: number
    createdAt: number
    message: number
    replyingToId: number
    profileId: number
    userId: number
    _all: number
  }


  export type OffersReplyMinAggregateInputType = {
    id?: true
    createdAt?: true
    message?: true
    replyingToId?: true
    profileId?: true
    userId?: true
  }

  export type OffersReplyMaxAggregateInputType = {
    id?: true
    createdAt?: true
    message?: true
    replyingToId?: true
    profileId?: true
    userId?: true
  }

  export type OffersReplyCountAggregateInputType = {
    id?: true
    createdAt?: true
    message?: true
    replyingToId?: true
    profileId?: true
    userId?: true
    _all?: true
  }

  export type OffersReplyAggregateArgs = {
    /**
     * Filter which OffersReply to aggregate.
     * 
    **/
    where?: OffersReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffersReplies to fetch.
     * 
    **/
    orderBy?: Enumerable<OffersReplyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OffersReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffersReplies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffersReplies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OffersReplies
    **/
    _count?: true | OffersReplyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OffersReplyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OffersReplyMaxAggregateInputType
  }

  export type GetOffersReplyAggregateType<T extends OffersReplyAggregateArgs> = {
        [P in keyof T & keyof AggregateOffersReply]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOffersReply[P]>
      : GetScalarType<T[P], AggregateOffersReply[P]>
  }




  export type OffersReplyGroupByArgs = {
    where?: OffersReplyWhereInput
    orderBy?: Enumerable<OffersReplyOrderByWithAggregationInput>
    by: Array<OffersReplyScalarFieldEnum>
    having?: OffersReplyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OffersReplyCountAggregateInputType | true
    _min?: OffersReplyMinAggregateInputType
    _max?: OffersReplyMaxAggregateInputType
  }


  export type OffersReplyGroupByOutputType = {
    id: string
    createdAt: Date
    message: string
    replyingToId: string | null
    profileId: string
    userId: string | null
    _count: OffersReplyCountAggregateOutputType | null
    _min: OffersReplyMinAggregateOutputType | null
    _max: OffersReplyMaxAggregateOutputType | null
  }

  type GetOffersReplyGroupByPayload<T extends OffersReplyGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OffersReplyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OffersReplyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OffersReplyGroupByOutputType[P]>
            : GetScalarType<T[P], OffersReplyGroupByOutputType[P]>
        }
      >
    >


  export type OffersReplySelect = {
    id?: boolean
    createdAt?: boolean
    message?: boolean
    replyingToId?: boolean
    replyingTo?: boolean | OffersReplyArgs
    replies?: boolean | OffersReplyFindManyArgs
    profile?: boolean | OffersProfileArgs
    profileId?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    _count?: boolean | OffersReplyCountOutputTypeArgs
  }

  export type OffersReplyInclude = {
    replyingTo?: boolean | OffersReplyArgs
    replies?: boolean | OffersReplyFindManyArgs
    profile?: boolean | OffersProfileArgs
    user?: boolean | UserArgs
    _count?: boolean | OffersReplyCountOutputTypeArgs
  }

  export type OffersReplyGetPayload<
    S extends boolean | null | undefined | OffersReplyArgs,
    U = keyof S
      > = S extends true
        ? OffersReply
    : S extends undefined
    ? never
    : S extends OffersReplyArgs | OffersReplyFindManyArgs
    ?'include' extends U
    ? OffersReply  & {
    [P in TrueKeys<S['include']>]:
        P extends 'replyingTo' ? OffersReplyGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'replies' ? Array < OffersReplyGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'profile' ? OffersProfileGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends '_count' ? OffersReplyCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'replyingTo' ? OffersReplyGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'replies' ? Array < OffersReplyGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'profile' ? OffersProfileGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends '_count' ? OffersReplyCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof OffersReply ? OffersReply[P] : never
  } 
    : OffersReply
  : OffersReply


  type OffersReplyCountArgs = Merge<
    Omit<OffersReplyFindManyArgs, 'select' | 'include'> & {
      select?: OffersReplyCountAggregateInputType | true
    }
  >

  export interface OffersReplyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one OffersReply that matches the filter.
     * @param {OffersReplyFindUniqueArgs} args - Arguments to find a OffersReply
     * @example
     * // Get one OffersReply
     * const offersReply = await prisma.offersReply.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OffersReplyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OffersReplyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OffersReply'> extends True ? CheckSelect<T, Prisma__OffersReplyClient<OffersReply>, Prisma__OffersReplyClient<OffersReplyGetPayload<T>>> : CheckSelect<T, Prisma__OffersReplyClient<OffersReply | null, null>, Prisma__OffersReplyClient<OffersReplyGetPayload<T> | null, null>>

    /**
     * Find the first OffersReply that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersReplyFindFirstArgs} args - Arguments to find a OffersReply
     * @example
     * // Get one OffersReply
     * const offersReply = await prisma.offersReply.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OffersReplyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OffersReplyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OffersReply'> extends True ? CheckSelect<T, Prisma__OffersReplyClient<OffersReply>, Prisma__OffersReplyClient<OffersReplyGetPayload<T>>> : CheckSelect<T, Prisma__OffersReplyClient<OffersReply | null, null>, Prisma__OffersReplyClient<OffersReplyGetPayload<T> | null, null>>

    /**
     * Find zero or more OffersReplies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersReplyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OffersReplies
     * const offersReplies = await prisma.offersReply.findMany()
     * 
     * // Get first 10 OffersReplies
     * const offersReplies = await prisma.offersReply.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offersReplyWithIdOnly = await prisma.offersReply.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OffersReplyFindManyArgs>(
      args?: SelectSubset<T, OffersReplyFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<OffersReply>>, PrismaPromise<Array<OffersReplyGetPayload<T>>>>

    /**
     * Create a OffersReply.
     * @param {OffersReplyCreateArgs} args - Arguments to create a OffersReply.
     * @example
     * // Create one OffersReply
     * const OffersReply = await prisma.offersReply.create({
     *   data: {
     *     // ... data to create a OffersReply
     *   }
     * })
     * 
    **/
    create<T extends OffersReplyCreateArgs>(
      args: SelectSubset<T, OffersReplyCreateArgs>
    ): CheckSelect<T, Prisma__OffersReplyClient<OffersReply>, Prisma__OffersReplyClient<OffersReplyGetPayload<T>>>

    /**
     * Create many OffersReplies.
     *     @param {OffersReplyCreateManyArgs} args - Arguments to create many OffersReplies.
     *     @example
     *     // Create many OffersReplies
     *     const offersReply = await prisma.offersReply.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OffersReplyCreateManyArgs>(
      args?: SelectSubset<T, OffersReplyCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a OffersReply.
     * @param {OffersReplyDeleteArgs} args - Arguments to delete one OffersReply.
     * @example
     * // Delete one OffersReply
     * const OffersReply = await prisma.offersReply.delete({
     *   where: {
     *     // ... filter to delete one OffersReply
     *   }
     * })
     * 
    **/
    delete<T extends OffersReplyDeleteArgs>(
      args: SelectSubset<T, OffersReplyDeleteArgs>
    ): CheckSelect<T, Prisma__OffersReplyClient<OffersReply>, Prisma__OffersReplyClient<OffersReplyGetPayload<T>>>

    /**
     * Update one OffersReply.
     * @param {OffersReplyUpdateArgs} args - Arguments to update one OffersReply.
     * @example
     * // Update one OffersReply
     * const offersReply = await prisma.offersReply.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OffersReplyUpdateArgs>(
      args: SelectSubset<T, OffersReplyUpdateArgs>
    ): CheckSelect<T, Prisma__OffersReplyClient<OffersReply>, Prisma__OffersReplyClient<OffersReplyGetPayload<T>>>

    /**
     * Delete zero or more OffersReplies.
     * @param {OffersReplyDeleteManyArgs} args - Arguments to filter OffersReplies to delete.
     * @example
     * // Delete a few OffersReplies
     * const { count } = await prisma.offersReply.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OffersReplyDeleteManyArgs>(
      args?: SelectSubset<T, OffersReplyDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more OffersReplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersReplyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OffersReplies
     * const offersReply = await prisma.offersReply.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OffersReplyUpdateManyArgs>(
      args: SelectSubset<T, OffersReplyUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one OffersReply.
     * @param {OffersReplyUpsertArgs} args - Arguments to update or create a OffersReply.
     * @example
     * // Update or create a OffersReply
     * const offersReply = await prisma.offersReply.upsert({
     *   create: {
     *     // ... data to create a OffersReply
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OffersReply we want to update
     *   }
     * })
    **/
    upsert<T extends OffersReplyUpsertArgs>(
      args: SelectSubset<T, OffersReplyUpsertArgs>
    ): CheckSelect<T, Prisma__OffersReplyClient<OffersReply>, Prisma__OffersReplyClient<OffersReplyGetPayload<T>>>

    /**
     * Find one OffersReply that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {OffersReplyFindUniqueOrThrowArgs} args - Arguments to find a OffersReply
     * @example
     * // Get one OffersReply
     * const offersReply = await prisma.offersReply.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OffersReplyFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OffersReplyFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__OffersReplyClient<OffersReply>, Prisma__OffersReplyClient<OffersReplyGetPayload<T>>>

    /**
     * Find the first OffersReply that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersReplyFindFirstOrThrowArgs} args - Arguments to find a OffersReply
     * @example
     * // Get one OffersReply
     * const offersReply = await prisma.offersReply.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OffersReplyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OffersReplyFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__OffersReplyClient<OffersReply>, Prisma__OffersReplyClient<OffersReplyGetPayload<T>>>

    /**
     * Count the number of OffersReplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersReplyCountArgs} args - Arguments to filter OffersReplies to count.
     * @example
     * // Count the number of OffersReplies
     * const count = await prisma.offersReply.count({
     *   where: {
     *     // ... the filter for the OffersReplies we want to count
     *   }
     * })
    **/
    count<T extends OffersReplyCountArgs>(
      args?: Subset<T, OffersReplyCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OffersReplyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OffersReply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersReplyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OffersReplyAggregateArgs>(args: Subset<T, OffersReplyAggregateArgs>): PrismaPromise<GetOffersReplyAggregateType<T>>

    /**
     * Group by OffersReply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersReplyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OffersReplyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OffersReplyGroupByArgs['orderBy'] }
        : { orderBy?: OffersReplyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OffersReplyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOffersReplyGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for OffersReply.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OffersReplyClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    replyingTo<T extends OffersReplyArgs = {}>(args?: Subset<T, OffersReplyArgs>): CheckSelect<T, Prisma__OffersReplyClient<OffersReply | Null>, Prisma__OffersReplyClient<OffersReplyGetPayload<T> | Null>>;

    replies<T extends OffersReplyFindManyArgs = {}>(args?: Subset<T, OffersReplyFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OffersReply>| Null>, PrismaPromise<Array<OffersReplyGetPayload<T>>| Null>>;

    profile<T extends OffersProfileArgs = {}>(args?: Subset<T, OffersProfileArgs>): CheckSelect<T, Prisma__OffersProfileClient<OffersProfile | Null>, Prisma__OffersProfileClient<OffersProfileGetPayload<T> | Null>>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * OffersReply base type for findUnique actions
   */
  export type OffersReplyFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the OffersReply
     * 
    **/
    select?: OffersReplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersReplyInclude | null
    /**
     * Filter, which OffersReply to fetch.
     * 
    **/
    where: OffersReplyWhereUniqueInput
  }

  /**
   * OffersReply: findUnique
   */
  export interface OffersReplyFindUniqueArgs extends OffersReplyFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OffersReply base type for findFirst actions
   */
  export type OffersReplyFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the OffersReply
     * 
    **/
    select?: OffersReplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersReplyInclude | null
    /**
     * Filter, which OffersReply to fetch.
     * 
    **/
    where?: OffersReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffersReplies to fetch.
     * 
    **/
    orderBy?: Enumerable<OffersReplyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OffersReplies.
     * 
    **/
    cursor?: OffersReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffersReplies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffersReplies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OffersReplies.
     * 
    **/
    distinct?: Enumerable<OffersReplyScalarFieldEnum>
  }

  /**
   * OffersReply: findFirst
   */
  export interface OffersReplyFindFirstArgs extends OffersReplyFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OffersReply findMany
   */
  export type OffersReplyFindManyArgs = {
    /**
     * Select specific fields to fetch from the OffersReply
     * 
    **/
    select?: OffersReplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersReplyInclude | null
    /**
     * Filter, which OffersReplies to fetch.
     * 
    **/
    where?: OffersReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffersReplies to fetch.
     * 
    **/
    orderBy?: Enumerable<OffersReplyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OffersReplies.
     * 
    **/
    cursor?: OffersReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffersReplies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffersReplies.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OffersReplyScalarFieldEnum>
  }


  /**
   * OffersReply create
   */
  export type OffersReplyCreateArgs = {
    /**
     * Select specific fields to fetch from the OffersReply
     * 
    **/
    select?: OffersReplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersReplyInclude | null
    /**
     * The data needed to create a OffersReply.
     * 
    **/
    data: XOR<OffersReplyCreateInput, OffersReplyUncheckedCreateInput>
  }


  /**
   * OffersReply createMany
   */
  export type OffersReplyCreateManyArgs = {
    /**
     * The data used to create many OffersReplies.
     * 
    **/
    data: Enumerable<OffersReplyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OffersReply update
   */
  export type OffersReplyUpdateArgs = {
    /**
     * Select specific fields to fetch from the OffersReply
     * 
    **/
    select?: OffersReplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersReplyInclude | null
    /**
     * The data needed to update a OffersReply.
     * 
    **/
    data: XOR<OffersReplyUpdateInput, OffersReplyUncheckedUpdateInput>
    /**
     * Choose, which OffersReply to update.
     * 
    **/
    where: OffersReplyWhereUniqueInput
  }


  /**
   * OffersReply updateMany
   */
  export type OffersReplyUpdateManyArgs = {
    /**
     * The data used to update OffersReplies.
     * 
    **/
    data: XOR<OffersReplyUpdateManyMutationInput, OffersReplyUncheckedUpdateManyInput>
    /**
     * Filter which OffersReplies to update
     * 
    **/
    where?: OffersReplyWhereInput
  }


  /**
   * OffersReply upsert
   */
  export type OffersReplyUpsertArgs = {
    /**
     * Select specific fields to fetch from the OffersReply
     * 
    **/
    select?: OffersReplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersReplyInclude | null
    /**
     * The filter to search for the OffersReply to update in case it exists.
     * 
    **/
    where: OffersReplyWhereUniqueInput
    /**
     * In case the OffersReply found by the `where` argument doesn't exist, create a new OffersReply with this data.
     * 
    **/
    create: XOR<OffersReplyCreateInput, OffersReplyUncheckedCreateInput>
    /**
     * In case the OffersReply was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OffersReplyUpdateInput, OffersReplyUncheckedUpdateInput>
  }


  /**
   * OffersReply delete
   */
  export type OffersReplyDeleteArgs = {
    /**
     * Select specific fields to fetch from the OffersReply
     * 
    **/
    select?: OffersReplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersReplyInclude | null
    /**
     * Filter which OffersReply to delete.
     * 
    **/
    where: OffersReplyWhereUniqueInput
  }


  /**
   * OffersReply deleteMany
   */
  export type OffersReplyDeleteManyArgs = {
    /**
     * Filter which OffersReplies to delete
     * 
    **/
    where?: OffersReplyWhereInput
  }


  /**
   * OffersReply: findUniqueOrThrow
   */
  export type OffersReplyFindUniqueOrThrowArgs = OffersReplyFindUniqueArgsBase
      

  /**
   * OffersReply: findFirstOrThrow
   */
  export type OffersReplyFindFirstOrThrowArgs = OffersReplyFindFirstArgsBase
      

  /**
   * OffersReply without action
   */
  export type OffersReplyArgs = {
    /**
     * Select specific fields to fetch from the OffersReply
     * 
    **/
    select?: OffersReplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersReplyInclude | null
  }



  /**
   * Model OffersOffer
   */


  export type AggregateOffersOffer = {
    _count: OffersOfferCountAggregateOutputType | null
    _min: OffersOfferMinAggregateOutputType | null
    _max: OffersOfferMaxAggregateOutputType | null
  }

  export type OffersOfferMinAggregateOutputType = {
    id: string | null
    profileId: string | null
    companyId: string | null
    cityId: string | null
    monthYearReceived: Date | null
    negotiationStrategy: string | null
    comments: string | null
    jobType: JobType | null
    offersInternId: string | null
    offersFullTimeId: string | null
  }

  export type OffersOfferMaxAggregateOutputType = {
    id: string | null
    profileId: string | null
    companyId: string | null
    cityId: string | null
    monthYearReceived: Date | null
    negotiationStrategy: string | null
    comments: string | null
    jobType: JobType | null
    offersInternId: string | null
    offersFullTimeId: string | null
  }

  export type OffersOfferCountAggregateOutputType = {
    id: number
    profileId: number
    companyId: number
    cityId: number
    monthYearReceived: number
    negotiationStrategy: number
    comments: number
    jobType: number
    offersInternId: number
    offersFullTimeId: number
    _all: number
  }


  export type OffersOfferMinAggregateInputType = {
    id?: true
    profileId?: true
    companyId?: true
    cityId?: true
    monthYearReceived?: true
    negotiationStrategy?: true
    comments?: true
    jobType?: true
    offersInternId?: true
    offersFullTimeId?: true
  }

  export type OffersOfferMaxAggregateInputType = {
    id?: true
    profileId?: true
    companyId?: true
    cityId?: true
    monthYearReceived?: true
    negotiationStrategy?: true
    comments?: true
    jobType?: true
    offersInternId?: true
    offersFullTimeId?: true
  }

  export type OffersOfferCountAggregateInputType = {
    id?: true
    profileId?: true
    companyId?: true
    cityId?: true
    monthYearReceived?: true
    negotiationStrategy?: true
    comments?: true
    jobType?: true
    offersInternId?: true
    offersFullTimeId?: true
    _all?: true
  }

  export type OffersOfferAggregateArgs = {
    /**
     * Filter which OffersOffer to aggregate.
     * 
    **/
    where?: OffersOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffersOffers to fetch.
     * 
    **/
    orderBy?: Enumerable<OffersOfferOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OffersOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffersOffers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffersOffers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OffersOffers
    **/
    _count?: true | OffersOfferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OffersOfferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OffersOfferMaxAggregateInputType
  }

  export type GetOffersOfferAggregateType<T extends OffersOfferAggregateArgs> = {
        [P in keyof T & keyof AggregateOffersOffer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOffersOffer[P]>
      : GetScalarType<T[P], AggregateOffersOffer[P]>
  }




  export type OffersOfferGroupByArgs = {
    where?: OffersOfferWhereInput
    orderBy?: Enumerable<OffersOfferOrderByWithAggregationInput>
    by: Array<OffersOfferScalarFieldEnum>
    having?: OffersOfferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OffersOfferCountAggregateInputType | true
    _min?: OffersOfferMinAggregateInputType
    _max?: OffersOfferMaxAggregateInputType
  }


  export type OffersOfferGroupByOutputType = {
    id: string
    profileId: string
    companyId: string
    cityId: string
    monthYearReceived: Date
    negotiationStrategy: string
    comments: string
    jobType: JobType
    offersInternId: string | null
    offersFullTimeId: string | null
    _count: OffersOfferCountAggregateOutputType | null
    _min: OffersOfferMinAggregateOutputType | null
    _max: OffersOfferMaxAggregateOutputType | null
  }

  type GetOffersOfferGroupByPayload<T extends OffersOfferGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OffersOfferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OffersOfferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OffersOfferGroupByOutputType[P]>
            : GetScalarType<T[P], OffersOfferGroupByOutputType[P]>
        }
      >
    >


  export type OffersOfferSelect = {
    id?: boolean
    profile?: boolean | OffersProfileArgs
    profileId?: boolean
    company?: boolean | CompanyArgs
    companyId?: boolean
    location?: boolean | CityArgs
    cityId?: boolean
    monthYearReceived?: boolean
    negotiationStrategy?: boolean
    comments?: boolean
    jobType?: boolean
    offersIntern?: boolean | OffersInternArgs
    offersInternId?: boolean
    offersFullTime?: boolean | OffersFullTimeArgs
    offersFullTimeId?: boolean
    offersAnalysis?: boolean | OffersAnalysisArgs
    offersAnalysisUnit?: boolean | OffersAnalysisUnitFindManyArgs
    OffersAnalysisUnit?: boolean | OffersAnalysisUnitFindManyArgs
    _count?: boolean | OffersOfferCountOutputTypeArgs
  }

  export type OffersOfferInclude = {
    profile?: boolean | OffersProfileArgs
    company?: boolean | CompanyArgs
    location?: boolean | CityArgs
    offersIntern?: boolean | OffersInternArgs
    offersFullTime?: boolean | OffersFullTimeArgs
    offersAnalysis?: boolean | OffersAnalysisArgs
    offersAnalysisUnit?: boolean | OffersAnalysisUnitFindManyArgs
    OffersAnalysisUnit?: boolean | OffersAnalysisUnitFindManyArgs
    _count?: boolean | OffersOfferCountOutputTypeArgs
  }

  export type OffersOfferGetPayload<
    S extends boolean | null | undefined | OffersOfferArgs,
    U = keyof S
      > = S extends true
        ? OffersOffer
    : S extends undefined
    ? never
    : S extends OffersOfferArgs | OffersOfferFindManyArgs
    ?'include' extends U
    ? OffersOffer  & {
    [P in TrueKeys<S['include']>]:
        P extends 'profile' ? OffersProfileGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'company' ? CompanyGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'location' ? CityGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'offersIntern' ? OffersInternGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'offersFullTime' ? OffersFullTimeGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'offersAnalysis' ? OffersAnalysisGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'offersAnalysisUnit' ? Array < OffersAnalysisUnitGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'OffersAnalysisUnit' ? Array < OffersAnalysisUnitGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? OffersOfferCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'profile' ? OffersProfileGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'company' ? CompanyGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'location' ? CityGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'offersIntern' ? OffersInternGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'offersFullTime' ? OffersFullTimeGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'offersAnalysis' ? OffersAnalysisGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'offersAnalysisUnit' ? Array < OffersAnalysisUnitGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'OffersAnalysisUnit' ? Array < OffersAnalysisUnitGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? OffersOfferCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof OffersOffer ? OffersOffer[P] : never
  } 
    : OffersOffer
  : OffersOffer


  type OffersOfferCountArgs = Merge<
    Omit<OffersOfferFindManyArgs, 'select' | 'include'> & {
      select?: OffersOfferCountAggregateInputType | true
    }
  >

  export interface OffersOfferDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one OffersOffer that matches the filter.
     * @param {OffersOfferFindUniqueArgs} args - Arguments to find a OffersOffer
     * @example
     * // Get one OffersOffer
     * const offersOffer = await prisma.offersOffer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OffersOfferFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OffersOfferFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OffersOffer'> extends True ? CheckSelect<T, Prisma__OffersOfferClient<OffersOffer>, Prisma__OffersOfferClient<OffersOfferGetPayload<T>>> : CheckSelect<T, Prisma__OffersOfferClient<OffersOffer | null, null>, Prisma__OffersOfferClient<OffersOfferGetPayload<T> | null, null>>

    /**
     * Find the first OffersOffer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersOfferFindFirstArgs} args - Arguments to find a OffersOffer
     * @example
     * // Get one OffersOffer
     * const offersOffer = await prisma.offersOffer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OffersOfferFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OffersOfferFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OffersOffer'> extends True ? CheckSelect<T, Prisma__OffersOfferClient<OffersOffer>, Prisma__OffersOfferClient<OffersOfferGetPayload<T>>> : CheckSelect<T, Prisma__OffersOfferClient<OffersOffer | null, null>, Prisma__OffersOfferClient<OffersOfferGetPayload<T> | null, null>>

    /**
     * Find zero or more OffersOffers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersOfferFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OffersOffers
     * const offersOffers = await prisma.offersOffer.findMany()
     * 
     * // Get first 10 OffersOffers
     * const offersOffers = await prisma.offersOffer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offersOfferWithIdOnly = await prisma.offersOffer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OffersOfferFindManyArgs>(
      args?: SelectSubset<T, OffersOfferFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<OffersOffer>>, PrismaPromise<Array<OffersOfferGetPayload<T>>>>

    /**
     * Create a OffersOffer.
     * @param {OffersOfferCreateArgs} args - Arguments to create a OffersOffer.
     * @example
     * // Create one OffersOffer
     * const OffersOffer = await prisma.offersOffer.create({
     *   data: {
     *     // ... data to create a OffersOffer
     *   }
     * })
     * 
    **/
    create<T extends OffersOfferCreateArgs>(
      args: SelectSubset<T, OffersOfferCreateArgs>
    ): CheckSelect<T, Prisma__OffersOfferClient<OffersOffer>, Prisma__OffersOfferClient<OffersOfferGetPayload<T>>>

    /**
     * Create many OffersOffers.
     *     @param {OffersOfferCreateManyArgs} args - Arguments to create many OffersOffers.
     *     @example
     *     // Create many OffersOffers
     *     const offersOffer = await prisma.offersOffer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OffersOfferCreateManyArgs>(
      args?: SelectSubset<T, OffersOfferCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a OffersOffer.
     * @param {OffersOfferDeleteArgs} args - Arguments to delete one OffersOffer.
     * @example
     * // Delete one OffersOffer
     * const OffersOffer = await prisma.offersOffer.delete({
     *   where: {
     *     // ... filter to delete one OffersOffer
     *   }
     * })
     * 
    **/
    delete<T extends OffersOfferDeleteArgs>(
      args: SelectSubset<T, OffersOfferDeleteArgs>
    ): CheckSelect<T, Prisma__OffersOfferClient<OffersOffer>, Prisma__OffersOfferClient<OffersOfferGetPayload<T>>>

    /**
     * Update one OffersOffer.
     * @param {OffersOfferUpdateArgs} args - Arguments to update one OffersOffer.
     * @example
     * // Update one OffersOffer
     * const offersOffer = await prisma.offersOffer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OffersOfferUpdateArgs>(
      args: SelectSubset<T, OffersOfferUpdateArgs>
    ): CheckSelect<T, Prisma__OffersOfferClient<OffersOffer>, Prisma__OffersOfferClient<OffersOfferGetPayload<T>>>

    /**
     * Delete zero or more OffersOffers.
     * @param {OffersOfferDeleteManyArgs} args - Arguments to filter OffersOffers to delete.
     * @example
     * // Delete a few OffersOffers
     * const { count } = await prisma.offersOffer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OffersOfferDeleteManyArgs>(
      args?: SelectSubset<T, OffersOfferDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more OffersOffers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersOfferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OffersOffers
     * const offersOffer = await prisma.offersOffer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OffersOfferUpdateManyArgs>(
      args: SelectSubset<T, OffersOfferUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one OffersOffer.
     * @param {OffersOfferUpsertArgs} args - Arguments to update or create a OffersOffer.
     * @example
     * // Update or create a OffersOffer
     * const offersOffer = await prisma.offersOffer.upsert({
     *   create: {
     *     // ... data to create a OffersOffer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OffersOffer we want to update
     *   }
     * })
    **/
    upsert<T extends OffersOfferUpsertArgs>(
      args: SelectSubset<T, OffersOfferUpsertArgs>
    ): CheckSelect<T, Prisma__OffersOfferClient<OffersOffer>, Prisma__OffersOfferClient<OffersOfferGetPayload<T>>>

    /**
     * Find one OffersOffer that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {OffersOfferFindUniqueOrThrowArgs} args - Arguments to find a OffersOffer
     * @example
     * // Get one OffersOffer
     * const offersOffer = await prisma.offersOffer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OffersOfferFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OffersOfferFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__OffersOfferClient<OffersOffer>, Prisma__OffersOfferClient<OffersOfferGetPayload<T>>>

    /**
     * Find the first OffersOffer that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersOfferFindFirstOrThrowArgs} args - Arguments to find a OffersOffer
     * @example
     * // Get one OffersOffer
     * const offersOffer = await prisma.offersOffer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OffersOfferFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OffersOfferFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__OffersOfferClient<OffersOffer>, Prisma__OffersOfferClient<OffersOfferGetPayload<T>>>

    /**
     * Count the number of OffersOffers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersOfferCountArgs} args - Arguments to filter OffersOffers to count.
     * @example
     * // Count the number of OffersOffers
     * const count = await prisma.offersOffer.count({
     *   where: {
     *     // ... the filter for the OffersOffers we want to count
     *   }
     * })
    **/
    count<T extends OffersOfferCountArgs>(
      args?: Subset<T, OffersOfferCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OffersOfferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OffersOffer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersOfferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OffersOfferAggregateArgs>(args: Subset<T, OffersOfferAggregateArgs>): PrismaPromise<GetOffersOfferAggregateType<T>>

    /**
     * Group by OffersOffer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersOfferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OffersOfferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OffersOfferGroupByArgs['orderBy'] }
        : { orderBy?: OffersOfferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OffersOfferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOffersOfferGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for OffersOffer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OffersOfferClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    profile<T extends OffersProfileArgs = {}>(args?: Subset<T, OffersProfileArgs>): CheckSelect<T, Prisma__OffersProfileClient<OffersProfile | Null>, Prisma__OffersProfileClient<OffersProfileGetPayload<T> | Null>>;

    company<T extends CompanyArgs = {}>(args?: Subset<T, CompanyArgs>): CheckSelect<T, Prisma__CompanyClient<Company | Null>, Prisma__CompanyClient<CompanyGetPayload<T> | Null>>;

    location<T extends CityArgs = {}>(args?: Subset<T, CityArgs>): CheckSelect<T, Prisma__CityClient<City | Null>, Prisma__CityClient<CityGetPayload<T> | Null>>;

    offersIntern<T extends OffersInternArgs = {}>(args?: Subset<T, OffersInternArgs>): CheckSelect<T, Prisma__OffersInternClient<OffersIntern | Null>, Prisma__OffersInternClient<OffersInternGetPayload<T> | Null>>;

    offersFullTime<T extends OffersFullTimeArgs = {}>(args?: Subset<T, OffersFullTimeArgs>): CheckSelect<T, Prisma__OffersFullTimeClient<OffersFullTime | Null>, Prisma__OffersFullTimeClient<OffersFullTimeGetPayload<T> | Null>>;

    offersAnalysis<T extends OffersAnalysisArgs = {}>(args?: Subset<T, OffersAnalysisArgs>): CheckSelect<T, Prisma__OffersAnalysisClient<OffersAnalysis | Null>, Prisma__OffersAnalysisClient<OffersAnalysisGetPayload<T> | Null>>;

    offersAnalysisUnit<T extends OffersAnalysisUnitFindManyArgs = {}>(args?: Subset<T, OffersAnalysisUnitFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OffersAnalysisUnit>| Null>, PrismaPromise<Array<OffersAnalysisUnitGetPayload<T>>| Null>>;

    OffersAnalysisUnit<T extends OffersAnalysisUnitFindManyArgs = {}>(args?: Subset<T, OffersAnalysisUnitFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OffersAnalysisUnit>| Null>, PrismaPromise<Array<OffersAnalysisUnitGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * OffersOffer base type for findUnique actions
   */
  export type OffersOfferFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the OffersOffer
     * 
    **/
    select?: OffersOfferSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersOfferInclude | null
    /**
     * Filter, which OffersOffer to fetch.
     * 
    **/
    where: OffersOfferWhereUniqueInput
  }

  /**
   * OffersOffer: findUnique
   */
  export interface OffersOfferFindUniqueArgs extends OffersOfferFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OffersOffer base type for findFirst actions
   */
  export type OffersOfferFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the OffersOffer
     * 
    **/
    select?: OffersOfferSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersOfferInclude | null
    /**
     * Filter, which OffersOffer to fetch.
     * 
    **/
    where?: OffersOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffersOffers to fetch.
     * 
    **/
    orderBy?: Enumerable<OffersOfferOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OffersOffers.
     * 
    **/
    cursor?: OffersOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffersOffers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffersOffers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OffersOffers.
     * 
    **/
    distinct?: Enumerable<OffersOfferScalarFieldEnum>
  }

  /**
   * OffersOffer: findFirst
   */
  export interface OffersOfferFindFirstArgs extends OffersOfferFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OffersOffer findMany
   */
  export type OffersOfferFindManyArgs = {
    /**
     * Select specific fields to fetch from the OffersOffer
     * 
    **/
    select?: OffersOfferSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersOfferInclude | null
    /**
     * Filter, which OffersOffers to fetch.
     * 
    **/
    where?: OffersOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffersOffers to fetch.
     * 
    **/
    orderBy?: Enumerable<OffersOfferOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OffersOffers.
     * 
    **/
    cursor?: OffersOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffersOffers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffersOffers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OffersOfferScalarFieldEnum>
  }


  /**
   * OffersOffer create
   */
  export type OffersOfferCreateArgs = {
    /**
     * Select specific fields to fetch from the OffersOffer
     * 
    **/
    select?: OffersOfferSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersOfferInclude | null
    /**
     * The data needed to create a OffersOffer.
     * 
    **/
    data: XOR<OffersOfferCreateInput, OffersOfferUncheckedCreateInput>
  }


  /**
   * OffersOffer createMany
   */
  export type OffersOfferCreateManyArgs = {
    /**
     * The data used to create many OffersOffers.
     * 
    **/
    data: Enumerable<OffersOfferCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OffersOffer update
   */
  export type OffersOfferUpdateArgs = {
    /**
     * Select specific fields to fetch from the OffersOffer
     * 
    **/
    select?: OffersOfferSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersOfferInclude | null
    /**
     * The data needed to update a OffersOffer.
     * 
    **/
    data: XOR<OffersOfferUpdateInput, OffersOfferUncheckedUpdateInput>
    /**
     * Choose, which OffersOffer to update.
     * 
    **/
    where: OffersOfferWhereUniqueInput
  }


  /**
   * OffersOffer updateMany
   */
  export type OffersOfferUpdateManyArgs = {
    /**
     * The data used to update OffersOffers.
     * 
    **/
    data: XOR<OffersOfferUpdateManyMutationInput, OffersOfferUncheckedUpdateManyInput>
    /**
     * Filter which OffersOffers to update
     * 
    **/
    where?: OffersOfferWhereInput
  }


  /**
   * OffersOffer upsert
   */
  export type OffersOfferUpsertArgs = {
    /**
     * Select specific fields to fetch from the OffersOffer
     * 
    **/
    select?: OffersOfferSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersOfferInclude | null
    /**
     * The filter to search for the OffersOffer to update in case it exists.
     * 
    **/
    where: OffersOfferWhereUniqueInput
    /**
     * In case the OffersOffer found by the `where` argument doesn't exist, create a new OffersOffer with this data.
     * 
    **/
    create: XOR<OffersOfferCreateInput, OffersOfferUncheckedCreateInput>
    /**
     * In case the OffersOffer was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OffersOfferUpdateInput, OffersOfferUncheckedUpdateInput>
  }


  /**
   * OffersOffer delete
   */
  export type OffersOfferDeleteArgs = {
    /**
     * Select specific fields to fetch from the OffersOffer
     * 
    **/
    select?: OffersOfferSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersOfferInclude | null
    /**
     * Filter which OffersOffer to delete.
     * 
    **/
    where: OffersOfferWhereUniqueInput
  }


  /**
   * OffersOffer deleteMany
   */
  export type OffersOfferDeleteManyArgs = {
    /**
     * Filter which OffersOffers to delete
     * 
    **/
    where?: OffersOfferWhereInput
  }


  /**
   * OffersOffer: findUniqueOrThrow
   */
  export type OffersOfferFindUniqueOrThrowArgs = OffersOfferFindUniqueArgsBase
      

  /**
   * OffersOffer: findFirstOrThrow
   */
  export type OffersOfferFindFirstOrThrowArgs = OffersOfferFindFirstArgsBase
      

  /**
   * OffersOffer without action
   */
  export type OffersOfferArgs = {
    /**
     * Select specific fields to fetch from the OffersOffer
     * 
    **/
    select?: OffersOfferSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersOfferInclude | null
  }



  /**
   * Model OffersIntern
   */


  export type AggregateOffersIntern = {
    _count: OffersInternCountAggregateOutputType | null
    _avg: OffersInternAvgAggregateOutputType | null
    _sum: OffersInternSumAggregateOutputType | null
    _min: OffersInternMinAggregateOutputType | null
    _max: OffersInternMaxAggregateOutputType | null
  }

  export type OffersInternAvgAggregateOutputType = {
    startYear: number | null
  }

  export type OffersInternSumAggregateOutputType = {
    startYear: number | null
  }

  export type OffersInternMinAggregateOutputType = {
    id: string | null
    title: string | null
    internshipCycle: string | null
    startYear: number | null
    monthlySalaryId: string | null
  }

  export type OffersInternMaxAggregateOutputType = {
    id: string | null
    title: string | null
    internshipCycle: string | null
    startYear: number | null
    monthlySalaryId: string | null
  }

  export type OffersInternCountAggregateOutputType = {
    id: number
    title: number
    internshipCycle: number
    startYear: number
    monthlySalaryId: number
    _all: number
  }


  export type OffersInternAvgAggregateInputType = {
    startYear?: true
  }

  export type OffersInternSumAggregateInputType = {
    startYear?: true
  }

  export type OffersInternMinAggregateInputType = {
    id?: true
    title?: true
    internshipCycle?: true
    startYear?: true
    monthlySalaryId?: true
  }

  export type OffersInternMaxAggregateInputType = {
    id?: true
    title?: true
    internshipCycle?: true
    startYear?: true
    monthlySalaryId?: true
  }

  export type OffersInternCountAggregateInputType = {
    id?: true
    title?: true
    internshipCycle?: true
    startYear?: true
    monthlySalaryId?: true
    _all?: true
  }

  export type OffersInternAggregateArgs = {
    /**
     * Filter which OffersIntern to aggregate.
     * 
    **/
    where?: OffersInternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffersInterns to fetch.
     * 
    **/
    orderBy?: Enumerable<OffersInternOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OffersInternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffersInterns from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffersInterns.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OffersInterns
    **/
    _count?: true | OffersInternCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OffersInternAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OffersInternSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OffersInternMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OffersInternMaxAggregateInputType
  }

  export type GetOffersInternAggregateType<T extends OffersInternAggregateArgs> = {
        [P in keyof T & keyof AggregateOffersIntern]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOffersIntern[P]>
      : GetScalarType<T[P], AggregateOffersIntern[P]>
  }




  export type OffersInternGroupByArgs = {
    where?: OffersInternWhereInput
    orderBy?: Enumerable<OffersInternOrderByWithAggregationInput>
    by: Array<OffersInternScalarFieldEnum>
    having?: OffersInternScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OffersInternCountAggregateInputType | true
    _avg?: OffersInternAvgAggregateInputType
    _sum?: OffersInternSumAggregateInputType
    _min?: OffersInternMinAggregateInputType
    _max?: OffersInternMaxAggregateInputType
  }


  export type OffersInternGroupByOutputType = {
    id: string
    title: string
    internshipCycle: string
    startYear: number
    monthlySalaryId: string
    _count: OffersInternCountAggregateOutputType | null
    _avg: OffersInternAvgAggregateOutputType | null
    _sum: OffersInternSumAggregateOutputType | null
    _min: OffersInternMinAggregateOutputType | null
    _max: OffersInternMaxAggregateOutputType | null
  }

  type GetOffersInternGroupByPayload<T extends OffersInternGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OffersInternGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OffersInternGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OffersInternGroupByOutputType[P]>
            : GetScalarType<T[P], OffersInternGroupByOutputType[P]>
        }
      >
    >


  export type OffersInternSelect = {
    id?: boolean
    title?: boolean
    internshipCycle?: boolean
    startYear?: boolean
    monthlySalary?: boolean | OffersCurrencyArgs
    monthlySalaryId?: boolean
    OffersOffer?: boolean | OffersOfferArgs
  }

  export type OffersInternInclude = {
    monthlySalary?: boolean | OffersCurrencyArgs
    OffersOffer?: boolean | OffersOfferArgs
  }

  export type OffersInternGetPayload<
    S extends boolean | null | undefined | OffersInternArgs,
    U = keyof S
      > = S extends true
        ? OffersIntern
    : S extends undefined
    ? never
    : S extends OffersInternArgs | OffersInternFindManyArgs
    ?'include' extends U
    ? OffersIntern  & {
    [P in TrueKeys<S['include']>]:
        P extends 'monthlySalary' ? OffersCurrencyGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'OffersOffer' ? OffersOfferGetPayload<Exclude<S['include'], undefined | null>[P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'monthlySalary' ? OffersCurrencyGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'OffersOffer' ? OffersOfferGetPayload<Exclude<S['select'], undefined | null>[P]> | null :  P extends keyof OffersIntern ? OffersIntern[P] : never
  } 
    : OffersIntern
  : OffersIntern


  type OffersInternCountArgs = Merge<
    Omit<OffersInternFindManyArgs, 'select' | 'include'> & {
      select?: OffersInternCountAggregateInputType | true
    }
  >

  export interface OffersInternDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one OffersIntern that matches the filter.
     * @param {OffersInternFindUniqueArgs} args - Arguments to find a OffersIntern
     * @example
     * // Get one OffersIntern
     * const offersIntern = await prisma.offersIntern.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OffersInternFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OffersInternFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OffersIntern'> extends True ? CheckSelect<T, Prisma__OffersInternClient<OffersIntern>, Prisma__OffersInternClient<OffersInternGetPayload<T>>> : CheckSelect<T, Prisma__OffersInternClient<OffersIntern | null, null>, Prisma__OffersInternClient<OffersInternGetPayload<T> | null, null>>

    /**
     * Find the first OffersIntern that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersInternFindFirstArgs} args - Arguments to find a OffersIntern
     * @example
     * // Get one OffersIntern
     * const offersIntern = await prisma.offersIntern.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OffersInternFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OffersInternFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OffersIntern'> extends True ? CheckSelect<T, Prisma__OffersInternClient<OffersIntern>, Prisma__OffersInternClient<OffersInternGetPayload<T>>> : CheckSelect<T, Prisma__OffersInternClient<OffersIntern | null, null>, Prisma__OffersInternClient<OffersInternGetPayload<T> | null, null>>

    /**
     * Find zero or more OffersInterns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersInternFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OffersInterns
     * const offersInterns = await prisma.offersIntern.findMany()
     * 
     * // Get first 10 OffersInterns
     * const offersInterns = await prisma.offersIntern.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offersInternWithIdOnly = await prisma.offersIntern.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OffersInternFindManyArgs>(
      args?: SelectSubset<T, OffersInternFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<OffersIntern>>, PrismaPromise<Array<OffersInternGetPayload<T>>>>

    /**
     * Create a OffersIntern.
     * @param {OffersInternCreateArgs} args - Arguments to create a OffersIntern.
     * @example
     * // Create one OffersIntern
     * const OffersIntern = await prisma.offersIntern.create({
     *   data: {
     *     // ... data to create a OffersIntern
     *   }
     * })
     * 
    **/
    create<T extends OffersInternCreateArgs>(
      args: SelectSubset<T, OffersInternCreateArgs>
    ): CheckSelect<T, Prisma__OffersInternClient<OffersIntern>, Prisma__OffersInternClient<OffersInternGetPayload<T>>>

    /**
     * Create many OffersInterns.
     *     @param {OffersInternCreateManyArgs} args - Arguments to create many OffersInterns.
     *     @example
     *     // Create many OffersInterns
     *     const offersIntern = await prisma.offersIntern.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OffersInternCreateManyArgs>(
      args?: SelectSubset<T, OffersInternCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a OffersIntern.
     * @param {OffersInternDeleteArgs} args - Arguments to delete one OffersIntern.
     * @example
     * // Delete one OffersIntern
     * const OffersIntern = await prisma.offersIntern.delete({
     *   where: {
     *     // ... filter to delete one OffersIntern
     *   }
     * })
     * 
    **/
    delete<T extends OffersInternDeleteArgs>(
      args: SelectSubset<T, OffersInternDeleteArgs>
    ): CheckSelect<T, Prisma__OffersInternClient<OffersIntern>, Prisma__OffersInternClient<OffersInternGetPayload<T>>>

    /**
     * Update one OffersIntern.
     * @param {OffersInternUpdateArgs} args - Arguments to update one OffersIntern.
     * @example
     * // Update one OffersIntern
     * const offersIntern = await prisma.offersIntern.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OffersInternUpdateArgs>(
      args: SelectSubset<T, OffersInternUpdateArgs>
    ): CheckSelect<T, Prisma__OffersInternClient<OffersIntern>, Prisma__OffersInternClient<OffersInternGetPayload<T>>>

    /**
     * Delete zero or more OffersInterns.
     * @param {OffersInternDeleteManyArgs} args - Arguments to filter OffersInterns to delete.
     * @example
     * // Delete a few OffersInterns
     * const { count } = await prisma.offersIntern.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OffersInternDeleteManyArgs>(
      args?: SelectSubset<T, OffersInternDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more OffersInterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersInternUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OffersInterns
     * const offersIntern = await prisma.offersIntern.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OffersInternUpdateManyArgs>(
      args: SelectSubset<T, OffersInternUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one OffersIntern.
     * @param {OffersInternUpsertArgs} args - Arguments to update or create a OffersIntern.
     * @example
     * // Update or create a OffersIntern
     * const offersIntern = await prisma.offersIntern.upsert({
     *   create: {
     *     // ... data to create a OffersIntern
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OffersIntern we want to update
     *   }
     * })
    **/
    upsert<T extends OffersInternUpsertArgs>(
      args: SelectSubset<T, OffersInternUpsertArgs>
    ): CheckSelect<T, Prisma__OffersInternClient<OffersIntern>, Prisma__OffersInternClient<OffersInternGetPayload<T>>>

    /**
     * Find one OffersIntern that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {OffersInternFindUniqueOrThrowArgs} args - Arguments to find a OffersIntern
     * @example
     * // Get one OffersIntern
     * const offersIntern = await prisma.offersIntern.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OffersInternFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OffersInternFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__OffersInternClient<OffersIntern>, Prisma__OffersInternClient<OffersInternGetPayload<T>>>

    /**
     * Find the first OffersIntern that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersInternFindFirstOrThrowArgs} args - Arguments to find a OffersIntern
     * @example
     * // Get one OffersIntern
     * const offersIntern = await prisma.offersIntern.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OffersInternFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OffersInternFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__OffersInternClient<OffersIntern>, Prisma__OffersInternClient<OffersInternGetPayload<T>>>

    /**
     * Count the number of OffersInterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersInternCountArgs} args - Arguments to filter OffersInterns to count.
     * @example
     * // Count the number of OffersInterns
     * const count = await prisma.offersIntern.count({
     *   where: {
     *     // ... the filter for the OffersInterns we want to count
     *   }
     * })
    **/
    count<T extends OffersInternCountArgs>(
      args?: Subset<T, OffersInternCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OffersInternCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OffersIntern.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersInternAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OffersInternAggregateArgs>(args: Subset<T, OffersInternAggregateArgs>): PrismaPromise<GetOffersInternAggregateType<T>>

    /**
     * Group by OffersIntern.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersInternGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OffersInternGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OffersInternGroupByArgs['orderBy'] }
        : { orderBy?: OffersInternGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OffersInternGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOffersInternGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for OffersIntern.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OffersInternClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    monthlySalary<T extends OffersCurrencyArgs = {}>(args?: Subset<T, OffersCurrencyArgs>): CheckSelect<T, Prisma__OffersCurrencyClient<OffersCurrency | Null>, Prisma__OffersCurrencyClient<OffersCurrencyGetPayload<T> | Null>>;

    OffersOffer<T extends OffersOfferArgs = {}>(args?: Subset<T, OffersOfferArgs>): CheckSelect<T, Prisma__OffersOfferClient<OffersOffer | Null>, Prisma__OffersOfferClient<OffersOfferGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * OffersIntern base type for findUnique actions
   */
  export type OffersInternFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the OffersIntern
     * 
    **/
    select?: OffersInternSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersInternInclude | null
    /**
     * Filter, which OffersIntern to fetch.
     * 
    **/
    where: OffersInternWhereUniqueInput
  }

  /**
   * OffersIntern: findUnique
   */
  export interface OffersInternFindUniqueArgs extends OffersInternFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OffersIntern base type for findFirst actions
   */
  export type OffersInternFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the OffersIntern
     * 
    **/
    select?: OffersInternSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersInternInclude | null
    /**
     * Filter, which OffersIntern to fetch.
     * 
    **/
    where?: OffersInternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffersInterns to fetch.
     * 
    **/
    orderBy?: Enumerable<OffersInternOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OffersInterns.
     * 
    **/
    cursor?: OffersInternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffersInterns from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffersInterns.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OffersInterns.
     * 
    **/
    distinct?: Enumerable<OffersInternScalarFieldEnum>
  }

  /**
   * OffersIntern: findFirst
   */
  export interface OffersInternFindFirstArgs extends OffersInternFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OffersIntern findMany
   */
  export type OffersInternFindManyArgs = {
    /**
     * Select specific fields to fetch from the OffersIntern
     * 
    **/
    select?: OffersInternSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersInternInclude | null
    /**
     * Filter, which OffersInterns to fetch.
     * 
    **/
    where?: OffersInternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffersInterns to fetch.
     * 
    **/
    orderBy?: Enumerable<OffersInternOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OffersInterns.
     * 
    **/
    cursor?: OffersInternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffersInterns from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffersInterns.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OffersInternScalarFieldEnum>
  }


  /**
   * OffersIntern create
   */
  export type OffersInternCreateArgs = {
    /**
     * Select specific fields to fetch from the OffersIntern
     * 
    **/
    select?: OffersInternSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersInternInclude | null
    /**
     * The data needed to create a OffersIntern.
     * 
    **/
    data: XOR<OffersInternCreateInput, OffersInternUncheckedCreateInput>
  }


  /**
   * OffersIntern createMany
   */
  export type OffersInternCreateManyArgs = {
    /**
     * The data used to create many OffersInterns.
     * 
    **/
    data: Enumerable<OffersInternCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OffersIntern update
   */
  export type OffersInternUpdateArgs = {
    /**
     * Select specific fields to fetch from the OffersIntern
     * 
    **/
    select?: OffersInternSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersInternInclude | null
    /**
     * The data needed to update a OffersIntern.
     * 
    **/
    data: XOR<OffersInternUpdateInput, OffersInternUncheckedUpdateInput>
    /**
     * Choose, which OffersIntern to update.
     * 
    **/
    where: OffersInternWhereUniqueInput
  }


  /**
   * OffersIntern updateMany
   */
  export type OffersInternUpdateManyArgs = {
    /**
     * The data used to update OffersInterns.
     * 
    **/
    data: XOR<OffersInternUpdateManyMutationInput, OffersInternUncheckedUpdateManyInput>
    /**
     * Filter which OffersInterns to update
     * 
    **/
    where?: OffersInternWhereInput
  }


  /**
   * OffersIntern upsert
   */
  export type OffersInternUpsertArgs = {
    /**
     * Select specific fields to fetch from the OffersIntern
     * 
    **/
    select?: OffersInternSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersInternInclude | null
    /**
     * The filter to search for the OffersIntern to update in case it exists.
     * 
    **/
    where: OffersInternWhereUniqueInput
    /**
     * In case the OffersIntern found by the `where` argument doesn't exist, create a new OffersIntern with this data.
     * 
    **/
    create: XOR<OffersInternCreateInput, OffersInternUncheckedCreateInput>
    /**
     * In case the OffersIntern was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OffersInternUpdateInput, OffersInternUncheckedUpdateInput>
  }


  /**
   * OffersIntern delete
   */
  export type OffersInternDeleteArgs = {
    /**
     * Select specific fields to fetch from the OffersIntern
     * 
    **/
    select?: OffersInternSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersInternInclude | null
    /**
     * Filter which OffersIntern to delete.
     * 
    **/
    where: OffersInternWhereUniqueInput
  }


  /**
   * OffersIntern deleteMany
   */
  export type OffersInternDeleteManyArgs = {
    /**
     * Filter which OffersInterns to delete
     * 
    **/
    where?: OffersInternWhereInput
  }


  /**
   * OffersIntern: findUniqueOrThrow
   */
  export type OffersInternFindUniqueOrThrowArgs = OffersInternFindUniqueArgsBase
      

  /**
   * OffersIntern: findFirstOrThrow
   */
  export type OffersInternFindFirstOrThrowArgs = OffersInternFindFirstArgsBase
      

  /**
   * OffersIntern without action
   */
  export type OffersInternArgs = {
    /**
     * Select specific fields to fetch from the OffersIntern
     * 
    **/
    select?: OffersInternSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersInternInclude | null
  }



  /**
   * Model OffersFullTime
   */


  export type AggregateOffersFullTime = {
    _count: OffersFullTimeCountAggregateOutputType | null
    _min: OffersFullTimeMinAggregateOutputType | null
    _max: OffersFullTimeMaxAggregateOutputType | null
  }

  export type OffersFullTimeMinAggregateOutputType = {
    id: string | null
    title: string | null
    level: string | null
    totalCompensationId: string | null
    baseSalaryId: string | null
    bonusId: string | null
    stocksId: string | null
  }

  export type OffersFullTimeMaxAggregateOutputType = {
    id: string | null
    title: string | null
    level: string | null
    totalCompensationId: string | null
    baseSalaryId: string | null
    bonusId: string | null
    stocksId: string | null
  }

  export type OffersFullTimeCountAggregateOutputType = {
    id: number
    title: number
    level: number
    totalCompensationId: number
    baseSalaryId: number
    bonusId: number
    stocksId: number
    _all: number
  }


  export type OffersFullTimeMinAggregateInputType = {
    id?: true
    title?: true
    level?: true
    totalCompensationId?: true
    baseSalaryId?: true
    bonusId?: true
    stocksId?: true
  }

  export type OffersFullTimeMaxAggregateInputType = {
    id?: true
    title?: true
    level?: true
    totalCompensationId?: true
    baseSalaryId?: true
    bonusId?: true
    stocksId?: true
  }

  export type OffersFullTimeCountAggregateInputType = {
    id?: true
    title?: true
    level?: true
    totalCompensationId?: true
    baseSalaryId?: true
    bonusId?: true
    stocksId?: true
    _all?: true
  }

  export type OffersFullTimeAggregateArgs = {
    /**
     * Filter which OffersFullTime to aggregate.
     * 
    **/
    where?: OffersFullTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffersFullTimes to fetch.
     * 
    **/
    orderBy?: Enumerable<OffersFullTimeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OffersFullTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffersFullTimes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffersFullTimes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OffersFullTimes
    **/
    _count?: true | OffersFullTimeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OffersFullTimeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OffersFullTimeMaxAggregateInputType
  }

  export type GetOffersFullTimeAggregateType<T extends OffersFullTimeAggregateArgs> = {
        [P in keyof T & keyof AggregateOffersFullTime]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOffersFullTime[P]>
      : GetScalarType<T[P], AggregateOffersFullTime[P]>
  }




  export type OffersFullTimeGroupByArgs = {
    where?: OffersFullTimeWhereInput
    orderBy?: Enumerable<OffersFullTimeOrderByWithAggregationInput>
    by: Array<OffersFullTimeScalarFieldEnum>
    having?: OffersFullTimeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OffersFullTimeCountAggregateInputType | true
    _min?: OffersFullTimeMinAggregateInputType
    _max?: OffersFullTimeMaxAggregateInputType
  }


  export type OffersFullTimeGroupByOutputType = {
    id: string
    title: string
    level: string
    totalCompensationId: string
    baseSalaryId: string | null
    bonusId: string | null
    stocksId: string | null
    _count: OffersFullTimeCountAggregateOutputType | null
    _min: OffersFullTimeMinAggregateOutputType | null
    _max: OffersFullTimeMaxAggregateOutputType | null
  }

  type GetOffersFullTimeGroupByPayload<T extends OffersFullTimeGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OffersFullTimeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OffersFullTimeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OffersFullTimeGroupByOutputType[P]>
            : GetScalarType<T[P], OffersFullTimeGroupByOutputType[P]>
        }
      >
    >


  export type OffersFullTimeSelect = {
    id?: boolean
    title?: boolean
    level?: boolean
    totalCompensation?: boolean | OffersCurrencyArgs
    totalCompensationId?: boolean
    baseSalary?: boolean | OffersCurrencyArgs
    baseSalaryId?: boolean
    bonus?: boolean | OffersCurrencyArgs
    bonusId?: boolean
    stocks?: boolean | OffersCurrencyArgs
    stocksId?: boolean
    OffersOffer?: boolean | OffersOfferArgs
  }

  export type OffersFullTimeInclude = {
    totalCompensation?: boolean | OffersCurrencyArgs
    baseSalary?: boolean | OffersCurrencyArgs
    bonus?: boolean | OffersCurrencyArgs
    stocks?: boolean | OffersCurrencyArgs
    OffersOffer?: boolean | OffersOfferArgs
  }

  export type OffersFullTimeGetPayload<
    S extends boolean | null | undefined | OffersFullTimeArgs,
    U = keyof S
      > = S extends true
        ? OffersFullTime
    : S extends undefined
    ? never
    : S extends OffersFullTimeArgs | OffersFullTimeFindManyArgs
    ?'include' extends U
    ? OffersFullTime  & {
    [P in TrueKeys<S['include']>]:
        P extends 'totalCompensation' ? OffersCurrencyGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'baseSalary' ? OffersCurrencyGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'bonus' ? OffersCurrencyGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'stocks' ? OffersCurrencyGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'OffersOffer' ? OffersOfferGetPayload<Exclude<S['include'], undefined | null>[P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'totalCompensation' ? OffersCurrencyGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'baseSalary' ? OffersCurrencyGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'bonus' ? OffersCurrencyGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'stocks' ? OffersCurrencyGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'OffersOffer' ? OffersOfferGetPayload<Exclude<S['select'], undefined | null>[P]> | null :  P extends keyof OffersFullTime ? OffersFullTime[P] : never
  } 
    : OffersFullTime
  : OffersFullTime


  type OffersFullTimeCountArgs = Merge<
    Omit<OffersFullTimeFindManyArgs, 'select' | 'include'> & {
      select?: OffersFullTimeCountAggregateInputType | true
    }
  >

  export interface OffersFullTimeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one OffersFullTime that matches the filter.
     * @param {OffersFullTimeFindUniqueArgs} args - Arguments to find a OffersFullTime
     * @example
     * // Get one OffersFullTime
     * const offersFullTime = await prisma.offersFullTime.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OffersFullTimeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OffersFullTimeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OffersFullTime'> extends True ? CheckSelect<T, Prisma__OffersFullTimeClient<OffersFullTime>, Prisma__OffersFullTimeClient<OffersFullTimeGetPayload<T>>> : CheckSelect<T, Prisma__OffersFullTimeClient<OffersFullTime | null, null>, Prisma__OffersFullTimeClient<OffersFullTimeGetPayload<T> | null, null>>

    /**
     * Find the first OffersFullTime that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersFullTimeFindFirstArgs} args - Arguments to find a OffersFullTime
     * @example
     * // Get one OffersFullTime
     * const offersFullTime = await prisma.offersFullTime.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OffersFullTimeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OffersFullTimeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OffersFullTime'> extends True ? CheckSelect<T, Prisma__OffersFullTimeClient<OffersFullTime>, Prisma__OffersFullTimeClient<OffersFullTimeGetPayload<T>>> : CheckSelect<T, Prisma__OffersFullTimeClient<OffersFullTime | null, null>, Prisma__OffersFullTimeClient<OffersFullTimeGetPayload<T> | null, null>>

    /**
     * Find zero or more OffersFullTimes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersFullTimeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OffersFullTimes
     * const offersFullTimes = await prisma.offersFullTime.findMany()
     * 
     * // Get first 10 OffersFullTimes
     * const offersFullTimes = await prisma.offersFullTime.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offersFullTimeWithIdOnly = await prisma.offersFullTime.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OffersFullTimeFindManyArgs>(
      args?: SelectSubset<T, OffersFullTimeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<OffersFullTime>>, PrismaPromise<Array<OffersFullTimeGetPayload<T>>>>

    /**
     * Create a OffersFullTime.
     * @param {OffersFullTimeCreateArgs} args - Arguments to create a OffersFullTime.
     * @example
     * // Create one OffersFullTime
     * const OffersFullTime = await prisma.offersFullTime.create({
     *   data: {
     *     // ... data to create a OffersFullTime
     *   }
     * })
     * 
    **/
    create<T extends OffersFullTimeCreateArgs>(
      args: SelectSubset<T, OffersFullTimeCreateArgs>
    ): CheckSelect<T, Prisma__OffersFullTimeClient<OffersFullTime>, Prisma__OffersFullTimeClient<OffersFullTimeGetPayload<T>>>

    /**
     * Create many OffersFullTimes.
     *     @param {OffersFullTimeCreateManyArgs} args - Arguments to create many OffersFullTimes.
     *     @example
     *     // Create many OffersFullTimes
     *     const offersFullTime = await prisma.offersFullTime.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OffersFullTimeCreateManyArgs>(
      args?: SelectSubset<T, OffersFullTimeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a OffersFullTime.
     * @param {OffersFullTimeDeleteArgs} args - Arguments to delete one OffersFullTime.
     * @example
     * // Delete one OffersFullTime
     * const OffersFullTime = await prisma.offersFullTime.delete({
     *   where: {
     *     // ... filter to delete one OffersFullTime
     *   }
     * })
     * 
    **/
    delete<T extends OffersFullTimeDeleteArgs>(
      args: SelectSubset<T, OffersFullTimeDeleteArgs>
    ): CheckSelect<T, Prisma__OffersFullTimeClient<OffersFullTime>, Prisma__OffersFullTimeClient<OffersFullTimeGetPayload<T>>>

    /**
     * Update one OffersFullTime.
     * @param {OffersFullTimeUpdateArgs} args - Arguments to update one OffersFullTime.
     * @example
     * // Update one OffersFullTime
     * const offersFullTime = await prisma.offersFullTime.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OffersFullTimeUpdateArgs>(
      args: SelectSubset<T, OffersFullTimeUpdateArgs>
    ): CheckSelect<T, Prisma__OffersFullTimeClient<OffersFullTime>, Prisma__OffersFullTimeClient<OffersFullTimeGetPayload<T>>>

    /**
     * Delete zero or more OffersFullTimes.
     * @param {OffersFullTimeDeleteManyArgs} args - Arguments to filter OffersFullTimes to delete.
     * @example
     * // Delete a few OffersFullTimes
     * const { count } = await prisma.offersFullTime.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OffersFullTimeDeleteManyArgs>(
      args?: SelectSubset<T, OffersFullTimeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more OffersFullTimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersFullTimeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OffersFullTimes
     * const offersFullTime = await prisma.offersFullTime.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OffersFullTimeUpdateManyArgs>(
      args: SelectSubset<T, OffersFullTimeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one OffersFullTime.
     * @param {OffersFullTimeUpsertArgs} args - Arguments to update or create a OffersFullTime.
     * @example
     * // Update or create a OffersFullTime
     * const offersFullTime = await prisma.offersFullTime.upsert({
     *   create: {
     *     // ... data to create a OffersFullTime
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OffersFullTime we want to update
     *   }
     * })
    **/
    upsert<T extends OffersFullTimeUpsertArgs>(
      args: SelectSubset<T, OffersFullTimeUpsertArgs>
    ): CheckSelect<T, Prisma__OffersFullTimeClient<OffersFullTime>, Prisma__OffersFullTimeClient<OffersFullTimeGetPayload<T>>>

    /**
     * Find one OffersFullTime that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {OffersFullTimeFindUniqueOrThrowArgs} args - Arguments to find a OffersFullTime
     * @example
     * // Get one OffersFullTime
     * const offersFullTime = await prisma.offersFullTime.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OffersFullTimeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OffersFullTimeFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__OffersFullTimeClient<OffersFullTime>, Prisma__OffersFullTimeClient<OffersFullTimeGetPayload<T>>>

    /**
     * Find the first OffersFullTime that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersFullTimeFindFirstOrThrowArgs} args - Arguments to find a OffersFullTime
     * @example
     * // Get one OffersFullTime
     * const offersFullTime = await prisma.offersFullTime.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OffersFullTimeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OffersFullTimeFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__OffersFullTimeClient<OffersFullTime>, Prisma__OffersFullTimeClient<OffersFullTimeGetPayload<T>>>

    /**
     * Count the number of OffersFullTimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersFullTimeCountArgs} args - Arguments to filter OffersFullTimes to count.
     * @example
     * // Count the number of OffersFullTimes
     * const count = await prisma.offersFullTime.count({
     *   where: {
     *     // ... the filter for the OffersFullTimes we want to count
     *   }
     * })
    **/
    count<T extends OffersFullTimeCountArgs>(
      args?: Subset<T, OffersFullTimeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OffersFullTimeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OffersFullTime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersFullTimeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OffersFullTimeAggregateArgs>(args: Subset<T, OffersFullTimeAggregateArgs>): PrismaPromise<GetOffersFullTimeAggregateType<T>>

    /**
     * Group by OffersFullTime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersFullTimeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OffersFullTimeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OffersFullTimeGroupByArgs['orderBy'] }
        : { orderBy?: OffersFullTimeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OffersFullTimeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOffersFullTimeGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for OffersFullTime.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OffersFullTimeClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    totalCompensation<T extends OffersCurrencyArgs = {}>(args?: Subset<T, OffersCurrencyArgs>): CheckSelect<T, Prisma__OffersCurrencyClient<OffersCurrency | Null>, Prisma__OffersCurrencyClient<OffersCurrencyGetPayload<T> | Null>>;

    baseSalary<T extends OffersCurrencyArgs = {}>(args?: Subset<T, OffersCurrencyArgs>): CheckSelect<T, Prisma__OffersCurrencyClient<OffersCurrency | Null>, Prisma__OffersCurrencyClient<OffersCurrencyGetPayload<T> | Null>>;

    bonus<T extends OffersCurrencyArgs = {}>(args?: Subset<T, OffersCurrencyArgs>): CheckSelect<T, Prisma__OffersCurrencyClient<OffersCurrency | Null>, Prisma__OffersCurrencyClient<OffersCurrencyGetPayload<T> | Null>>;

    stocks<T extends OffersCurrencyArgs = {}>(args?: Subset<T, OffersCurrencyArgs>): CheckSelect<T, Prisma__OffersCurrencyClient<OffersCurrency | Null>, Prisma__OffersCurrencyClient<OffersCurrencyGetPayload<T> | Null>>;

    OffersOffer<T extends OffersOfferArgs = {}>(args?: Subset<T, OffersOfferArgs>): CheckSelect<T, Prisma__OffersOfferClient<OffersOffer | Null>, Prisma__OffersOfferClient<OffersOfferGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * OffersFullTime base type for findUnique actions
   */
  export type OffersFullTimeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the OffersFullTime
     * 
    **/
    select?: OffersFullTimeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersFullTimeInclude | null
    /**
     * Filter, which OffersFullTime to fetch.
     * 
    **/
    where: OffersFullTimeWhereUniqueInput
  }

  /**
   * OffersFullTime: findUnique
   */
  export interface OffersFullTimeFindUniqueArgs extends OffersFullTimeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OffersFullTime base type for findFirst actions
   */
  export type OffersFullTimeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the OffersFullTime
     * 
    **/
    select?: OffersFullTimeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersFullTimeInclude | null
    /**
     * Filter, which OffersFullTime to fetch.
     * 
    **/
    where?: OffersFullTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffersFullTimes to fetch.
     * 
    **/
    orderBy?: Enumerable<OffersFullTimeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OffersFullTimes.
     * 
    **/
    cursor?: OffersFullTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffersFullTimes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffersFullTimes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OffersFullTimes.
     * 
    **/
    distinct?: Enumerable<OffersFullTimeScalarFieldEnum>
  }

  /**
   * OffersFullTime: findFirst
   */
  export interface OffersFullTimeFindFirstArgs extends OffersFullTimeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OffersFullTime findMany
   */
  export type OffersFullTimeFindManyArgs = {
    /**
     * Select specific fields to fetch from the OffersFullTime
     * 
    **/
    select?: OffersFullTimeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersFullTimeInclude | null
    /**
     * Filter, which OffersFullTimes to fetch.
     * 
    **/
    where?: OffersFullTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffersFullTimes to fetch.
     * 
    **/
    orderBy?: Enumerable<OffersFullTimeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OffersFullTimes.
     * 
    **/
    cursor?: OffersFullTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffersFullTimes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffersFullTimes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OffersFullTimeScalarFieldEnum>
  }


  /**
   * OffersFullTime create
   */
  export type OffersFullTimeCreateArgs = {
    /**
     * Select specific fields to fetch from the OffersFullTime
     * 
    **/
    select?: OffersFullTimeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersFullTimeInclude | null
    /**
     * The data needed to create a OffersFullTime.
     * 
    **/
    data: XOR<OffersFullTimeCreateInput, OffersFullTimeUncheckedCreateInput>
  }


  /**
   * OffersFullTime createMany
   */
  export type OffersFullTimeCreateManyArgs = {
    /**
     * The data used to create many OffersFullTimes.
     * 
    **/
    data: Enumerable<OffersFullTimeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OffersFullTime update
   */
  export type OffersFullTimeUpdateArgs = {
    /**
     * Select specific fields to fetch from the OffersFullTime
     * 
    **/
    select?: OffersFullTimeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersFullTimeInclude | null
    /**
     * The data needed to update a OffersFullTime.
     * 
    **/
    data: XOR<OffersFullTimeUpdateInput, OffersFullTimeUncheckedUpdateInput>
    /**
     * Choose, which OffersFullTime to update.
     * 
    **/
    where: OffersFullTimeWhereUniqueInput
  }


  /**
   * OffersFullTime updateMany
   */
  export type OffersFullTimeUpdateManyArgs = {
    /**
     * The data used to update OffersFullTimes.
     * 
    **/
    data: XOR<OffersFullTimeUpdateManyMutationInput, OffersFullTimeUncheckedUpdateManyInput>
    /**
     * Filter which OffersFullTimes to update
     * 
    **/
    where?: OffersFullTimeWhereInput
  }


  /**
   * OffersFullTime upsert
   */
  export type OffersFullTimeUpsertArgs = {
    /**
     * Select specific fields to fetch from the OffersFullTime
     * 
    **/
    select?: OffersFullTimeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersFullTimeInclude | null
    /**
     * The filter to search for the OffersFullTime to update in case it exists.
     * 
    **/
    where: OffersFullTimeWhereUniqueInput
    /**
     * In case the OffersFullTime found by the `where` argument doesn't exist, create a new OffersFullTime with this data.
     * 
    **/
    create: XOR<OffersFullTimeCreateInput, OffersFullTimeUncheckedCreateInput>
    /**
     * In case the OffersFullTime was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OffersFullTimeUpdateInput, OffersFullTimeUncheckedUpdateInput>
  }


  /**
   * OffersFullTime delete
   */
  export type OffersFullTimeDeleteArgs = {
    /**
     * Select specific fields to fetch from the OffersFullTime
     * 
    **/
    select?: OffersFullTimeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersFullTimeInclude | null
    /**
     * Filter which OffersFullTime to delete.
     * 
    **/
    where: OffersFullTimeWhereUniqueInput
  }


  /**
   * OffersFullTime deleteMany
   */
  export type OffersFullTimeDeleteManyArgs = {
    /**
     * Filter which OffersFullTimes to delete
     * 
    **/
    where?: OffersFullTimeWhereInput
  }


  /**
   * OffersFullTime: findUniqueOrThrow
   */
  export type OffersFullTimeFindUniqueOrThrowArgs = OffersFullTimeFindUniqueArgsBase
      

  /**
   * OffersFullTime: findFirstOrThrow
   */
  export type OffersFullTimeFindFirstOrThrowArgs = OffersFullTimeFindFirstArgsBase
      

  /**
   * OffersFullTime without action
   */
  export type OffersFullTimeArgs = {
    /**
     * Select specific fields to fetch from the OffersFullTime
     * 
    **/
    select?: OffersFullTimeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersFullTimeInclude | null
  }



  /**
   * Model OffersAnalysis
   */


  export type AggregateOffersAnalysis = {
    _count: OffersAnalysisCountAggregateOutputType | null
    _min: OffersAnalysisMinAggregateOutputType | null
    _max: OffersAnalysisMaxAggregateOutputType | null
  }

  export type OffersAnalysisMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    profileId: string | null
    offerId: string | null
    overallAnalysisUnitId: string | null
  }

  export type OffersAnalysisMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    profileId: string | null
    offerId: string | null
    overallAnalysisUnitId: string | null
  }

  export type OffersAnalysisCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    profileId: number
    offerId: number
    overallAnalysisUnitId: number
    _all: number
  }


  export type OffersAnalysisMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    profileId?: true
    offerId?: true
    overallAnalysisUnitId?: true
  }

  export type OffersAnalysisMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    profileId?: true
    offerId?: true
    overallAnalysisUnitId?: true
  }

  export type OffersAnalysisCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    profileId?: true
    offerId?: true
    overallAnalysisUnitId?: true
    _all?: true
  }

  export type OffersAnalysisAggregateArgs = {
    /**
     * Filter which OffersAnalysis to aggregate.
     * 
    **/
    where?: OffersAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffersAnalyses to fetch.
     * 
    **/
    orderBy?: Enumerable<OffersAnalysisOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OffersAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffersAnalyses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffersAnalyses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OffersAnalyses
    **/
    _count?: true | OffersAnalysisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OffersAnalysisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OffersAnalysisMaxAggregateInputType
  }

  export type GetOffersAnalysisAggregateType<T extends OffersAnalysisAggregateArgs> = {
        [P in keyof T & keyof AggregateOffersAnalysis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOffersAnalysis[P]>
      : GetScalarType<T[P], AggregateOffersAnalysis[P]>
  }




  export type OffersAnalysisGroupByArgs = {
    where?: OffersAnalysisWhereInput
    orderBy?: Enumerable<OffersAnalysisOrderByWithAggregationInput>
    by: Array<OffersAnalysisScalarFieldEnum>
    having?: OffersAnalysisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OffersAnalysisCountAggregateInputType | true
    _min?: OffersAnalysisMinAggregateInputType
    _max?: OffersAnalysisMaxAggregateInputType
  }


  export type OffersAnalysisGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    profileId: string
    offerId: string
    overallAnalysisUnitId: string
    _count: OffersAnalysisCountAggregateOutputType | null
    _min: OffersAnalysisMinAggregateOutputType | null
    _max: OffersAnalysisMaxAggregateOutputType | null
  }

  type GetOffersAnalysisGroupByPayload<T extends OffersAnalysisGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OffersAnalysisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OffersAnalysisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OffersAnalysisGroupByOutputType[P]>
            : GetScalarType<T[P], OffersAnalysisGroupByOutputType[P]>
        }
      >
    >


  export type OffersAnalysisSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | OffersProfileArgs
    profileId?: boolean
    overallHighestOffer?: boolean | OffersOfferArgs
    offerId?: boolean
    overallAnalysis?: boolean | OffersAnalysisUnitArgs
    overallAnalysisUnitId?: boolean
    companyAnalysis?: boolean | OffersAnalysisUnitFindManyArgs
    _count?: boolean | OffersAnalysisCountOutputTypeArgs
  }

  export type OffersAnalysisInclude = {
    profile?: boolean | OffersProfileArgs
    overallHighestOffer?: boolean | OffersOfferArgs
    overallAnalysis?: boolean | OffersAnalysisUnitArgs
    companyAnalysis?: boolean | OffersAnalysisUnitFindManyArgs
    _count?: boolean | OffersAnalysisCountOutputTypeArgs
  }

  export type OffersAnalysisGetPayload<
    S extends boolean | null | undefined | OffersAnalysisArgs,
    U = keyof S
      > = S extends true
        ? OffersAnalysis
    : S extends undefined
    ? never
    : S extends OffersAnalysisArgs | OffersAnalysisFindManyArgs
    ?'include' extends U
    ? OffersAnalysis  & {
    [P in TrueKeys<S['include']>]:
        P extends 'profile' ? OffersProfileGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'overallHighestOffer' ? OffersOfferGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'overallAnalysis' ? OffersAnalysisUnitGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'companyAnalysis' ? Array < OffersAnalysisUnitGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? OffersAnalysisCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'profile' ? OffersProfileGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'overallHighestOffer' ? OffersOfferGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'overallAnalysis' ? OffersAnalysisUnitGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'companyAnalysis' ? Array < OffersAnalysisUnitGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? OffersAnalysisCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof OffersAnalysis ? OffersAnalysis[P] : never
  } 
    : OffersAnalysis
  : OffersAnalysis


  type OffersAnalysisCountArgs = Merge<
    Omit<OffersAnalysisFindManyArgs, 'select' | 'include'> & {
      select?: OffersAnalysisCountAggregateInputType | true
    }
  >

  export interface OffersAnalysisDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one OffersAnalysis that matches the filter.
     * @param {OffersAnalysisFindUniqueArgs} args - Arguments to find a OffersAnalysis
     * @example
     * // Get one OffersAnalysis
     * const offersAnalysis = await prisma.offersAnalysis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OffersAnalysisFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OffersAnalysisFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OffersAnalysis'> extends True ? CheckSelect<T, Prisma__OffersAnalysisClient<OffersAnalysis>, Prisma__OffersAnalysisClient<OffersAnalysisGetPayload<T>>> : CheckSelect<T, Prisma__OffersAnalysisClient<OffersAnalysis | null, null>, Prisma__OffersAnalysisClient<OffersAnalysisGetPayload<T> | null, null>>

    /**
     * Find the first OffersAnalysis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersAnalysisFindFirstArgs} args - Arguments to find a OffersAnalysis
     * @example
     * // Get one OffersAnalysis
     * const offersAnalysis = await prisma.offersAnalysis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OffersAnalysisFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OffersAnalysisFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OffersAnalysis'> extends True ? CheckSelect<T, Prisma__OffersAnalysisClient<OffersAnalysis>, Prisma__OffersAnalysisClient<OffersAnalysisGetPayload<T>>> : CheckSelect<T, Prisma__OffersAnalysisClient<OffersAnalysis | null, null>, Prisma__OffersAnalysisClient<OffersAnalysisGetPayload<T> | null, null>>

    /**
     * Find zero or more OffersAnalyses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersAnalysisFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OffersAnalyses
     * const offersAnalyses = await prisma.offersAnalysis.findMany()
     * 
     * // Get first 10 OffersAnalyses
     * const offersAnalyses = await prisma.offersAnalysis.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offersAnalysisWithIdOnly = await prisma.offersAnalysis.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OffersAnalysisFindManyArgs>(
      args?: SelectSubset<T, OffersAnalysisFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<OffersAnalysis>>, PrismaPromise<Array<OffersAnalysisGetPayload<T>>>>

    /**
     * Create a OffersAnalysis.
     * @param {OffersAnalysisCreateArgs} args - Arguments to create a OffersAnalysis.
     * @example
     * // Create one OffersAnalysis
     * const OffersAnalysis = await prisma.offersAnalysis.create({
     *   data: {
     *     // ... data to create a OffersAnalysis
     *   }
     * })
     * 
    **/
    create<T extends OffersAnalysisCreateArgs>(
      args: SelectSubset<T, OffersAnalysisCreateArgs>
    ): CheckSelect<T, Prisma__OffersAnalysisClient<OffersAnalysis>, Prisma__OffersAnalysisClient<OffersAnalysisGetPayload<T>>>

    /**
     * Create many OffersAnalyses.
     *     @param {OffersAnalysisCreateManyArgs} args - Arguments to create many OffersAnalyses.
     *     @example
     *     // Create many OffersAnalyses
     *     const offersAnalysis = await prisma.offersAnalysis.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OffersAnalysisCreateManyArgs>(
      args?: SelectSubset<T, OffersAnalysisCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a OffersAnalysis.
     * @param {OffersAnalysisDeleteArgs} args - Arguments to delete one OffersAnalysis.
     * @example
     * // Delete one OffersAnalysis
     * const OffersAnalysis = await prisma.offersAnalysis.delete({
     *   where: {
     *     // ... filter to delete one OffersAnalysis
     *   }
     * })
     * 
    **/
    delete<T extends OffersAnalysisDeleteArgs>(
      args: SelectSubset<T, OffersAnalysisDeleteArgs>
    ): CheckSelect<T, Prisma__OffersAnalysisClient<OffersAnalysis>, Prisma__OffersAnalysisClient<OffersAnalysisGetPayload<T>>>

    /**
     * Update one OffersAnalysis.
     * @param {OffersAnalysisUpdateArgs} args - Arguments to update one OffersAnalysis.
     * @example
     * // Update one OffersAnalysis
     * const offersAnalysis = await prisma.offersAnalysis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OffersAnalysisUpdateArgs>(
      args: SelectSubset<T, OffersAnalysisUpdateArgs>
    ): CheckSelect<T, Prisma__OffersAnalysisClient<OffersAnalysis>, Prisma__OffersAnalysisClient<OffersAnalysisGetPayload<T>>>

    /**
     * Delete zero or more OffersAnalyses.
     * @param {OffersAnalysisDeleteManyArgs} args - Arguments to filter OffersAnalyses to delete.
     * @example
     * // Delete a few OffersAnalyses
     * const { count } = await prisma.offersAnalysis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OffersAnalysisDeleteManyArgs>(
      args?: SelectSubset<T, OffersAnalysisDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more OffersAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersAnalysisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OffersAnalyses
     * const offersAnalysis = await prisma.offersAnalysis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OffersAnalysisUpdateManyArgs>(
      args: SelectSubset<T, OffersAnalysisUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one OffersAnalysis.
     * @param {OffersAnalysisUpsertArgs} args - Arguments to update or create a OffersAnalysis.
     * @example
     * // Update or create a OffersAnalysis
     * const offersAnalysis = await prisma.offersAnalysis.upsert({
     *   create: {
     *     // ... data to create a OffersAnalysis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OffersAnalysis we want to update
     *   }
     * })
    **/
    upsert<T extends OffersAnalysisUpsertArgs>(
      args: SelectSubset<T, OffersAnalysisUpsertArgs>
    ): CheckSelect<T, Prisma__OffersAnalysisClient<OffersAnalysis>, Prisma__OffersAnalysisClient<OffersAnalysisGetPayload<T>>>

    /**
     * Find one OffersAnalysis that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {OffersAnalysisFindUniqueOrThrowArgs} args - Arguments to find a OffersAnalysis
     * @example
     * // Get one OffersAnalysis
     * const offersAnalysis = await prisma.offersAnalysis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OffersAnalysisFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OffersAnalysisFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__OffersAnalysisClient<OffersAnalysis>, Prisma__OffersAnalysisClient<OffersAnalysisGetPayload<T>>>

    /**
     * Find the first OffersAnalysis that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersAnalysisFindFirstOrThrowArgs} args - Arguments to find a OffersAnalysis
     * @example
     * // Get one OffersAnalysis
     * const offersAnalysis = await prisma.offersAnalysis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OffersAnalysisFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OffersAnalysisFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__OffersAnalysisClient<OffersAnalysis>, Prisma__OffersAnalysisClient<OffersAnalysisGetPayload<T>>>

    /**
     * Count the number of OffersAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersAnalysisCountArgs} args - Arguments to filter OffersAnalyses to count.
     * @example
     * // Count the number of OffersAnalyses
     * const count = await prisma.offersAnalysis.count({
     *   where: {
     *     // ... the filter for the OffersAnalyses we want to count
     *   }
     * })
    **/
    count<T extends OffersAnalysisCountArgs>(
      args?: Subset<T, OffersAnalysisCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OffersAnalysisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OffersAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersAnalysisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OffersAnalysisAggregateArgs>(args: Subset<T, OffersAnalysisAggregateArgs>): PrismaPromise<GetOffersAnalysisAggregateType<T>>

    /**
     * Group by OffersAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersAnalysisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OffersAnalysisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OffersAnalysisGroupByArgs['orderBy'] }
        : { orderBy?: OffersAnalysisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OffersAnalysisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOffersAnalysisGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for OffersAnalysis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OffersAnalysisClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    profile<T extends OffersProfileArgs = {}>(args?: Subset<T, OffersProfileArgs>): CheckSelect<T, Prisma__OffersProfileClient<OffersProfile | Null>, Prisma__OffersProfileClient<OffersProfileGetPayload<T> | Null>>;

    overallHighestOffer<T extends OffersOfferArgs = {}>(args?: Subset<T, OffersOfferArgs>): CheckSelect<T, Prisma__OffersOfferClient<OffersOffer | Null>, Prisma__OffersOfferClient<OffersOfferGetPayload<T> | Null>>;

    overallAnalysis<T extends OffersAnalysisUnitArgs = {}>(args?: Subset<T, OffersAnalysisUnitArgs>): CheckSelect<T, Prisma__OffersAnalysisUnitClient<OffersAnalysisUnit | Null>, Prisma__OffersAnalysisUnitClient<OffersAnalysisUnitGetPayload<T> | Null>>;

    companyAnalysis<T extends OffersAnalysisUnitFindManyArgs = {}>(args?: Subset<T, OffersAnalysisUnitFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OffersAnalysisUnit>| Null>, PrismaPromise<Array<OffersAnalysisUnitGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * OffersAnalysis base type for findUnique actions
   */
  export type OffersAnalysisFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the OffersAnalysis
     * 
    **/
    select?: OffersAnalysisSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersAnalysisInclude | null
    /**
     * Filter, which OffersAnalysis to fetch.
     * 
    **/
    where: OffersAnalysisWhereUniqueInput
  }

  /**
   * OffersAnalysis: findUnique
   */
  export interface OffersAnalysisFindUniqueArgs extends OffersAnalysisFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OffersAnalysis base type for findFirst actions
   */
  export type OffersAnalysisFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the OffersAnalysis
     * 
    **/
    select?: OffersAnalysisSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersAnalysisInclude | null
    /**
     * Filter, which OffersAnalysis to fetch.
     * 
    **/
    where?: OffersAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffersAnalyses to fetch.
     * 
    **/
    orderBy?: Enumerable<OffersAnalysisOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OffersAnalyses.
     * 
    **/
    cursor?: OffersAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffersAnalyses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffersAnalyses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OffersAnalyses.
     * 
    **/
    distinct?: Enumerable<OffersAnalysisScalarFieldEnum>
  }

  /**
   * OffersAnalysis: findFirst
   */
  export interface OffersAnalysisFindFirstArgs extends OffersAnalysisFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OffersAnalysis findMany
   */
  export type OffersAnalysisFindManyArgs = {
    /**
     * Select specific fields to fetch from the OffersAnalysis
     * 
    **/
    select?: OffersAnalysisSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersAnalysisInclude | null
    /**
     * Filter, which OffersAnalyses to fetch.
     * 
    **/
    where?: OffersAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffersAnalyses to fetch.
     * 
    **/
    orderBy?: Enumerable<OffersAnalysisOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OffersAnalyses.
     * 
    **/
    cursor?: OffersAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffersAnalyses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffersAnalyses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OffersAnalysisScalarFieldEnum>
  }


  /**
   * OffersAnalysis create
   */
  export type OffersAnalysisCreateArgs = {
    /**
     * Select specific fields to fetch from the OffersAnalysis
     * 
    **/
    select?: OffersAnalysisSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersAnalysisInclude | null
    /**
     * The data needed to create a OffersAnalysis.
     * 
    **/
    data: XOR<OffersAnalysisCreateInput, OffersAnalysisUncheckedCreateInput>
  }


  /**
   * OffersAnalysis createMany
   */
  export type OffersAnalysisCreateManyArgs = {
    /**
     * The data used to create many OffersAnalyses.
     * 
    **/
    data: Enumerable<OffersAnalysisCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OffersAnalysis update
   */
  export type OffersAnalysisUpdateArgs = {
    /**
     * Select specific fields to fetch from the OffersAnalysis
     * 
    **/
    select?: OffersAnalysisSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersAnalysisInclude | null
    /**
     * The data needed to update a OffersAnalysis.
     * 
    **/
    data: XOR<OffersAnalysisUpdateInput, OffersAnalysisUncheckedUpdateInput>
    /**
     * Choose, which OffersAnalysis to update.
     * 
    **/
    where: OffersAnalysisWhereUniqueInput
  }


  /**
   * OffersAnalysis updateMany
   */
  export type OffersAnalysisUpdateManyArgs = {
    /**
     * The data used to update OffersAnalyses.
     * 
    **/
    data: XOR<OffersAnalysisUpdateManyMutationInput, OffersAnalysisUncheckedUpdateManyInput>
    /**
     * Filter which OffersAnalyses to update
     * 
    **/
    where?: OffersAnalysisWhereInput
  }


  /**
   * OffersAnalysis upsert
   */
  export type OffersAnalysisUpsertArgs = {
    /**
     * Select specific fields to fetch from the OffersAnalysis
     * 
    **/
    select?: OffersAnalysisSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersAnalysisInclude | null
    /**
     * The filter to search for the OffersAnalysis to update in case it exists.
     * 
    **/
    where: OffersAnalysisWhereUniqueInput
    /**
     * In case the OffersAnalysis found by the `where` argument doesn't exist, create a new OffersAnalysis with this data.
     * 
    **/
    create: XOR<OffersAnalysisCreateInput, OffersAnalysisUncheckedCreateInput>
    /**
     * In case the OffersAnalysis was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OffersAnalysisUpdateInput, OffersAnalysisUncheckedUpdateInput>
  }


  /**
   * OffersAnalysis delete
   */
  export type OffersAnalysisDeleteArgs = {
    /**
     * Select specific fields to fetch from the OffersAnalysis
     * 
    **/
    select?: OffersAnalysisSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersAnalysisInclude | null
    /**
     * Filter which OffersAnalysis to delete.
     * 
    **/
    where: OffersAnalysisWhereUniqueInput
  }


  /**
   * OffersAnalysis deleteMany
   */
  export type OffersAnalysisDeleteManyArgs = {
    /**
     * Filter which OffersAnalyses to delete
     * 
    **/
    where?: OffersAnalysisWhereInput
  }


  /**
   * OffersAnalysis: findUniqueOrThrow
   */
  export type OffersAnalysisFindUniqueOrThrowArgs = OffersAnalysisFindUniqueArgsBase
      

  /**
   * OffersAnalysis: findFirstOrThrow
   */
  export type OffersAnalysisFindFirstOrThrowArgs = OffersAnalysisFindFirstArgsBase
      

  /**
   * OffersAnalysis without action
   */
  export type OffersAnalysisArgs = {
    /**
     * Select specific fields to fetch from the OffersAnalysis
     * 
    **/
    select?: OffersAnalysisSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersAnalysisInclude | null
  }



  /**
   * Model OffersAnalysisUnit
   */


  export type AggregateOffersAnalysisUnit = {
    _count: OffersAnalysisUnitCountAggregateOutputType | null
    _avg: OffersAnalysisUnitAvgAggregateOutputType | null
    _sum: OffersAnalysisUnitSumAggregateOutputType | null
    _min: OffersAnalysisUnitMinAggregateOutputType | null
    _max: OffersAnalysisUnitMaxAggregateOutputType | null
  }

  export type OffersAnalysisUnitAvgAggregateOutputType = {
    percentile: number | null
    noOfSimilarOffers: number | null
  }

  export type OffersAnalysisUnitSumAggregateOutputType = {
    percentile: number | null
    noOfSimilarOffers: number | null
  }

  export type OffersAnalysisUnitMinAggregateOutputType = {
    id: string | null
    analysedOfferId: string | null
    percentile: number | null
    noOfSimilarOffers: number | null
  }

  export type OffersAnalysisUnitMaxAggregateOutputType = {
    id: string | null
    analysedOfferId: string | null
    percentile: number | null
    noOfSimilarOffers: number | null
  }

  export type OffersAnalysisUnitCountAggregateOutputType = {
    id: number
    analysedOfferId: number
    percentile: number
    noOfSimilarOffers: number
    _all: number
  }


  export type OffersAnalysisUnitAvgAggregateInputType = {
    percentile?: true
    noOfSimilarOffers?: true
  }

  export type OffersAnalysisUnitSumAggregateInputType = {
    percentile?: true
    noOfSimilarOffers?: true
  }

  export type OffersAnalysisUnitMinAggregateInputType = {
    id?: true
    analysedOfferId?: true
    percentile?: true
    noOfSimilarOffers?: true
  }

  export type OffersAnalysisUnitMaxAggregateInputType = {
    id?: true
    analysedOfferId?: true
    percentile?: true
    noOfSimilarOffers?: true
  }

  export type OffersAnalysisUnitCountAggregateInputType = {
    id?: true
    analysedOfferId?: true
    percentile?: true
    noOfSimilarOffers?: true
    _all?: true
  }

  export type OffersAnalysisUnitAggregateArgs = {
    /**
     * Filter which OffersAnalysisUnit to aggregate.
     * 
    **/
    where?: OffersAnalysisUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffersAnalysisUnits to fetch.
     * 
    **/
    orderBy?: Enumerable<OffersAnalysisUnitOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OffersAnalysisUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffersAnalysisUnits from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffersAnalysisUnits.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OffersAnalysisUnits
    **/
    _count?: true | OffersAnalysisUnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OffersAnalysisUnitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OffersAnalysisUnitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OffersAnalysisUnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OffersAnalysisUnitMaxAggregateInputType
  }

  export type GetOffersAnalysisUnitAggregateType<T extends OffersAnalysisUnitAggregateArgs> = {
        [P in keyof T & keyof AggregateOffersAnalysisUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOffersAnalysisUnit[P]>
      : GetScalarType<T[P], AggregateOffersAnalysisUnit[P]>
  }




  export type OffersAnalysisUnitGroupByArgs = {
    where?: OffersAnalysisUnitWhereInput
    orderBy?: Enumerable<OffersAnalysisUnitOrderByWithAggregationInput>
    by: Array<OffersAnalysisUnitScalarFieldEnum>
    having?: OffersAnalysisUnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OffersAnalysisUnitCountAggregateInputType | true
    _avg?: OffersAnalysisUnitAvgAggregateInputType
    _sum?: OffersAnalysisUnitSumAggregateInputType
    _min?: OffersAnalysisUnitMinAggregateInputType
    _max?: OffersAnalysisUnitMaxAggregateInputType
  }


  export type OffersAnalysisUnitGroupByOutputType = {
    id: string
    analysedOfferId: string
    percentile: number
    noOfSimilarOffers: number
    _count: OffersAnalysisUnitCountAggregateOutputType | null
    _avg: OffersAnalysisUnitAvgAggregateOutputType | null
    _sum: OffersAnalysisUnitSumAggregateOutputType | null
    _min: OffersAnalysisUnitMinAggregateOutputType | null
    _max: OffersAnalysisUnitMaxAggregateOutputType | null
  }

  type GetOffersAnalysisUnitGroupByPayload<T extends OffersAnalysisUnitGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OffersAnalysisUnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OffersAnalysisUnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OffersAnalysisUnitGroupByOutputType[P]>
            : GetScalarType<T[P], OffersAnalysisUnitGroupByOutputType[P]>
        }
      >
    >


  export type OffersAnalysisUnitSelect = {
    id?: boolean
    analysedOffer?: boolean | OffersOfferArgs
    analysedOfferId?: boolean
    percentile?: boolean
    noOfSimilarOffers?: boolean
    topSimilarOffers?: boolean | OffersOfferFindManyArgs
    offersAnalysisOverall?: boolean | OffersAnalysisFindManyArgs
    offersAnalysisCompany?: boolean | OffersAnalysisFindManyArgs
    _count?: boolean | OffersAnalysisUnitCountOutputTypeArgs
  }

  export type OffersAnalysisUnitInclude = {
    analysedOffer?: boolean | OffersOfferArgs
    topSimilarOffers?: boolean | OffersOfferFindManyArgs
    offersAnalysisOverall?: boolean | OffersAnalysisFindManyArgs
    offersAnalysisCompany?: boolean | OffersAnalysisFindManyArgs
    _count?: boolean | OffersAnalysisUnitCountOutputTypeArgs
  }

  export type OffersAnalysisUnitGetPayload<
    S extends boolean | null | undefined | OffersAnalysisUnitArgs,
    U = keyof S
      > = S extends true
        ? OffersAnalysisUnit
    : S extends undefined
    ? never
    : S extends OffersAnalysisUnitArgs | OffersAnalysisUnitFindManyArgs
    ?'include' extends U
    ? OffersAnalysisUnit  & {
    [P in TrueKeys<S['include']>]:
        P extends 'analysedOffer' ? OffersOfferGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'topSimilarOffers' ? Array < OffersOfferGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'offersAnalysisOverall' ? Array < OffersAnalysisGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'offersAnalysisCompany' ? Array < OffersAnalysisGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? OffersAnalysisUnitCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'analysedOffer' ? OffersOfferGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'topSimilarOffers' ? Array < OffersOfferGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'offersAnalysisOverall' ? Array < OffersAnalysisGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'offersAnalysisCompany' ? Array < OffersAnalysisGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? OffersAnalysisUnitCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof OffersAnalysisUnit ? OffersAnalysisUnit[P] : never
  } 
    : OffersAnalysisUnit
  : OffersAnalysisUnit


  type OffersAnalysisUnitCountArgs = Merge<
    Omit<OffersAnalysisUnitFindManyArgs, 'select' | 'include'> & {
      select?: OffersAnalysisUnitCountAggregateInputType | true
    }
  >

  export interface OffersAnalysisUnitDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one OffersAnalysisUnit that matches the filter.
     * @param {OffersAnalysisUnitFindUniqueArgs} args - Arguments to find a OffersAnalysisUnit
     * @example
     * // Get one OffersAnalysisUnit
     * const offersAnalysisUnit = await prisma.offersAnalysisUnit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OffersAnalysisUnitFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OffersAnalysisUnitFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OffersAnalysisUnit'> extends True ? CheckSelect<T, Prisma__OffersAnalysisUnitClient<OffersAnalysisUnit>, Prisma__OffersAnalysisUnitClient<OffersAnalysisUnitGetPayload<T>>> : CheckSelect<T, Prisma__OffersAnalysisUnitClient<OffersAnalysisUnit | null, null>, Prisma__OffersAnalysisUnitClient<OffersAnalysisUnitGetPayload<T> | null, null>>

    /**
     * Find the first OffersAnalysisUnit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersAnalysisUnitFindFirstArgs} args - Arguments to find a OffersAnalysisUnit
     * @example
     * // Get one OffersAnalysisUnit
     * const offersAnalysisUnit = await prisma.offersAnalysisUnit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OffersAnalysisUnitFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OffersAnalysisUnitFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OffersAnalysisUnit'> extends True ? CheckSelect<T, Prisma__OffersAnalysisUnitClient<OffersAnalysisUnit>, Prisma__OffersAnalysisUnitClient<OffersAnalysisUnitGetPayload<T>>> : CheckSelect<T, Prisma__OffersAnalysisUnitClient<OffersAnalysisUnit | null, null>, Prisma__OffersAnalysisUnitClient<OffersAnalysisUnitGetPayload<T> | null, null>>

    /**
     * Find zero or more OffersAnalysisUnits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersAnalysisUnitFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OffersAnalysisUnits
     * const offersAnalysisUnits = await prisma.offersAnalysisUnit.findMany()
     * 
     * // Get first 10 OffersAnalysisUnits
     * const offersAnalysisUnits = await prisma.offersAnalysisUnit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offersAnalysisUnitWithIdOnly = await prisma.offersAnalysisUnit.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OffersAnalysisUnitFindManyArgs>(
      args?: SelectSubset<T, OffersAnalysisUnitFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<OffersAnalysisUnit>>, PrismaPromise<Array<OffersAnalysisUnitGetPayload<T>>>>

    /**
     * Create a OffersAnalysisUnit.
     * @param {OffersAnalysisUnitCreateArgs} args - Arguments to create a OffersAnalysisUnit.
     * @example
     * // Create one OffersAnalysisUnit
     * const OffersAnalysisUnit = await prisma.offersAnalysisUnit.create({
     *   data: {
     *     // ... data to create a OffersAnalysisUnit
     *   }
     * })
     * 
    **/
    create<T extends OffersAnalysisUnitCreateArgs>(
      args: SelectSubset<T, OffersAnalysisUnitCreateArgs>
    ): CheckSelect<T, Prisma__OffersAnalysisUnitClient<OffersAnalysisUnit>, Prisma__OffersAnalysisUnitClient<OffersAnalysisUnitGetPayload<T>>>

    /**
     * Create many OffersAnalysisUnits.
     *     @param {OffersAnalysisUnitCreateManyArgs} args - Arguments to create many OffersAnalysisUnits.
     *     @example
     *     // Create many OffersAnalysisUnits
     *     const offersAnalysisUnit = await prisma.offersAnalysisUnit.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OffersAnalysisUnitCreateManyArgs>(
      args?: SelectSubset<T, OffersAnalysisUnitCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a OffersAnalysisUnit.
     * @param {OffersAnalysisUnitDeleteArgs} args - Arguments to delete one OffersAnalysisUnit.
     * @example
     * // Delete one OffersAnalysisUnit
     * const OffersAnalysisUnit = await prisma.offersAnalysisUnit.delete({
     *   where: {
     *     // ... filter to delete one OffersAnalysisUnit
     *   }
     * })
     * 
    **/
    delete<T extends OffersAnalysisUnitDeleteArgs>(
      args: SelectSubset<T, OffersAnalysisUnitDeleteArgs>
    ): CheckSelect<T, Prisma__OffersAnalysisUnitClient<OffersAnalysisUnit>, Prisma__OffersAnalysisUnitClient<OffersAnalysisUnitGetPayload<T>>>

    /**
     * Update one OffersAnalysisUnit.
     * @param {OffersAnalysisUnitUpdateArgs} args - Arguments to update one OffersAnalysisUnit.
     * @example
     * // Update one OffersAnalysisUnit
     * const offersAnalysisUnit = await prisma.offersAnalysisUnit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OffersAnalysisUnitUpdateArgs>(
      args: SelectSubset<T, OffersAnalysisUnitUpdateArgs>
    ): CheckSelect<T, Prisma__OffersAnalysisUnitClient<OffersAnalysisUnit>, Prisma__OffersAnalysisUnitClient<OffersAnalysisUnitGetPayload<T>>>

    /**
     * Delete zero or more OffersAnalysisUnits.
     * @param {OffersAnalysisUnitDeleteManyArgs} args - Arguments to filter OffersAnalysisUnits to delete.
     * @example
     * // Delete a few OffersAnalysisUnits
     * const { count } = await prisma.offersAnalysisUnit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OffersAnalysisUnitDeleteManyArgs>(
      args?: SelectSubset<T, OffersAnalysisUnitDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more OffersAnalysisUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersAnalysisUnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OffersAnalysisUnits
     * const offersAnalysisUnit = await prisma.offersAnalysisUnit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OffersAnalysisUnitUpdateManyArgs>(
      args: SelectSubset<T, OffersAnalysisUnitUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one OffersAnalysisUnit.
     * @param {OffersAnalysisUnitUpsertArgs} args - Arguments to update or create a OffersAnalysisUnit.
     * @example
     * // Update or create a OffersAnalysisUnit
     * const offersAnalysisUnit = await prisma.offersAnalysisUnit.upsert({
     *   create: {
     *     // ... data to create a OffersAnalysisUnit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OffersAnalysisUnit we want to update
     *   }
     * })
    **/
    upsert<T extends OffersAnalysisUnitUpsertArgs>(
      args: SelectSubset<T, OffersAnalysisUnitUpsertArgs>
    ): CheckSelect<T, Prisma__OffersAnalysisUnitClient<OffersAnalysisUnit>, Prisma__OffersAnalysisUnitClient<OffersAnalysisUnitGetPayload<T>>>

    /**
     * Find one OffersAnalysisUnit that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {OffersAnalysisUnitFindUniqueOrThrowArgs} args - Arguments to find a OffersAnalysisUnit
     * @example
     * // Get one OffersAnalysisUnit
     * const offersAnalysisUnit = await prisma.offersAnalysisUnit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OffersAnalysisUnitFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OffersAnalysisUnitFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__OffersAnalysisUnitClient<OffersAnalysisUnit>, Prisma__OffersAnalysisUnitClient<OffersAnalysisUnitGetPayload<T>>>

    /**
     * Find the first OffersAnalysisUnit that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersAnalysisUnitFindFirstOrThrowArgs} args - Arguments to find a OffersAnalysisUnit
     * @example
     * // Get one OffersAnalysisUnit
     * const offersAnalysisUnit = await prisma.offersAnalysisUnit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OffersAnalysisUnitFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OffersAnalysisUnitFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__OffersAnalysisUnitClient<OffersAnalysisUnit>, Prisma__OffersAnalysisUnitClient<OffersAnalysisUnitGetPayload<T>>>

    /**
     * Count the number of OffersAnalysisUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersAnalysisUnitCountArgs} args - Arguments to filter OffersAnalysisUnits to count.
     * @example
     * // Count the number of OffersAnalysisUnits
     * const count = await prisma.offersAnalysisUnit.count({
     *   where: {
     *     // ... the filter for the OffersAnalysisUnits we want to count
     *   }
     * })
    **/
    count<T extends OffersAnalysisUnitCountArgs>(
      args?: Subset<T, OffersAnalysisUnitCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OffersAnalysisUnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OffersAnalysisUnit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersAnalysisUnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OffersAnalysisUnitAggregateArgs>(args: Subset<T, OffersAnalysisUnitAggregateArgs>): PrismaPromise<GetOffersAnalysisUnitAggregateType<T>>

    /**
     * Group by OffersAnalysisUnit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersAnalysisUnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OffersAnalysisUnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OffersAnalysisUnitGroupByArgs['orderBy'] }
        : { orderBy?: OffersAnalysisUnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OffersAnalysisUnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOffersAnalysisUnitGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for OffersAnalysisUnit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OffersAnalysisUnitClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    analysedOffer<T extends OffersOfferArgs = {}>(args?: Subset<T, OffersOfferArgs>): CheckSelect<T, Prisma__OffersOfferClient<OffersOffer | Null>, Prisma__OffersOfferClient<OffersOfferGetPayload<T> | Null>>;

    topSimilarOffers<T extends OffersOfferFindManyArgs = {}>(args?: Subset<T, OffersOfferFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OffersOffer>| Null>, PrismaPromise<Array<OffersOfferGetPayload<T>>| Null>>;

    offersAnalysisOverall<T extends OffersAnalysisFindManyArgs = {}>(args?: Subset<T, OffersAnalysisFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OffersAnalysis>| Null>, PrismaPromise<Array<OffersAnalysisGetPayload<T>>| Null>>;

    offersAnalysisCompany<T extends OffersAnalysisFindManyArgs = {}>(args?: Subset<T, OffersAnalysisFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OffersAnalysis>| Null>, PrismaPromise<Array<OffersAnalysisGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * OffersAnalysisUnit base type for findUnique actions
   */
  export type OffersAnalysisUnitFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the OffersAnalysisUnit
     * 
    **/
    select?: OffersAnalysisUnitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersAnalysisUnitInclude | null
    /**
     * Filter, which OffersAnalysisUnit to fetch.
     * 
    **/
    where: OffersAnalysisUnitWhereUniqueInput
  }

  /**
   * OffersAnalysisUnit: findUnique
   */
  export interface OffersAnalysisUnitFindUniqueArgs extends OffersAnalysisUnitFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OffersAnalysisUnit base type for findFirst actions
   */
  export type OffersAnalysisUnitFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the OffersAnalysisUnit
     * 
    **/
    select?: OffersAnalysisUnitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersAnalysisUnitInclude | null
    /**
     * Filter, which OffersAnalysisUnit to fetch.
     * 
    **/
    where?: OffersAnalysisUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffersAnalysisUnits to fetch.
     * 
    **/
    orderBy?: Enumerable<OffersAnalysisUnitOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OffersAnalysisUnits.
     * 
    **/
    cursor?: OffersAnalysisUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffersAnalysisUnits from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffersAnalysisUnits.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OffersAnalysisUnits.
     * 
    **/
    distinct?: Enumerable<OffersAnalysisUnitScalarFieldEnum>
  }

  /**
   * OffersAnalysisUnit: findFirst
   */
  export interface OffersAnalysisUnitFindFirstArgs extends OffersAnalysisUnitFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OffersAnalysisUnit findMany
   */
  export type OffersAnalysisUnitFindManyArgs = {
    /**
     * Select specific fields to fetch from the OffersAnalysisUnit
     * 
    **/
    select?: OffersAnalysisUnitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersAnalysisUnitInclude | null
    /**
     * Filter, which OffersAnalysisUnits to fetch.
     * 
    **/
    where?: OffersAnalysisUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffersAnalysisUnits to fetch.
     * 
    **/
    orderBy?: Enumerable<OffersAnalysisUnitOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OffersAnalysisUnits.
     * 
    **/
    cursor?: OffersAnalysisUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffersAnalysisUnits from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffersAnalysisUnits.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OffersAnalysisUnitScalarFieldEnum>
  }


  /**
   * OffersAnalysisUnit create
   */
  export type OffersAnalysisUnitCreateArgs = {
    /**
     * Select specific fields to fetch from the OffersAnalysisUnit
     * 
    **/
    select?: OffersAnalysisUnitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersAnalysisUnitInclude | null
    /**
     * The data needed to create a OffersAnalysisUnit.
     * 
    **/
    data: XOR<OffersAnalysisUnitCreateInput, OffersAnalysisUnitUncheckedCreateInput>
  }


  /**
   * OffersAnalysisUnit createMany
   */
  export type OffersAnalysisUnitCreateManyArgs = {
    /**
     * The data used to create many OffersAnalysisUnits.
     * 
    **/
    data: Enumerable<OffersAnalysisUnitCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OffersAnalysisUnit update
   */
  export type OffersAnalysisUnitUpdateArgs = {
    /**
     * Select specific fields to fetch from the OffersAnalysisUnit
     * 
    **/
    select?: OffersAnalysisUnitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersAnalysisUnitInclude | null
    /**
     * The data needed to update a OffersAnalysisUnit.
     * 
    **/
    data: XOR<OffersAnalysisUnitUpdateInput, OffersAnalysisUnitUncheckedUpdateInput>
    /**
     * Choose, which OffersAnalysisUnit to update.
     * 
    **/
    where: OffersAnalysisUnitWhereUniqueInput
  }


  /**
   * OffersAnalysisUnit updateMany
   */
  export type OffersAnalysisUnitUpdateManyArgs = {
    /**
     * The data used to update OffersAnalysisUnits.
     * 
    **/
    data: XOR<OffersAnalysisUnitUpdateManyMutationInput, OffersAnalysisUnitUncheckedUpdateManyInput>
    /**
     * Filter which OffersAnalysisUnits to update
     * 
    **/
    where?: OffersAnalysisUnitWhereInput
  }


  /**
   * OffersAnalysisUnit upsert
   */
  export type OffersAnalysisUnitUpsertArgs = {
    /**
     * Select specific fields to fetch from the OffersAnalysisUnit
     * 
    **/
    select?: OffersAnalysisUnitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersAnalysisUnitInclude | null
    /**
     * The filter to search for the OffersAnalysisUnit to update in case it exists.
     * 
    **/
    where: OffersAnalysisUnitWhereUniqueInput
    /**
     * In case the OffersAnalysisUnit found by the `where` argument doesn't exist, create a new OffersAnalysisUnit with this data.
     * 
    **/
    create: XOR<OffersAnalysisUnitCreateInput, OffersAnalysisUnitUncheckedCreateInput>
    /**
     * In case the OffersAnalysisUnit was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OffersAnalysisUnitUpdateInput, OffersAnalysisUnitUncheckedUpdateInput>
  }


  /**
   * OffersAnalysisUnit delete
   */
  export type OffersAnalysisUnitDeleteArgs = {
    /**
     * Select specific fields to fetch from the OffersAnalysisUnit
     * 
    **/
    select?: OffersAnalysisUnitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersAnalysisUnitInclude | null
    /**
     * Filter which OffersAnalysisUnit to delete.
     * 
    **/
    where: OffersAnalysisUnitWhereUniqueInput
  }


  /**
   * OffersAnalysisUnit deleteMany
   */
  export type OffersAnalysisUnitDeleteManyArgs = {
    /**
     * Filter which OffersAnalysisUnits to delete
     * 
    **/
    where?: OffersAnalysisUnitWhereInput
  }


  /**
   * OffersAnalysisUnit: findUniqueOrThrow
   */
  export type OffersAnalysisUnitFindUniqueOrThrowArgs = OffersAnalysisUnitFindUniqueArgsBase
      

  /**
   * OffersAnalysisUnit: findFirstOrThrow
   */
  export type OffersAnalysisUnitFindFirstOrThrowArgs = OffersAnalysisUnitFindFirstArgsBase
      

  /**
   * OffersAnalysisUnit without action
   */
  export type OffersAnalysisUnitArgs = {
    /**
     * Select specific fields to fetch from the OffersAnalysisUnit
     * 
    **/
    select?: OffersAnalysisUnitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OffersAnalysisUnitInclude | null
  }



  /**
   * Model QuestionsQuestion
   */


  export type AggregateQuestionsQuestion = {
    _count: QuestionsQuestionCountAggregateOutputType | null
    _avg: QuestionsQuestionAvgAggregateOutputType | null
    _sum: QuestionsQuestionSumAggregateOutputType | null
    _min: QuestionsQuestionMinAggregateOutputType | null
    _max: QuestionsQuestionMaxAggregateOutputType | null
  }

  export type QuestionsQuestionAvgAggregateOutputType = {
    upvotes: number | null
    numEncounters: number | null
  }

  export type QuestionsQuestionSumAggregateOutputType = {
    upvotes: number | null
    numEncounters: number | null
  }

  export type QuestionsQuestionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    content: string | null
    questionType: QuestionsQuestionType | null
    lastSeenAt: Date | null
    upvotes: number | null
    numEncounters: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionsQuestionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    content: string | null
    questionType: QuestionsQuestionType | null
    lastSeenAt: Date | null
    upvotes: number | null
    numEncounters: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionsQuestionCountAggregateOutputType = {
    id: number
    userId: number
    content: number
    questionType: number
    lastSeenAt: number
    upvotes: number
    numEncounters: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuestionsQuestionAvgAggregateInputType = {
    upvotes?: true
    numEncounters?: true
  }

  export type QuestionsQuestionSumAggregateInputType = {
    upvotes?: true
    numEncounters?: true
  }

  export type QuestionsQuestionMinAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    questionType?: true
    lastSeenAt?: true
    upvotes?: true
    numEncounters?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionsQuestionMaxAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    questionType?: true
    lastSeenAt?: true
    upvotes?: true
    numEncounters?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionsQuestionCountAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    questionType?: true
    lastSeenAt?: true
    upvotes?: true
    numEncounters?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuestionsQuestionAggregateArgs = {
    /**
     * Filter which QuestionsQuestion to aggregate.
     * 
    **/
    where?: QuestionsQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsQuestions to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionsQuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: QuestionsQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsQuestions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsQuestions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestionsQuestions
    **/
    _count?: true | QuestionsQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionsQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionsQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionsQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionsQuestionMaxAggregateInputType
  }

  export type GetQuestionsQuestionAggregateType<T extends QuestionsQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionsQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionsQuestion[P]>
      : GetScalarType<T[P], AggregateQuestionsQuestion[P]>
  }




  export type QuestionsQuestionGroupByArgs = {
    where?: QuestionsQuestionWhereInput
    orderBy?: Enumerable<QuestionsQuestionOrderByWithAggregationInput>
    by: Array<QuestionsQuestionScalarFieldEnum>
    having?: QuestionsQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionsQuestionCountAggregateInputType | true
    _avg?: QuestionsQuestionAvgAggregateInputType
    _sum?: QuestionsQuestionSumAggregateInputType
    _min?: QuestionsQuestionMinAggregateInputType
    _max?: QuestionsQuestionMaxAggregateInputType
  }


  export type QuestionsQuestionGroupByOutputType = {
    id: string
    userId: string | null
    content: string
    questionType: QuestionsQuestionType
    lastSeenAt: Date | null
    upvotes: number
    numEncounters: number
    createdAt: Date
    updatedAt: Date
    _count: QuestionsQuestionCountAggregateOutputType | null
    _avg: QuestionsQuestionAvgAggregateOutputType | null
    _sum: QuestionsQuestionSumAggregateOutputType | null
    _min: QuestionsQuestionMinAggregateOutputType | null
    _max: QuestionsQuestionMaxAggregateOutputType | null
  }

  type GetQuestionsQuestionGroupByPayload<T extends QuestionsQuestionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<QuestionsQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionsQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionsQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionsQuestionGroupByOutputType[P]>
        }
      >
    >


  export type QuestionsQuestionSelect = {
    id?: boolean
    userId?: boolean
    content?: boolean
    questionType?: boolean
    lastSeenAt?: boolean
    upvotes?: boolean
    numEncounters?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs
    encounters?: boolean | QuestionsQuestionEncounterFindManyArgs
    votes?: boolean | QuestionsQuestionVoteFindManyArgs
    comments?: boolean | QuestionsQuestionCommentFindManyArgs
    answers?: boolean | QuestionsAnswerFindManyArgs
    questionsListQuestionEntries?: boolean | QuestionsListQuestionEntryFindManyArgs
    _count?: boolean | QuestionsQuestionCountOutputTypeArgs
  }

  export type QuestionsQuestionInclude = {
    user?: boolean | UserArgs
    encounters?: boolean | QuestionsQuestionEncounterFindManyArgs
    votes?: boolean | QuestionsQuestionVoteFindManyArgs
    comments?: boolean | QuestionsQuestionCommentFindManyArgs
    answers?: boolean | QuestionsAnswerFindManyArgs
    questionsListQuestionEntries?: boolean | QuestionsListQuestionEntryFindManyArgs
    _count?: boolean | QuestionsQuestionCountOutputTypeArgs
  }

  export type QuestionsQuestionGetPayload<
    S extends boolean | null | undefined | QuestionsQuestionArgs,
    U = keyof S
      > = S extends true
        ? QuestionsQuestion
    : S extends undefined
    ? never
    : S extends QuestionsQuestionArgs | QuestionsQuestionFindManyArgs
    ?'include' extends U
    ? QuestionsQuestion  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'encounters' ? Array < QuestionsQuestionEncounterGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'votes' ? Array < QuestionsQuestionVoteGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'comments' ? Array < QuestionsQuestionCommentGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'answers' ? Array < QuestionsAnswerGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'questionsListQuestionEntries' ? Array < QuestionsListQuestionEntryGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? QuestionsQuestionCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'encounters' ? Array < QuestionsQuestionEncounterGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'votes' ? Array < QuestionsQuestionVoteGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'comments' ? Array < QuestionsQuestionCommentGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'answers' ? Array < QuestionsAnswerGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'questionsListQuestionEntries' ? Array < QuestionsListQuestionEntryGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? QuestionsQuestionCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof QuestionsQuestion ? QuestionsQuestion[P] : never
  } 
    : QuestionsQuestion
  : QuestionsQuestion


  type QuestionsQuestionCountArgs = Merge<
    Omit<QuestionsQuestionFindManyArgs, 'select' | 'include'> & {
      select?: QuestionsQuestionCountAggregateInputType | true
    }
  >

  export interface QuestionsQuestionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one QuestionsQuestion that matches the filter.
     * @param {QuestionsQuestionFindUniqueArgs} args - Arguments to find a QuestionsQuestion
     * @example
     * // Get one QuestionsQuestion
     * const questionsQuestion = await prisma.questionsQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuestionsQuestionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QuestionsQuestionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'QuestionsQuestion'> extends True ? CheckSelect<T, Prisma__QuestionsQuestionClient<QuestionsQuestion>, Prisma__QuestionsQuestionClient<QuestionsQuestionGetPayload<T>>> : CheckSelect<T, Prisma__QuestionsQuestionClient<QuestionsQuestion | null, null>, Prisma__QuestionsQuestionClient<QuestionsQuestionGetPayload<T> | null, null>>

    /**
     * Find the first QuestionsQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsQuestionFindFirstArgs} args - Arguments to find a QuestionsQuestion
     * @example
     * // Get one QuestionsQuestion
     * const questionsQuestion = await prisma.questionsQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuestionsQuestionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QuestionsQuestionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'QuestionsQuestion'> extends True ? CheckSelect<T, Prisma__QuestionsQuestionClient<QuestionsQuestion>, Prisma__QuestionsQuestionClient<QuestionsQuestionGetPayload<T>>> : CheckSelect<T, Prisma__QuestionsQuestionClient<QuestionsQuestion | null, null>, Prisma__QuestionsQuestionClient<QuestionsQuestionGetPayload<T> | null, null>>

    /**
     * Find zero or more QuestionsQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsQuestionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionsQuestions
     * const questionsQuestions = await prisma.questionsQuestion.findMany()
     * 
     * // Get first 10 QuestionsQuestions
     * const questionsQuestions = await prisma.questionsQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionsQuestionWithIdOnly = await prisma.questionsQuestion.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuestionsQuestionFindManyArgs>(
      args?: SelectSubset<T, QuestionsQuestionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<QuestionsQuestion>>, PrismaPromise<Array<QuestionsQuestionGetPayload<T>>>>

    /**
     * Create a QuestionsQuestion.
     * @param {QuestionsQuestionCreateArgs} args - Arguments to create a QuestionsQuestion.
     * @example
     * // Create one QuestionsQuestion
     * const QuestionsQuestion = await prisma.questionsQuestion.create({
     *   data: {
     *     // ... data to create a QuestionsQuestion
     *   }
     * })
     * 
    **/
    create<T extends QuestionsQuestionCreateArgs>(
      args: SelectSubset<T, QuestionsQuestionCreateArgs>
    ): CheckSelect<T, Prisma__QuestionsQuestionClient<QuestionsQuestion>, Prisma__QuestionsQuestionClient<QuestionsQuestionGetPayload<T>>>

    /**
     * Create many QuestionsQuestions.
     *     @param {QuestionsQuestionCreateManyArgs} args - Arguments to create many QuestionsQuestions.
     *     @example
     *     // Create many QuestionsQuestions
     *     const questionsQuestion = await prisma.questionsQuestion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuestionsQuestionCreateManyArgs>(
      args?: SelectSubset<T, QuestionsQuestionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a QuestionsQuestion.
     * @param {QuestionsQuestionDeleteArgs} args - Arguments to delete one QuestionsQuestion.
     * @example
     * // Delete one QuestionsQuestion
     * const QuestionsQuestion = await prisma.questionsQuestion.delete({
     *   where: {
     *     // ... filter to delete one QuestionsQuestion
     *   }
     * })
     * 
    **/
    delete<T extends QuestionsQuestionDeleteArgs>(
      args: SelectSubset<T, QuestionsQuestionDeleteArgs>
    ): CheckSelect<T, Prisma__QuestionsQuestionClient<QuestionsQuestion>, Prisma__QuestionsQuestionClient<QuestionsQuestionGetPayload<T>>>

    /**
     * Update one QuestionsQuestion.
     * @param {QuestionsQuestionUpdateArgs} args - Arguments to update one QuestionsQuestion.
     * @example
     * // Update one QuestionsQuestion
     * const questionsQuestion = await prisma.questionsQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuestionsQuestionUpdateArgs>(
      args: SelectSubset<T, QuestionsQuestionUpdateArgs>
    ): CheckSelect<T, Prisma__QuestionsQuestionClient<QuestionsQuestion>, Prisma__QuestionsQuestionClient<QuestionsQuestionGetPayload<T>>>

    /**
     * Delete zero or more QuestionsQuestions.
     * @param {QuestionsQuestionDeleteManyArgs} args - Arguments to filter QuestionsQuestions to delete.
     * @example
     * // Delete a few QuestionsQuestions
     * const { count } = await prisma.questionsQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuestionsQuestionDeleteManyArgs>(
      args?: SelectSubset<T, QuestionsQuestionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionsQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionsQuestions
     * const questionsQuestion = await prisma.questionsQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuestionsQuestionUpdateManyArgs>(
      args: SelectSubset<T, QuestionsQuestionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one QuestionsQuestion.
     * @param {QuestionsQuestionUpsertArgs} args - Arguments to update or create a QuestionsQuestion.
     * @example
     * // Update or create a QuestionsQuestion
     * const questionsQuestion = await prisma.questionsQuestion.upsert({
     *   create: {
     *     // ... data to create a QuestionsQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionsQuestion we want to update
     *   }
     * })
    **/
    upsert<T extends QuestionsQuestionUpsertArgs>(
      args: SelectSubset<T, QuestionsQuestionUpsertArgs>
    ): CheckSelect<T, Prisma__QuestionsQuestionClient<QuestionsQuestion>, Prisma__QuestionsQuestionClient<QuestionsQuestionGetPayload<T>>>

    /**
     * Find one QuestionsQuestion that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {QuestionsQuestionFindUniqueOrThrowArgs} args - Arguments to find a QuestionsQuestion
     * @example
     * // Get one QuestionsQuestion
     * const questionsQuestion = await prisma.questionsQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuestionsQuestionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, QuestionsQuestionFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__QuestionsQuestionClient<QuestionsQuestion>, Prisma__QuestionsQuestionClient<QuestionsQuestionGetPayload<T>>>

    /**
     * Find the first QuestionsQuestion that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsQuestionFindFirstOrThrowArgs} args - Arguments to find a QuestionsQuestion
     * @example
     * // Get one QuestionsQuestion
     * const questionsQuestion = await prisma.questionsQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuestionsQuestionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, QuestionsQuestionFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__QuestionsQuestionClient<QuestionsQuestion>, Prisma__QuestionsQuestionClient<QuestionsQuestionGetPayload<T>>>

    /**
     * Count the number of QuestionsQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsQuestionCountArgs} args - Arguments to filter QuestionsQuestions to count.
     * @example
     * // Count the number of QuestionsQuestions
     * const count = await prisma.questionsQuestion.count({
     *   where: {
     *     // ... the filter for the QuestionsQuestions we want to count
     *   }
     * })
    **/
    count<T extends QuestionsQuestionCountArgs>(
      args?: Subset<T, QuestionsQuestionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionsQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionsQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionsQuestionAggregateArgs>(args: Subset<T, QuestionsQuestionAggregateArgs>): PrismaPromise<GetQuestionsQuestionAggregateType<T>>

    /**
     * Group by QuestionsQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionsQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionsQuestionGroupByArgs['orderBy'] }
        : { orderBy?: QuestionsQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionsQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionsQuestionGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestionsQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QuestionsQuestionClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    encounters<T extends QuestionsQuestionEncounterFindManyArgs = {}>(args?: Subset<T, QuestionsQuestionEncounterFindManyArgs>): CheckSelect<T, PrismaPromise<Array<QuestionsQuestionEncounter>| Null>, PrismaPromise<Array<QuestionsQuestionEncounterGetPayload<T>>| Null>>;

    votes<T extends QuestionsQuestionVoteFindManyArgs = {}>(args?: Subset<T, QuestionsQuestionVoteFindManyArgs>): CheckSelect<T, PrismaPromise<Array<QuestionsQuestionVote>| Null>, PrismaPromise<Array<QuestionsQuestionVoteGetPayload<T>>| Null>>;

    comments<T extends QuestionsQuestionCommentFindManyArgs = {}>(args?: Subset<T, QuestionsQuestionCommentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<QuestionsQuestionComment>| Null>, PrismaPromise<Array<QuestionsQuestionCommentGetPayload<T>>| Null>>;

    answers<T extends QuestionsAnswerFindManyArgs = {}>(args?: Subset<T, QuestionsAnswerFindManyArgs>): CheckSelect<T, PrismaPromise<Array<QuestionsAnswer>| Null>, PrismaPromise<Array<QuestionsAnswerGetPayload<T>>| Null>>;

    questionsListQuestionEntries<T extends QuestionsListQuestionEntryFindManyArgs = {}>(args?: Subset<T, QuestionsListQuestionEntryFindManyArgs>): CheckSelect<T, PrismaPromise<Array<QuestionsListQuestionEntry>| Null>, PrismaPromise<Array<QuestionsListQuestionEntryGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * QuestionsQuestion base type for findUnique actions
   */
  export type QuestionsQuestionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the QuestionsQuestion
     * 
    **/
    select?: QuestionsQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsQuestionInclude | null
    /**
     * Filter, which QuestionsQuestion to fetch.
     * 
    **/
    where: QuestionsQuestionWhereUniqueInput
  }

  /**
   * QuestionsQuestion: findUnique
   */
  export interface QuestionsQuestionFindUniqueArgs extends QuestionsQuestionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuestionsQuestion base type for findFirst actions
   */
  export type QuestionsQuestionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the QuestionsQuestion
     * 
    **/
    select?: QuestionsQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsQuestionInclude | null
    /**
     * Filter, which QuestionsQuestion to fetch.
     * 
    **/
    where?: QuestionsQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsQuestions to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionsQuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionsQuestions.
     * 
    **/
    cursor?: QuestionsQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsQuestions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsQuestions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionsQuestions.
     * 
    **/
    distinct?: Enumerable<QuestionsQuestionScalarFieldEnum>
  }

  /**
   * QuestionsQuestion: findFirst
   */
  export interface QuestionsQuestionFindFirstArgs extends QuestionsQuestionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuestionsQuestion findMany
   */
  export type QuestionsQuestionFindManyArgs = {
    /**
     * Select specific fields to fetch from the QuestionsQuestion
     * 
    **/
    select?: QuestionsQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsQuestionInclude | null
    /**
     * Filter, which QuestionsQuestions to fetch.
     * 
    **/
    where?: QuestionsQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsQuestions to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionsQuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestionsQuestions.
     * 
    **/
    cursor?: QuestionsQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsQuestions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsQuestions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<QuestionsQuestionScalarFieldEnum>
  }


  /**
   * QuestionsQuestion create
   */
  export type QuestionsQuestionCreateArgs = {
    /**
     * Select specific fields to fetch from the QuestionsQuestion
     * 
    **/
    select?: QuestionsQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsQuestionInclude | null
    /**
     * The data needed to create a QuestionsQuestion.
     * 
    **/
    data: XOR<QuestionsQuestionCreateInput, QuestionsQuestionUncheckedCreateInput>
  }


  /**
   * QuestionsQuestion createMany
   */
  export type QuestionsQuestionCreateManyArgs = {
    /**
     * The data used to create many QuestionsQuestions.
     * 
    **/
    data: Enumerable<QuestionsQuestionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * QuestionsQuestion update
   */
  export type QuestionsQuestionUpdateArgs = {
    /**
     * Select specific fields to fetch from the QuestionsQuestion
     * 
    **/
    select?: QuestionsQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsQuestionInclude | null
    /**
     * The data needed to update a QuestionsQuestion.
     * 
    **/
    data: XOR<QuestionsQuestionUpdateInput, QuestionsQuestionUncheckedUpdateInput>
    /**
     * Choose, which QuestionsQuestion to update.
     * 
    **/
    where: QuestionsQuestionWhereUniqueInput
  }


  /**
   * QuestionsQuestion updateMany
   */
  export type QuestionsQuestionUpdateManyArgs = {
    /**
     * The data used to update QuestionsQuestions.
     * 
    **/
    data: XOR<QuestionsQuestionUpdateManyMutationInput, QuestionsQuestionUncheckedUpdateManyInput>
    /**
     * Filter which QuestionsQuestions to update
     * 
    **/
    where?: QuestionsQuestionWhereInput
  }


  /**
   * QuestionsQuestion upsert
   */
  export type QuestionsQuestionUpsertArgs = {
    /**
     * Select specific fields to fetch from the QuestionsQuestion
     * 
    **/
    select?: QuestionsQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsQuestionInclude | null
    /**
     * The filter to search for the QuestionsQuestion to update in case it exists.
     * 
    **/
    where: QuestionsQuestionWhereUniqueInput
    /**
     * In case the QuestionsQuestion found by the `where` argument doesn't exist, create a new QuestionsQuestion with this data.
     * 
    **/
    create: XOR<QuestionsQuestionCreateInput, QuestionsQuestionUncheckedCreateInput>
    /**
     * In case the QuestionsQuestion was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<QuestionsQuestionUpdateInput, QuestionsQuestionUncheckedUpdateInput>
  }


  /**
   * QuestionsQuestion delete
   */
  export type QuestionsQuestionDeleteArgs = {
    /**
     * Select specific fields to fetch from the QuestionsQuestion
     * 
    **/
    select?: QuestionsQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsQuestionInclude | null
    /**
     * Filter which QuestionsQuestion to delete.
     * 
    **/
    where: QuestionsQuestionWhereUniqueInput
  }


  /**
   * QuestionsQuestion deleteMany
   */
  export type QuestionsQuestionDeleteManyArgs = {
    /**
     * Filter which QuestionsQuestions to delete
     * 
    **/
    where?: QuestionsQuestionWhereInput
  }


  /**
   * QuestionsQuestion: findUniqueOrThrow
   */
  export type QuestionsQuestionFindUniqueOrThrowArgs = QuestionsQuestionFindUniqueArgsBase
      

  /**
   * QuestionsQuestion: findFirstOrThrow
   */
  export type QuestionsQuestionFindFirstOrThrowArgs = QuestionsQuestionFindFirstArgsBase
      

  /**
   * QuestionsQuestion without action
   */
  export type QuestionsQuestionArgs = {
    /**
     * Select specific fields to fetch from the QuestionsQuestion
     * 
    **/
    select?: QuestionsQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsQuestionInclude | null
  }



  /**
   * Model QuestionsQuestionEncounter
   */


  export type AggregateQuestionsQuestionEncounter = {
    _count: QuestionsQuestionEncounterCountAggregateOutputType | null
    _min: QuestionsQuestionEncounterMinAggregateOutputType | null
    _max: QuestionsQuestionEncounterMaxAggregateOutputType | null
  }

  export type QuestionsQuestionEncounterMinAggregateOutputType = {
    id: string | null
    questionId: string | null
    userId: string | null
    companyId: string | null
    countryId: string | null
    stateId: string | null
    cityId: string | null
    role: string | null
    seenAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionsQuestionEncounterMaxAggregateOutputType = {
    id: string | null
    questionId: string | null
    userId: string | null
    companyId: string | null
    countryId: string | null
    stateId: string | null
    cityId: string | null
    role: string | null
    seenAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionsQuestionEncounterCountAggregateOutputType = {
    id: number
    questionId: number
    userId: number
    companyId: number
    countryId: number
    stateId: number
    cityId: number
    role: number
    seenAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuestionsQuestionEncounterMinAggregateInputType = {
    id?: true
    questionId?: true
    userId?: true
    companyId?: true
    countryId?: true
    stateId?: true
    cityId?: true
    role?: true
    seenAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionsQuestionEncounterMaxAggregateInputType = {
    id?: true
    questionId?: true
    userId?: true
    companyId?: true
    countryId?: true
    stateId?: true
    cityId?: true
    role?: true
    seenAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionsQuestionEncounterCountAggregateInputType = {
    id?: true
    questionId?: true
    userId?: true
    companyId?: true
    countryId?: true
    stateId?: true
    cityId?: true
    role?: true
    seenAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuestionsQuestionEncounterAggregateArgs = {
    /**
     * Filter which QuestionsQuestionEncounter to aggregate.
     * 
    **/
    where?: QuestionsQuestionEncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsQuestionEncounters to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionsQuestionEncounterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: QuestionsQuestionEncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsQuestionEncounters from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsQuestionEncounters.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestionsQuestionEncounters
    **/
    _count?: true | QuestionsQuestionEncounterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionsQuestionEncounterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionsQuestionEncounterMaxAggregateInputType
  }

  export type GetQuestionsQuestionEncounterAggregateType<T extends QuestionsQuestionEncounterAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionsQuestionEncounter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionsQuestionEncounter[P]>
      : GetScalarType<T[P], AggregateQuestionsQuestionEncounter[P]>
  }




  export type QuestionsQuestionEncounterGroupByArgs = {
    where?: QuestionsQuestionEncounterWhereInput
    orderBy?: Enumerable<QuestionsQuestionEncounterOrderByWithAggregationInput>
    by: Array<QuestionsQuestionEncounterScalarFieldEnum>
    having?: QuestionsQuestionEncounterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionsQuestionEncounterCountAggregateInputType | true
    _min?: QuestionsQuestionEncounterMinAggregateInputType
    _max?: QuestionsQuestionEncounterMaxAggregateInputType
  }


  export type QuestionsQuestionEncounterGroupByOutputType = {
    id: string
    questionId: string
    userId: string | null
    companyId: string | null
    countryId: string | null
    stateId: string | null
    cityId: string | null
    role: string
    seenAt: Date
    createdAt: Date
    updatedAt: Date
    _count: QuestionsQuestionEncounterCountAggregateOutputType | null
    _min: QuestionsQuestionEncounterMinAggregateOutputType | null
    _max: QuestionsQuestionEncounterMaxAggregateOutputType | null
  }

  type GetQuestionsQuestionEncounterGroupByPayload<T extends QuestionsQuestionEncounterGroupByArgs> = PrismaPromise<
    Array<
      PickArray<QuestionsQuestionEncounterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionsQuestionEncounterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionsQuestionEncounterGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionsQuestionEncounterGroupByOutputType[P]>
        }
      >
    >


  export type QuestionsQuestionEncounterSelect = {
    id?: boolean
    questionId?: boolean
    userId?: boolean
    companyId?: boolean
    countryId?: boolean
    stateId?: boolean
    cityId?: boolean
    role?: boolean
    seenAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    country?: boolean | CountryArgs
    state?: boolean | StateArgs
    city?: boolean | CityArgs
    company?: boolean | CompanyArgs
    user?: boolean | UserArgs
    question?: boolean | QuestionsQuestionArgs
  }

  export type QuestionsQuestionEncounterInclude = {
    country?: boolean | CountryArgs
    state?: boolean | StateArgs
    city?: boolean | CityArgs
    company?: boolean | CompanyArgs
    user?: boolean | UserArgs
    question?: boolean | QuestionsQuestionArgs
  }

  export type QuestionsQuestionEncounterGetPayload<
    S extends boolean | null | undefined | QuestionsQuestionEncounterArgs,
    U = keyof S
      > = S extends true
        ? QuestionsQuestionEncounter
    : S extends undefined
    ? never
    : S extends QuestionsQuestionEncounterArgs | QuestionsQuestionEncounterFindManyArgs
    ?'include' extends U
    ? QuestionsQuestionEncounter  & {
    [P in TrueKeys<S['include']>]:
        P extends 'country' ? CountryGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'state' ? StateGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'city' ? CityGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'company' ? CompanyGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'question' ? QuestionsQuestionGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'country' ? CountryGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'state' ? StateGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'city' ? CityGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'company' ? CompanyGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'question' ? QuestionsQuestionGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof QuestionsQuestionEncounter ? QuestionsQuestionEncounter[P] : never
  } 
    : QuestionsQuestionEncounter
  : QuestionsQuestionEncounter


  type QuestionsQuestionEncounterCountArgs = Merge<
    Omit<QuestionsQuestionEncounterFindManyArgs, 'select' | 'include'> & {
      select?: QuestionsQuestionEncounterCountAggregateInputType | true
    }
  >

  export interface QuestionsQuestionEncounterDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one QuestionsQuestionEncounter that matches the filter.
     * @param {QuestionsQuestionEncounterFindUniqueArgs} args - Arguments to find a QuestionsQuestionEncounter
     * @example
     * // Get one QuestionsQuestionEncounter
     * const questionsQuestionEncounter = await prisma.questionsQuestionEncounter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuestionsQuestionEncounterFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QuestionsQuestionEncounterFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'QuestionsQuestionEncounter'> extends True ? CheckSelect<T, Prisma__QuestionsQuestionEncounterClient<QuestionsQuestionEncounter>, Prisma__QuestionsQuestionEncounterClient<QuestionsQuestionEncounterGetPayload<T>>> : CheckSelect<T, Prisma__QuestionsQuestionEncounterClient<QuestionsQuestionEncounter | null, null>, Prisma__QuestionsQuestionEncounterClient<QuestionsQuestionEncounterGetPayload<T> | null, null>>

    /**
     * Find the first QuestionsQuestionEncounter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsQuestionEncounterFindFirstArgs} args - Arguments to find a QuestionsQuestionEncounter
     * @example
     * // Get one QuestionsQuestionEncounter
     * const questionsQuestionEncounter = await prisma.questionsQuestionEncounter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuestionsQuestionEncounterFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QuestionsQuestionEncounterFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'QuestionsQuestionEncounter'> extends True ? CheckSelect<T, Prisma__QuestionsQuestionEncounterClient<QuestionsQuestionEncounter>, Prisma__QuestionsQuestionEncounterClient<QuestionsQuestionEncounterGetPayload<T>>> : CheckSelect<T, Prisma__QuestionsQuestionEncounterClient<QuestionsQuestionEncounter | null, null>, Prisma__QuestionsQuestionEncounterClient<QuestionsQuestionEncounterGetPayload<T> | null, null>>

    /**
     * Find zero or more QuestionsQuestionEncounters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsQuestionEncounterFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionsQuestionEncounters
     * const questionsQuestionEncounters = await prisma.questionsQuestionEncounter.findMany()
     * 
     * // Get first 10 QuestionsQuestionEncounters
     * const questionsQuestionEncounters = await prisma.questionsQuestionEncounter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionsQuestionEncounterWithIdOnly = await prisma.questionsQuestionEncounter.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuestionsQuestionEncounterFindManyArgs>(
      args?: SelectSubset<T, QuestionsQuestionEncounterFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<QuestionsQuestionEncounter>>, PrismaPromise<Array<QuestionsQuestionEncounterGetPayload<T>>>>

    /**
     * Create a QuestionsQuestionEncounter.
     * @param {QuestionsQuestionEncounterCreateArgs} args - Arguments to create a QuestionsQuestionEncounter.
     * @example
     * // Create one QuestionsQuestionEncounter
     * const QuestionsQuestionEncounter = await prisma.questionsQuestionEncounter.create({
     *   data: {
     *     // ... data to create a QuestionsQuestionEncounter
     *   }
     * })
     * 
    **/
    create<T extends QuestionsQuestionEncounterCreateArgs>(
      args: SelectSubset<T, QuestionsQuestionEncounterCreateArgs>
    ): CheckSelect<T, Prisma__QuestionsQuestionEncounterClient<QuestionsQuestionEncounter>, Prisma__QuestionsQuestionEncounterClient<QuestionsQuestionEncounterGetPayload<T>>>

    /**
     * Create many QuestionsQuestionEncounters.
     *     @param {QuestionsQuestionEncounterCreateManyArgs} args - Arguments to create many QuestionsQuestionEncounters.
     *     @example
     *     // Create many QuestionsQuestionEncounters
     *     const questionsQuestionEncounter = await prisma.questionsQuestionEncounter.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuestionsQuestionEncounterCreateManyArgs>(
      args?: SelectSubset<T, QuestionsQuestionEncounterCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a QuestionsQuestionEncounter.
     * @param {QuestionsQuestionEncounterDeleteArgs} args - Arguments to delete one QuestionsQuestionEncounter.
     * @example
     * // Delete one QuestionsQuestionEncounter
     * const QuestionsQuestionEncounter = await prisma.questionsQuestionEncounter.delete({
     *   where: {
     *     // ... filter to delete one QuestionsQuestionEncounter
     *   }
     * })
     * 
    **/
    delete<T extends QuestionsQuestionEncounterDeleteArgs>(
      args: SelectSubset<T, QuestionsQuestionEncounterDeleteArgs>
    ): CheckSelect<T, Prisma__QuestionsQuestionEncounterClient<QuestionsQuestionEncounter>, Prisma__QuestionsQuestionEncounterClient<QuestionsQuestionEncounterGetPayload<T>>>

    /**
     * Update one QuestionsQuestionEncounter.
     * @param {QuestionsQuestionEncounterUpdateArgs} args - Arguments to update one QuestionsQuestionEncounter.
     * @example
     * // Update one QuestionsQuestionEncounter
     * const questionsQuestionEncounter = await prisma.questionsQuestionEncounter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuestionsQuestionEncounterUpdateArgs>(
      args: SelectSubset<T, QuestionsQuestionEncounterUpdateArgs>
    ): CheckSelect<T, Prisma__QuestionsQuestionEncounterClient<QuestionsQuestionEncounter>, Prisma__QuestionsQuestionEncounterClient<QuestionsQuestionEncounterGetPayload<T>>>

    /**
     * Delete zero or more QuestionsQuestionEncounters.
     * @param {QuestionsQuestionEncounterDeleteManyArgs} args - Arguments to filter QuestionsQuestionEncounters to delete.
     * @example
     * // Delete a few QuestionsQuestionEncounters
     * const { count } = await prisma.questionsQuestionEncounter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuestionsQuestionEncounterDeleteManyArgs>(
      args?: SelectSubset<T, QuestionsQuestionEncounterDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionsQuestionEncounters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsQuestionEncounterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionsQuestionEncounters
     * const questionsQuestionEncounter = await prisma.questionsQuestionEncounter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuestionsQuestionEncounterUpdateManyArgs>(
      args: SelectSubset<T, QuestionsQuestionEncounterUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one QuestionsQuestionEncounter.
     * @param {QuestionsQuestionEncounterUpsertArgs} args - Arguments to update or create a QuestionsQuestionEncounter.
     * @example
     * // Update or create a QuestionsQuestionEncounter
     * const questionsQuestionEncounter = await prisma.questionsQuestionEncounter.upsert({
     *   create: {
     *     // ... data to create a QuestionsQuestionEncounter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionsQuestionEncounter we want to update
     *   }
     * })
    **/
    upsert<T extends QuestionsQuestionEncounterUpsertArgs>(
      args: SelectSubset<T, QuestionsQuestionEncounterUpsertArgs>
    ): CheckSelect<T, Prisma__QuestionsQuestionEncounterClient<QuestionsQuestionEncounter>, Prisma__QuestionsQuestionEncounterClient<QuestionsQuestionEncounterGetPayload<T>>>

    /**
     * Find one QuestionsQuestionEncounter that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {QuestionsQuestionEncounterFindUniqueOrThrowArgs} args - Arguments to find a QuestionsQuestionEncounter
     * @example
     * // Get one QuestionsQuestionEncounter
     * const questionsQuestionEncounter = await prisma.questionsQuestionEncounter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuestionsQuestionEncounterFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, QuestionsQuestionEncounterFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__QuestionsQuestionEncounterClient<QuestionsQuestionEncounter>, Prisma__QuestionsQuestionEncounterClient<QuestionsQuestionEncounterGetPayload<T>>>

    /**
     * Find the first QuestionsQuestionEncounter that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsQuestionEncounterFindFirstOrThrowArgs} args - Arguments to find a QuestionsQuestionEncounter
     * @example
     * // Get one QuestionsQuestionEncounter
     * const questionsQuestionEncounter = await prisma.questionsQuestionEncounter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuestionsQuestionEncounterFindFirstOrThrowArgs>(
      args?: SelectSubset<T, QuestionsQuestionEncounterFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__QuestionsQuestionEncounterClient<QuestionsQuestionEncounter>, Prisma__QuestionsQuestionEncounterClient<QuestionsQuestionEncounterGetPayload<T>>>

    /**
     * Count the number of QuestionsQuestionEncounters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsQuestionEncounterCountArgs} args - Arguments to filter QuestionsQuestionEncounters to count.
     * @example
     * // Count the number of QuestionsQuestionEncounters
     * const count = await prisma.questionsQuestionEncounter.count({
     *   where: {
     *     // ... the filter for the QuestionsQuestionEncounters we want to count
     *   }
     * })
    **/
    count<T extends QuestionsQuestionEncounterCountArgs>(
      args?: Subset<T, QuestionsQuestionEncounterCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionsQuestionEncounterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionsQuestionEncounter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsQuestionEncounterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionsQuestionEncounterAggregateArgs>(args: Subset<T, QuestionsQuestionEncounterAggregateArgs>): PrismaPromise<GetQuestionsQuestionEncounterAggregateType<T>>

    /**
     * Group by QuestionsQuestionEncounter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsQuestionEncounterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionsQuestionEncounterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionsQuestionEncounterGroupByArgs['orderBy'] }
        : { orderBy?: QuestionsQuestionEncounterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionsQuestionEncounterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionsQuestionEncounterGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestionsQuestionEncounter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QuestionsQuestionEncounterClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    country<T extends CountryArgs = {}>(args?: Subset<T, CountryArgs>): CheckSelect<T, Prisma__CountryClient<Country | Null>, Prisma__CountryClient<CountryGetPayload<T> | Null>>;

    state<T extends StateArgs = {}>(args?: Subset<T, StateArgs>): CheckSelect<T, Prisma__StateClient<State | Null>, Prisma__StateClient<StateGetPayload<T> | Null>>;

    city<T extends CityArgs = {}>(args?: Subset<T, CityArgs>): CheckSelect<T, Prisma__CityClient<City | Null>, Prisma__CityClient<CityGetPayload<T> | Null>>;

    company<T extends CompanyArgs = {}>(args?: Subset<T, CompanyArgs>): CheckSelect<T, Prisma__CompanyClient<Company | Null>, Prisma__CompanyClient<CompanyGetPayload<T> | Null>>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    question<T extends QuestionsQuestionArgs = {}>(args?: Subset<T, QuestionsQuestionArgs>): CheckSelect<T, Prisma__QuestionsQuestionClient<QuestionsQuestion | Null>, Prisma__QuestionsQuestionClient<QuestionsQuestionGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * QuestionsQuestionEncounter base type for findUnique actions
   */
  export type QuestionsQuestionEncounterFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the QuestionsQuestionEncounter
     * 
    **/
    select?: QuestionsQuestionEncounterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsQuestionEncounterInclude | null
    /**
     * Filter, which QuestionsQuestionEncounter to fetch.
     * 
    **/
    where: QuestionsQuestionEncounterWhereUniqueInput
  }

  /**
   * QuestionsQuestionEncounter: findUnique
   */
  export interface QuestionsQuestionEncounterFindUniqueArgs extends QuestionsQuestionEncounterFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuestionsQuestionEncounter base type for findFirst actions
   */
  export type QuestionsQuestionEncounterFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the QuestionsQuestionEncounter
     * 
    **/
    select?: QuestionsQuestionEncounterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsQuestionEncounterInclude | null
    /**
     * Filter, which QuestionsQuestionEncounter to fetch.
     * 
    **/
    where?: QuestionsQuestionEncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsQuestionEncounters to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionsQuestionEncounterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionsQuestionEncounters.
     * 
    **/
    cursor?: QuestionsQuestionEncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsQuestionEncounters from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsQuestionEncounters.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionsQuestionEncounters.
     * 
    **/
    distinct?: Enumerable<QuestionsQuestionEncounterScalarFieldEnum>
  }

  /**
   * QuestionsQuestionEncounter: findFirst
   */
  export interface QuestionsQuestionEncounterFindFirstArgs extends QuestionsQuestionEncounterFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuestionsQuestionEncounter findMany
   */
  export type QuestionsQuestionEncounterFindManyArgs = {
    /**
     * Select specific fields to fetch from the QuestionsQuestionEncounter
     * 
    **/
    select?: QuestionsQuestionEncounterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsQuestionEncounterInclude | null
    /**
     * Filter, which QuestionsQuestionEncounters to fetch.
     * 
    **/
    where?: QuestionsQuestionEncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsQuestionEncounters to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionsQuestionEncounterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestionsQuestionEncounters.
     * 
    **/
    cursor?: QuestionsQuestionEncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsQuestionEncounters from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsQuestionEncounters.
     * 
    **/
    skip?: number
    distinct?: Enumerable<QuestionsQuestionEncounterScalarFieldEnum>
  }


  /**
   * QuestionsQuestionEncounter create
   */
  export type QuestionsQuestionEncounterCreateArgs = {
    /**
     * Select specific fields to fetch from the QuestionsQuestionEncounter
     * 
    **/
    select?: QuestionsQuestionEncounterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsQuestionEncounterInclude | null
    /**
     * The data needed to create a QuestionsQuestionEncounter.
     * 
    **/
    data: XOR<QuestionsQuestionEncounterCreateInput, QuestionsQuestionEncounterUncheckedCreateInput>
  }


  /**
   * QuestionsQuestionEncounter createMany
   */
  export type QuestionsQuestionEncounterCreateManyArgs = {
    /**
     * The data used to create many QuestionsQuestionEncounters.
     * 
    **/
    data: Enumerable<QuestionsQuestionEncounterCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * QuestionsQuestionEncounter update
   */
  export type QuestionsQuestionEncounterUpdateArgs = {
    /**
     * Select specific fields to fetch from the QuestionsQuestionEncounter
     * 
    **/
    select?: QuestionsQuestionEncounterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsQuestionEncounterInclude | null
    /**
     * The data needed to update a QuestionsQuestionEncounter.
     * 
    **/
    data: XOR<QuestionsQuestionEncounterUpdateInput, QuestionsQuestionEncounterUncheckedUpdateInput>
    /**
     * Choose, which QuestionsQuestionEncounter to update.
     * 
    **/
    where: QuestionsQuestionEncounterWhereUniqueInput
  }


  /**
   * QuestionsQuestionEncounter updateMany
   */
  export type QuestionsQuestionEncounterUpdateManyArgs = {
    /**
     * The data used to update QuestionsQuestionEncounters.
     * 
    **/
    data: XOR<QuestionsQuestionEncounterUpdateManyMutationInput, QuestionsQuestionEncounterUncheckedUpdateManyInput>
    /**
     * Filter which QuestionsQuestionEncounters to update
     * 
    **/
    where?: QuestionsQuestionEncounterWhereInput
  }


  /**
   * QuestionsQuestionEncounter upsert
   */
  export type QuestionsQuestionEncounterUpsertArgs = {
    /**
     * Select specific fields to fetch from the QuestionsQuestionEncounter
     * 
    **/
    select?: QuestionsQuestionEncounterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsQuestionEncounterInclude | null
    /**
     * The filter to search for the QuestionsQuestionEncounter to update in case it exists.
     * 
    **/
    where: QuestionsQuestionEncounterWhereUniqueInput
    /**
     * In case the QuestionsQuestionEncounter found by the `where` argument doesn't exist, create a new QuestionsQuestionEncounter with this data.
     * 
    **/
    create: XOR<QuestionsQuestionEncounterCreateInput, QuestionsQuestionEncounterUncheckedCreateInput>
    /**
     * In case the QuestionsQuestionEncounter was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<QuestionsQuestionEncounterUpdateInput, QuestionsQuestionEncounterUncheckedUpdateInput>
  }


  /**
   * QuestionsQuestionEncounter delete
   */
  export type QuestionsQuestionEncounterDeleteArgs = {
    /**
     * Select specific fields to fetch from the QuestionsQuestionEncounter
     * 
    **/
    select?: QuestionsQuestionEncounterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsQuestionEncounterInclude | null
    /**
     * Filter which QuestionsQuestionEncounter to delete.
     * 
    **/
    where: QuestionsQuestionEncounterWhereUniqueInput
  }


  /**
   * QuestionsQuestionEncounter deleteMany
   */
  export type QuestionsQuestionEncounterDeleteManyArgs = {
    /**
     * Filter which QuestionsQuestionEncounters to delete
     * 
    **/
    where?: QuestionsQuestionEncounterWhereInput
  }


  /**
   * QuestionsQuestionEncounter: findUniqueOrThrow
   */
  export type QuestionsQuestionEncounterFindUniqueOrThrowArgs = QuestionsQuestionEncounterFindUniqueArgsBase
      

  /**
   * QuestionsQuestionEncounter: findFirstOrThrow
   */
  export type QuestionsQuestionEncounterFindFirstOrThrowArgs = QuestionsQuestionEncounterFindFirstArgsBase
      

  /**
   * QuestionsQuestionEncounter without action
   */
  export type QuestionsQuestionEncounterArgs = {
    /**
     * Select specific fields to fetch from the QuestionsQuestionEncounter
     * 
    **/
    select?: QuestionsQuestionEncounterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsQuestionEncounterInclude | null
  }



  /**
   * Model QuestionsQuestionVote
   */


  export type AggregateQuestionsQuestionVote = {
    _count: QuestionsQuestionVoteCountAggregateOutputType | null
    _min: QuestionsQuestionVoteMinAggregateOutputType | null
    _max: QuestionsQuestionVoteMaxAggregateOutputType | null
  }

  export type QuestionsQuestionVoteMinAggregateOutputType = {
    id: string | null
    questionId: string | null
    userId: string | null
    vote: Vote | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionsQuestionVoteMaxAggregateOutputType = {
    id: string | null
    questionId: string | null
    userId: string | null
    vote: Vote | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionsQuestionVoteCountAggregateOutputType = {
    id: number
    questionId: number
    userId: number
    vote: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuestionsQuestionVoteMinAggregateInputType = {
    id?: true
    questionId?: true
    userId?: true
    vote?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionsQuestionVoteMaxAggregateInputType = {
    id?: true
    questionId?: true
    userId?: true
    vote?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionsQuestionVoteCountAggregateInputType = {
    id?: true
    questionId?: true
    userId?: true
    vote?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuestionsQuestionVoteAggregateArgs = {
    /**
     * Filter which QuestionsQuestionVote to aggregate.
     * 
    **/
    where?: QuestionsQuestionVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsQuestionVotes to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionsQuestionVoteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: QuestionsQuestionVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsQuestionVotes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsQuestionVotes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestionsQuestionVotes
    **/
    _count?: true | QuestionsQuestionVoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionsQuestionVoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionsQuestionVoteMaxAggregateInputType
  }

  export type GetQuestionsQuestionVoteAggregateType<T extends QuestionsQuestionVoteAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionsQuestionVote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionsQuestionVote[P]>
      : GetScalarType<T[P], AggregateQuestionsQuestionVote[P]>
  }




  export type QuestionsQuestionVoteGroupByArgs = {
    where?: QuestionsQuestionVoteWhereInput
    orderBy?: Enumerable<QuestionsQuestionVoteOrderByWithAggregationInput>
    by: Array<QuestionsQuestionVoteScalarFieldEnum>
    having?: QuestionsQuestionVoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionsQuestionVoteCountAggregateInputType | true
    _min?: QuestionsQuestionVoteMinAggregateInputType
    _max?: QuestionsQuestionVoteMaxAggregateInputType
  }


  export type QuestionsQuestionVoteGroupByOutputType = {
    id: string
    questionId: string
    userId: string | null
    vote: Vote
    createdAt: Date
    updatedAt: Date
    _count: QuestionsQuestionVoteCountAggregateOutputType | null
    _min: QuestionsQuestionVoteMinAggregateOutputType | null
    _max: QuestionsQuestionVoteMaxAggregateOutputType | null
  }

  type GetQuestionsQuestionVoteGroupByPayload<T extends QuestionsQuestionVoteGroupByArgs> = PrismaPromise<
    Array<
      PickArray<QuestionsQuestionVoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionsQuestionVoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionsQuestionVoteGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionsQuestionVoteGroupByOutputType[P]>
        }
      >
    >


  export type QuestionsQuestionVoteSelect = {
    id?: boolean
    questionId?: boolean
    userId?: boolean
    vote?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs
    question?: boolean | QuestionsQuestionArgs
  }

  export type QuestionsQuestionVoteInclude = {
    user?: boolean | UserArgs
    question?: boolean | QuestionsQuestionArgs
  }

  export type QuestionsQuestionVoteGetPayload<
    S extends boolean | null | undefined | QuestionsQuestionVoteArgs,
    U = keyof S
      > = S extends true
        ? QuestionsQuestionVote
    : S extends undefined
    ? never
    : S extends QuestionsQuestionVoteArgs | QuestionsQuestionVoteFindManyArgs
    ?'include' extends U
    ? QuestionsQuestionVote  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'question' ? QuestionsQuestionGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'question' ? QuestionsQuestionGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof QuestionsQuestionVote ? QuestionsQuestionVote[P] : never
  } 
    : QuestionsQuestionVote
  : QuestionsQuestionVote


  type QuestionsQuestionVoteCountArgs = Merge<
    Omit<QuestionsQuestionVoteFindManyArgs, 'select' | 'include'> & {
      select?: QuestionsQuestionVoteCountAggregateInputType | true
    }
  >

  export interface QuestionsQuestionVoteDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one QuestionsQuestionVote that matches the filter.
     * @param {QuestionsQuestionVoteFindUniqueArgs} args - Arguments to find a QuestionsQuestionVote
     * @example
     * // Get one QuestionsQuestionVote
     * const questionsQuestionVote = await prisma.questionsQuestionVote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuestionsQuestionVoteFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QuestionsQuestionVoteFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'QuestionsQuestionVote'> extends True ? CheckSelect<T, Prisma__QuestionsQuestionVoteClient<QuestionsQuestionVote>, Prisma__QuestionsQuestionVoteClient<QuestionsQuestionVoteGetPayload<T>>> : CheckSelect<T, Prisma__QuestionsQuestionVoteClient<QuestionsQuestionVote | null, null>, Prisma__QuestionsQuestionVoteClient<QuestionsQuestionVoteGetPayload<T> | null, null>>

    /**
     * Find the first QuestionsQuestionVote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsQuestionVoteFindFirstArgs} args - Arguments to find a QuestionsQuestionVote
     * @example
     * // Get one QuestionsQuestionVote
     * const questionsQuestionVote = await prisma.questionsQuestionVote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuestionsQuestionVoteFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QuestionsQuestionVoteFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'QuestionsQuestionVote'> extends True ? CheckSelect<T, Prisma__QuestionsQuestionVoteClient<QuestionsQuestionVote>, Prisma__QuestionsQuestionVoteClient<QuestionsQuestionVoteGetPayload<T>>> : CheckSelect<T, Prisma__QuestionsQuestionVoteClient<QuestionsQuestionVote | null, null>, Prisma__QuestionsQuestionVoteClient<QuestionsQuestionVoteGetPayload<T> | null, null>>

    /**
     * Find zero or more QuestionsQuestionVotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsQuestionVoteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionsQuestionVotes
     * const questionsQuestionVotes = await prisma.questionsQuestionVote.findMany()
     * 
     * // Get first 10 QuestionsQuestionVotes
     * const questionsQuestionVotes = await prisma.questionsQuestionVote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionsQuestionVoteWithIdOnly = await prisma.questionsQuestionVote.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuestionsQuestionVoteFindManyArgs>(
      args?: SelectSubset<T, QuestionsQuestionVoteFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<QuestionsQuestionVote>>, PrismaPromise<Array<QuestionsQuestionVoteGetPayload<T>>>>

    /**
     * Create a QuestionsQuestionVote.
     * @param {QuestionsQuestionVoteCreateArgs} args - Arguments to create a QuestionsQuestionVote.
     * @example
     * // Create one QuestionsQuestionVote
     * const QuestionsQuestionVote = await prisma.questionsQuestionVote.create({
     *   data: {
     *     // ... data to create a QuestionsQuestionVote
     *   }
     * })
     * 
    **/
    create<T extends QuestionsQuestionVoteCreateArgs>(
      args: SelectSubset<T, QuestionsQuestionVoteCreateArgs>
    ): CheckSelect<T, Prisma__QuestionsQuestionVoteClient<QuestionsQuestionVote>, Prisma__QuestionsQuestionVoteClient<QuestionsQuestionVoteGetPayload<T>>>

    /**
     * Create many QuestionsQuestionVotes.
     *     @param {QuestionsQuestionVoteCreateManyArgs} args - Arguments to create many QuestionsQuestionVotes.
     *     @example
     *     // Create many QuestionsQuestionVotes
     *     const questionsQuestionVote = await prisma.questionsQuestionVote.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuestionsQuestionVoteCreateManyArgs>(
      args?: SelectSubset<T, QuestionsQuestionVoteCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a QuestionsQuestionVote.
     * @param {QuestionsQuestionVoteDeleteArgs} args - Arguments to delete one QuestionsQuestionVote.
     * @example
     * // Delete one QuestionsQuestionVote
     * const QuestionsQuestionVote = await prisma.questionsQuestionVote.delete({
     *   where: {
     *     // ... filter to delete one QuestionsQuestionVote
     *   }
     * })
     * 
    **/
    delete<T extends QuestionsQuestionVoteDeleteArgs>(
      args: SelectSubset<T, QuestionsQuestionVoteDeleteArgs>
    ): CheckSelect<T, Prisma__QuestionsQuestionVoteClient<QuestionsQuestionVote>, Prisma__QuestionsQuestionVoteClient<QuestionsQuestionVoteGetPayload<T>>>

    /**
     * Update one QuestionsQuestionVote.
     * @param {QuestionsQuestionVoteUpdateArgs} args - Arguments to update one QuestionsQuestionVote.
     * @example
     * // Update one QuestionsQuestionVote
     * const questionsQuestionVote = await prisma.questionsQuestionVote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuestionsQuestionVoteUpdateArgs>(
      args: SelectSubset<T, QuestionsQuestionVoteUpdateArgs>
    ): CheckSelect<T, Prisma__QuestionsQuestionVoteClient<QuestionsQuestionVote>, Prisma__QuestionsQuestionVoteClient<QuestionsQuestionVoteGetPayload<T>>>

    /**
     * Delete zero or more QuestionsQuestionVotes.
     * @param {QuestionsQuestionVoteDeleteManyArgs} args - Arguments to filter QuestionsQuestionVotes to delete.
     * @example
     * // Delete a few QuestionsQuestionVotes
     * const { count } = await prisma.questionsQuestionVote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuestionsQuestionVoteDeleteManyArgs>(
      args?: SelectSubset<T, QuestionsQuestionVoteDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionsQuestionVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsQuestionVoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionsQuestionVotes
     * const questionsQuestionVote = await prisma.questionsQuestionVote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuestionsQuestionVoteUpdateManyArgs>(
      args: SelectSubset<T, QuestionsQuestionVoteUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one QuestionsQuestionVote.
     * @param {QuestionsQuestionVoteUpsertArgs} args - Arguments to update or create a QuestionsQuestionVote.
     * @example
     * // Update or create a QuestionsQuestionVote
     * const questionsQuestionVote = await prisma.questionsQuestionVote.upsert({
     *   create: {
     *     // ... data to create a QuestionsQuestionVote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionsQuestionVote we want to update
     *   }
     * })
    **/
    upsert<T extends QuestionsQuestionVoteUpsertArgs>(
      args: SelectSubset<T, QuestionsQuestionVoteUpsertArgs>
    ): CheckSelect<T, Prisma__QuestionsQuestionVoteClient<QuestionsQuestionVote>, Prisma__QuestionsQuestionVoteClient<QuestionsQuestionVoteGetPayload<T>>>

    /**
     * Find one QuestionsQuestionVote that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {QuestionsQuestionVoteFindUniqueOrThrowArgs} args - Arguments to find a QuestionsQuestionVote
     * @example
     * // Get one QuestionsQuestionVote
     * const questionsQuestionVote = await prisma.questionsQuestionVote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuestionsQuestionVoteFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, QuestionsQuestionVoteFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__QuestionsQuestionVoteClient<QuestionsQuestionVote>, Prisma__QuestionsQuestionVoteClient<QuestionsQuestionVoteGetPayload<T>>>

    /**
     * Find the first QuestionsQuestionVote that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsQuestionVoteFindFirstOrThrowArgs} args - Arguments to find a QuestionsQuestionVote
     * @example
     * // Get one QuestionsQuestionVote
     * const questionsQuestionVote = await prisma.questionsQuestionVote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuestionsQuestionVoteFindFirstOrThrowArgs>(
      args?: SelectSubset<T, QuestionsQuestionVoteFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__QuestionsQuestionVoteClient<QuestionsQuestionVote>, Prisma__QuestionsQuestionVoteClient<QuestionsQuestionVoteGetPayload<T>>>

    /**
     * Count the number of QuestionsQuestionVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsQuestionVoteCountArgs} args - Arguments to filter QuestionsQuestionVotes to count.
     * @example
     * // Count the number of QuestionsQuestionVotes
     * const count = await prisma.questionsQuestionVote.count({
     *   where: {
     *     // ... the filter for the QuestionsQuestionVotes we want to count
     *   }
     * })
    **/
    count<T extends QuestionsQuestionVoteCountArgs>(
      args?: Subset<T, QuestionsQuestionVoteCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionsQuestionVoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionsQuestionVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsQuestionVoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionsQuestionVoteAggregateArgs>(args: Subset<T, QuestionsQuestionVoteAggregateArgs>): PrismaPromise<GetQuestionsQuestionVoteAggregateType<T>>

    /**
     * Group by QuestionsQuestionVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsQuestionVoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionsQuestionVoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionsQuestionVoteGroupByArgs['orderBy'] }
        : { orderBy?: QuestionsQuestionVoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionsQuestionVoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionsQuestionVoteGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestionsQuestionVote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QuestionsQuestionVoteClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    question<T extends QuestionsQuestionArgs = {}>(args?: Subset<T, QuestionsQuestionArgs>): CheckSelect<T, Prisma__QuestionsQuestionClient<QuestionsQuestion | Null>, Prisma__QuestionsQuestionClient<QuestionsQuestionGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * QuestionsQuestionVote base type for findUnique actions
   */
  export type QuestionsQuestionVoteFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the QuestionsQuestionVote
     * 
    **/
    select?: QuestionsQuestionVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsQuestionVoteInclude | null
    /**
     * Filter, which QuestionsQuestionVote to fetch.
     * 
    **/
    where: QuestionsQuestionVoteWhereUniqueInput
  }

  /**
   * QuestionsQuestionVote: findUnique
   */
  export interface QuestionsQuestionVoteFindUniqueArgs extends QuestionsQuestionVoteFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuestionsQuestionVote base type for findFirst actions
   */
  export type QuestionsQuestionVoteFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the QuestionsQuestionVote
     * 
    **/
    select?: QuestionsQuestionVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsQuestionVoteInclude | null
    /**
     * Filter, which QuestionsQuestionVote to fetch.
     * 
    **/
    where?: QuestionsQuestionVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsQuestionVotes to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionsQuestionVoteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionsQuestionVotes.
     * 
    **/
    cursor?: QuestionsQuestionVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsQuestionVotes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsQuestionVotes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionsQuestionVotes.
     * 
    **/
    distinct?: Enumerable<QuestionsQuestionVoteScalarFieldEnum>
  }

  /**
   * QuestionsQuestionVote: findFirst
   */
  export interface QuestionsQuestionVoteFindFirstArgs extends QuestionsQuestionVoteFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuestionsQuestionVote findMany
   */
  export type QuestionsQuestionVoteFindManyArgs = {
    /**
     * Select specific fields to fetch from the QuestionsQuestionVote
     * 
    **/
    select?: QuestionsQuestionVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsQuestionVoteInclude | null
    /**
     * Filter, which QuestionsQuestionVotes to fetch.
     * 
    **/
    where?: QuestionsQuestionVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsQuestionVotes to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionsQuestionVoteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestionsQuestionVotes.
     * 
    **/
    cursor?: QuestionsQuestionVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsQuestionVotes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsQuestionVotes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<QuestionsQuestionVoteScalarFieldEnum>
  }


  /**
   * QuestionsQuestionVote create
   */
  export type QuestionsQuestionVoteCreateArgs = {
    /**
     * Select specific fields to fetch from the QuestionsQuestionVote
     * 
    **/
    select?: QuestionsQuestionVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsQuestionVoteInclude | null
    /**
     * The data needed to create a QuestionsQuestionVote.
     * 
    **/
    data: XOR<QuestionsQuestionVoteCreateInput, QuestionsQuestionVoteUncheckedCreateInput>
  }


  /**
   * QuestionsQuestionVote createMany
   */
  export type QuestionsQuestionVoteCreateManyArgs = {
    /**
     * The data used to create many QuestionsQuestionVotes.
     * 
    **/
    data: Enumerable<QuestionsQuestionVoteCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * QuestionsQuestionVote update
   */
  export type QuestionsQuestionVoteUpdateArgs = {
    /**
     * Select specific fields to fetch from the QuestionsQuestionVote
     * 
    **/
    select?: QuestionsQuestionVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsQuestionVoteInclude | null
    /**
     * The data needed to update a QuestionsQuestionVote.
     * 
    **/
    data: XOR<QuestionsQuestionVoteUpdateInput, QuestionsQuestionVoteUncheckedUpdateInput>
    /**
     * Choose, which QuestionsQuestionVote to update.
     * 
    **/
    where: QuestionsQuestionVoteWhereUniqueInput
  }


  /**
   * QuestionsQuestionVote updateMany
   */
  export type QuestionsQuestionVoteUpdateManyArgs = {
    /**
     * The data used to update QuestionsQuestionVotes.
     * 
    **/
    data: XOR<QuestionsQuestionVoteUpdateManyMutationInput, QuestionsQuestionVoteUncheckedUpdateManyInput>
    /**
     * Filter which QuestionsQuestionVotes to update
     * 
    **/
    where?: QuestionsQuestionVoteWhereInput
  }


  /**
   * QuestionsQuestionVote upsert
   */
  export type QuestionsQuestionVoteUpsertArgs = {
    /**
     * Select specific fields to fetch from the QuestionsQuestionVote
     * 
    **/
    select?: QuestionsQuestionVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsQuestionVoteInclude | null
    /**
     * The filter to search for the QuestionsQuestionVote to update in case it exists.
     * 
    **/
    where: QuestionsQuestionVoteWhereUniqueInput
    /**
     * In case the QuestionsQuestionVote found by the `where` argument doesn't exist, create a new QuestionsQuestionVote with this data.
     * 
    **/
    create: XOR<QuestionsQuestionVoteCreateInput, QuestionsQuestionVoteUncheckedCreateInput>
    /**
     * In case the QuestionsQuestionVote was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<QuestionsQuestionVoteUpdateInput, QuestionsQuestionVoteUncheckedUpdateInput>
  }


  /**
   * QuestionsQuestionVote delete
   */
  export type QuestionsQuestionVoteDeleteArgs = {
    /**
     * Select specific fields to fetch from the QuestionsQuestionVote
     * 
    **/
    select?: QuestionsQuestionVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsQuestionVoteInclude | null
    /**
     * Filter which QuestionsQuestionVote to delete.
     * 
    **/
    where: QuestionsQuestionVoteWhereUniqueInput
  }


  /**
   * QuestionsQuestionVote deleteMany
   */
  export type QuestionsQuestionVoteDeleteManyArgs = {
    /**
     * Filter which QuestionsQuestionVotes to delete
     * 
    **/
    where?: QuestionsQuestionVoteWhereInput
  }


  /**
   * QuestionsQuestionVote: findUniqueOrThrow
   */
  export type QuestionsQuestionVoteFindUniqueOrThrowArgs = QuestionsQuestionVoteFindUniqueArgsBase
      

  /**
   * QuestionsQuestionVote: findFirstOrThrow
   */
  export type QuestionsQuestionVoteFindFirstOrThrowArgs = QuestionsQuestionVoteFindFirstArgsBase
      

  /**
   * QuestionsQuestionVote without action
   */
  export type QuestionsQuestionVoteArgs = {
    /**
     * Select specific fields to fetch from the QuestionsQuestionVote
     * 
    **/
    select?: QuestionsQuestionVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsQuestionVoteInclude | null
  }



  /**
   * Model QuestionsQuestionComment
   */


  export type AggregateQuestionsQuestionComment = {
    _count: QuestionsQuestionCommentCountAggregateOutputType | null
    _avg: QuestionsQuestionCommentAvgAggregateOutputType | null
    _sum: QuestionsQuestionCommentSumAggregateOutputType | null
    _min: QuestionsQuestionCommentMinAggregateOutputType | null
    _max: QuestionsQuestionCommentMaxAggregateOutputType | null
  }

  export type QuestionsQuestionCommentAvgAggregateOutputType = {
    upvotes: number | null
  }

  export type QuestionsQuestionCommentSumAggregateOutputType = {
    upvotes: number | null
  }

  export type QuestionsQuestionCommentMinAggregateOutputType = {
    id: string | null
    questionId: string | null
    userId: string | null
    upvotes: number | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionsQuestionCommentMaxAggregateOutputType = {
    id: string | null
    questionId: string | null
    userId: string | null
    upvotes: number | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionsQuestionCommentCountAggregateOutputType = {
    id: number
    questionId: number
    userId: number
    upvotes: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuestionsQuestionCommentAvgAggregateInputType = {
    upvotes?: true
  }

  export type QuestionsQuestionCommentSumAggregateInputType = {
    upvotes?: true
  }

  export type QuestionsQuestionCommentMinAggregateInputType = {
    id?: true
    questionId?: true
    userId?: true
    upvotes?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionsQuestionCommentMaxAggregateInputType = {
    id?: true
    questionId?: true
    userId?: true
    upvotes?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionsQuestionCommentCountAggregateInputType = {
    id?: true
    questionId?: true
    userId?: true
    upvotes?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuestionsQuestionCommentAggregateArgs = {
    /**
     * Filter which QuestionsQuestionComment to aggregate.
     * 
    **/
    where?: QuestionsQuestionCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsQuestionComments to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionsQuestionCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: QuestionsQuestionCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsQuestionComments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsQuestionComments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestionsQuestionComments
    **/
    _count?: true | QuestionsQuestionCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionsQuestionCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionsQuestionCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionsQuestionCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionsQuestionCommentMaxAggregateInputType
  }

  export type GetQuestionsQuestionCommentAggregateType<T extends QuestionsQuestionCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionsQuestionComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionsQuestionComment[P]>
      : GetScalarType<T[P], AggregateQuestionsQuestionComment[P]>
  }




  export type QuestionsQuestionCommentGroupByArgs = {
    where?: QuestionsQuestionCommentWhereInput
    orderBy?: Enumerable<QuestionsQuestionCommentOrderByWithAggregationInput>
    by: Array<QuestionsQuestionCommentScalarFieldEnum>
    having?: QuestionsQuestionCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionsQuestionCommentCountAggregateInputType | true
    _avg?: QuestionsQuestionCommentAvgAggregateInputType
    _sum?: QuestionsQuestionCommentSumAggregateInputType
    _min?: QuestionsQuestionCommentMinAggregateInputType
    _max?: QuestionsQuestionCommentMaxAggregateInputType
  }


  export type QuestionsQuestionCommentGroupByOutputType = {
    id: string
    questionId: string
    userId: string | null
    upvotes: number
    content: string
    createdAt: Date
    updatedAt: Date
    _count: QuestionsQuestionCommentCountAggregateOutputType | null
    _avg: QuestionsQuestionCommentAvgAggregateOutputType | null
    _sum: QuestionsQuestionCommentSumAggregateOutputType | null
    _min: QuestionsQuestionCommentMinAggregateOutputType | null
    _max: QuestionsQuestionCommentMaxAggregateOutputType | null
  }

  type GetQuestionsQuestionCommentGroupByPayload<T extends QuestionsQuestionCommentGroupByArgs> = PrismaPromise<
    Array<
      PickArray<QuestionsQuestionCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionsQuestionCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionsQuestionCommentGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionsQuestionCommentGroupByOutputType[P]>
        }
      >
    >


  export type QuestionsQuestionCommentSelect = {
    id?: boolean
    questionId?: boolean
    userId?: boolean
    upvotes?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs
    question?: boolean | QuestionsQuestionArgs
    votes?: boolean | QuestionsQuestionCommentVoteFindManyArgs
    _count?: boolean | QuestionsQuestionCommentCountOutputTypeArgs
  }

  export type QuestionsQuestionCommentInclude = {
    user?: boolean | UserArgs
    question?: boolean | QuestionsQuestionArgs
    votes?: boolean | QuestionsQuestionCommentVoteFindManyArgs
    _count?: boolean | QuestionsQuestionCommentCountOutputTypeArgs
  }

  export type QuestionsQuestionCommentGetPayload<
    S extends boolean | null | undefined | QuestionsQuestionCommentArgs,
    U = keyof S
      > = S extends true
        ? QuestionsQuestionComment
    : S extends undefined
    ? never
    : S extends QuestionsQuestionCommentArgs | QuestionsQuestionCommentFindManyArgs
    ?'include' extends U
    ? QuestionsQuestionComment  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'question' ? QuestionsQuestionGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'votes' ? Array < QuestionsQuestionCommentVoteGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? QuestionsQuestionCommentCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'question' ? QuestionsQuestionGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'votes' ? Array < QuestionsQuestionCommentVoteGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? QuestionsQuestionCommentCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof QuestionsQuestionComment ? QuestionsQuestionComment[P] : never
  } 
    : QuestionsQuestionComment
  : QuestionsQuestionComment


  type QuestionsQuestionCommentCountArgs = Merge<
    Omit<QuestionsQuestionCommentFindManyArgs, 'select' | 'include'> & {
      select?: QuestionsQuestionCommentCountAggregateInputType | true
    }
  >

  export interface QuestionsQuestionCommentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one QuestionsQuestionComment that matches the filter.
     * @param {QuestionsQuestionCommentFindUniqueArgs} args - Arguments to find a QuestionsQuestionComment
     * @example
     * // Get one QuestionsQuestionComment
     * const questionsQuestionComment = await prisma.questionsQuestionComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuestionsQuestionCommentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QuestionsQuestionCommentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'QuestionsQuestionComment'> extends True ? CheckSelect<T, Prisma__QuestionsQuestionCommentClient<QuestionsQuestionComment>, Prisma__QuestionsQuestionCommentClient<QuestionsQuestionCommentGetPayload<T>>> : CheckSelect<T, Prisma__QuestionsQuestionCommentClient<QuestionsQuestionComment | null, null>, Prisma__QuestionsQuestionCommentClient<QuestionsQuestionCommentGetPayload<T> | null, null>>

    /**
     * Find the first QuestionsQuestionComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsQuestionCommentFindFirstArgs} args - Arguments to find a QuestionsQuestionComment
     * @example
     * // Get one QuestionsQuestionComment
     * const questionsQuestionComment = await prisma.questionsQuestionComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuestionsQuestionCommentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QuestionsQuestionCommentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'QuestionsQuestionComment'> extends True ? CheckSelect<T, Prisma__QuestionsQuestionCommentClient<QuestionsQuestionComment>, Prisma__QuestionsQuestionCommentClient<QuestionsQuestionCommentGetPayload<T>>> : CheckSelect<T, Prisma__QuestionsQuestionCommentClient<QuestionsQuestionComment | null, null>, Prisma__QuestionsQuestionCommentClient<QuestionsQuestionCommentGetPayload<T> | null, null>>

    /**
     * Find zero or more QuestionsQuestionComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsQuestionCommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionsQuestionComments
     * const questionsQuestionComments = await prisma.questionsQuestionComment.findMany()
     * 
     * // Get first 10 QuestionsQuestionComments
     * const questionsQuestionComments = await prisma.questionsQuestionComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionsQuestionCommentWithIdOnly = await prisma.questionsQuestionComment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuestionsQuestionCommentFindManyArgs>(
      args?: SelectSubset<T, QuestionsQuestionCommentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<QuestionsQuestionComment>>, PrismaPromise<Array<QuestionsQuestionCommentGetPayload<T>>>>

    /**
     * Create a QuestionsQuestionComment.
     * @param {QuestionsQuestionCommentCreateArgs} args - Arguments to create a QuestionsQuestionComment.
     * @example
     * // Create one QuestionsQuestionComment
     * const QuestionsQuestionComment = await prisma.questionsQuestionComment.create({
     *   data: {
     *     // ... data to create a QuestionsQuestionComment
     *   }
     * })
     * 
    **/
    create<T extends QuestionsQuestionCommentCreateArgs>(
      args: SelectSubset<T, QuestionsQuestionCommentCreateArgs>
    ): CheckSelect<T, Prisma__QuestionsQuestionCommentClient<QuestionsQuestionComment>, Prisma__QuestionsQuestionCommentClient<QuestionsQuestionCommentGetPayload<T>>>

    /**
     * Create many QuestionsQuestionComments.
     *     @param {QuestionsQuestionCommentCreateManyArgs} args - Arguments to create many QuestionsQuestionComments.
     *     @example
     *     // Create many QuestionsQuestionComments
     *     const questionsQuestionComment = await prisma.questionsQuestionComment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuestionsQuestionCommentCreateManyArgs>(
      args?: SelectSubset<T, QuestionsQuestionCommentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a QuestionsQuestionComment.
     * @param {QuestionsQuestionCommentDeleteArgs} args - Arguments to delete one QuestionsQuestionComment.
     * @example
     * // Delete one QuestionsQuestionComment
     * const QuestionsQuestionComment = await prisma.questionsQuestionComment.delete({
     *   where: {
     *     // ... filter to delete one QuestionsQuestionComment
     *   }
     * })
     * 
    **/
    delete<T extends QuestionsQuestionCommentDeleteArgs>(
      args: SelectSubset<T, QuestionsQuestionCommentDeleteArgs>
    ): CheckSelect<T, Prisma__QuestionsQuestionCommentClient<QuestionsQuestionComment>, Prisma__QuestionsQuestionCommentClient<QuestionsQuestionCommentGetPayload<T>>>

    /**
     * Update one QuestionsQuestionComment.
     * @param {QuestionsQuestionCommentUpdateArgs} args - Arguments to update one QuestionsQuestionComment.
     * @example
     * // Update one QuestionsQuestionComment
     * const questionsQuestionComment = await prisma.questionsQuestionComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuestionsQuestionCommentUpdateArgs>(
      args: SelectSubset<T, QuestionsQuestionCommentUpdateArgs>
    ): CheckSelect<T, Prisma__QuestionsQuestionCommentClient<QuestionsQuestionComment>, Prisma__QuestionsQuestionCommentClient<QuestionsQuestionCommentGetPayload<T>>>

    /**
     * Delete zero or more QuestionsQuestionComments.
     * @param {QuestionsQuestionCommentDeleteManyArgs} args - Arguments to filter QuestionsQuestionComments to delete.
     * @example
     * // Delete a few QuestionsQuestionComments
     * const { count } = await prisma.questionsQuestionComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuestionsQuestionCommentDeleteManyArgs>(
      args?: SelectSubset<T, QuestionsQuestionCommentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionsQuestionComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsQuestionCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionsQuestionComments
     * const questionsQuestionComment = await prisma.questionsQuestionComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuestionsQuestionCommentUpdateManyArgs>(
      args: SelectSubset<T, QuestionsQuestionCommentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one QuestionsQuestionComment.
     * @param {QuestionsQuestionCommentUpsertArgs} args - Arguments to update or create a QuestionsQuestionComment.
     * @example
     * // Update or create a QuestionsQuestionComment
     * const questionsQuestionComment = await prisma.questionsQuestionComment.upsert({
     *   create: {
     *     // ... data to create a QuestionsQuestionComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionsQuestionComment we want to update
     *   }
     * })
    **/
    upsert<T extends QuestionsQuestionCommentUpsertArgs>(
      args: SelectSubset<T, QuestionsQuestionCommentUpsertArgs>
    ): CheckSelect<T, Prisma__QuestionsQuestionCommentClient<QuestionsQuestionComment>, Prisma__QuestionsQuestionCommentClient<QuestionsQuestionCommentGetPayload<T>>>

    /**
     * Find one QuestionsQuestionComment that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {QuestionsQuestionCommentFindUniqueOrThrowArgs} args - Arguments to find a QuestionsQuestionComment
     * @example
     * // Get one QuestionsQuestionComment
     * const questionsQuestionComment = await prisma.questionsQuestionComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuestionsQuestionCommentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, QuestionsQuestionCommentFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__QuestionsQuestionCommentClient<QuestionsQuestionComment>, Prisma__QuestionsQuestionCommentClient<QuestionsQuestionCommentGetPayload<T>>>

    /**
     * Find the first QuestionsQuestionComment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsQuestionCommentFindFirstOrThrowArgs} args - Arguments to find a QuestionsQuestionComment
     * @example
     * // Get one QuestionsQuestionComment
     * const questionsQuestionComment = await prisma.questionsQuestionComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuestionsQuestionCommentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, QuestionsQuestionCommentFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__QuestionsQuestionCommentClient<QuestionsQuestionComment>, Prisma__QuestionsQuestionCommentClient<QuestionsQuestionCommentGetPayload<T>>>

    /**
     * Count the number of QuestionsQuestionComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsQuestionCommentCountArgs} args - Arguments to filter QuestionsQuestionComments to count.
     * @example
     * // Count the number of QuestionsQuestionComments
     * const count = await prisma.questionsQuestionComment.count({
     *   where: {
     *     // ... the filter for the QuestionsQuestionComments we want to count
     *   }
     * })
    **/
    count<T extends QuestionsQuestionCommentCountArgs>(
      args?: Subset<T, QuestionsQuestionCommentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionsQuestionCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionsQuestionComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsQuestionCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionsQuestionCommentAggregateArgs>(args: Subset<T, QuestionsQuestionCommentAggregateArgs>): PrismaPromise<GetQuestionsQuestionCommentAggregateType<T>>

    /**
     * Group by QuestionsQuestionComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsQuestionCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionsQuestionCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionsQuestionCommentGroupByArgs['orderBy'] }
        : { orderBy?: QuestionsQuestionCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionsQuestionCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionsQuestionCommentGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestionsQuestionComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QuestionsQuestionCommentClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    question<T extends QuestionsQuestionArgs = {}>(args?: Subset<T, QuestionsQuestionArgs>): CheckSelect<T, Prisma__QuestionsQuestionClient<QuestionsQuestion | Null>, Prisma__QuestionsQuestionClient<QuestionsQuestionGetPayload<T> | Null>>;

    votes<T extends QuestionsQuestionCommentVoteFindManyArgs = {}>(args?: Subset<T, QuestionsQuestionCommentVoteFindManyArgs>): CheckSelect<T, PrismaPromise<Array<QuestionsQuestionCommentVote>| Null>, PrismaPromise<Array<QuestionsQuestionCommentVoteGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * QuestionsQuestionComment base type for findUnique actions
   */
  export type QuestionsQuestionCommentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the QuestionsQuestionComment
     * 
    **/
    select?: QuestionsQuestionCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsQuestionCommentInclude | null
    /**
     * Filter, which QuestionsQuestionComment to fetch.
     * 
    **/
    where: QuestionsQuestionCommentWhereUniqueInput
  }

  /**
   * QuestionsQuestionComment: findUnique
   */
  export interface QuestionsQuestionCommentFindUniqueArgs extends QuestionsQuestionCommentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuestionsQuestionComment base type for findFirst actions
   */
  export type QuestionsQuestionCommentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the QuestionsQuestionComment
     * 
    **/
    select?: QuestionsQuestionCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsQuestionCommentInclude | null
    /**
     * Filter, which QuestionsQuestionComment to fetch.
     * 
    **/
    where?: QuestionsQuestionCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsQuestionComments to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionsQuestionCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionsQuestionComments.
     * 
    **/
    cursor?: QuestionsQuestionCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsQuestionComments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsQuestionComments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionsQuestionComments.
     * 
    **/
    distinct?: Enumerable<QuestionsQuestionCommentScalarFieldEnum>
  }

  /**
   * QuestionsQuestionComment: findFirst
   */
  export interface QuestionsQuestionCommentFindFirstArgs extends QuestionsQuestionCommentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuestionsQuestionComment findMany
   */
  export type QuestionsQuestionCommentFindManyArgs = {
    /**
     * Select specific fields to fetch from the QuestionsQuestionComment
     * 
    **/
    select?: QuestionsQuestionCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsQuestionCommentInclude | null
    /**
     * Filter, which QuestionsQuestionComments to fetch.
     * 
    **/
    where?: QuestionsQuestionCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsQuestionComments to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionsQuestionCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestionsQuestionComments.
     * 
    **/
    cursor?: QuestionsQuestionCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsQuestionComments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsQuestionComments.
     * 
    **/
    skip?: number
    distinct?: Enumerable<QuestionsQuestionCommentScalarFieldEnum>
  }


  /**
   * QuestionsQuestionComment create
   */
  export type QuestionsQuestionCommentCreateArgs = {
    /**
     * Select specific fields to fetch from the QuestionsQuestionComment
     * 
    **/
    select?: QuestionsQuestionCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsQuestionCommentInclude | null
    /**
     * The data needed to create a QuestionsQuestionComment.
     * 
    **/
    data: XOR<QuestionsQuestionCommentCreateInput, QuestionsQuestionCommentUncheckedCreateInput>
  }


  /**
   * QuestionsQuestionComment createMany
   */
  export type QuestionsQuestionCommentCreateManyArgs = {
    /**
     * The data used to create many QuestionsQuestionComments.
     * 
    **/
    data: Enumerable<QuestionsQuestionCommentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * QuestionsQuestionComment update
   */
  export type QuestionsQuestionCommentUpdateArgs = {
    /**
     * Select specific fields to fetch from the QuestionsQuestionComment
     * 
    **/
    select?: QuestionsQuestionCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsQuestionCommentInclude | null
    /**
     * The data needed to update a QuestionsQuestionComment.
     * 
    **/
    data: XOR<QuestionsQuestionCommentUpdateInput, QuestionsQuestionCommentUncheckedUpdateInput>
    /**
     * Choose, which QuestionsQuestionComment to update.
     * 
    **/
    where: QuestionsQuestionCommentWhereUniqueInput
  }


  /**
   * QuestionsQuestionComment updateMany
   */
  export type QuestionsQuestionCommentUpdateManyArgs = {
    /**
     * The data used to update QuestionsQuestionComments.
     * 
    **/
    data: XOR<QuestionsQuestionCommentUpdateManyMutationInput, QuestionsQuestionCommentUncheckedUpdateManyInput>
    /**
     * Filter which QuestionsQuestionComments to update
     * 
    **/
    where?: QuestionsQuestionCommentWhereInput
  }


  /**
   * QuestionsQuestionComment upsert
   */
  export type QuestionsQuestionCommentUpsertArgs = {
    /**
     * Select specific fields to fetch from the QuestionsQuestionComment
     * 
    **/
    select?: QuestionsQuestionCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsQuestionCommentInclude | null
    /**
     * The filter to search for the QuestionsQuestionComment to update in case it exists.
     * 
    **/
    where: QuestionsQuestionCommentWhereUniqueInput
    /**
     * In case the QuestionsQuestionComment found by the `where` argument doesn't exist, create a new QuestionsQuestionComment with this data.
     * 
    **/
    create: XOR<QuestionsQuestionCommentCreateInput, QuestionsQuestionCommentUncheckedCreateInput>
    /**
     * In case the QuestionsQuestionComment was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<QuestionsQuestionCommentUpdateInput, QuestionsQuestionCommentUncheckedUpdateInput>
  }


  /**
   * QuestionsQuestionComment delete
   */
  export type QuestionsQuestionCommentDeleteArgs = {
    /**
     * Select specific fields to fetch from the QuestionsQuestionComment
     * 
    **/
    select?: QuestionsQuestionCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsQuestionCommentInclude | null
    /**
     * Filter which QuestionsQuestionComment to delete.
     * 
    **/
    where: QuestionsQuestionCommentWhereUniqueInput
  }


  /**
   * QuestionsQuestionComment deleteMany
   */
  export type QuestionsQuestionCommentDeleteManyArgs = {
    /**
     * Filter which QuestionsQuestionComments to delete
     * 
    **/
    where?: QuestionsQuestionCommentWhereInput
  }


  /**
   * QuestionsQuestionComment: findUniqueOrThrow
   */
  export type QuestionsQuestionCommentFindUniqueOrThrowArgs = QuestionsQuestionCommentFindUniqueArgsBase
      

  /**
   * QuestionsQuestionComment: findFirstOrThrow
   */
  export type QuestionsQuestionCommentFindFirstOrThrowArgs = QuestionsQuestionCommentFindFirstArgsBase
      

  /**
   * QuestionsQuestionComment without action
   */
  export type QuestionsQuestionCommentArgs = {
    /**
     * Select specific fields to fetch from the QuestionsQuestionComment
     * 
    **/
    select?: QuestionsQuestionCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsQuestionCommentInclude | null
  }



  /**
   * Model QuestionsQuestionCommentVote
   */


  export type AggregateQuestionsQuestionCommentVote = {
    _count: QuestionsQuestionCommentVoteCountAggregateOutputType | null
    _min: QuestionsQuestionCommentVoteMinAggregateOutputType | null
    _max: QuestionsQuestionCommentVoteMaxAggregateOutputType | null
  }

  export type QuestionsQuestionCommentVoteMinAggregateOutputType = {
    id: string | null
    questionCommentId: string | null
    userId: string | null
    vote: Vote | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionsQuestionCommentVoteMaxAggregateOutputType = {
    id: string | null
    questionCommentId: string | null
    userId: string | null
    vote: Vote | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionsQuestionCommentVoteCountAggregateOutputType = {
    id: number
    questionCommentId: number
    userId: number
    vote: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuestionsQuestionCommentVoteMinAggregateInputType = {
    id?: true
    questionCommentId?: true
    userId?: true
    vote?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionsQuestionCommentVoteMaxAggregateInputType = {
    id?: true
    questionCommentId?: true
    userId?: true
    vote?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionsQuestionCommentVoteCountAggregateInputType = {
    id?: true
    questionCommentId?: true
    userId?: true
    vote?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuestionsQuestionCommentVoteAggregateArgs = {
    /**
     * Filter which QuestionsQuestionCommentVote to aggregate.
     * 
    **/
    where?: QuestionsQuestionCommentVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsQuestionCommentVotes to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionsQuestionCommentVoteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: QuestionsQuestionCommentVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsQuestionCommentVotes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsQuestionCommentVotes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestionsQuestionCommentVotes
    **/
    _count?: true | QuestionsQuestionCommentVoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionsQuestionCommentVoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionsQuestionCommentVoteMaxAggregateInputType
  }

  export type GetQuestionsQuestionCommentVoteAggregateType<T extends QuestionsQuestionCommentVoteAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionsQuestionCommentVote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionsQuestionCommentVote[P]>
      : GetScalarType<T[P], AggregateQuestionsQuestionCommentVote[P]>
  }




  export type QuestionsQuestionCommentVoteGroupByArgs = {
    where?: QuestionsQuestionCommentVoteWhereInput
    orderBy?: Enumerable<QuestionsQuestionCommentVoteOrderByWithAggregationInput>
    by: Array<QuestionsQuestionCommentVoteScalarFieldEnum>
    having?: QuestionsQuestionCommentVoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionsQuestionCommentVoteCountAggregateInputType | true
    _min?: QuestionsQuestionCommentVoteMinAggregateInputType
    _max?: QuestionsQuestionCommentVoteMaxAggregateInputType
  }


  export type QuestionsQuestionCommentVoteGroupByOutputType = {
    id: string
    questionCommentId: string
    userId: string | null
    vote: Vote
    createdAt: Date
    updatedAt: Date
    _count: QuestionsQuestionCommentVoteCountAggregateOutputType | null
    _min: QuestionsQuestionCommentVoteMinAggregateOutputType | null
    _max: QuestionsQuestionCommentVoteMaxAggregateOutputType | null
  }

  type GetQuestionsQuestionCommentVoteGroupByPayload<T extends QuestionsQuestionCommentVoteGroupByArgs> = PrismaPromise<
    Array<
      PickArray<QuestionsQuestionCommentVoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionsQuestionCommentVoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionsQuestionCommentVoteGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionsQuestionCommentVoteGroupByOutputType[P]>
        }
      >
    >


  export type QuestionsQuestionCommentVoteSelect = {
    id?: boolean
    questionCommentId?: boolean
    userId?: boolean
    vote?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs
    comment?: boolean | QuestionsQuestionCommentArgs
  }

  export type QuestionsQuestionCommentVoteInclude = {
    user?: boolean | UserArgs
    comment?: boolean | QuestionsQuestionCommentArgs
  }

  export type QuestionsQuestionCommentVoteGetPayload<
    S extends boolean | null | undefined | QuestionsQuestionCommentVoteArgs,
    U = keyof S
      > = S extends true
        ? QuestionsQuestionCommentVote
    : S extends undefined
    ? never
    : S extends QuestionsQuestionCommentVoteArgs | QuestionsQuestionCommentVoteFindManyArgs
    ?'include' extends U
    ? QuestionsQuestionCommentVote  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'comment' ? QuestionsQuestionCommentGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'comment' ? QuestionsQuestionCommentGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof QuestionsQuestionCommentVote ? QuestionsQuestionCommentVote[P] : never
  } 
    : QuestionsQuestionCommentVote
  : QuestionsQuestionCommentVote


  type QuestionsQuestionCommentVoteCountArgs = Merge<
    Omit<QuestionsQuestionCommentVoteFindManyArgs, 'select' | 'include'> & {
      select?: QuestionsQuestionCommentVoteCountAggregateInputType | true
    }
  >

  export interface QuestionsQuestionCommentVoteDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one QuestionsQuestionCommentVote that matches the filter.
     * @param {QuestionsQuestionCommentVoteFindUniqueArgs} args - Arguments to find a QuestionsQuestionCommentVote
     * @example
     * // Get one QuestionsQuestionCommentVote
     * const questionsQuestionCommentVote = await prisma.questionsQuestionCommentVote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuestionsQuestionCommentVoteFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QuestionsQuestionCommentVoteFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'QuestionsQuestionCommentVote'> extends True ? CheckSelect<T, Prisma__QuestionsQuestionCommentVoteClient<QuestionsQuestionCommentVote>, Prisma__QuestionsQuestionCommentVoteClient<QuestionsQuestionCommentVoteGetPayload<T>>> : CheckSelect<T, Prisma__QuestionsQuestionCommentVoteClient<QuestionsQuestionCommentVote | null, null>, Prisma__QuestionsQuestionCommentVoteClient<QuestionsQuestionCommentVoteGetPayload<T> | null, null>>

    /**
     * Find the first QuestionsQuestionCommentVote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsQuestionCommentVoteFindFirstArgs} args - Arguments to find a QuestionsQuestionCommentVote
     * @example
     * // Get one QuestionsQuestionCommentVote
     * const questionsQuestionCommentVote = await prisma.questionsQuestionCommentVote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuestionsQuestionCommentVoteFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QuestionsQuestionCommentVoteFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'QuestionsQuestionCommentVote'> extends True ? CheckSelect<T, Prisma__QuestionsQuestionCommentVoteClient<QuestionsQuestionCommentVote>, Prisma__QuestionsQuestionCommentVoteClient<QuestionsQuestionCommentVoteGetPayload<T>>> : CheckSelect<T, Prisma__QuestionsQuestionCommentVoteClient<QuestionsQuestionCommentVote | null, null>, Prisma__QuestionsQuestionCommentVoteClient<QuestionsQuestionCommentVoteGetPayload<T> | null, null>>

    /**
     * Find zero or more QuestionsQuestionCommentVotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsQuestionCommentVoteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionsQuestionCommentVotes
     * const questionsQuestionCommentVotes = await prisma.questionsQuestionCommentVote.findMany()
     * 
     * // Get first 10 QuestionsQuestionCommentVotes
     * const questionsQuestionCommentVotes = await prisma.questionsQuestionCommentVote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionsQuestionCommentVoteWithIdOnly = await prisma.questionsQuestionCommentVote.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuestionsQuestionCommentVoteFindManyArgs>(
      args?: SelectSubset<T, QuestionsQuestionCommentVoteFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<QuestionsQuestionCommentVote>>, PrismaPromise<Array<QuestionsQuestionCommentVoteGetPayload<T>>>>

    /**
     * Create a QuestionsQuestionCommentVote.
     * @param {QuestionsQuestionCommentVoteCreateArgs} args - Arguments to create a QuestionsQuestionCommentVote.
     * @example
     * // Create one QuestionsQuestionCommentVote
     * const QuestionsQuestionCommentVote = await prisma.questionsQuestionCommentVote.create({
     *   data: {
     *     // ... data to create a QuestionsQuestionCommentVote
     *   }
     * })
     * 
    **/
    create<T extends QuestionsQuestionCommentVoteCreateArgs>(
      args: SelectSubset<T, QuestionsQuestionCommentVoteCreateArgs>
    ): CheckSelect<T, Prisma__QuestionsQuestionCommentVoteClient<QuestionsQuestionCommentVote>, Prisma__QuestionsQuestionCommentVoteClient<QuestionsQuestionCommentVoteGetPayload<T>>>

    /**
     * Create many QuestionsQuestionCommentVotes.
     *     @param {QuestionsQuestionCommentVoteCreateManyArgs} args - Arguments to create many QuestionsQuestionCommentVotes.
     *     @example
     *     // Create many QuestionsQuestionCommentVotes
     *     const questionsQuestionCommentVote = await prisma.questionsQuestionCommentVote.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuestionsQuestionCommentVoteCreateManyArgs>(
      args?: SelectSubset<T, QuestionsQuestionCommentVoteCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a QuestionsQuestionCommentVote.
     * @param {QuestionsQuestionCommentVoteDeleteArgs} args - Arguments to delete one QuestionsQuestionCommentVote.
     * @example
     * // Delete one QuestionsQuestionCommentVote
     * const QuestionsQuestionCommentVote = await prisma.questionsQuestionCommentVote.delete({
     *   where: {
     *     // ... filter to delete one QuestionsQuestionCommentVote
     *   }
     * })
     * 
    **/
    delete<T extends QuestionsQuestionCommentVoteDeleteArgs>(
      args: SelectSubset<T, QuestionsQuestionCommentVoteDeleteArgs>
    ): CheckSelect<T, Prisma__QuestionsQuestionCommentVoteClient<QuestionsQuestionCommentVote>, Prisma__QuestionsQuestionCommentVoteClient<QuestionsQuestionCommentVoteGetPayload<T>>>

    /**
     * Update one QuestionsQuestionCommentVote.
     * @param {QuestionsQuestionCommentVoteUpdateArgs} args - Arguments to update one QuestionsQuestionCommentVote.
     * @example
     * // Update one QuestionsQuestionCommentVote
     * const questionsQuestionCommentVote = await prisma.questionsQuestionCommentVote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuestionsQuestionCommentVoteUpdateArgs>(
      args: SelectSubset<T, QuestionsQuestionCommentVoteUpdateArgs>
    ): CheckSelect<T, Prisma__QuestionsQuestionCommentVoteClient<QuestionsQuestionCommentVote>, Prisma__QuestionsQuestionCommentVoteClient<QuestionsQuestionCommentVoteGetPayload<T>>>

    /**
     * Delete zero or more QuestionsQuestionCommentVotes.
     * @param {QuestionsQuestionCommentVoteDeleteManyArgs} args - Arguments to filter QuestionsQuestionCommentVotes to delete.
     * @example
     * // Delete a few QuestionsQuestionCommentVotes
     * const { count } = await prisma.questionsQuestionCommentVote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuestionsQuestionCommentVoteDeleteManyArgs>(
      args?: SelectSubset<T, QuestionsQuestionCommentVoteDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionsQuestionCommentVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsQuestionCommentVoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionsQuestionCommentVotes
     * const questionsQuestionCommentVote = await prisma.questionsQuestionCommentVote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuestionsQuestionCommentVoteUpdateManyArgs>(
      args: SelectSubset<T, QuestionsQuestionCommentVoteUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one QuestionsQuestionCommentVote.
     * @param {QuestionsQuestionCommentVoteUpsertArgs} args - Arguments to update or create a QuestionsQuestionCommentVote.
     * @example
     * // Update or create a QuestionsQuestionCommentVote
     * const questionsQuestionCommentVote = await prisma.questionsQuestionCommentVote.upsert({
     *   create: {
     *     // ... data to create a QuestionsQuestionCommentVote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionsQuestionCommentVote we want to update
     *   }
     * })
    **/
    upsert<T extends QuestionsQuestionCommentVoteUpsertArgs>(
      args: SelectSubset<T, QuestionsQuestionCommentVoteUpsertArgs>
    ): CheckSelect<T, Prisma__QuestionsQuestionCommentVoteClient<QuestionsQuestionCommentVote>, Prisma__QuestionsQuestionCommentVoteClient<QuestionsQuestionCommentVoteGetPayload<T>>>

    /**
     * Find one QuestionsQuestionCommentVote that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {QuestionsQuestionCommentVoteFindUniqueOrThrowArgs} args - Arguments to find a QuestionsQuestionCommentVote
     * @example
     * // Get one QuestionsQuestionCommentVote
     * const questionsQuestionCommentVote = await prisma.questionsQuestionCommentVote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuestionsQuestionCommentVoteFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, QuestionsQuestionCommentVoteFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__QuestionsQuestionCommentVoteClient<QuestionsQuestionCommentVote>, Prisma__QuestionsQuestionCommentVoteClient<QuestionsQuestionCommentVoteGetPayload<T>>>

    /**
     * Find the first QuestionsQuestionCommentVote that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsQuestionCommentVoteFindFirstOrThrowArgs} args - Arguments to find a QuestionsQuestionCommentVote
     * @example
     * // Get one QuestionsQuestionCommentVote
     * const questionsQuestionCommentVote = await prisma.questionsQuestionCommentVote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuestionsQuestionCommentVoteFindFirstOrThrowArgs>(
      args?: SelectSubset<T, QuestionsQuestionCommentVoteFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__QuestionsQuestionCommentVoteClient<QuestionsQuestionCommentVote>, Prisma__QuestionsQuestionCommentVoteClient<QuestionsQuestionCommentVoteGetPayload<T>>>

    /**
     * Count the number of QuestionsQuestionCommentVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsQuestionCommentVoteCountArgs} args - Arguments to filter QuestionsQuestionCommentVotes to count.
     * @example
     * // Count the number of QuestionsQuestionCommentVotes
     * const count = await prisma.questionsQuestionCommentVote.count({
     *   where: {
     *     // ... the filter for the QuestionsQuestionCommentVotes we want to count
     *   }
     * })
    **/
    count<T extends QuestionsQuestionCommentVoteCountArgs>(
      args?: Subset<T, QuestionsQuestionCommentVoteCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionsQuestionCommentVoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionsQuestionCommentVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsQuestionCommentVoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionsQuestionCommentVoteAggregateArgs>(args: Subset<T, QuestionsQuestionCommentVoteAggregateArgs>): PrismaPromise<GetQuestionsQuestionCommentVoteAggregateType<T>>

    /**
     * Group by QuestionsQuestionCommentVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsQuestionCommentVoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionsQuestionCommentVoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionsQuestionCommentVoteGroupByArgs['orderBy'] }
        : { orderBy?: QuestionsQuestionCommentVoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionsQuestionCommentVoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionsQuestionCommentVoteGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestionsQuestionCommentVote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QuestionsQuestionCommentVoteClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    comment<T extends QuestionsQuestionCommentArgs = {}>(args?: Subset<T, QuestionsQuestionCommentArgs>): CheckSelect<T, Prisma__QuestionsQuestionCommentClient<QuestionsQuestionComment | Null>, Prisma__QuestionsQuestionCommentClient<QuestionsQuestionCommentGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * QuestionsQuestionCommentVote base type for findUnique actions
   */
  export type QuestionsQuestionCommentVoteFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the QuestionsQuestionCommentVote
     * 
    **/
    select?: QuestionsQuestionCommentVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsQuestionCommentVoteInclude | null
    /**
     * Filter, which QuestionsQuestionCommentVote to fetch.
     * 
    **/
    where: QuestionsQuestionCommentVoteWhereUniqueInput
  }

  /**
   * QuestionsQuestionCommentVote: findUnique
   */
  export interface QuestionsQuestionCommentVoteFindUniqueArgs extends QuestionsQuestionCommentVoteFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuestionsQuestionCommentVote base type for findFirst actions
   */
  export type QuestionsQuestionCommentVoteFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the QuestionsQuestionCommentVote
     * 
    **/
    select?: QuestionsQuestionCommentVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsQuestionCommentVoteInclude | null
    /**
     * Filter, which QuestionsQuestionCommentVote to fetch.
     * 
    **/
    where?: QuestionsQuestionCommentVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsQuestionCommentVotes to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionsQuestionCommentVoteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionsQuestionCommentVotes.
     * 
    **/
    cursor?: QuestionsQuestionCommentVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsQuestionCommentVotes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsQuestionCommentVotes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionsQuestionCommentVotes.
     * 
    **/
    distinct?: Enumerable<QuestionsQuestionCommentVoteScalarFieldEnum>
  }

  /**
   * QuestionsQuestionCommentVote: findFirst
   */
  export interface QuestionsQuestionCommentVoteFindFirstArgs extends QuestionsQuestionCommentVoteFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuestionsQuestionCommentVote findMany
   */
  export type QuestionsQuestionCommentVoteFindManyArgs = {
    /**
     * Select specific fields to fetch from the QuestionsQuestionCommentVote
     * 
    **/
    select?: QuestionsQuestionCommentVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsQuestionCommentVoteInclude | null
    /**
     * Filter, which QuestionsQuestionCommentVotes to fetch.
     * 
    **/
    where?: QuestionsQuestionCommentVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsQuestionCommentVotes to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionsQuestionCommentVoteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestionsQuestionCommentVotes.
     * 
    **/
    cursor?: QuestionsQuestionCommentVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsQuestionCommentVotes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsQuestionCommentVotes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<QuestionsQuestionCommentVoteScalarFieldEnum>
  }


  /**
   * QuestionsQuestionCommentVote create
   */
  export type QuestionsQuestionCommentVoteCreateArgs = {
    /**
     * Select specific fields to fetch from the QuestionsQuestionCommentVote
     * 
    **/
    select?: QuestionsQuestionCommentVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsQuestionCommentVoteInclude | null
    /**
     * The data needed to create a QuestionsQuestionCommentVote.
     * 
    **/
    data: XOR<QuestionsQuestionCommentVoteCreateInput, QuestionsQuestionCommentVoteUncheckedCreateInput>
  }


  /**
   * QuestionsQuestionCommentVote createMany
   */
  export type QuestionsQuestionCommentVoteCreateManyArgs = {
    /**
     * The data used to create many QuestionsQuestionCommentVotes.
     * 
    **/
    data: Enumerable<QuestionsQuestionCommentVoteCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * QuestionsQuestionCommentVote update
   */
  export type QuestionsQuestionCommentVoteUpdateArgs = {
    /**
     * Select specific fields to fetch from the QuestionsQuestionCommentVote
     * 
    **/
    select?: QuestionsQuestionCommentVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsQuestionCommentVoteInclude | null
    /**
     * The data needed to update a QuestionsQuestionCommentVote.
     * 
    **/
    data: XOR<QuestionsQuestionCommentVoteUpdateInput, QuestionsQuestionCommentVoteUncheckedUpdateInput>
    /**
     * Choose, which QuestionsQuestionCommentVote to update.
     * 
    **/
    where: QuestionsQuestionCommentVoteWhereUniqueInput
  }


  /**
   * QuestionsQuestionCommentVote updateMany
   */
  export type QuestionsQuestionCommentVoteUpdateManyArgs = {
    /**
     * The data used to update QuestionsQuestionCommentVotes.
     * 
    **/
    data: XOR<QuestionsQuestionCommentVoteUpdateManyMutationInput, QuestionsQuestionCommentVoteUncheckedUpdateManyInput>
    /**
     * Filter which QuestionsQuestionCommentVotes to update
     * 
    **/
    where?: QuestionsQuestionCommentVoteWhereInput
  }


  /**
   * QuestionsQuestionCommentVote upsert
   */
  export type QuestionsQuestionCommentVoteUpsertArgs = {
    /**
     * Select specific fields to fetch from the QuestionsQuestionCommentVote
     * 
    **/
    select?: QuestionsQuestionCommentVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsQuestionCommentVoteInclude | null
    /**
     * The filter to search for the QuestionsQuestionCommentVote to update in case it exists.
     * 
    **/
    where: QuestionsQuestionCommentVoteWhereUniqueInput
    /**
     * In case the QuestionsQuestionCommentVote found by the `where` argument doesn't exist, create a new QuestionsQuestionCommentVote with this data.
     * 
    **/
    create: XOR<QuestionsQuestionCommentVoteCreateInput, QuestionsQuestionCommentVoteUncheckedCreateInput>
    /**
     * In case the QuestionsQuestionCommentVote was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<QuestionsQuestionCommentVoteUpdateInput, QuestionsQuestionCommentVoteUncheckedUpdateInput>
  }


  /**
   * QuestionsQuestionCommentVote delete
   */
  export type QuestionsQuestionCommentVoteDeleteArgs = {
    /**
     * Select specific fields to fetch from the QuestionsQuestionCommentVote
     * 
    **/
    select?: QuestionsQuestionCommentVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsQuestionCommentVoteInclude | null
    /**
     * Filter which QuestionsQuestionCommentVote to delete.
     * 
    **/
    where: QuestionsQuestionCommentVoteWhereUniqueInput
  }


  /**
   * QuestionsQuestionCommentVote deleteMany
   */
  export type QuestionsQuestionCommentVoteDeleteManyArgs = {
    /**
     * Filter which QuestionsQuestionCommentVotes to delete
     * 
    **/
    where?: QuestionsQuestionCommentVoteWhereInput
  }


  /**
   * QuestionsQuestionCommentVote: findUniqueOrThrow
   */
  export type QuestionsQuestionCommentVoteFindUniqueOrThrowArgs = QuestionsQuestionCommentVoteFindUniqueArgsBase
      

  /**
   * QuestionsQuestionCommentVote: findFirstOrThrow
   */
  export type QuestionsQuestionCommentVoteFindFirstOrThrowArgs = QuestionsQuestionCommentVoteFindFirstArgsBase
      

  /**
   * QuestionsQuestionCommentVote without action
   */
  export type QuestionsQuestionCommentVoteArgs = {
    /**
     * Select specific fields to fetch from the QuestionsQuestionCommentVote
     * 
    **/
    select?: QuestionsQuestionCommentVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsQuestionCommentVoteInclude | null
  }



  /**
   * Model QuestionsAnswer
   */


  export type AggregateQuestionsAnswer = {
    _count: QuestionsAnswerCountAggregateOutputType | null
    _avg: QuestionsAnswerAvgAggregateOutputType | null
    _sum: QuestionsAnswerSumAggregateOutputType | null
    _min: QuestionsAnswerMinAggregateOutputType | null
    _max: QuestionsAnswerMaxAggregateOutputType | null
  }

  export type QuestionsAnswerAvgAggregateOutputType = {
    upvotes: number | null
  }

  export type QuestionsAnswerSumAggregateOutputType = {
    upvotes: number | null
  }

  export type QuestionsAnswerMinAggregateOutputType = {
    id: string | null
    questionId: string | null
    userId: string | null
    content: string | null
    upvotes: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionsAnswerMaxAggregateOutputType = {
    id: string | null
    questionId: string | null
    userId: string | null
    content: string | null
    upvotes: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionsAnswerCountAggregateOutputType = {
    id: number
    questionId: number
    userId: number
    content: number
    upvotes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuestionsAnswerAvgAggregateInputType = {
    upvotes?: true
  }

  export type QuestionsAnswerSumAggregateInputType = {
    upvotes?: true
  }

  export type QuestionsAnswerMinAggregateInputType = {
    id?: true
    questionId?: true
    userId?: true
    content?: true
    upvotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionsAnswerMaxAggregateInputType = {
    id?: true
    questionId?: true
    userId?: true
    content?: true
    upvotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionsAnswerCountAggregateInputType = {
    id?: true
    questionId?: true
    userId?: true
    content?: true
    upvotes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuestionsAnswerAggregateArgs = {
    /**
     * Filter which QuestionsAnswer to aggregate.
     * 
    **/
    where?: QuestionsAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsAnswers to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionsAnswerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: QuestionsAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsAnswers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsAnswers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestionsAnswers
    **/
    _count?: true | QuestionsAnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionsAnswerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionsAnswerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionsAnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionsAnswerMaxAggregateInputType
  }

  export type GetQuestionsAnswerAggregateType<T extends QuestionsAnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionsAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionsAnswer[P]>
      : GetScalarType<T[P], AggregateQuestionsAnswer[P]>
  }




  export type QuestionsAnswerGroupByArgs = {
    where?: QuestionsAnswerWhereInput
    orderBy?: Enumerable<QuestionsAnswerOrderByWithAggregationInput>
    by: Array<QuestionsAnswerScalarFieldEnum>
    having?: QuestionsAnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionsAnswerCountAggregateInputType | true
    _avg?: QuestionsAnswerAvgAggregateInputType
    _sum?: QuestionsAnswerSumAggregateInputType
    _min?: QuestionsAnswerMinAggregateInputType
    _max?: QuestionsAnswerMaxAggregateInputType
  }


  export type QuestionsAnswerGroupByOutputType = {
    id: string
    questionId: string
    userId: string | null
    content: string
    upvotes: number
    createdAt: Date
    updatedAt: Date
    _count: QuestionsAnswerCountAggregateOutputType | null
    _avg: QuestionsAnswerAvgAggregateOutputType | null
    _sum: QuestionsAnswerSumAggregateOutputType | null
    _min: QuestionsAnswerMinAggregateOutputType | null
    _max: QuestionsAnswerMaxAggregateOutputType | null
  }

  type GetQuestionsAnswerGroupByPayload<T extends QuestionsAnswerGroupByArgs> = PrismaPromise<
    Array<
      PickArray<QuestionsAnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionsAnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionsAnswerGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionsAnswerGroupByOutputType[P]>
        }
      >
    >


  export type QuestionsAnswerSelect = {
    id?: boolean
    questionId?: boolean
    userId?: boolean
    content?: boolean
    upvotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs
    question?: boolean | QuestionsQuestionArgs
    votes?: boolean | QuestionsAnswerVoteFindManyArgs
    comments?: boolean | QuestionsAnswerCommentFindManyArgs
    _count?: boolean | QuestionsAnswerCountOutputTypeArgs
  }

  export type QuestionsAnswerInclude = {
    user?: boolean | UserArgs
    question?: boolean | QuestionsQuestionArgs
    votes?: boolean | QuestionsAnswerVoteFindManyArgs
    comments?: boolean | QuestionsAnswerCommentFindManyArgs
    _count?: boolean | QuestionsAnswerCountOutputTypeArgs
  }

  export type QuestionsAnswerGetPayload<
    S extends boolean | null | undefined | QuestionsAnswerArgs,
    U = keyof S
      > = S extends true
        ? QuestionsAnswer
    : S extends undefined
    ? never
    : S extends QuestionsAnswerArgs | QuestionsAnswerFindManyArgs
    ?'include' extends U
    ? QuestionsAnswer  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'question' ? QuestionsQuestionGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'votes' ? Array < QuestionsAnswerVoteGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'comments' ? Array < QuestionsAnswerCommentGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? QuestionsAnswerCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'question' ? QuestionsQuestionGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'votes' ? Array < QuestionsAnswerVoteGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'comments' ? Array < QuestionsAnswerCommentGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? QuestionsAnswerCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof QuestionsAnswer ? QuestionsAnswer[P] : never
  } 
    : QuestionsAnswer
  : QuestionsAnswer


  type QuestionsAnswerCountArgs = Merge<
    Omit<QuestionsAnswerFindManyArgs, 'select' | 'include'> & {
      select?: QuestionsAnswerCountAggregateInputType | true
    }
  >

  export interface QuestionsAnswerDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one QuestionsAnswer that matches the filter.
     * @param {QuestionsAnswerFindUniqueArgs} args - Arguments to find a QuestionsAnswer
     * @example
     * // Get one QuestionsAnswer
     * const questionsAnswer = await prisma.questionsAnswer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuestionsAnswerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QuestionsAnswerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'QuestionsAnswer'> extends True ? CheckSelect<T, Prisma__QuestionsAnswerClient<QuestionsAnswer>, Prisma__QuestionsAnswerClient<QuestionsAnswerGetPayload<T>>> : CheckSelect<T, Prisma__QuestionsAnswerClient<QuestionsAnswer | null, null>, Prisma__QuestionsAnswerClient<QuestionsAnswerGetPayload<T> | null, null>>

    /**
     * Find the first QuestionsAnswer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsAnswerFindFirstArgs} args - Arguments to find a QuestionsAnswer
     * @example
     * // Get one QuestionsAnswer
     * const questionsAnswer = await prisma.questionsAnswer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuestionsAnswerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QuestionsAnswerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'QuestionsAnswer'> extends True ? CheckSelect<T, Prisma__QuestionsAnswerClient<QuestionsAnswer>, Prisma__QuestionsAnswerClient<QuestionsAnswerGetPayload<T>>> : CheckSelect<T, Prisma__QuestionsAnswerClient<QuestionsAnswer | null, null>, Prisma__QuestionsAnswerClient<QuestionsAnswerGetPayload<T> | null, null>>

    /**
     * Find zero or more QuestionsAnswers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsAnswerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionsAnswers
     * const questionsAnswers = await prisma.questionsAnswer.findMany()
     * 
     * // Get first 10 QuestionsAnswers
     * const questionsAnswers = await prisma.questionsAnswer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionsAnswerWithIdOnly = await prisma.questionsAnswer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuestionsAnswerFindManyArgs>(
      args?: SelectSubset<T, QuestionsAnswerFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<QuestionsAnswer>>, PrismaPromise<Array<QuestionsAnswerGetPayload<T>>>>

    /**
     * Create a QuestionsAnswer.
     * @param {QuestionsAnswerCreateArgs} args - Arguments to create a QuestionsAnswer.
     * @example
     * // Create one QuestionsAnswer
     * const QuestionsAnswer = await prisma.questionsAnswer.create({
     *   data: {
     *     // ... data to create a QuestionsAnswer
     *   }
     * })
     * 
    **/
    create<T extends QuestionsAnswerCreateArgs>(
      args: SelectSubset<T, QuestionsAnswerCreateArgs>
    ): CheckSelect<T, Prisma__QuestionsAnswerClient<QuestionsAnswer>, Prisma__QuestionsAnswerClient<QuestionsAnswerGetPayload<T>>>

    /**
     * Create many QuestionsAnswers.
     *     @param {QuestionsAnswerCreateManyArgs} args - Arguments to create many QuestionsAnswers.
     *     @example
     *     // Create many QuestionsAnswers
     *     const questionsAnswer = await prisma.questionsAnswer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuestionsAnswerCreateManyArgs>(
      args?: SelectSubset<T, QuestionsAnswerCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a QuestionsAnswer.
     * @param {QuestionsAnswerDeleteArgs} args - Arguments to delete one QuestionsAnswer.
     * @example
     * // Delete one QuestionsAnswer
     * const QuestionsAnswer = await prisma.questionsAnswer.delete({
     *   where: {
     *     // ... filter to delete one QuestionsAnswer
     *   }
     * })
     * 
    **/
    delete<T extends QuestionsAnswerDeleteArgs>(
      args: SelectSubset<T, QuestionsAnswerDeleteArgs>
    ): CheckSelect<T, Prisma__QuestionsAnswerClient<QuestionsAnswer>, Prisma__QuestionsAnswerClient<QuestionsAnswerGetPayload<T>>>

    /**
     * Update one QuestionsAnswer.
     * @param {QuestionsAnswerUpdateArgs} args - Arguments to update one QuestionsAnswer.
     * @example
     * // Update one QuestionsAnswer
     * const questionsAnswer = await prisma.questionsAnswer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuestionsAnswerUpdateArgs>(
      args: SelectSubset<T, QuestionsAnswerUpdateArgs>
    ): CheckSelect<T, Prisma__QuestionsAnswerClient<QuestionsAnswer>, Prisma__QuestionsAnswerClient<QuestionsAnswerGetPayload<T>>>

    /**
     * Delete zero or more QuestionsAnswers.
     * @param {QuestionsAnswerDeleteManyArgs} args - Arguments to filter QuestionsAnswers to delete.
     * @example
     * // Delete a few QuestionsAnswers
     * const { count } = await prisma.questionsAnswer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuestionsAnswerDeleteManyArgs>(
      args?: SelectSubset<T, QuestionsAnswerDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionsAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsAnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionsAnswers
     * const questionsAnswer = await prisma.questionsAnswer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuestionsAnswerUpdateManyArgs>(
      args: SelectSubset<T, QuestionsAnswerUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one QuestionsAnswer.
     * @param {QuestionsAnswerUpsertArgs} args - Arguments to update or create a QuestionsAnswer.
     * @example
     * // Update or create a QuestionsAnswer
     * const questionsAnswer = await prisma.questionsAnswer.upsert({
     *   create: {
     *     // ... data to create a QuestionsAnswer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionsAnswer we want to update
     *   }
     * })
    **/
    upsert<T extends QuestionsAnswerUpsertArgs>(
      args: SelectSubset<T, QuestionsAnswerUpsertArgs>
    ): CheckSelect<T, Prisma__QuestionsAnswerClient<QuestionsAnswer>, Prisma__QuestionsAnswerClient<QuestionsAnswerGetPayload<T>>>

    /**
     * Find one QuestionsAnswer that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {QuestionsAnswerFindUniqueOrThrowArgs} args - Arguments to find a QuestionsAnswer
     * @example
     * // Get one QuestionsAnswer
     * const questionsAnswer = await prisma.questionsAnswer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuestionsAnswerFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, QuestionsAnswerFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__QuestionsAnswerClient<QuestionsAnswer>, Prisma__QuestionsAnswerClient<QuestionsAnswerGetPayload<T>>>

    /**
     * Find the first QuestionsAnswer that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsAnswerFindFirstOrThrowArgs} args - Arguments to find a QuestionsAnswer
     * @example
     * // Get one QuestionsAnswer
     * const questionsAnswer = await prisma.questionsAnswer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuestionsAnswerFindFirstOrThrowArgs>(
      args?: SelectSubset<T, QuestionsAnswerFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__QuestionsAnswerClient<QuestionsAnswer>, Prisma__QuestionsAnswerClient<QuestionsAnswerGetPayload<T>>>

    /**
     * Count the number of QuestionsAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsAnswerCountArgs} args - Arguments to filter QuestionsAnswers to count.
     * @example
     * // Count the number of QuestionsAnswers
     * const count = await prisma.questionsAnswer.count({
     *   where: {
     *     // ... the filter for the QuestionsAnswers we want to count
     *   }
     * })
    **/
    count<T extends QuestionsAnswerCountArgs>(
      args?: Subset<T, QuestionsAnswerCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionsAnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionsAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsAnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionsAnswerAggregateArgs>(args: Subset<T, QuestionsAnswerAggregateArgs>): PrismaPromise<GetQuestionsAnswerAggregateType<T>>

    /**
     * Group by QuestionsAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsAnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionsAnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionsAnswerGroupByArgs['orderBy'] }
        : { orderBy?: QuestionsAnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionsAnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionsAnswerGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestionsAnswer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QuestionsAnswerClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    question<T extends QuestionsQuestionArgs = {}>(args?: Subset<T, QuestionsQuestionArgs>): CheckSelect<T, Prisma__QuestionsQuestionClient<QuestionsQuestion | Null>, Prisma__QuestionsQuestionClient<QuestionsQuestionGetPayload<T> | Null>>;

    votes<T extends QuestionsAnswerVoteFindManyArgs = {}>(args?: Subset<T, QuestionsAnswerVoteFindManyArgs>): CheckSelect<T, PrismaPromise<Array<QuestionsAnswerVote>| Null>, PrismaPromise<Array<QuestionsAnswerVoteGetPayload<T>>| Null>>;

    comments<T extends QuestionsAnswerCommentFindManyArgs = {}>(args?: Subset<T, QuestionsAnswerCommentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<QuestionsAnswerComment>| Null>, PrismaPromise<Array<QuestionsAnswerCommentGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * QuestionsAnswer base type for findUnique actions
   */
  export type QuestionsAnswerFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the QuestionsAnswer
     * 
    **/
    select?: QuestionsAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsAnswerInclude | null
    /**
     * Filter, which QuestionsAnswer to fetch.
     * 
    **/
    where: QuestionsAnswerWhereUniqueInput
  }

  /**
   * QuestionsAnswer: findUnique
   */
  export interface QuestionsAnswerFindUniqueArgs extends QuestionsAnswerFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuestionsAnswer base type for findFirst actions
   */
  export type QuestionsAnswerFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the QuestionsAnswer
     * 
    **/
    select?: QuestionsAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsAnswerInclude | null
    /**
     * Filter, which QuestionsAnswer to fetch.
     * 
    **/
    where?: QuestionsAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsAnswers to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionsAnswerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionsAnswers.
     * 
    **/
    cursor?: QuestionsAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsAnswers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsAnswers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionsAnswers.
     * 
    **/
    distinct?: Enumerable<QuestionsAnswerScalarFieldEnum>
  }

  /**
   * QuestionsAnswer: findFirst
   */
  export interface QuestionsAnswerFindFirstArgs extends QuestionsAnswerFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuestionsAnswer findMany
   */
  export type QuestionsAnswerFindManyArgs = {
    /**
     * Select specific fields to fetch from the QuestionsAnswer
     * 
    **/
    select?: QuestionsAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsAnswerInclude | null
    /**
     * Filter, which QuestionsAnswers to fetch.
     * 
    **/
    where?: QuestionsAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsAnswers to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionsAnswerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestionsAnswers.
     * 
    **/
    cursor?: QuestionsAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsAnswers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsAnswers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<QuestionsAnswerScalarFieldEnum>
  }


  /**
   * QuestionsAnswer create
   */
  export type QuestionsAnswerCreateArgs = {
    /**
     * Select specific fields to fetch from the QuestionsAnswer
     * 
    **/
    select?: QuestionsAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsAnswerInclude | null
    /**
     * The data needed to create a QuestionsAnswer.
     * 
    **/
    data: XOR<QuestionsAnswerCreateInput, QuestionsAnswerUncheckedCreateInput>
  }


  /**
   * QuestionsAnswer createMany
   */
  export type QuestionsAnswerCreateManyArgs = {
    /**
     * The data used to create many QuestionsAnswers.
     * 
    **/
    data: Enumerable<QuestionsAnswerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * QuestionsAnswer update
   */
  export type QuestionsAnswerUpdateArgs = {
    /**
     * Select specific fields to fetch from the QuestionsAnswer
     * 
    **/
    select?: QuestionsAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsAnswerInclude | null
    /**
     * The data needed to update a QuestionsAnswer.
     * 
    **/
    data: XOR<QuestionsAnswerUpdateInput, QuestionsAnswerUncheckedUpdateInput>
    /**
     * Choose, which QuestionsAnswer to update.
     * 
    **/
    where: QuestionsAnswerWhereUniqueInput
  }


  /**
   * QuestionsAnswer updateMany
   */
  export type QuestionsAnswerUpdateManyArgs = {
    /**
     * The data used to update QuestionsAnswers.
     * 
    **/
    data: XOR<QuestionsAnswerUpdateManyMutationInput, QuestionsAnswerUncheckedUpdateManyInput>
    /**
     * Filter which QuestionsAnswers to update
     * 
    **/
    where?: QuestionsAnswerWhereInput
  }


  /**
   * QuestionsAnswer upsert
   */
  export type QuestionsAnswerUpsertArgs = {
    /**
     * Select specific fields to fetch from the QuestionsAnswer
     * 
    **/
    select?: QuestionsAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsAnswerInclude | null
    /**
     * The filter to search for the QuestionsAnswer to update in case it exists.
     * 
    **/
    where: QuestionsAnswerWhereUniqueInput
    /**
     * In case the QuestionsAnswer found by the `where` argument doesn't exist, create a new QuestionsAnswer with this data.
     * 
    **/
    create: XOR<QuestionsAnswerCreateInput, QuestionsAnswerUncheckedCreateInput>
    /**
     * In case the QuestionsAnswer was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<QuestionsAnswerUpdateInput, QuestionsAnswerUncheckedUpdateInput>
  }


  /**
   * QuestionsAnswer delete
   */
  export type QuestionsAnswerDeleteArgs = {
    /**
     * Select specific fields to fetch from the QuestionsAnswer
     * 
    **/
    select?: QuestionsAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsAnswerInclude | null
    /**
     * Filter which QuestionsAnswer to delete.
     * 
    **/
    where: QuestionsAnswerWhereUniqueInput
  }


  /**
   * QuestionsAnswer deleteMany
   */
  export type QuestionsAnswerDeleteManyArgs = {
    /**
     * Filter which QuestionsAnswers to delete
     * 
    **/
    where?: QuestionsAnswerWhereInput
  }


  /**
   * QuestionsAnswer: findUniqueOrThrow
   */
  export type QuestionsAnswerFindUniqueOrThrowArgs = QuestionsAnswerFindUniqueArgsBase
      

  /**
   * QuestionsAnswer: findFirstOrThrow
   */
  export type QuestionsAnswerFindFirstOrThrowArgs = QuestionsAnswerFindFirstArgsBase
      

  /**
   * QuestionsAnswer without action
   */
  export type QuestionsAnswerArgs = {
    /**
     * Select specific fields to fetch from the QuestionsAnswer
     * 
    **/
    select?: QuestionsAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsAnswerInclude | null
  }



  /**
   * Model QuestionsAnswerVote
   */


  export type AggregateQuestionsAnswerVote = {
    _count: QuestionsAnswerVoteCountAggregateOutputType | null
    _min: QuestionsAnswerVoteMinAggregateOutputType | null
    _max: QuestionsAnswerVoteMaxAggregateOutputType | null
  }

  export type QuestionsAnswerVoteMinAggregateOutputType = {
    id: string | null
    answerId: string | null
    userId: string | null
    vote: Vote | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionsAnswerVoteMaxAggregateOutputType = {
    id: string | null
    answerId: string | null
    userId: string | null
    vote: Vote | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionsAnswerVoteCountAggregateOutputType = {
    id: number
    answerId: number
    userId: number
    vote: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuestionsAnswerVoteMinAggregateInputType = {
    id?: true
    answerId?: true
    userId?: true
    vote?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionsAnswerVoteMaxAggregateInputType = {
    id?: true
    answerId?: true
    userId?: true
    vote?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionsAnswerVoteCountAggregateInputType = {
    id?: true
    answerId?: true
    userId?: true
    vote?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuestionsAnswerVoteAggregateArgs = {
    /**
     * Filter which QuestionsAnswerVote to aggregate.
     * 
    **/
    where?: QuestionsAnswerVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsAnswerVotes to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionsAnswerVoteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: QuestionsAnswerVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsAnswerVotes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsAnswerVotes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestionsAnswerVotes
    **/
    _count?: true | QuestionsAnswerVoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionsAnswerVoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionsAnswerVoteMaxAggregateInputType
  }

  export type GetQuestionsAnswerVoteAggregateType<T extends QuestionsAnswerVoteAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionsAnswerVote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionsAnswerVote[P]>
      : GetScalarType<T[P], AggregateQuestionsAnswerVote[P]>
  }




  export type QuestionsAnswerVoteGroupByArgs = {
    where?: QuestionsAnswerVoteWhereInput
    orderBy?: Enumerable<QuestionsAnswerVoteOrderByWithAggregationInput>
    by: Array<QuestionsAnswerVoteScalarFieldEnum>
    having?: QuestionsAnswerVoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionsAnswerVoteCountAggregateInputType | true
    _min?: QuestionsAnswerVoteMinAggregateInputType
    _max?: QuestionsAnswerVoteMaxAggregateInputType
  }


  export type QuestionsAnswerVoteGroupByOutputType = {
    id: string
    answerId: string
    userId: string | null
    vote: Vote
    createdAt: Date
    updatedAt: Date
    _count: QuestionsAnswerVoteCountAggregateOutputType | null
    _min: QuestionsAnswerVoteMinAggregateOutputType | null
    _max: QuestionsAnswerVoteMaxAggregateOutputType | null
  }

  type GetQuestionsAnswerVoteGroupByPayload<T extends QuestionsAnswerVoteGroupByArgs> = PrismaPromise<
    Array<
      PickArray<QuestionsAnswerVoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionsAnswerVoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionsAnswerVoteGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionsAnswerVoteGroupByOutputType[P]>
        }
      >
    >


  export type QuestionsAnswerVoteSelect = {
    id?: boolean
    answerId?: boolean
    userId?: boolean
    vote?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs
    answer?: boolean | QuestionsAnswerArgs
  }

  export type QuestionsAnswerVoteInclude = {
    user?: boolean | UserArgs
    answer?: boolean | QuestionsAnswerArgs
  }

  export type QuestionsAnswerVoteGetPayload<
    S extends boolean | null | undefined | QuestionsAnswerVoteArgs,
    U = keyof S
      > = S extends true
        ? QuestionsAnswerVote
    : S extends undefined
    ? never
    : S extends QuestionsAnswerVoteArgs | QuestionsAnswerVoteFindManyArgs
    ?'include' extends U
    ? QuestionsAnswerVote  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'answer' ? QuestionsAnswerGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'answer' ? QuestionsAnswerGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof QuestionsAnswerVote ? QuestionsAnswerVote[P] : never
  } 
    : QuestionsAnswerVote
  : QuestionsAnswerVote


  type QuestionsAnswerVoteCountArgs = Merge<
    Omit<QuestionsAnswerVoteFindManyArgs, 'select' | 'include'> & {
      select?: QuestionsAnswerVoteCountAggregateInputType | true
    }
  >

  export interface QuestionsAnswerVoteDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one QuestionsAnswerVote that matches the filter.
     * @param {QuestionsAnswerVoteFindUniqueArgs} args - Arguments to find a QuestionsAnswerVote
     * @example
     * // Get one QuestionsAnswerVote
     * const questionsAnswerVote = await prisma.questionsAnswerVote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuestionsAnswerVoteFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QuestionsAnswerVoteFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'QuestionsAnswerVote'> extends True ? CheckSelect<T, Prisma__QuestionsAnswerVoteClient<QuestionsAnswerVote>, Prisma__QuestionsAnswerVoteClient<QuestionsAnswerVoteGetPayload<T>>> : CheckSelect<T, Prisma__QuestionsAnswerVoteClient<QuestionsAnswerVote | null, null>, Prisma__QuestionsAnswerVoteClient<QuestionsAnswerVoteGetPayload<T> | null, null>>

    /**
     * Find the first QuestionsAnswerVote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsAnswerVoteFindFirstArgs} args - Arguments to find a QuestionsAnswerVote
     * @example
     * // Get one QuestionsAnswerVote
     * const questionsAnswerVote = await prisma.questionsAnswerVote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuestionsAnswerVoteFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QuestionsAnswerVoteFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'QuestionsAnswerVote'> extends True ? CheckSelect<T, Prisma__QuestionsAnswerVoteClient<QuestionsAnswerVote>, Prisma__QuestionsAnswerVoteClient<QuestionsAnswerVoteGetPayload<T>>> : CheckSelect<T, Prisma__QuestionsAnswerVoteClient<QuestionsAnswerVote | null, null>, Prisma__QuestionsAnswerVoteClient<QuestionsAnswerVoteGetPayload<T> | null, null>>

    /**
     * Find zero or more QuestionsAnswerVotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsAnswerVoteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionsAnswerVotes
     * const questionsAnswerVotes = await prisma.questionsAnswerVote.findMany()
     * 
     * // Get first 10 QuestionsAnswerVotes
     * const questionsAnswerVotes = await prisma.questionsAnswerVote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionsAnswerVoteWithIdOnly = await prisma.questionsAnswerVote.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuestionsAnswerVoteFindManyArgs>(
      args?: SelectSubset<T, QuestionsAnswerVoteFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<QuestionsAnswerVote>>, PrismaPromise<Array<QuestionsAnswerVoteGetPayload<T>>>>

    /**
     * Create a QuestionsAnswerVote.
     * @param {QuestionsAnswerVoteCreateArgs} args - Arguments to create a QuestionsAnswerVote.
     * @example
     * // Create one QuestionsAnswerVote
     * const QuestionsAnswerVote = await prisma.questionsAnswerVote.create({
     *   data: {
     *     // ... data to create a QuestionsAnswerVote
     *   }
     * })
     * 
    **/
    create<T extends QuestionsAnswerVoteCreateArgs>(
      args: SelectSubset<T, QuestionsAnswerVoteCreateArgs>
    ): CheckSelect<T, Prisma__QuestionsAnswerVoteClient<QuestionsAnswerVote>, Prisma__QuestionsAnswerVoteClient<QuestionsAnswerVoteGetPayload<T>>>

    /**
     * Create many QuestionsAnswerVotes.
     *     @param {QuestionsAnswerVoteCreateManyArgs} args - Arguments to create many QuestionsAnswerVotes.
     *     @example
     *     // Create many QuestionsAnswerVotes
     *     const questionsAnswerVote = await prisma.questionsAnswerVote.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuestionsAnswerVoteCreateManyArgs>(
      args?: SelectSubset<T, QuestionsAnswerVoteCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a QuestionsAnswerVote.
     * @param {QuestionsAnswerVoteDeleteArgs} args - Arguments to delete one QuestionsAnswerVote.
     * @example
     * // Delete one QuestionsAnswerVote
     * const QuestionsAnswerVote = await prisma.questionsAnswerVote.delete({
     *   where: {
     *     // ... filter to delete one QuestionsAnswerVote
     *   }
     * })
     * 
    **/
    delete<T extends QuestionsAnswerVoteDeleteArgs>(
      args: SelectSubset<T, QuestionsAnswerVoteDeleteArgs>
    ): CheckSelect<T, Prisma__QuestionsAnswerVoteClient<QuestionsAnswerVote>, Prisma__QuestionsAnswerVoteClient<QuestionsAnswerVoteGetPayload<T>>>

    /**
     * Update one QuestionsAnswerVote.
     * @param {QuestionsAnswerVoteUpdateArgs} args - Arguments to update one QuestionsAnswerVote.
     * @example
     * // Update one QuestionsAnswerVote
     * const questionsAnswerVote = await prisma.questionsAnswerVote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuestionsAnswerVoteUpdateArgs>(
      args: SelectSubset<T, QuestionsAnswerVoteUpdateArgs>
    ): CheckSelect<T, Prisma__QuestionsAnswerVoteClient<QuestionsAnswerVote>, Prisma__QuestionsAnswerVoteClient<QuestionsAnswerVoteGetPayload<T>>>

    /**
     * Delete zero or more QuestionsAnswerVotes.
     * @param {QuestionsAnswerVoteDeleteManyArgs} args - Arguments to filter QuestionsAnswerVotes to delete.
     * @example
     * // Delete a few QuestionsAnswerVotes
     * const { count } = await prisma.questionsAnswerVote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuestionsAnswerVoteDeleteManyArgs>(
      args?: SelectSubset<T, QuestionsAnswerVoteDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionsAnswerVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsAnswerVoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionsAnswerVotes
     * const questionsAnswerVote = await prisma.questionsAnswerVote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuestionsAnswerVoteUpdateManyArgs>(
      args: SelectSubset<T, QuestionsAnswerVoteUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one QuestionsAnswerVote.
     * @param {QuestionsAnswerVoteUpsertArgs} args - Arguments to update or create a QuestionsAnswerVote.
     * @example
     * // Update or create a QuestionsAnswerVote
     * const questionsAnswerVote = await prisma.questionsAnswerVote.upsert({
     *   create: {
     *     // ... data to create a QuestionsAnswerVote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionsAnswerVote we want to update
     *   }
     * })
    **/
    upsert<T extends QuestionsAnswerVoteUpsertArgs>(
      args: SelectSubset<T, QuestionsAnswerVoteUpsertArgs>
    ): CheckSelect<T, Prisma__QuestionsAnswerVoteClient<QuestionsAnswerVote>, Prisma__QuestionsAnswerVoteClient<QuestionsAnswerVoteGetPayload<T>>>

    /**
     * Find one QuestionsAnswerVote that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {QuestionsAnswerVoteFindUniqueOrThrowArgs} args - Arguments to find a QuestionsAnswerVote
     * @example
     * // Get one QuestionsAnswerVote
     * const questionsAnswerVote = await prisma.questionsAnswerVote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuestionsAnswerVoteFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, QuestionsAnswerVoteFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__QuestionsAnswerVoteClient<QuestionsAnswerVote>, Prisma__QuestionsAnswerVoteClient<QuestionsAnswerVoteGetPayload<T>>>

    /**
     * Find the first QuestionsAnswerVote that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsAnswerVoteFindFirstOrThrowArgs} args - Arguments to find a QuestionsAnswerVote
     * @example
     * // Get one QuestionsAnswerVote
     * const questionsAnswerVote = await prisma.questionsAnswerVote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuestionsAnswerVoteFindFirstOrThrowArgs>(
      args?: SelectSubset<T, QuestionsAnswerVoteFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__QuestionsAnswerVoteClient<QuestionsAnswerVote>, Prisma__QuestionsAnswerVoteClient<QuestionsAnswerVoteGetPayload<T>>>

    /**
     * Count the number of QuestionsAnswerVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsAnswerVoteCountArgs} args - Arguments to filter QuestionsAnswerVotes to count.
     * @example
     * // Count the number of QuestionsAnswerVotes
     * const count = await prisma.questionsAnswerVote.count({
     *   where: {
     *     // ... the filter for the QuestionsAnswerVotes we want to count
     *   }
     * })
    **/
    count<T extends QuestionsAnswerVoteCountArgs>(
      args?: Subset<T, QuestionsAnswerVoteCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionsAnswerVoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionsAnswerVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsAnswerVoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionsAnswerVoteAggregateArgs>(args: Subset<T, QuestionsAnswerVoteAggregateArgs>): PrismaPromise<GetQuestionsAnswerVoteAggregateType<T>>

    /**
     * Group by QuestionsAnswerVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsAnswerVoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionsAnswerVoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionsAnswerVoteGroupByArgs['orderBy'] }
        : { orderBy?: QuestionsAnswerVoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionsAnswerVoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionsAnswerVoteGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestionsAnswerVote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QuestionsAnswerVoteClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    answer<T extends QuestionsAnswerArgs = {}>(args?: Subset<T, QuestionsAnswerArgs>): CheckSelect<T, Prisma__QuestionsAnswerClient<QuestionsAnswer | Null>, Prisma__QuestionsAnswerClient<QuestionsAnswerGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * QuestionsAnswerVote base type for findUnique actions
   */
  export type QuestionsAnswerVoteFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the QuestionsAnswerVote
     * 
    **/
    select?: QuestionsAnswerVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsAnswerVoteInclude | null
    /**
     * Filter, which QuestionsAnswerVote to fetch.
     * 
    **/
    where: QuestionsAnswerVoteWhereUniqueInput
  }

  /**
   * QuestionsAnswerVote: findUnique
   */
  export interface QuestionsAnswerVoteFindUniqueArgs extends QuestionsAnswerVoteFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuestionsAnswerVote base type for findFirst actions
   */
  export type QuestionsAnswerVoteFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the QuestionsAnswerVote
     * 
    **/
    select?: QuestionsAnswerVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsAnswerVoteInclude | null
    /**
     * Filter, which QuestionsAnswerVote to fetch.
     * 
    **/
    where?: QuestionsAnswerVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsAnswerVotes to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionsAnswerVoteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionsAnswerVotes.
     * 
    **/
    cursor?: QuestionsAnswerVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsAnswerVotes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsAnswerVotes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionsAnswerVotes.
     * 
    **/
    distinct?: Enumerable<QuestionsAnswerVoteScalarFieldEnum>
  }

  /**
   * QuestionsAnswerVote: findFirst
   */
  export interface QuestionsAnswerVoteFindFirstArgs extends QuestionsAnswerVoteFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuestionsAnswerVote findMany
   */
  export type QuestionsAnswerVoteFindManyArgs = {
    /**
     * Select specific fields to fetch from the QuestionsAnswerVote
     * 
    **/
    select?: QuestionsAnswerVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsAnswerVoteInclude | null
    /**
     * Filter, which QuestionsAnswerVotes to fetch.
     * 
    **/
    where?: QuestionsAnswerVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsAnswerVotes to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionsAnswerVoteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestionsAnswerVotes.
     * 
    **/
    cursor?: QuestionsAnswerVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsAnswerVotes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsAnswerVotes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<QuestionsAnswerVoteScalarFieldEnum>
  }


  /**
   * QuestionsAnswerVote create
   */
  export type QuestionsAnswerVoteCreateArgs = {
    /**
     * Select specific fields to fetch from the QuestionsAnswerVote
     * 
    **/
    select?: QuestionsAnswerVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsAnswerVoteInclude | null
    /**
     * The data needed to create a QuestionsAnswerVote.
     * 
    **/
    data: XOR<QuestionsAnswerVoteCreateInput, QuestionsAnswerVoteUncheckedCreateInput>
  }


  /**
   * QuestionsAnswerVote createMany
   */
  export type QuestionsAnswerVoteCreateManyArgs = {
    /**
     * The data used to create many QuestionsAnswerVotes.
     * 
    **/
    data: Enumerable<QuestionsAnswerVoteCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * QuestionsAnswerVote update
   */
  export type QuestionsAnswerVoteUpdateArgs = {
    /**
     * Select specific fields to fetch from the QuestionsAnswerVote
     * 
    **/
    select?: QuestionsAnswerVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsAnswerVoteInclude | null
    /**
     * The data needed to update a QuestionsAnswerVote.
     * 
    **/
    data: XOR<QuestionsAnswerVoteUpdateInput, QuestionsAnswerVoteUncheckedUpdateInput>
    /**
     * Choose, which QuestionsAnswerVote to update.
     * 
    **/
    where: QuestionsAnswerVoteWhereUniqueInput
  }


  /**
   * QuestionsAnswerVote updateMany
   */
  export type QuestionsAnswerVoteUpdateManyArgs = {
    /**
     * The data used to update QuestionsAnswerVotes.
     * 
    **/
    data: XOR<QuestionsAnswerVoteUpdateManyMutationInput, QuestionsAnswerVoteUncheckedUpdateManyInput>
    /**
     * Filter which QuestionsAnswerVotes to update
     * 
    **/
    where?: QuestionsAnswerVoteWhereInput
  }


  /**
   * QuestionsAnswerVote upsert
   */
  export type QuestionsAnswerVoteUpsertArgs = {
    /**
     * Select specific fields to fetch from the QuestionsAnswerVote
     * 
    **/
    select?: QuestionsAnswerVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsAnswerVoteInclude | null
    /**
     * The filter to search for the QuestionsAnswerVote to update in case it exists.
     * 
    **/
    where: QuestionsAnswerVoteWhereUniqueInput
    /**
     * In case the QuestionsAnswerVote found by the `where` argument doesn't exist, create a new QuestionsAnswerVote with this data.
     * 
    **/
    create: XOR<QuestionsAnswerVoteCreateInput, QuestionsAnswerVoteUncheckedCreateInput>
    /**
     * In case the QuestionsAnswerVote was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<QuestionsAnswerVoteUpdateInput, QuestionsAnswerVoteUncheckedUpdateInput>
  }


  /**
   * QuestionsAnswerVote delete
   */
  export type QuestionsAnswerVoteDeleteArgs = {
    /**
     * Select specific fields to fetch from the QuestionsAnswerVote
     * 
    **/
    select?: QuestionsAnswerVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsAnswerVoteInclude | null
    /**
     * Filter which QuestionsAnswerVote to delete.
     * 
    **/
    where: QuestionsAnswerVoteWhereUniqueInput
  }


  /**
   * QuestionsAnswerVote deleteMany
   */
  export type QuestionsAnswerVoteDeleteManyArgs = {
    /**
     * Filter which QuestionsAnswerVotes to delete
     * 
    **/
    where?: QuestionsAnswerVoteWhereInput
  }


  /**
   * QuestionsAnswerVote: findUniqueOrThrow
   */
  export type QuestionsAnswerVoteFindUniqueOrThrowArgs = QuestionsAnswerVoteFindUniqueArgsBase
      

  /**
   * QuestionsAnswerVote: findFirstOrThrow
   */
  export type QuestionsAnswerVoteFindFirstOrThrowArgs = QuestionsAnswerVoteFindFirstArgsBase
      

  /**
   * QuestionsAnswerVote without action
   */
  export type QuestionsAnswerVoteArgs = {
    /**
     * Select specific fields to fetch from the QuestionsAnswerVote
     * 
    **/
    select?: QuestionsAnswerVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsAnswerVoteInclude | null
  }



  /**
   * Model QuestionsAnswerComment
   */


  export type AggregateQuestionsAnswerComment = {
    _count: QuestionsAnswerCommentCountAggregateOutputType | null
    _avg: QuestionsAnswerCommentAvgAggregateOutputType | null
    _sum: QuestionsAnswerCommentSumAggregateOutputType | null
    _min: QuestionsAnswerCommentMinAggregateOutputType | null
    _max: QuestionsAnswerCommentMaxAggregateOutputType | null
  }

  export type QuestionsAnswerCommentAvgAggregateOutputType = {
    upvotes: number | null
  }

  export type QuestionsAnswerCommentSumAggregateOutputType = {
    upvotes: number | null
  }

  export type QuestionsAnswerCommentMinAggregateOutputType = {
    id: string | null
    answerId: string | null
    userId: string | null
    content: string | null
    upvotes: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionsAnswerCommentMaxAggregateOutputType = {
    id: string | null
    answerId: string | null
    userId: string | null
    content: string | null
    upvotes: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionsAnswerCommentCountAggregateOutputType = {
    id: number
    answerId: number
    userId: number
    content: number
    upvotes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuestionsAnswerCommentAvgAggregateInputType = {
    upvotes?: true
  }

  export type QuestionsAnswerCommentSumAggregateInputType = {
    upvotes?: true
  }

  export type QuestionsAnswerCommentMinAggregateInputType = {
    id?: true
    answerId?: true
    userId?: true
    content?: true
    upvotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionsAnswerCommentMaxAggregateInputType = {
    id?: true
    answerId?: true
    userId?: true
    content?: true
    upvotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionsAnswerCommentCountAggregateInputType = {
    id?: true
    answerId?: true
    userId?: true
    content?: true
    upvotes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuestionsAnswerCommentAggregateArgs = {
    /**
     * Filter which QuestionsAnswerComment to aggregate.
     * 
    **/
    where?: QuestionsAnswerCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsAnswerComments to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionsAnswerCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: QuestionsAnswerCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsAnswerComments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsAnswerComments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestionsAnswerComments
    **/
    _count?: true | QuestionsAnswerCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionsAnswerCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionsAnswerCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionsAnswerCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionsAnswerCommentMaxAggregateInputType
  }

  export type GetQuestionsAnswerCommentAggregateType<T extends QuestionsAnswerCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionsAnswerComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionsAnswerComment[P]>
      : GetScalarType<T[P], AggregateQuestionsAnswerComment[P]>
  }




  export type QuestionsAnswerCommentGroupByArgs = {
    where?: QuestionsAnswerCommentWhereInput
    orderBy?: Enumerable<QuestionsAnswerCommentOrderByWithAggregationInput>
    by: Array<QuestionsAnswerCommentScalarFieldEnum>
    having?: QuestionsAnswerCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionsAnswerCommentCountAggregateInputType | true
    _avg?: QuestionsAnswerCommentAvgAggregateInputType
    _sum?: QuestionsAnswerCommentSumAggregateInputType
    _min?: QuestionsAnswerCommentMinAggregateInputType
    _max?: QuestionsAnswerCommentMaxAggregateInputType
  }


  export type QuestionsAnswerCommentGroupByOutputType = {
    id: string
    answerId: string
    userId: string | null
    content: string
    upvotes: number
    createdAt: Date
    updatedAt: Date
    _count: QuestionsAnswerCommentCountAggregateOutputType | null
    _avg: QuestionsAnswerCommentAvgAggregateOutputType | null
    _sum: QuestionsAnswerCommentSumAggregateOutputType | null
    _min: QuestionsAnswerCommentMinAggregateOutputType | null
    _max: QuestionsAnswerCommentMaxAggregateOutputType | null
  }

  type GetQuestionsAnswerCommentGroupByPayload<T extends QuestionsAnswerCommentGroupByArgs> = PrismaPromise<
    Array<
      PickArray<QuestionsAnswerCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionsAnswerCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionsAnswerCommentGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionsAnswerCommentGroupByOutputType[P]>
        }
      >
    >


  export type QuestionsAnswerCommentSelect = {
    id?: boolean
    answerId?: boolean
    userId?: boolean
    content?: boolean
    upvotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs
    answer?: boolean | QuestionsAnswerArgs
    votes?: boolean | QuestionsAnswerCommentVoteFindManyArgs
    _count?: boolean | QuestionsAnswerCommentCountOutputTypeArgs
  }

  export type QuestionsAnswerCommentInclude = {
    user?: boolean | UserArgs
    answer?: boolean | QuestionsAnswerArgs
    votes?: boolean | QuestionsAnswerCommentVoteFindManyArgs
    _count?: boolean | QuestionsAnswerCommentCountOutputTypeArgs
  }

  export type QuestionsAnswerCommentGetPayload<
    S extends boolean | null | undefined | QuestionsAnswerCommentArgs,
    U = keyof S
      > = S extends true
        ? QuestionsAnswerComment
    : S extends undefined
    ? never
    : S extends QuestionsAnswerCommentArgs | QuestionsAnswerCommentFindManyArgs
    ?'include' extends U
    ? QuestionsAnswerComment  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'answer' ? QuestionsAnswerGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'votes' ? Array < QuestionsAnswerCommentVoteGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? QuestionsAnswerCommentCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'answer' ? QuestionsAnswerGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'votes' ? Array < QuestionsAnswerCommentVoteGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? QuestionsAnswerCommentCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof QuestionsAnswerComment ? QuestionsAnswerComment[P] : never
  } 
    : QuestionsAnswerComment
  : QuestionsAnswerComment


  type QuestionsAnswerCommentCountArgs = Merge<
    Omit<QuestionsAnswerCommentFindManyArgs, 'select' | 'include'> & {
      select?: QuestionsAnswerCommentCountAggregateInputType | true
    }
  >

  export interface QuestionsAnswerCommentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one QuestionsAnswerComment that matches the filter.
     * @param {QuestionsAnswerCommentFindUniqueArgs} args - Arguments to find a QuestionsAnswerComment
     * @example
     * // Get one QuestionsAnswerComment
     * const questionsAnswerComment = await prisma.questionsAnswerComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuestionsAnswerCommentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QuestionsAnswerCommentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'QuestionsAnswerComment'> extends True ? CheckSelect<T, Prisma__QuestionsAnswerCommentClient<QuestionsAnswerComment>, Prisma__QuestionsAnswerCommentClient<QuestionsAnswerCommentGetPayload<T>>> : CheckSelect<T, Prisma__QuestionsAnswerCommentClient<QuestionsAnswerComment | null, null>, Prisma__QuestionsAnswerCommentClient<QuestionsAnswerCommentGetPayload<T> | null, null>>

    /**
     * Find the first QuestionsAnswerComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsAnswerCommentFindFirstArgs} args - Arguments to find a QuestionsAnswerComment
     * @example
     * // Get one QuestionsAnswerComment
     * const questionsAnswerComment = await prisma.questionsAnswerComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuestionsAnswerCommentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QuestionsAnswerCommentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'QuestionsAnswerComment'> extends True ? CheckSelect<T, Prisma__QuestionsAnswerCommentClient<QuestionsAnswerComment>, Prisma__QuestionsAnswerCommentClient<QuestionsAnswerCommentGetPayload<T>>> : CheckSelect<T, Prisma__QuestionsAnswerCommentClient<QuestionsAnswerComment | null, null>, Prisma__QuestionsAnswerCommentClient<QuestionsAnswerCommentGetPayload<T> | null, null>>

    /**
     * Find zero or more QuestionsAnswerComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsAnswerCommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionsAnswerComments
     * const questionsAnswerComments = await prisma.questionsAnswerComment.findMany()
     * 
     * // Get first 10 QuestionsAnswerComments
     * const questionsAnswerComments = await prisma.questionsAnswerComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionsAnswerCommentWithIdOnly = await prisma.questionsAnswerComment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuestionsAnswerCommentFindManyArgs>(
      args?: SelectSubset<T, QuestionsAnswerCommentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<QuestionsAnswerComment>>, PrismaPromise<Array<QuestionsAnswerCommentGetPayload<T>>>>

    /**
     * Create a QuestionsAnswerComment.
     * @param {QuestionsAnswerCommentCreateArgs} args - Arguments to create a QuestionsAnswerComment.
     * @example
     * // Create one QuestionsAnswerComment
     * const QuestionsAnswerComment = await prisma.questionsAnswerComment.create({
     *   data: {
     *     // ... data to create a QuestionsAnswerComment
     *   }
     * })
     * 
    **/
    create<T extends QuestionsAnswerCommentCreateArgs>(
      args: SelectSubset<T, QuestionsAnswerCommentCreateArgs>
    ): CheckSelect<T, Prisma__QuestionsAnswerCommentClient<QuestionsAnswerComment>, Prisma__QuestionsAnswerCommentClient<QuestionsAnswerCommentGetPayload<T>>>

    /**
     * Create many QuestionsAnswerComments.
     *     @param {QuestionsAnswerCommentCreateManyArgs} args - Arguments to create many QuestionsAnswerComments.
     *     @example
     *     // Create many QuestionsAnswerComments
     *     const questionsAnswerComment = await prisma.questionsAnswerComment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuestionsAnswerCommentCreateManyArgs>(
      args?: SelectSubset<T, QuestionsAnswerCommentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a QuestionsAnswerComment.
     * @param {QuestionsAnswerCommentDeleteArgs} args - Arguments to delete one QuestionsAnswerComment.
     * @example
     * // Delete one QuestionsAnswerComment
     * const QuestionsAnswerComment = await prisma.questionsAnswerComment.delete({
     *   where: {
     *     // ... filter to delete one QuestionsAnswerComment
     *   }
     * })
     * 
    **/
    delete<T extends QuestionsAnswerCommentDeleteArgs>(
      args: SelectSubset<T, QuestionsAnswerCommentDeleteArgs>
    ): CheckSelect<T, Prisma__QuestionsAnswerCommentClient<QuestionsAnswerComment>, Prisma__QuestionsAnswerCommentClient<QuestionsAnswerCommentGetPayload<T>>>

    /**
     * Update one QuestionsAnswerComment.
     * @param {QuestionsAnswerCommentUpdateArgs} args - Arguments to update one QuestionsAnswerComment.
     * @example
     * // Update one QuestionsAnswerComment
     * const questionsAnswerComment = await prisma.questionsAnswerComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuestionsAnswerCommentUpdateArgs>(
      args: SelectSubset<T, QuestionsAnswerCommentUpdateArgs>
    ): CheckSelect<T, Prisma__QuestionsAnswerCommentClient<QuestionsAnswerComment>, Prisma__QuestionsAnswerCommentClient<QuestionsAnswerCommentGetPayload<T>>>

    /**
     * Delete zero or more QuestionsAnswerComments.
     * @param {QuestionsAnswerCommentDeleteManyArgs} args - Arguments to filter QuestionsAnswerComments to delete.
     * @example
     * // Delete a few QuestionsAnswerComments
     * const { count } = await prisma.questionsAnswerComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuestionsAnswerCommentDeleteManyArgs>(
      args?: SelectSubset<T, QuestionsAnswerCommentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionsAnswerComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsAnswerCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionsAnswerComments
     * const questionsAnswerComment = await prisma.questionsAnswerComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuestionsAnswerCommentUpdateManyArgs>(
      args: SelectSubset<T, QuestionsAnswerCommentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one QuestionsAnswerComment.
     * @param {QuestionsAnswerCommentUpsertArgs} args - Arguments to update or create a QuestionsAnswerComment.
     * @example
     * // Update or create a QuestionsAnswerComment
     * const questionsAnswerComment = await prisma.questionsAnswerComment.upsert({
     *   create: {
     *     // ... data to create a QuestionsAnswerComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionsAnswerComment we want to update
     *   }
     * })
    **/
    upsert<T extends QuestionsAnswerCommentUpsertArgs>(
      args: SelectSubset<T, QuestionsAnswerCommentUpsertArgs>
    ): CheckSelect<T, Prisma__QuestionsAnswerCommentClient<QuestionsAnswerComment>, Prisma__QuestionsAnswerCommentClient<QuestionsAnswerCommentGetPayload<T>>>

    /**
     * Find one QuestionsAnswerComment that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {QuestionsAnswerCommentFindUniqueOrThrowArgs} args - Arguments to find a QuestionsAnswerComment
     * @example
     * // Get one QuestionsAnswerComment
     * const questionsAnswerComment = await prisma.questionsAnswerComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuestionsAnswerCommentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, QuestionsAnswerCommentFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__QuestionsAnswerCommentClient<QuestionsAnswerComment>, Prisma__QuestionsAnswerCommentClient<QuestionsAnswerCommentGetPayload<T>>>

    /**
     * Find the first QuestionsAnswerComment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsAnswerCommentFindFirstOrThrowArgs} args - Arguments to find a QuestionsAnswerComment
     * @example
     * // Get one QuestionsAnswerComment
     * const questionsAnswerComment = await prisma.questionsAnswerComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuestionsAnswerCommentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, QuestionsAnswerCommentFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__QuestionsAnswerCommentClient<QuestionsAnswerComment>, Prisma__QuestionsAnswerCommentClient<QuestionsAnswerCommentGetPayload<T>>>

    /**
     * Count the number of QuestionsAnswerComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsAnswerCommentCountArgs} args - Arguments to filter QuestionsAnswerComments to count.
     * @example
     * // Count the number of QuestionsAnswerComments
     * const count = await prisma.questionsAnswerComment.count({
     *   where: {
     *     // ... the filter for the QuestionsAnswerComments we want to count
     *   }
     * })
    **/
    count<T extends QuestionsAnswerCommentCountArgs>(
      args?: Subset<T, QuestionsAnswerCommentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionsAnswerCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionsAnswerComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsAnswerCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionsAnswerCommentAggregateArgs>(args: Subset<T, QuestionsAnswerCommentAggregateArgs>): PrismaPromise<GetQuestionsAnswerCommentAggregateType<T>>

    /**
     * Group by QuestionsAnswerComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsAnswerCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionsAnswerCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionsAnswerCommentGroupByArgs['orderBy'] }
        : { orderBy?: QuestionsAnswerCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionsAnswerCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionsAnswerCommentGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestionsAnswerComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QuestionsAnswerCommentClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    answer<T extends QuestionsAnswerArgs = {}>(args?: Subset<T, QuestionsAnswerArgs>): CheckSelect<T, Prisma__QuestionsAnswerClient<QuestionsAnswer | Null>, Prisma__QuestionsAnswerClient<QuestionsAnswerGetPayload<T> | Null>>;

    votes<T extends QuestionsAnswerCommentVoteFindManyArgs = {}>(args?: Subset<T, QuestionsAnswerCommentVoteFindManyArgs>): CheckSelect<T, PrismaPromise<Array<QuestionsAnswerCommentVote>| Null>, PrismaPromise<Array<QuestionsAnswerCommentVoteGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * QuestionsAnswerComment base type for findUnique actions
   */
  export type QuestionsAnswerCommentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the QuestionsAnswerComment
     * 
    **/
    select?: QuestionsAnswerCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsAnswerCommentInclude | null
    /**
     * Filter, which QuestionsAnswerComment to fetch.
     * 
    **/
    where: QuestionsAnswerCommentWhereUniqueInput
  }

  /**
   * QuestionsAnswerComment: findUnique
   */
  export interface QuestionsAnswerCommentFindUniqueArgs extends QuestionsAnswerCommentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuestionsAnswerComment base type for findFirst actions
   */
  export type QuestionsAnswerCommentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the QuestionsAnswerComment
     * 
    **/
    select?: QuestionsAnswerCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsAnswerCommentInclude | null
    /**
     * Filter, which QuestionsAnswerComment to fetch.
     * 
    **/
    where?: QuestionsAnswerCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsAnswerComments to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionsAnswerCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionsAnswerComments.
     * 
    **/
    cursor?: QuestionsAnswerCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsAnswerComments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsAnswerComments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionsAnswerComments.
     * 
    **/
    distinct?: Enumerable<QuestionsAnswerCommentScalarFieldEnum>
  }

  /**
   * QuestionsAnswerComment: findFirst
   */
  export interface QuestionsAnswerCommentFindFirstArgs extends QuestionsAnswerCommentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuestionsAnswerComment findMany
   */
  export type QuestionsAnswerCommentFindManyArgs = {
    /**
     * Select specific fields to fetch from the QuestionsAnswerComment
     * 
    **/
    select?: QuestionsAnswerCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsAnswerCommentInclude | null
    /**
     * Filter, which QuestionsAnswerComments to fetch.
     * 
    **/
    where?: QuestionsAnswerCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsAnswerComments to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionsAnswerCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestionsAnswerComments.
     * 
    **/
    cursor?: QuestionsAnswerCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsAnswerComments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsAnswerComments.
     * 
    **/
    skip?: number
    distinct?: Enumerable<QuestionsAnswerCommentScalarFieldEnum>
  }


  /**
   * QuestionsAnswerComment create
   */
  export type QuestionsAnswerCommentCreateArgs = {
    /**
     * Select specific fields to fetch from the QuestionsAnswerComment
     * 
    **/
    select?: QuestionsAnswerCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsAnswerCommentInclude | null
    /**
     * The data needed to create a QuestionsAnswerComment.
     * 
    **/
    data: XOR<QuestionsAnswerCommentCreateInput, QuestionsAnswerCommentUncheckedCreateInput>
  }


  /**
   * QuestionsAnswerComment createMany
   */
  export type QuestionsAnswerCommentCreateManyArgs = {
    /**
     * The data used to create many QuestionsAnswerComments.
     * 
    **/
    data: Enumerable<QuestionsAnswerCommentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * QuestionsAnswerComment update
   */
  export type QuestionsAnswerCommentUpdateArgs = {
    /**
     * Select specific fields to fetch from the QuestionsAnswerComment
     * 
    **/
    select?: QuestionsAnswerCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsAnswerCommentInclude | null
    /**
     * The data needed to update a QuestionsAnswerComment.
     * 
    **/
    data: XOR<QuestionsAnswerCommentUpdateInput, QuestionsAnswerCommentUncheckedUpdateInput>
    /**
     * Choose, which QuestionsAnswerComment to update.
     * 
    **/
    where: QuestionsAnswerCommentWhereUniqueInput
  }


  /**
   * QuestionsAnswerComment updateMany
   */
  export type QuestionsAnswerCommentUpdateManyArgs = {
    /**
     * The data used to update QuestionsAnswerComments.
     * 
    **/
    data: XOR<QuestionsAnswerCommentUpdateManyMutationInput, QuestionsAnswerCommentUncheckedUpdateManyInput>
    /**
     * Filter which QuestionsAnswerComments to update
     * 
    **/
    where?: QuestionsAnswerCommentWhereInput
  }


  /**
   * QuestionsAnswerComment upsert
   */
  export type QuestionsAnswerCommentUpsertArgs = {
    /**
     * Select specific fields to fetch from the QuestionsAnswerComment
     * 
    **/
    select?: QuestionsAnswerCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsAnswerCommentInclude | null
    /**
     * The filter to search for the QuestionsAnswerComment to update in case it exists.
     * 
    **/
    where: QuestionsAnswerCommentWhereUniqueInput
    /**
     * In case the QuestionsAnswerComment found by the `where` argument doesn't exist, create a new QuestionsAnswerComment with this data.
     * 
    **/
    create: XOR<QuestionsAnswerCommentCreateInput, QuestionsAnswerCommentUncheckedCreateInput>
    /**
     * In case the QuestionsAnswerComment was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<QuestionsAnswerCommentUpdateInput, QuestionsAnswerCommentUncheckedUpdateInput>
  }


  /**
   * QuestionsAnswerComment delete
   */
  export type QuestionsAnswerCommentDeleteArgs = {
    /**
     * Select specific fields to fetch from the QuestionsAnswerComment
     * 
    **/
    select?: QuestionsAnswerCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsAnswerCommentInclude | null
    /**
     * Filter which QuestionsAnswerComment to delete.
     * 
    **/
    where: QuestionsAnswerCommentWhereUniqueInput
  }


  /**
   * QuestionsAnswerComment deleteMany
   */
  export type QuestionsAnswerCommentDeleteManyArgs = {
    /**
     * Filter which QuestionsAnswerComments to delete
     * 
    **/
    where?: QuestionsAnswerCommentWhereInput
  }


  /**
   * QuestionsAnswerComment: findUniqueOrThrow
   */
  export type QuestionsAnswerCommentFindUniqueOrThrowArgs = QuestionsAnswerCommentFindUniqueArgsBase
      

  /**
   * QuestionsAnswerComment: findFirstOrThrow
   */
  export type QuestionsAnswerCommentFindFirstOrThrowArgs = QuestionsAnswerCommentFindFirstArgsBase
      

  /**
   * QuestionsAnswerComment without action
   */
  export type QuestionsAnswerCommentArgs = {
    /**
     * Select specific fields to fetch from the QuestionsAnswerComment
     * 
    **/
    select?: QuestionsAnswerCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsAnswerCommentInclude | null
  }



  /**
   * Model QuestionsAnswerCommentVote
   */


  export type AggregateQuestionsAnswerCommentVote = {
    _count: QuestionsAnswerCommentVoteCountAggregateOutputType | null
    _min: QuestionsAnswerCommentVoteMinAggregateOutputType | null
    _max: QuestionsAnswerCommentVoteMaxAggregateOutputType | null
  }

  export type QuestionsAnswerCommentVoteMinAggregateOutputType = {
    id: string | null
    answerCommentId: string | null
    userId: string | null
    vote: Vote | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionsAnswerCommentVoteMaxAggregateOutputType = {
    id: string | null
    answerCommentId: string | null
    userId: string | null
    vote: Vote | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionsAnswerCommentVoteCountAggregateOutputType = {
    id: number
    answerCommentId: number
    userId: number
    vote: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuestionsAnswerCommentVoteMinAggregateInputType = {
    id?: true
    answerCommentId?: true
    userId?: true
    vote?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionsAnswerCommentVoteMaxAggregateInputType = {
    id?: true
    answerCommentId?: true
    userId?: true
    vote?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionsAnswerCommentVoteCountAggregateInputType = {
    id?: true
    answerCommentId?: true
    userId?: true
    vote?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuestionsAnswerCommentVoteAggregateArgs = {
    /**
     * Filter which QuestionsAnswerCommentVote to aggregate.
     * 
    **/
    where?: QuestionsAnswerCommentVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsAnswerCommentVotes to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionsAnswerCommentVoteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: QuestionsAnswerCommentVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsAnswerCommentVotes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsAnswerCommentVotes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestionsAnswerCommentVotes
    **/
    _count?: true | QuestionsAnswerCommentVoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionsAnswerCommentVoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionsAnswerCommentVoteMaxAggregateInputType
  }

  export type GetQuestionsAnswerCommentVoteAggregateType<T extends QuestionsAnswerCommentVoteAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionsAnswerCommentVote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionsAnswerCommentVote[P]>
      : GetScalarType<T[P], AggregateQuestionsAnswerCommentVote[P]>
  }




  export type QuestionsAnswerCommentVoteGroupByArgs = {
    where?: QuestionsAnswerCommentVoteWhereInput
    orderBy?: Enumerable<QuestionsAnswerCommentVoteOrderByWithAggregationInput>
    by: Array<QuestionsAnswerCommentVoteScalarFieldEnum>
    having?: QuestionsAnswerCommentVoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionsAnswerCommentVoteCountAggregateInputType | true
    _min?: QuestionsAnswerCommentVoteMinAggregateInputType
    _max?: QuestionsAnswerCommentVoteMaxAggregateInputType
  }


  export type QuestionsAnswerCommentVoteGroupByOutputType = {
    id: string
    answerCommentId: string
    userId: string | null
    vote: Vote
    createdAt: Date
    updatedAt: Date
    _count: QuestionsAnswerCommentVoteCountAggregateOutputType | null
    _min: QuestionsAnswerCommentVoteMinAggregateOutputType | null
    _max: QuestionsAnswerCommentVoteMaxAggregateOutputType | null
  }

  type GetQuestionsAnswerCommentVoteGroupByPayload<T extends QuestionsAnswerCommentVoteGroupByArgs> = PrismaPromise<
    Array<
      PickArray<QuestionsAnswerCommentVoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionsAnswerCommentVoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionsAnswerCommentVoteGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionsAnswerCommentVoteGroupByOutputType[P]>
        }
      >
    >


  export type QuestionsAnswerCommentVoteSelect = {
    id?: boolean
    answerCommentId?: boolean
    userId?: boolean
    vote?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs
    comment?: boolean | QuestionsAnswerCommentArgs
  }

  export type QuestionsAnswerCommentVoteInclude = {
    user?: boolean | UserArgs
    comment?: boolean | QuestionsAnswerCommentArgs
  }

  export type QuestionsAnswerCommentVoteGetPayload<
    S extends boolean | null | undefined | QuestionsAnswerCommentVoteArgs,
    U = keyof S
      > = S extends true
        ? QuestionsAnswerCommentVote
    : S extends undefined
    ? never
    : S extends QuestionsAnswerCommentVoteArgs | QuestionsAnswerCommentVoteFindManyArgs
    ?'include' extends U
    ? QuestionsAnswerCommentVote  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'comment' ? QuestionsAnswerCommentGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'comment' ? QuestionsAnswerCommentGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof QuestionsAnswerCommentVote ? QuestionsAnswerCommentVote[P] : never
  } 
    : QuestionsAnswerCommentVote
  : QuestionsAnswerCommentVote


  type QuestionsAnswerCommentVoteCountArgs = Merge<
    Omit<QuestionsAnswerCommentVoteFindManyArgs, 'select' | 'include'> & {
      select?: QuestionsAnswerCommentVoteCountAggregateInputType | true
    }
  >

  export interface QuestionsAnswerCommentVoteDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one QuestionsAnswerCommentVote that matches the filter.
     * @param {QuestionsAnswerCommentVoteFindUniqueArgs} args - Arguments to find a QuestionsAnswerCommentVote
     * @example
     * // Get one QuestionsAnswerCommentVote
     * const questionsAnswerCommentVote = await prisma.questionsAnswerCommentVote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuestionsAnswerCommentVoteFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QuestionsAnswerCommentVoteFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'QuestionsAnswerCommentVote'> extends True ? CheckSelect<T, Prisma__QuestionsAnswerCommentVoteClient<QuestionsAnswerCommentVote>, Prisma__QuestionsAnswerCommentVoteClient<QuestionsAnswerCommentVoteGetPayload<T>>> : CheckSelect<T, Prisma__QuestionsAnswerCommentVoteClient<QuestionsAnswerCommentVote | null, null>, Prisma__QuestionsAnswerCommentVoteClient<QuestionsAnswerCommentVoteGetPayload<T> | null, null>>

    /**
     * Find the first QuestionsAnswerCommentVote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsAnswerCommentVoteFindFirstArgs} args - Arguments to find a QuestionsAnswerCommentVote
     * @example
     * // Get one QuestionsAnswerCommentVote
     * const questionsAnswerCommentVote = await prisma.questionsAnswerCommentVote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuestionsAnswerCommentVoteFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QuestionsAnswerCommentVoteFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'QuestionsAnswerCommentVote'> extends True ? CheckSelect<T, Prisma__QuestionsAnswerCommentVoteClient<QuestionsAnswerCommentVote>, Prisma__QuestionsAnswerCommentVoteClient<QuestionsAnswerCommentVoteGetPayload<T>>> : CheckSelect<T, Prisma__QuestionsAnswerCommentVoteClient<QuestionsAnswerCommentVote | null, null>, Prisma__QuestionsAnswerCommentVoteClient<QuestionsAnswerCommentVoteGetPayload<T> | null, null>>

    /**
     * Find zero or more QuestionsAnswerCommentVotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsAnswerCommentVoteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionsAnswerCommentVotes
     * const questionsAnswerCommentVotes = await prisma.questionsAnswerCommentVote.findMany()
     * 
     * // Get first 10 QuestionsAnswerCommentVotes
     * const questionsAnswerCommentVotes = await prisma.questionsAnswerCommentVote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionsAnswerCommentVoteWithIdOnly = await prisma.questionsAnswerCommentVote.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuestionsAnswerCommentVoteFindManyArgs>(
      args?: SelectSubset<T, QuestionsAnswerCommentVoteFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<QuestionsAnswerCommentVote>>, PrismaPromise<Array<QuestionsAnswerCommentVoteGetPayload<T>>>>

    /**
     * Create a QuestionsAnswerCommentVote.
     * @param {QuestionsAnswerCommentVoteCreateArgs} args - Arguments to create a QuestionsAnswerCommentVote.
     * @example
     * // Create one QuestionsAnswerCommentVote
     * const QuestionsAnswerCommentVote = await prisma.questionsAnswerCommentVote.create({
     *   data: {
     *     // ... data to create a QuestionsAnswerCommentVote
     *   }
     * })
     * 
    **/
    create<T extends QuestionsAnswerCommentVoteCreateArgs>(
      args: SelectSubset<T, QuestionsAnswerCommentVoteCreateArgs>
    ): CheckSelect<T, Prisma__QuestionsAnswerCommentVoteClient<QuestionsAnswerCommentVote>, Prisma__QuestionsAnswerCommentVoteClient<QuestionsAnswerCommentVoteGetPayload<T>>>

    /**
     * Create many QuestionsAnswerCommentVotes.
     *     @param {QuestionsAnswerCommentVoteCreateManyArgs} args - Arguments to create many QuestionsAnswerCommentVotes.
     *     @example
     *     // Create many QuestionsAnswerCommentVotes
     *     const questionsAnswerCommentVote = await prisma.questionsAnswerCommentVote.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuestionsAnswerCommentVoteCreateManyArgs>(
      args?: SelectSubset<T, QuestionsAnswerCommentVoteCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a QuestionsAnswerCommentVote.
     * @param {QuestionsAnswerCommentVoteDeleteArgs} args - Arguments to delete one QuestionsAnswerCommentVote.
     * @example
     * // Delete one QuestionsAnswerCommentVote
     * const QuestionsAnswerCommentVote = await prisma.questionsAnswerCommentVote.delete({
     *   where: {
     *     // ... filter to delete one QuestionsAnswerCommentVote
     *   }
     * })
     * 
    **/
    delete<T extends QuestionsAnswerCommentVoteDeleteArgs>(
      args: SelectSubset<T, QuestionsAnswerCommentVoteDeleteArgs>
    ): CheckSelect<T, Prisma__QuestionsAnswerCommentVoteClient<QuestionsAnswerCommentVote>, Prisma__QuestionsAnswerCommentVoteClient<QuestionsAnswerCommentVoteGetPayload<T>>>

    /**
     * Update one QuestionsAnswerCommentVote.
     * @param {QuestionsAnswerCommentVoteUpdateArgs} args - Arguments to update one QuestionsAnswerCommentVote.
     * @example
     * // Update one QuestionsAnswerCommentVote
     * const questionsAnswerCommentVote = await prisma.questionsAnswerCommentVote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuestionsAnswerCommentVoteUpdateArgs>(
      args: SelectSubset<T, QuestionsAnswerCommentVoteUpdateArgs>
    ): CheckSelect<T, Prisma__QuestionsAnswerCommentVoteClient<QuestionsAnswerCommentVote>, Prisma__QuestionsAnswerCommentVoteClient<QuestionsAnswerCommentVoteGetPayload<T>>>

    /**
     * Delete zero or more QuestionsAnswerCommentVotes.
     * @param {QuestionsAnswerCommentVoteDeleteManyArgs} args - Arguments to filter QuestionsAnswerCommentVotes to delete.
     * @example
     * // Delete a few QuestionsAnswerCommentVotes
     * const { count } = await prisma.questionsAnswerCommentVote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuestionsAnswerCommentVoteDeleteManyArgs>(
      args?: SelectSubset<T, QuestionsAnswerCommentVoteDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionsAnswerCommentVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsAnswerCommentVoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionsAnswerCommentVotes
     * const questionsAnswerCommentVote = await prisma.questionsAnswerCommentVote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuestionsAnswerCommentVoteUpdateManyArgs>(
      args: SelectSubset<T, QuestionsAnswerCommentVoteUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one QuestionsAnswerCommentVote.
     * @param {QuestionsAnswerCommentVoteUpsertArgs} args - Arguments to update or create a QuestionsAnswerCommentVote.
     * @example
     * // Update or create a QuestionsAnswerCommentVote
     * const questionsAnswerCommentVote = await prisma.questionsAnswerCommentVote.upsert({
     *   create: {
     *     // ... data to create a QuestionsAnswerCommentVote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionsAnswerCommentVote we want to update
     *   }
     * })
    **/
    upsert<T extends QuestionsAnswerCommentVoteUpsertArgs>(
      args: SelectSubset<T, QuestionsAnswerCommentVoteUpsertArgs>
    ): CheckSelect<T, Prisma__QuestionsAnswerCommentVoteClient<QuestionsAnswerCommentVote>, Prisma__QuestionsAnswerCommentVoteClient<QuestionsAnswerCommentVoteGetPayload<T>>>

    /**
     * Find one QuestionsAnswerCommentVote that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {QuestionsAnswerCommentVoteFindUniqueOrThrowArgs} args - Arguments to find a QuestionsAnswerCommentVote
     * @example
     * // Get one QuestionsAnswerCommentVote
     * const questionsAnswerCommentVote = await prisma.questionsAnswerCommentVote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuestionsAnswerCommentVoteFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, QuestionsAnswerCommentVoteFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__QuestionsAnswerCommentVoteClient<QuestionsAnswerCommentVote>, Prisma__QuestionsAnswerCommentVoteClient<QuestionsAnswerCommentVoteGetPayload<T>>>

    /**
     * Find the first QuestionsAnswerCommentVote that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsAnswerCommentVoteFindFirstOrThrowArgs} args - Arguments to find a QuestionsAnswerCommentVote
     * @example
     * // Get one QuestionsAnswerCommentVote
     * const questionsAnswerCommentVote = await prisma.questionsAnswerCommentVote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuestionsAnswerCommentVoteFindFirstOrThrowArgs>(
      args?: SelectSubset<T, QuestionsAnswerCommentVoteFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__QuestionsAnswerCommentVoteClient<QuestionsAnswerCommentVote>, Prisma__QuestionsAnswerCommentVoteClient<QuestionsAnswerCommentVoteGetPayload<T>>>

    /**
     * Count the number of QuestionsAnswerCommentVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsAnswerCommentVoteCountArgs} args - Arguments to filter QuestionsAnswerCommentVotes to count.
     * @example
     * // Count the number of QuestionsAnswerCommentVotes
     * const count = await prisma.questionsAnswerCommentVote.count({
     *   where: {
     *     // ... the filter for the QuestionsAnswerCommentVotes we want to count
     *   }
     * })
    **/
    count<T extends QuestionsAnswerCommentVoteCountArgs>(
      args?: Subset<T, QuestionsAnswerCommentVoteCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionsAnswerCommentVoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionsAnswerCommentVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsAnswerCommentVoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionsAnswerCommentVoteAggregateArgs>(args: Subset<T, QuestionsAnswerCommentVoteAggregateArgs>): PrismaPromise<GetQuestionsAnswerCommentVoteAggregateType<T>>

    /**
     * Group by QuestionsAnswerCommentVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsAnswerCommentVoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionsAnswerCommentVoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionsAnswerCommentVoteGroupByArgs['orderBy'] }
        : { orderBy?: QuestionsAnswerCommentVoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionsAnswerCommentVoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionsAnswerCommentVoteGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestionsAnswerCommentVote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QuestionsAnswerCommentVoteClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    comment<T extends QuestionsAnswerCommentArgs = {}>(args?: Subset<T, QuestionsAnswerCommentArgs>): CheckSelect<T, Prisma__QuestionsAnswerCommentClient<QuestionsAnswerComment | Null>, Prisma__QuestionsAnswerCommentClient<QuestionsAnswerCommentGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * QuestionsAnswerCommentVote base type for findUnique actions
   */
  export type QuestionsAnswerCommentVoteFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the QuestionsAnswerCommentVote
     * 
    **/
    select?: QuestionsAnswerCommentVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsAnswerCommentVoteInclude | null
    /**
     * Filter, which QuestionsAnswerCommentVote to fetch.
     * 
    **/
    where: QuestionsAnswerCommentVoteWhereUniqueInput
  }

  /**
   * QuestionsAnswerCommentVote: findUnique
   */
  export interface QuestionsAnswerCommentVoteFindUniqueArgs extends QuestionsAnswerCommentVoteFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuestionsAnswerCommentVote base type for findFirst actions
   */
  export type QuestionsAnswerCommentVoteFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the QuestionsAnswerCommentVote
     * 
    **/
    select?: QuestionsAnswerCommentVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsAnswerCommentVoteInclude | null
    /**
     * Filter, which QuestionsAnswerCommentVote to fetch.
     * 
    **/
    where?: QuestionsAnswerCommentVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsAnswerCommentVotes to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionsAnswerCommentVoteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionsAnswerCommentVotes.
     * 
    **/
    cursor?: QuestionsAnswerCommentVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsAnswerCommentVotes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsAnswerCommentVotes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionsAnswerCommentVotes.
     * 
    **/
    distinct?: Enumerable<QuestionsAnswerCommentVoteScalarFieldEnum>
  }

  /**
   * QuestionsAnswerCommentVote: findFirst
   */
  export interface QuestionsAnswerCommentVoteFindFirstArgs extends QuestionsAnswerCommentVoteFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuestionsAnswerCommentVote findMany
   */
  export type QuestionsAnswerCommentVoteFindManyArgs = {
    /**
     * Select specific fields to fetch from the QuestionsAnswerCommentVote
     * 
    **/
    select?: QuestionsAnswerCommentVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsAnswerCommentVoteInclude | null
    /**
     * Filter, which QuestionsAnswerCommentVotes to fetch.
     * 
    **/
    where?: QuestionsAnswerCommentVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsAnswerCommentVotes to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionsAnswerCommentVoteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestionsAnswerCommentVotes.
     * 
    **/
    cursor?: QuestionsAnswerCommentVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsAnswerCommentVotes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsAnswerCommentVotes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<QuestionsAnswerCommentVoteScalarFieldEnum>
  }


  /**
   * QuestionsAnswerCommentVote create
   */
  export type QuestionsAnswerCommentVoteCreateArgs = {
    /**
     * Select specific fields to fetch from the QuestionsAnswerCommentVote
     * 
    **/
    select?: QuestionsAnswerCommentVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsAnswerCommentVoteInclude | null
    /**
     * The data needed to create a QuestionsAnswerCommentVote.
     * 
    **/
    data: XOR<QuestionsAnswerCommentVoteCreateInput, QuestionsAnswerCommentVoteUncheckedCreateInput>
  }


  /**
   * QuestionsAnswerCommentVote createMany
   */
  export type QuestionsAnswerCommentVoteCreateManyArgs = {
    /**
     * The data used to create many QuestionsAnswerCommentVotes.
     * 
    **/
    data: Enumerable<QuestionsAnswerCommentVoteCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * QuestionsAnswerCommentVote update
   */
  export type QuestionsAnswerCommentVoteUpdateArgs = {
    /**
     * Select specific fields to fetch from the QuestionsAnswerCommentVote
     * 
    **/
    select?: QuestionsAnswerCommentVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsAnswerCommentVoteInclude | null
    /**
     * The data needed to update a QuestionsAnswerCommentVote.
     * 
    **/
    data: XOR<QuestionsAnswerCommentVoteUpdateInput, QuestionsAnswerCommentVoteUncheckedUpdateInput>
    /**
     * Choose, which QuestionsAnswerCommentVote to update.
     * 
    **/
    where: QuestionsAnswerCommentVoteWhereUniqueInput
  }


  /**
   * QuestionsAnswerCommentVote updateMany
   */
  export type QuestionsAnswerCommentVoteUpdateManyArgs = {
    /**
     * The data used to update QuestionsAnswerCommentVotes.
     * 
    **/
    data: XOR<QuestionsAnswerCommentVoteUpdateManyMutationInput, QuestionsAnswerCommentVoteUncheckedUpdateManyInput>
    /**
     * Filter which QuestionsAnswerCommentVotes to update
     * 
    **/
    where?: QuestionsAnswerCommentVoteWhereInput
  }


  /**
   * QuestionsAnswerCommentVote upsert
   */
  export type QuestionsAnswerCommentVoteUpsertArgs = {
    /**
     * Select specific fields to fetch from the QuestionsAnswerCommentVote
     * 
    **/
    select?: QuestionsAnswerCommentVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsAnswerCommentVoteInclude | null
    /**
     * The filter to search for the QuestionsAnswerCommentVote to update in case it exists.
     * 
    **/
    where: QuestionsAnswerCommentVoteWhereUniqueInput
    /**
     * In case the QuestionsAnswerCommentVote found by the `where` argument doesn't exist, create a new QuestionsAnswerCommentVote with this data.
     * 
    **/
    create: XOR<QuestionsAnswerCommentVoteCreateInput, QuestionsAnswerCommentVoteUncheckedCreateInput>
    /**
     * In case the QuestionsAnswerCommentVote was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<QuestionsAnswerCommentVoteUpdateInput, QuestionsAnswerCommentVoteUncheckedUpdateInput>
  }


  /**
   * QuestionsAnswerCommentVote delete
   */
  export type QuestionsAnswerCommentVoteDeleteArgs = {
    /**
     * Select specific fields to fetch from the QuestionsAnswerCommentVote
     * 
    **/
    select?: QuestionsAnswerCommentVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsAnswerCommentVoteInclude | null
    /**
     * Filter which QuestionsAnswerCommentVote to delete.
     * 
    **/
    where: QuestionsAnswerCommentVoteWhereUniqueInput
  }


  /**
   * QuestionsAnswerCommentVote deleteMany
   */
  export type QuestionsAnswerCommentVoteDeleteManyArgs = {
    /**
     * Filter which QuestionsAnswerCommentVotes to delete
     * 
    **/
    where?: QuestionsAnswerCommentVoteWhereInput
  }


  /**
   * QuestionsAnswerCommentVote: findUniqueOrThrow
   */
  export type QuestionsAnswerCommentVoteFindUniqueOrThrowArgs = QuestionsAnswerCommentVoteFindUniqueArgsBase
      

  /**
   * QuestionsAnswerCommentVote: findFirstOrThrow
   */
  export type QuestionsAnswerCommentVoteFindFirstOrThrowArgs = QuestionsAnswerCommentVoteFindFirstArgsBase
      

  /**
   * QuestionsAnswerCommentVote without action
   */
  export type QuestionsAnswerCommentVoteArgs = {
    /**
     * Select specific fields to fetch from the QuestionsAnswerCommentVote
     * 
    **/
    select?: QuestionsAnswerCommentVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsAnswerCommentVoteInclude | null
  }



  /**
   * Model QuestionsList
   */


  export type AggregateQuestionsList = {
    _count: QuestionsListCountAggregateOutputType | null
    _min: QuestionsListMinAggregateOutputType | null
    _max: QuestionsListMaxAggregateOutputType | null
  }

  export type QuestionsListMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionsListMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionsListCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuestionsListMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionsListMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionsListCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuestionsListAggregateArgs = {
    /**
     * Filter which QuestionsList to aggregate.
     * 
    **/
    where?: QuestionsListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsLists to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionsListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: QuestionsListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsLists from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsLists.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestionsLists
    **/
    _count?: true | QuestionsListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionsListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionsListMaxAggregateInputType
  }

  export type GetQuestionsListAggregateType<T extends QuestionsListAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionsList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionsList[P]>
      : GetScalarType<T[P], AggregateQuestionsList[P]>
  }




  export type QuestionsListGroupByArgs = {
    where?: QuestionsListWhereInput
    orderBy?: Enumerable<QuestionsListOrderByWithAggregationInput>
    by: Array<QuestionsListScalarFieldEnum>
    having?: QuestionsListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionsListCountAggregateInputType | true
    _min?: QuestionsListMinAggregateInputType
    _max?: QuestionsListMaxAggregateInputType
  }


  export type QuestionsListGroupByOutputType = {
    id: string
    userId: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: QuestionsListCountAggregateOutputType | null
    _min: QuestionsListMinAggregateOutputType | null
    _max: QuestionsListMaxAggregateOutputType | null
  }

  type GetQuestionsListGroupByPayload<T extends QuestionsListGroupByArgs> = PrismaPromise<
    Array<
      PickArray<QuestionsListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionsListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionsListGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionsListGroupByOutputType[P]>
        }
      >
    >


  export type QuestionsListSelect = {
    id?: boolean
    userId?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs
    questionEntries?: boolean | QuestionsListQuestionEntryFindManyArgs
    _count?: boolean | QuestionsListCountOutputTypeArgs
  }

  export type QuestionsListInclude = {
    user?: boolean | UserArgs
    questionEntries?: boolean | QuestionsListQuestionEntryFindManyArgs
    _count?: boolean | QuestionsListCountOutputTypeArgs
  }

  export type QuestionsListGetPayload<
    S extends boolean | null | undefined | QuestionsListArgs,
    U = keyof S
      > = S extends true
        ? QuestionsList
    : S extends undefined
    ? never
    : S extends QuestionsListArgs | QuestionsListFindManyArgs
    ?'include' extends U
    ? QuestionsList  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'questionEntries' ? Array < QuestionsListQuestionEntryGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? QuestionsListCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'questionEntries' ? Array < QuestionsListQuestionEntryGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? QuestionsListCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof QuestionsList ? QuestionsList[P] : never
  } 
    : QuestionsList
  : QuestionsList


  type QuestionsListCountArgs = Merge<
    Omit<QuestionsListFindManyArgs, 'select' | 'include'> & {
      select?: QuestionsListCountAggregateInputType | true
    }
  >

  export interface QuestionsListDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one QuestionsList that matches the filter.
     * @param {QuestionsListFindUniqueArgs} args - Arguments to find a QuestionsList
     * @example
     * // Get one QuestionsList
     * const questionsList = await prisma.questionsList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuestionsListFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QuestionsListFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'QuestionsList'> extends True ? CheckSelect<T, Prisma__QuestionsListClient<QuestionsList>, Prisma__QuestionsListClient<QuestionsListGetPayload<T>>> : CheckSelect<T, Prisma__QuestionsListClient<QuestionsList | null, null>, Prisma__QuestionsListClient<QuestionsListGetPayload<T> | null, null>>

    /**
     * Find the first QuestionsList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsListFindFirstArgs} args - Arguments to find a QuestionsList
     * @example
     * // Get one QuestionsList
     * const questionsList = await prisma.questionsList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuestionsListFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QuestionsListFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'QuestionsList'> extends True ? CheckSelect<T, Prisma__QuestionsListClient<QuestionsList>, Prisma__QuestionsListClient<QuestionsListGetPayload<T>>> : CheckSelect<T, Prisma__QuestionsListClient<QuestionsList | null, null>, Prisma__QuestionsListClient<QuestionsListGetPayload<T> | null, null>>

    /**
     * Find zero or more QuestionsLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsListFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionsLists
     * const questionsLists = await prisma.questionsList.findMany()
     * 
     * // Get first 10 QuestionsLists
     * const questionsLists = await prisma.questionsList.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionsListWithIdOnly = await prisma.questionsList.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuestionsListFindManyArgs>(
      args?: SelectSubset<T, QuestionsListFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<QuestionsList>>, PrismaPromise<Array<QuestionsListGetPayload<T>>>>

    /**
     * Create a QuestionsList.
     * @param {QuestionsListCreateArgs} args - Arguments to create a QuestionsList.
     * @example
     * // Create one QuestionsList
     * const QuestionsList = await prisma.questionsList.create({
     *   data: {
     *     // ... data to create a QuestionsList
     *   }
     * })
     * 
    **/
    create<T extends QuestionsListCreateArgs>(
      args: SelectSubset<T, QuestionsListCreateArgs>
    ): CheckSelect<T, Prisma__QuestionsListClient<QuestionsList>, Prisma__QuestionsListClient<QuestionsListGetPayload<T>>>

    /**
     * Create many QuestionsLists.
     *     @param {QuestionsListCreateManyArgs} args - Arguments to create many QuestionsLists.
     *     @example
     *     // Create many QuestionsLists
     *     const questionsList = await prisma.questionsList.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuestionsListCreateManyArgs>(
      args?: SelectSubset<T, QuestionsListCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a QuestionsList.
     * @param {QuestionsListDeleteArgs} args - Arguments to delete one QuestionsList.
     * @example
     * // Delete one QuestionsList
     * const QuestionsList = await prisma.questionsList.delete({
     *   where: {
     *     // ... filter to delete one QuestionsList
     *   }
     * })
     * 
    **/
    delete<T extends QuestionsListDeleteArgs>(
      args: SelectSubset<T, QuestionsListDeleteArgs>
    ): CheckSelect<T, Prisma__QuestionsListClient<QuestionsList>, Prisma__QuestionsListClient<QuestionsListGetPayload<T>>>

    /**
     * Update one QuestionsList.
     * @param {QuestionsListUpdateArgs} args - Arguments to update one QuestionsList.
     * @example
     * // Update one QuestionsList
     * const questionsList = await prisma.questionsList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuestionsListUpdateArgs>(
      args: SelectSubset<T, QuestionsListUpdateArgs>
    ): CheckSelect<T, Prisma__QuestionsListClient<QuestionsList>, Prisma__QuestionsListClient<QuestionsListGetPayload<T>>>

    /**
     * Delete zero or more QuestionsLists.
     * @param {QuestionsListDeleteManyArgs} args - Arguments to filter QuestionsLists to delete.
     * @example
     * // Delete a few QuestionsLists
     * const { count } = await prisma.questionsList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuestionsListDeleteManyArgs>(
      args?: SelectSubset<T, QuestionsListDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionsLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionsLists
     * const questionsList = await prisma.questionsList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuestionsListUpdateManyArgs>(
      args: SelectSubset<T, QuestionsListUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one QuestionsList.
     * @param {QuestionsListUpsertArgs} args - Arguments to update or create a QuestionsList.
     * @example
     * // Update or create a QuestionsList
     * const questionsList = await prisma.questionsList.upsert({
     *   create: {
     *     // ... data to create a QuestionsList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionsList we want to update
     *   }
     * })
    **/
    upsert<T extends QuestionsListUpsertArgs>(
      args: SelectSubset<T, QuestionsListUpsertArgs>
    ): CheckSelect<T, Prisma__QuestionsListClient<QuestionsList>, Prisma__QuestionsListClient<QuestionsListGetPayload<T>>>

    /**
     * Find one QuestionsList that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {QuestionsListFindUniqueOrThrowArgs} args - Arguments to find a QuestionsList
     * @example
     * // Get one QuestionsList
     * const questionsList = await prisma.questionsList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuestionsListFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, QuestionsListFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__QuestionsListClient<QuestionsList>, Prisma__QuestionsListClient<QuestionsListGetPayload<T>>>

    /**
     * Find the first QuestionsList that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsListFindFirstOrThrowArgs} args - Arguments to find a QuestionsList
     * @example
     * // Get one QuestionsList
     * const questionsList = await prisma.questionsList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuestionsListFindFirstOrThrowArgs>(
      args?: SelectSubset<T, QuestionsListFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__QuestionsListClient<QuestionsList>, Prisma__QuestionsListClient<QuestionsListGetPayload<T>>>

    /**
     * Count the number of QuestionsLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsListCountArgs} args - Arguments to filter QuestionsLists to count.
     * @example
     * // Count the number of QuestionsLists
     * const count = await prisma.questionsList.count({
     *   where: {
     *     // ... the filter for the QuestionsLists we want to count
     *   }
     * })
    **/
    count<T extends QuestionsListCountArgs>(
      args?: Subset<T, QuestionsListCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionsListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionsList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionsListAggregateArgs>(args: Subset<T, QuestionsListAggregateArgs>): PrismaPromise<GetQuestionsListAggregateType<T>>

    /**
     * Group by QuestionsList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionsListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionsListGroupByArgs['orderBy'] }
        : { orderBy?: QuestionsListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionsListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionsListGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestionsList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QuestionsListClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    questionEntries<T extends QuestionsListQuestionEntryFindManyArgs = {}>(args?: Subset<T, QuestionsListQuestionEntryFindManyArgs>): CheckSelect<T, PrismaPromise<Array<QuestionsListQuestionEntry>| Null>, PrismaPromise<Array<QuestionsListQuestionEntryGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * QuestionsList base type for findUnique actions
   */
  export type QuestionsListFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the QuestionsList
     * 
    **/
    select?: QuestionsListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsListInclude | null
    /**
     * Filter, which QuestionsList to fetch.
     * 
    **/
    where: QuestionsListWhereUniqueInput
  }

  /**
   * QuestionsList: findUnique
   */
  export interface QuestionsListFindUniqueArgs extends QuestionsListFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuestionsList base type for findFirst actions
   */
  export type QuestionsListFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the QuestionsList
     * 
    **/
    select?: QuestionsListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsListInclude | null
    /**
     * Filter, which QuestionsList to fetch.
     * 
    **/
    where?: QuestionsListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsLists to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionsListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionsLists.
     * 
    **/
    cursor?: QuestionsListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsLists from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsLists.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionsLists.
     * 
    **/
    distinct?: Enumerable<QuestionsListScalarFieldEnum>
  }

  /**
   * QuestionsList: findFirst
   */
  export interface QuestionsListFindFirstArgs extends QuestionsListFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuestionsList findMany
   */
  export type QuestionsListFindManyArgs = {
    /**
     * Select specific fields to fetch from the QuestionsList
     * 
    **/
    select?: QuestionsListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsListInclude | null
    /**
     * Filter, which QuestionsLists to fetch.
     * 
    **/
    where?: QuestionsListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsLists to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionsListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestionsLists.
     * 
    **/
    cursor?: QuestionsListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsLists from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsLists.
     * 
    **/
    skip?: number
    distinct?: Enumerable<QuestionsListScalarFieldEnum>
  }


  /**
   * QuestionsList create
   */
  export type QuestionsListCreateArgs = {
    /**
     * Select specific fields to fetch from the QuestionsList
     * 
    **/
    select?: QuestionsListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsListInclude | null
    /**
     * The data needed to create a QuestionsList.
     * 
    **/
    data: XOR<QuestionsListCreateInput, QuestionsListUncheckedCreateInput>
  }


  /**
   * QuestionsList createMany
   */
  export type QuestionsListCreateManyArgs = {
    /**
     * The data used to create many QuestionsLists.
     * 
    **/
    data: Enumerable<QuestionsListCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * QuestionsList update
   */
  export type QuestionsListUpdateArgs = {
    /**
     * Select specific fields to fetch from the QuestionsList
     * 
    **/
    select?: QuestionsListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsListInclude | null
    /**
     * The data needed to update a QuestionsList.
     * 
    **/
    data: XOR<QuestionsListUpdateInput, QuestionsListUncheckedUpdateInput>
    /**
     * Choose, which QuestionsList to update.
     * 
    **/
    where: QuestionsListWhereUniqueInput
  }


  /**
   * QuestionsList updateMany
   */
  export type QuestionsListUpdateManyArgs = {
    /**
     * The data used to update QuestionsLists.
     * 
    **/
    data: XOR<QuestionsListUpdateManyMutationInput, QuestionsListUncheckedUpdateManyInput>
    /**
     * Filter which QuestionsLists to update
     * 
    **/
    where?: QuestionsListWhereInput
  }


  /**
   * QuestionsList upsert
   */
  export type QuestionsListUpsertArgs = {
    /**
     * Select specific fields to fetch from the QuestionsList
     * 
    **/
    select?: QuestionsListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsListInclude | null
    /**
     * The filter to search for the QuestionsList to update in case it exists.
     * 
    **/
    where: QuestionsListWhereUniqueInput
    /**
     * In case the QuestionsList found by the `where` argument doesn't exist, create a new QuestionsList with this data.
     * 
    **/
    create: XOR<QuestionsListCreateInput, QuestionsListUncheckedCreateInput>
    /**
     * In case the QuestionsList was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<QuestionsListUpdateInput, QuestionsListUncheckedUpdateInput>
  }


  /**
   * QuestionsList delete
   */
  export type QuestionsListDeleteArgs = {
    /**
     * Select specific fields to fetch from the QuestionsList
     * 
    **/
    select?: QuestionsListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsListInclude | null
    /**
     * Filter which QuestionsList to delete.
     * 
    **/
    where: QuestionsListWhereUniqueInput
  }


  /**
   * QuestionsList deleteMany
   */
  export type QuestionsListDeleteManyArgs = {
    /**
     * Filter which QuestionsLists to delete
     * 
    **/
    where?: QuestionsListWhereInput
  }


  /**
   * QuestionsList: findUniqueOrThrow
   */
  export type QuestionsListFindUniqueOrThrowArgs = QuestionsListFindUniqueArgsBase
      

  /**
   * QuestionsList: findFirstOrThrow
   */
  export type QuestionsListFindFirstOrThrowArgs = QuestionsListFindFirstArgsBase
      

  /**
   * QuestionsList without action
   */
  export type QuestionsListArgs = {
    /**
     * Select specific fields to fetch from the QuestionsList
     * 
    **/
    select?: QuestionsListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsListInclude | null
  }



  /**
   * Model QuestionsListQuestionEntry
   */


  export type AggregateQuestionsListQuestionEntry = {
    _count: QuestionsListQuestionEntryCountAggregateOutputType | null
    _min: QuestionsListQuestionEntryMinAggregateOutputType | null
    _max: QuestionsListQuestionEntryMaxAggregateOutputType | null
  }

  export type QuestionsListQuestionEntryMinAggregateOutputType = {
    id: string | null
    listId: string | null
    questionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionsListQuestionEntryMaxAggregateOutputType = {
    id: string | null
    listId: string | null
    questionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionsListQuestionEntryCountAggregateOutputType = {
    id: number
    listId: number
    questionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuestionsListQuestionEntryMinAggregateInputType = {
    id?: true
    listId?: true
    questionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionsListQuestionEntryMaxAggregateInputType = {
    id?: true
    listId?: true
    questionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionsListQuestionEntryCountAggregateInputType = {
    id?: true
    listId?: true
    questionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuestionsListQuestionEntryAggregateArgs = {
    /**
     * Filter which QuestionsListQuestionEntry to aggregate.
     * 
    **/
    where?: QuestionsListQuestionEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsListQuestionEntries to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionsListQuestionEntryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: QuestionsListQuestionEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsListQuestionEntries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsListQuestionEntries.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestionsListQuestionEntries
    **/
    _count?: true | QuestionsListQuestionEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionsListQuestionEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionsListQuestionEntryMaxAggregateInputType
  }

  export type GetQuestionsListQuestionEntryAggregateType<T extends QuestionsListQuestionEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionsListQuestionEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionsListQuestionEntry[P]>
      : GetScalarType<T[P], AggregateQuestionsListQuestionEntry[P]>
  }




  export type QuestionsListQuestionEntryGroupByArgs = {
    where?: QuestionsListQuestionEntryWhereInput
    orderBy?: Enumerable<QuestionsListQuestionEntryOrderByWithAggregationInput>
    by: Array<QuestionsListQuestionEntryScalarFieldEnum>
    having?: QuestionsListQuestionEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionsListQuestionEntryCountAggregateInputType | true
    _min?: QuestionsListQuestionEntryMinAggregateInputType
    _max?: QuestionsListQuestionEntryMaxAggregateInputType
  }


  export type QuestionsListQuestionEntryGroupByOutputType = {
    id: string
    listId: string
    questionId: string
    createdAt: Date
    updatedAt: Date
    _count: QuestionsListQuestionEntryCountAggregateOutputType | null
    _min: QuestionsListQuestionEntryMinAggregateOutputType | null
    _max: QuestionsListQuestionEntryMaxAggregateOutputType | null
  }

  type GetQuestionsListQuestionEntryGroupByPayload<T extends QuestionsListQuestionEntryGroupByArgs> = PrismaPromise<
    Array<
      PickArray<QuestionsListQuestionEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionsListQuestionEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionsListQuestionEntryGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionsListQuestionEntryGroupByOutputType[P]>
        }
      >
    >


  export type QuestionsListQuestionEntrySelect = {
    id?: boolean
    listId?: boolean
    questionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    list?: boolean | QuestionsListArgs
    question?: boolean | QuestionsQuestionArgs
  }

  export type QuestionsListQuestionEntryInclude = {
    list?: boolean | QuestionsListArgs
    question?: boolean | QuestionsQuestionArgs
  }

  export type QuestionsListQuestionEntryGetPayload<
    S extends boolean | null | undefined | QuestionsListQuestionEntryArgs,
    U = keyof S
      > = S extends true
        ? QuestionsListQuestionEntry
    : S extends undefined
    ? never
    : S extends QuestionsListQuestionEntryArgs | QuestionsListQuestionEntryFindManyArgs
    ?'include' extends U
    ? QuestionsListQuestionEntry  & {
    [P in TrueKeys<S['include']>]:
        P extends 'list' ? QuestionsListGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'question' ? QuestionsQuestionGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'list' ? QuestionsListGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'question' ? QuestionsQuestionGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof QuestionsListQuestionEntry ? QuestionsListQuestionEntry[P] : never
  } 
    : QuestionsListQuestionEntry
  : QuestionsListQuestionEntry


  type QuestionsListQuestionEntryCountArgs = Merge<
    Omit<QuestionsListQuestionEntryFindManyArgs, 'select' | 'include'> & {
      select?: QuestionsListQuestionEntryCountAggregateInputType | true
    }
  >

  export interface QuestionsListQuestionEntryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one QuestionsListQuestionEntry that matches the filter.
     * @param {QuestionsListQuestionEntryFindUniqueArgs} args - Arguments to find a QuestionsListQuestionEntry
     * @example
     * // Get one QuestionsListQuestionEntry
     * const questionsListQuestionEntry = await prisma.questionsListQuestionEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuestionsListQuestionEntryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QuestionsListQuestionEntryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'QuestionsListQuestionEntry'> extends True ? CheckSelect<T, Prisma__QuestionsListQuestionEntryClient<QuestionsListQuestionEntry>, Prisma__QuestionsListQuestionEntryClient<QuestionsListQuestionEntryGetPayload<T>>> : CheckSelect<T, Prisma__QuestionsListQuestionEntryClient<QuestionsListQuestionEntry | null, null>, Prisma__QuestionsListQuestionEntryClient<QuestionsListQuestionEntryGetPayload<T> | null, null>>

    /**
     * Find the first QuestionsListQuestionEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsListQuestionEntryFindFirstArgs} args - Arguments to find a QuestionsListQuestionEntry
     * @example
     * // Get one QuestionsListQuestionEntry
     * const questionsListQuestionEntry = await prisma.questionsListQuestionEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuestionsListQuestionEntryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QuestionsListQuestionEntryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'QuestionsListQuestionEntry'> extends True ? CheckSelect<T, Prisma__QuestionsListQuestionEntryClient<QuestionsListQuestionEntry>, Prisma__QuestionsListQuestionEntryClient<QuestionsListQuestionEntryGetPayload<T>>> : CheckSelect<T, Prisma__QuestionsListQuestionEntryClient<QuestionsListQuestionEntry | null, null>, Prisma__QuestionsListQuestionEntryClient<QuestionsListQuestionEntryGetPayload<T> | null, null>>

    /**
     * Find zero or more QuestionsListQuestionEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsListQuestionEntryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionsListQuestionEntries
     * const questionsListQuestionEntries = await prisma.questionsListQuestionEntry.findMany()
     * 
     * // Get first 10 QuestionsListQuestionEntries
     * const questionsListQuestionEntries = await prisma.questionsListQuestionEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionsListQuestionEntryWithIdOnly = await prisma.questionsListQuestionEntry.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuestionsListQuestionEntryFindManyArgs>(
      args?: SelectSubset<T, QuestionsListQuestionEntryFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<QuestionsListQuestionEntry>>, PrismaPromise<Array<QuestionsListQuestionEntryGetPayload<T>>>>

    /**
     * Create a QuestionsListQuestionEntry.
     * @param {QuestionsListQuestionEntryCreateArgs} args - Arguments to create a QuestionsListQuestionEntry.
     * @example
     * // Create one QuestionsListQuestionEntry
     * const QuestionsListQuestionEntry = await prisma.questionsListQuestionEntry.create({
     *   data: {
     *     // ... data to create a QuestionsListQuestionEntry
     *   }
     * })
     * 
    **/
    create<T extends QuestionsListQuestionEntryCreateArgs>(
      args: SelectSubset<T, QuestionsListQuestionEntryCreateArgs>
    ): CheckSelect<T, Prisma__QuestionsListQuestionEntryClient<QuestionsListQuestionEntry>, Prisma__QuestionsListQuestionEntryClient<QuestionsListQuestionEntryGetPayload<T>>>

    /**
     * Create many QuestionsListQuestionEntries.
     *     @param {QuestionsListQuestionEntryCreateManyArgs} args - Arguments to create many QuestionsListQuestionEntries.
     *     @example
     *     // Create many QuestionsListQuestionEntries
     *     const questionsListQuestionEntry = await prisma.questionsListQuestionEntry.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuestionsListQuestionEntryCreateManyArgs>(
      args?: SelectSubset<T, QuestionsListQuestionEntryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a QuestionsListQuestionEntry.
     * @param {QuestionsListQuestionEntryDeleteArgs} args - Arguments to delete one QuestionsListQuestionEntry.
     * @example
     * // Delete one QuestionsListQuestionEntry
     * const QuestionsListQuestionEntry = await prisma.questionsListQuestionEntry.delete({
     *   where: {
     *     // ... filter to delete one QuestionsListQuestionEntry
     *   }
     * })
     * 
    **/
    delete<T extends QuestionsListQuestionEntryDeleteArgs>(
      args: SelectSubset<T, QuestionsListQuestionEntryDeleteArgs>
    ): CheckSelect<T, Prisma__QuestionsListQuestionEntryClient<QuestionsListQuestionEntry>, Prisma__QuestionsListQuestionEntryClient<QuestionsListQuestionEntryGetPayload<T>>>

    /**
     * Update one QuestionsListQuestionEntry.
     * @param {QuestionsListQuestionEntryUpdateArgs} args - Arguments to update one QuestionsListQuestionEntry.
     * @example
     * // Update one QuestionsListQuestionEntry
     * const questionsListQuestionEntry = await prisma.questionsListQuestionEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuestionsListQuestionEntryUpdateArgs>(
      args: SelectSubset<T, QuestionsListQuestionEntryUpdateArgs>
    ): CheckSelect<T, Prisma__QuestionsListQuestionEntryClient<QuestionsListQuestionEntry>, Prisma__QuestionsListQuestionEntryClient<QuestionsListQuestionEntryGetPayload<T>>>

    /**
     * Delete zero or more QuestionsListQuestionEntries.
     * @param {QuestionsListQuestionEntryDeleteManyArgs} args - Arguments to filter QuestionsListQuestionEntries to delete.
     * @example
     * // Delete a few QuestionsListQuestionEntries
     * const { count } = await prisma.questionsListQuestionEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuestionsListQuestionEntryDeleteManyArgs>(
      args?: SelectSubset<T, QuestionsListQuestionEntryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionsListQuestionEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsListQuestionEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionsListQuestionEntries
     * const questionsListQuestionEntry = await prisma.questionsListQuestionEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuestionsListQuestionEntryUpdateManyArgs>(
      args: SelectSubset<T, QuestionsListQuestionEntryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one QuestionsListQuestionEntry.
     * @param {QuestionsListQuestionEntryUpsertArgs} args - Arguments to update or create a QuestionsListQuestionEntry.
     * @example
     * // Update or create a QuestionsListQuestionEntry
     * const questionsListQuestionEntry = await prisma.questionsListQuestionEntry.upsert({
     *   create: {
     *     // ... data to create a QuestionsListQuestionEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionsListQuestionEntry we want to update
     *   }
     * })
    **/
    upsert<T extends QuestionsListQuestionEntryUpsertArgs>(
      args: SelectSubset<T, QuestionsListQuestionEntryUpsertArgs>
    ): CheckSelect<T, Prisma__QuestionsListQuestionEntryClient<QuestionsListQuestionEntry>, Prisma__QuestionsListQuestionEntryClient<QuestionsListQuestionEntryGetPayload<T>>>

    /**
     * Find one QuestionsListQuestionEntry that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {QuestionsListQuestionEntryFindUniqueOrThrowArgs} args - Arguments to find a QuestionsListQuestionEntry
     * @example
     * // Get one QuestionsListQuestionEntry
     * const questionsListQuestionEntry = await prisma.questionsListQuestionEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuestionsListQuestionEntryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, QuestionsListQuestionEntryFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__QuestionsListQuestionEntryClient<QuestionsListQuestionEntry>, Prisma__QuestionsListQuestionEntryClient<QuestionsListQuestionEntryGetPayload<T>>>

    /**
     * Find the first QuestionsListQuestionEntry that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsListQuestionEntryFindFirstOrThrowArgs} args - Arguments to find a QuestionsListQuestionEntry
     * @example
     * // Get one QuestionsListQuestionEntry
     * const questionsListQuestionEntry = await prisma.questionsListQuestionEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuestionsListQuestionEntryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, QuestionsListQuestionEntryFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__QuestionsListQuestionEntryClient<QuestionsListQuestionEntry>, Prisma__QuestionsListQuestionEntryClient<QuestionsListQuestionEntryGetPayload<T>>>

    /**
     * Count the number of QuestionsListQuestionEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsListQuestionEntryCountArgs} args - Arguments to filter QuestionsListQuestionEntries to count.
     * @example
     * // Count the number of QuestionsListQuestionEntries
     * const count = await prisma.questionsListQuestionEntry.count({
     *   where: {
     *     // ... the filter for the QuestionsListQuestionEntries we want to count
     *   }
     * })
    **/
    count<T extends QuestionsListQuestionEntryCountArgs>(
      args?: Subset<T, QuestionsListQuestionEntryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionsListQuestionEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionsListQuestionEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsListQuestionEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionsListQuestionEntryAggregateArgs>(args: Subset<T, QuestionsListQuestionEntryAggregateArgs>): PrismaPromise<GetQuestionsListQuestionEntryAggregateType<T>>

    /**
     * Group by QuestionsListQuestionEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsListQuestionEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionsListQuestionEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionsListQuestionEntryGroupByArgs['orderBy'] }
        : { orderBy?: QuestionsListQuestionEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionsListQuestionEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionsListQuestionEntryGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestionsListQuestionEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QuestionsListQuestionEntryClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    list<T extends QuestionsListArgs = {}>(args?: Subset<T, QuestionsListArgs>): CheckSelect<T, Prisma__QuestionsListClient<QuestionsList | Null>, Prisma__QuestionsListClient<QuestionsListGetPayload<T> | Null>>;

    question<T extends QuestionsQuestionArgs = {}>(args?: Subset<T, QuestionsQuestionArgs>): CheckSelect<T, Prisma__QuestionsQuestionClient<QuestionsQuestion | Null>, Prisma__QuestionsQuestionClient<QuestionsQuestionGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * QuestionsListQuestionEntry base type for findUnique actions
   */
  export type QuestionsListQuestionEntryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the QuestionsListQuestionEntry
     * 
    **/
    select?: QuestionsListQuestionEntrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsListQuestionEntryInclude | null
    /**
     * Filter, which QuestionsListQuestionEntry to fetch.
     * 
    **/
    where: QuestionsListQuestionEntryWhereUniqueInput
  }

  /**
   * QuestionsListQuestionEntry: findUnique
   */
  export interface QuestionsListQuestionEntryFindUniqueArgs extends QuestionsListQuestionEntryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuestionsListQuestionEntry base type for findFirst actions
   */
  export type QuestionsListQuestionEntryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the QuestionsListQuestionEntry
     * 
    **/
    select?: QuestionsListQuestionEntrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsListQuestionEntryInclude | null
    /**
     * Filter, which QuestionsListQuestionEntry to fetch.
     * 
    **/
    where?: QuestionsListQuestionEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsListQuestionEntries to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionsListQuestionEntryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionsListQuestionEntries.
     * 
    **/
    cursor?: QuestionsListQuestionEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsListQuestionEntries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsListQuestionEntries.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionsListQuestionEntries.
     * 
    **/
    distinct?: Enumerable<QuestionsListQuestionEntryScalarFieldEnum>
  }

  /**
   * QuestionsListQuestionEntry: findFirst
   */
  export interface QuestionsListQuestionEntryFindFirstArgs extends QuestionsListQuestionEntryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuestionsListQuestionEntry findMany
   */
  export type QuestionsListQuestionEntryFindManyArgs = {
    /**
     * Select specific fields to fetch from the QuestionsListQuestionEntry
     * 
    **/
    select?: QuestionsListQuestionEntrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsListQuestionEntryInclude | null
    /**
     * Filter, which QuestionsListQuestionEntries to fetch.
     * 
    **/
    where?: QuestionsListQuestionEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsListQuestionEntries to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionsListQuestionEntryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestionsListQuestionEntries.
     * 
    **/
    cursor?: QuestionsListQuestionEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsListQuestionEntries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsListQuestionEntries.
     * 
    **/
    skip?: number
    distinct?: Enumerable<QuestionsListQuestionEntryScalarFieldEnum>
  }


  /**
   * QuestionsListQuestionEntry create
   */
  export type QuestionsListQuestionEntryCreateArgs = {
    /**
     * Select specific fields to fetch from the QuestionsListQuestionEntry
     * 
    **/
    select?: QuestionsListQuestionEntrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsListQuestionEntryInclude | null
    /**
     * The data needed to create a QuestionsListQuestionEntry.
     * 
    **/
    data: XOR<QuestionsListQuestionEntryCreateInput, QuestionsListQuestionEntryUncheckedCreateInput>
  }


  /**
   * QuestionsListQuestionEntry createMany
   */
  export type QuestionsListQuestionEntryCreateManyArgs = {
    /**
     * The data used to create many QuestionsListQuestionEntries.
     * 
    **/
    data: Enumerable<QuestionsListQuestionEntryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * QuestionsListQuestionEntry update
   */
  export type QuestionsListQuestionEntryUpdateArgs = {
    /**
     * Select specific fields to fetch from the QuestionsListQuestionEntry
     * 
    **/
    select?: QuestionsListQuestionEntrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsListQuestionEntryInclude | null
    /**
     * The data needed to update a QuestionsListQuestionEntry.
     * 
    **/
    data: XOR<QuestionsListQuestionEntryUpdateInput, QuestionsListQuestionEntryUncheckedUpdateInput>
    /**
     * Choose, which QuestionsListQuestionEntry to update.
     * 
    **/
    where: QuestionsListQuestionEntryWhereUniqueInput
  }


  /**
   * QuestionsListQuestionEntry updateMany
   */
  export type QuestionsListQuestionEntryUpdateManyArgs = {
    /**
     * The data used to update QuestionsListQuestionEntries.
     * 
    **/
    data: XOR<QuestionsListQuestionEntryUpdateManyMutationInput, QuestionsListQuestionEntryUncheckedUpdateManyInput>
    /**
     * Filter which QuestionsListQuestionEntries to update
     * 
    **/
    where?: QuestionsListQuestionEntryWhereInput
  }


  /**
   * QuestionsListQuestionEntry upsert
   */
  export type QuestionsListQuestionEntryUpsertArgs = {
    /**
     * Select specific fields to fetch from the QuestionsListQuestionEntry
     * 
    **/
    select?: QuestionsListQuestionEntrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsListQuestionEntryInclude | null
    /**
     * The filter to search for the QuestionsListQuestionEntry to update in case it exists.
     * 
    **/
    where: QuestionsListQuestionEntryWhereUniqueInput
    /**
     * In case the QuestionsListQuestionEntry found by the `where` argument doesn't exist, create a new QuestionsListQuestionEntry with this data.
     * 
    **/
    create: XOR<QuestionsListQuestionEntryCreateInput, QuestionsListQuestionEntryUncheckedCreateInput>
    /**
     * In case the QuestionsListQuestionEntry was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<QuestionsListQuestionEntryUpdateInput, QuestionsListQuestionEntryUncheckedUpdateInput>
  }


  /**
   * QuestionsListQuestionEntry delete
   */
  export type QuestionsListQuestionEntryDeleteArgs = {
    /**
     * Select specific fields to fetch from the QuestionsListQuestionEntry
     * 
    **/
    select?: QuestionsListQuestionEntrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsListQuestionEntryInclude | null
    /**
     * Filter which QuestionsListQuestionEntry to delete.
     * 
    **/
    where: QuestionsListQuestionEntryWhereUniqueInput
  }


  /**
   * QuestionsListQuestionEntry deleteMany
   */
  export type QuestionsListQuestionEntryDeleteManyArgs = {
    /**
     * Filter which QuestionsListQuestionEntries to delete
     * 
    **/
    where?: QuestionsListQuestionEntryWhereInput
  }


  /**
   * QuestionsListQuestionEntry: findUniqueOrThrow
   */
  export type QuestionsListQuestionEntryFindUniqueOrThrowArgs = QuestionsListQuestionEntryFindUniqueArgsBase
      

  /**
   * QuestionsListQuestionEntry: findFirstOrThrow
   */
  export type QuestionsListQuestionEntryFindFirstOrThrowArgs = QuestionsListQuestionEntryFindFirstArgsBase
      

  /**
   * QuestionsListQuestionEntry without action
   */
  export type QuestionsListQuestionEntryArgs = {
    /**
     * Select specific fields to fetch from the QuestionsListQuestionEntry
     * 
    **/
    select?: QuestionsListQuestionEntrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionsListQuestionEntryInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const CityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    stateId: 'stateId',
    ranking: 'ranking'
  };

  export type CityScalarFieldEnum = (typeof CityScalarFieldEnum)[keyof typeof CityScalarFieldEnum]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    logoUrl: 'logoUrl',
    website: 'website',
    ranking: 'ranking',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const CountryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    ranking: 'ranking'
  };

  export type CountryScalarFieldEnum = (typeof CountryScalarFieldEnum)[keyof typeof CountryScalarFieldEnum]


  export const OffersAdminScalarFieldEnum: {
    id: 'id',
    userId: 'userId'
  };

  export type OffersAdminScalarFieldEnum = (typeof OffersAdminScalarFieldEnum)[keyof typeof OffersAdminScalarFieldEnum]


  export const OffersAnalysisScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    profileId: 'profileId',
    offerId: 'offerId',
    overallAnalysisUnitId: 'overallAnalysisUnitId'
  };

  export type OffersAnalysisScalarFieldEnum = (typeof OffersAnalysisScalarFieldEnum)[keyof typeof OffersAnalysisScalarFieldEnum]


  export const OffersAnalysisUnitScalarFieldEnum: {
    id: 'id',
    analysedOfferId: 'analysedOfferId',
    percentile: 'percentile',
    noOfSimilarOffers: 'noOfSimilarOffers'
  };

  export type OffersAnalysisUnitScalarFieldEnum = (typeof OffersAnalysisUnitScalarFieldEnum)[keyof typeof OffersAnalysisUnitScalarFieldEnum]


  export const OffersBackgroundScalarFieldEnum: {
    id: 'id',
    totalYoe: 'totalYoe',
    offersProfileId: 'offersProfileId'
  };

  export type OffersBackgroundScalarFieldEnum = (typeof OffersBackgroundScalarFieldEnum)[keyof typeof OffersBackgroundScalarFieldEnum]


  export const OffersCurrencyScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    value: 'value',
    currency: 'currency',
    baseValue: 'baseValue',
    baseCurrency: 'baseCurrency'
  };

  export type OffersCurrencyScalarFieldEnum = (typeof OffersCurrencyScalarFieldEnum)[keyof typeof OffersCurrencyScalarFieldEnum]


  export const OffersEducationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    field: 'field',
    school: 'school',
    startDate: 'startDate',
    endDate: 'endDate',
    backgroundId: 'backgroundId'
  };

  export type OffersEducationScalarFieldEnum = (typeof OffersEducationScalarFieldEnum)[keyof typeof OffersEducationScalarFieldEnum]


  export const OffersExperienceScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    jobType: 'jobType',
    title: 'title',
    durationInMonths: 'durationInMonths',
    cityId: 'cityId',
    level: 'level',
    totalCompensationId: 'totalCompensationId',
    monthlySalaryId: 'monthlySalaryId',
    backgroundId: 'backgroundId'
  };

  export type OffersExperienceScalarFieldEnum = (typeof OffersExperienceScalarFieldEnum)[keyof typeof OffersExperienceScalarFieldEnum]


  export const OffersFullTimeScalarFieldEnum: {
    id: 'id',
    title: 'title',
    level: 'level',
    totalCompensationId: 'totalCompensationId',
    baseSalaryId: 'baseSalaryId',
    bonusId: 'bonusId',
    stocksId: 'stocksId'
  };

  export type OffersFullTimeScalarFieldEnum = (typeof OffersFullTimeScalarFieldEnum)[keyof typeof OffersFullTimeScalarFieldEnum]


  export const OffersInternScalarFieldEnum: {
    id: 'id',
    title: 'title',
    internshipCycle: 'internshipCycle',
    startYear: 'startYear',
    monthlySalaryId: 'monthlySalaryId'
  };

  export type OffersInternScalarFieldEnum = (typeof OffersInternScalarFieldEnum)[keyof typeof OffersInternScalarFieldEnum]


  export const OffersOfferScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    companyId: 'companyId',
    cityId: 'cityId',
    monthYearReceived: 'monthYearReceived',
    negotiationStrategy: 'negotiationStrategy',
    comments: 'comments',
    jobType: 'jobType',
    offersInternId: 'offersInternId',
    offersFullTimeId: 'offersFullTimeId'
  };

  export type OffersOfferScalarFieldEnum = (typeof OffersOfferScalarFieldEnum)[keyof typeof OffersOfferScalarFieldEnum]


  export const OffersProfileScalarFieldEnum: {
    id: 'id',
    profileName: 'profileName',
    createdAt: 'createdAt',
    editToken: 'editToken'
  };

  export type OffersProfileScalarFieldEnum = (typeof OffersProfileScalarFieldEnum)[keyof typeof OffersProfileScalarFieldEnum]


  export const OffersReplyScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    message: 'message',
    replyingToId: 'replyingToId',
    profileId: 'profileId',
    userId: 'userId'
  };

  export type OffersReplyScalarFieldEnum = (typeof OffersReplyScalarFieldEnum)[keyof typeof OffersReplyScalarFieldEnum]


  export const OffersSpecificYoeScalarFieldEnum: {
    id: 'id',
    yoe: 'yoe',
    domain: 'domain',
    backgroundId: 'backgroundId'
  };

  export type OffersSpecificYoeScalarFieldEnum = (typeof OffersSpecificYoeScalarFieldEnum)[keyof typeof OffersSpecificYoeScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const QuestionsAnswerCommentScalarFieldEnum: {
    id: 'id',
    answerId: 'answerId',
    userId: 'userId',
    content: 'content',
    upvotes: 'upvotes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuestionsAnswerCommentScalarFieldEnum = (typeof QuestionsAnswerCommentScalarFieldEnum)[keyof typeof QuestionsAnswerCommentScalarFieldEnum]


  export const QuestionsAnswerCommentVoteScalarFieldEnum: {
    id: 'id',
    answerCommentId: 'answerCommentId',
    userId: 'userId',
    vote: 'vote',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuestionsAnswerCommentVoteScalarFieldEnum = (typeof QuestionsAnswerCommentVoteScalarFieldEnum)[keyof typeof QuestionsAnswerCommentVoteScalarFieldEnum]


  export const QuestionsAnswerScalarFieldEnum: {
    id: 'id',
    questionId: 'questionId',
    userId: 'userId',
    content: 'content',
    upvotes: 'upvotes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuestionsAnswerScalarFieldEnum = (typeof QuestionsAnswerScalarFieldEnum)[keyof typeof QuestionsAnswerScalarFieldEnum]


  export const QuestionsAnswerVoteScalarFieldEnum: {
    id: 'id',
    answerId: 'answerId',
    userId: 'userId',
    vote: 'vote',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuestionsAnswerVoteScalarFieldEnum = (typeof QuestionsAnswerVoteScalarFieldEnum)[keyof typeof QuestionsAnswerVoteScalarFieldEnum]


  export const QuestionsListQuestionEntryScalarFieldEnum: {
    id: 'id',
    listId: 'listId',
    questionId: 'questionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuestionsListQuestionEntryScalarFieldEnum = (typeof QuestionsListQuestionEntryScalarFieldEnum)[keyof typeof QuestionsListQuestionEntryScalarFieldEnum]


  export const QuestionsListScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuestionsListScalarFieldEnum = (typeof QuestionsListScalarFieldEnum)[keyof typeof QuestionsListScalarFieldEnum]


  export const QuestionsQuestionCommentScalarFieldEnum: {
    id: 'id',
    questionId: 'questionId',
    userId: 'userId',
    upvotes: 'upvotes',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuestionsQuestionCommentScalarFieldEnum = (typeof QuestionsQuestionCommentScalarFieldEnum)[keyof typeof QuestionsQuestionCommentScalarFieldEnum]


  export const QuestionsQuestionCommentVoteScalarFieldEnum: {
    id: 'id',
    questionCommentId: 'questionCommentId',
    userId: 'userId',
    vote: 'vote',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuestionsQuestionCommentVoteScalarFieldEnum = (typeof QuestionsQuestionCommentVoteScalarFieldEnum)[keyof typeof QuestionsQuestionCommentVoteScalarFieldEnum]


  export const QuestionsQuestionEncounterScalarFieldEnum: {
    id: 'id',
    questionId: 'questionId',
    userId: 'userId',
    companyId: 'companyId',
    countryId: 'countryId',
    stateId: 'stateId',
    cityId: 'cityId',
    role: 'role',
    seenAt: 'seenAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuestionsQuestionEncounterScalarFieldEnum = (typeof QuestionsQuestionEncounterScalarFieldEnum)[keyof typeof QuestionsQuestionEncounterScalarFieldEnum]


  export const QuestionsQuestionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    content: 'content',
    questionType: 'questionType',
    lastSeenAt: 'lastSeenAt',
    upvotes: 'upvotes',
    numEncounters: 'numEncounters',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuestionsQuestionScalarFieldEnum = (typeof QuestionsQuestionScalarFieldEnum)[keyof typeof QuestionsQuestionScalarFieldEnum]


  export const QuestionsQuestionVoteScalarFieldEnum: {
    id: 'id',
    questionId: 'questionId',
    userId: 'userId',
    vote: 'vote',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuestionsQuestionVoteScalarFieldEnum = (typeof QuestionsQuestionVoteScalarFieldEnum)[keyof typeof QuestionsQuestionVoteScalarFieldEnum]


  export const ResumesCommentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    resumeId: 'resumeId',
    parentId: 'parentId',
    description: 'description',
    section: 'section',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ResumesCommentScalarFieldEnum = (typeof ResumesCommentScalarFieldEnum)[keyof typeof ResumesCommentScalarFieldEnum]


  export const ResumesCommentVoteScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    commentId: 'commentId',
    value: 'value',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ResumesCommentVoteScalarFieldEnum = (typeof ResumesCommentVoteScalarFieldEnum)[keyof typeof ResumesCommentVoteScalarFieldEnum]


  export const ResumesResumeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    role: 'role',
    experience: 'experience',
    locationId: 'locationId',
    url: 'url',
    additionalInfo: 'additionalInfo',
    isResolved: 'isResolved',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ResumesResumeScalarFieldEnum = (typeof ResumesResumeScalarFieldEnum)[keyof typeof ResumesResumeScalarFieldEnum]


  export const ResumesStarScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    resumeId: 'resumeId',
    createdAt: 'createdAt'
  };

  export type ResumesStarScalarFieldEnum = (typeof ResumesStarScalarFieldEnum)[keyof typeof ResumesStarScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const StateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    countryId: 'countryId'
  };

  export type StateScalarFieldEnum = (typeof StateScalarFieldEnum)[keyof typeof StateScalarFieldEnum]


  export const TodoScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    text: 'text',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TodoScalarFieldEnum = (typeof TodoScalarFieldEnum)[keyof typeof TodoScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type AccountWhereInput = {
    AND?: Enumerable<AccountWhereInput>
    OR?: Enumerable<AccountWhereInput>
    NOT?: Enumerable<AccountWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    type?: StringFilter | string
    provider?: StringFilter | string
    providerAccountId?: StringFilter | string
    refresh_token?: StringNullableFilter | string | null
    access_token?: StringNullableFilter | string | null
    expires_at?: IntNullableFilter | number | null
    token_type?: StringNullableFilter | string | null
    scope?: StringNullableFilter | string | null
    id_token?: StringNullableFilter | string | null
    session_state?: StringNullableFilter | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = {
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
  }

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AccountScalarWhereWithAggregatesInput>
    OR?: Enumerable<AccountScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AccountScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    provider?: StringWithAggregatesFilter | string
    providerAccountId?: StringWithAggregatesFilter | string
    refresh_token?: StringNullableWithAggregatesFilter | string | null
    access_token?: StringNullableWithAggregatesFilter | string | null
    expires_at?: IntNullableWithAggregatesFilter | number | null
    token_type?: StringNullableWithAggregatesFilter | string | null
    scope?: StringNullableWithAggregatesFilter | string | null
    id_token?: StringNullableWithAggregatesFilter | string | null
    session_state?: StringNullableWithAggregatesFilter | string | null
  }

  export type SessionWhereInput = {
    AND?: Enumerable<SessionWhereInput>
    OR?: Enumerable<SessionWhereInput>
    NOT?: Enumerable<SessionWhereInput>
    id?: StringFilter | string
    sessionToken?: StringFilter | string
    userId?: StringFilter | string
    expires?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = {
    id?: string
    sessionToken?: string
  }

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SessionScalarWhereWithAggregatesInput>
    OR?: Enumerable<SessionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SessionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    sessionToken?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    expires?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    name?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    emailVerified?: DateTimeNullableFilter | Date | string | null
    image?: StringNullableFilter | string | null
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    todos?: TodoListRelationFilter
    resumesResumes?: ResumesResumeListRelationFilter
    resumesStars?: ResumesStarListRelationFilter
    resumesComments?: ResumesCommentListRelationFilter
    resumesCommentVotes?: ResumesCommentVoteListRelationFilter
    questionsQuestions?: QuestionsQuestionListRelationFilter
    questionsQuestionEncounters?: QuestionsQuestionEncounterListRelationFilter
    questionsQuestionVotes?: QuestionsQuestionVoteListRelationFilter
    questionsQuestionComments?: QuestionsQuestionCommentListRelationFilter
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteListRelationFilter
    questionsAnswers?: QuestionsAnswerListRelationFilter
    questionsAnswerVotes?: QuestionsAnswerVoteListRelationFilter
    questionsAnswerComments?: QuestionsAnswerCommentListRelationFilter
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteListRelationFilter
    OffersProfile?: OffersProfileListRelationFilter
    offersDiscussion?: OffersReplyListRelationFilter
    questionsLists?: QuestionsListListRelationFilter
    OffersAdmin?: XOR<OffersAdminRelationFilter, OffersAdminWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    todos?: TodoOrderByRelationAggregateInput
    resumesResumes?: ResumesResumeOrderByRelationAggregateInput
    resumesStars?: ResumesStarOrderByRelationAggregateInput
    resumesComments?: ResumesCommentOrderByRelationAggregateInput
    resumesCommentVotes?: ResumesCommentVoteOrderByRelationAggregateInput
    questionsQuestions?: QuestionsQuestionOrderByRelationAggregateInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterOrderByRelationAggregateInput
    questionsQuestionVotes?: QuestionsQuestionVoteOrderByRelationAggregateInput
    questionsQuestionComments?: QuestionsQuestionCommentOrderByRelationAggregateInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteOrderByRelationAggregateInput
    questionsAnswers?: QuestionsAnswerOrderByRelationAggregateInput
    questionsAnswerVotes?: QuestionsAnswerVoteOrderByRelationAggregateInput
    questionsAnswerComments?: QuestionsAnswerCommentOrderByRelationAggregateInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteOrderByRelationAggregateInput
    OffersProfile?: OffersProfileOrderByRelationAggregateInput
    offersDiscussion?: OffersReplyOrderByRelationAggregateInput
    questionsLists?: QuestionsListOrderByRelationAggregateInput
    OffersAdmin?: OffersAdminOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringNullableWithAggregatesFilter | string | null
    email?: StringNullableWithAggregatesFilter | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter | Date | string | null
    image?: StringNullableWithAggregatesFilter | string | null
  }

  export type VerificationTokenWhereInput = {
    AND?: Enumerable<VerificationTokenWhereInput>
    OR?: Enumerable<VerificationTokenWhereInput>
    NOT?: Enumerable<VerificationTokenWhereInput>
    identifier?: StringFilter | string
    token?: StringFilter | string
    expires?: DateTimeFilter | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = {
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
  }

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VerificationTokenScalarWhereWithAggregatesInput>
    OR?: Enumerable<VerificationTokenScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VerificationTokenScalarWhereWithAggregatesInput>
    identifier?: StringWithAggregatesFilter | string
    token?: StringWithAggregatesFilter | string
    expires?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TodoWhereInput = {
    AND?: Enumerable<TodoWhereInput>
    OR?: Enumerable<TodoWhereInput>
    NOT?: Enumerable<TodoWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    text?: StringFilter | string
    status?: EnumTodoStatusFilter | TodoStatus
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TodoOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TodoWhereUniqueInput = {
    id?: string
  }

  export type TodoOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TodoCountOrderByAggregateInput
    _max?: TodoMaxOrderByAggregateInput
    _min?: TodoMinOrderByAggregateInput
  }

  export type TodoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TodoScalarWhereWithAggregatesInput>
    OR?: Enumerable<TodoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TodoScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    text?: StringWithAggregatesFilter | string
    status?: EnumTodoStatusWithAggregatesFilter | TodoStatus
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CompanyWhereInput = {
    AND?: Enumerable<CompanyWhereInput>
    OR?: Enumerable<CompanyWhereInput>
    NOT?: Enumerable<CompanyWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    slug?: StringFilter | string
    description?: StringNullableFilter | string | null
    logoUrl?: StringNullableFilter | string | null
    website?: StringNullableFilter | string | null
    ranking?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    questionsQuestionEncounter?: QuestionsQuestionEncounterListRelationFilter
    OffersExperience?: OffersExperienceListRelationFilter
    OffersOffer?: OffersOfferListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
    website?: SortOrder
    ranking?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    questionsQuestionEncounter?: QuestionsQuestionEncounterOrderByRelationAggregateInput
    OffersExperience?: OffersExperienceOrderByRelationAggregateInput
    OffersOffer?: OffersOfferOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = {
    id?: string
    slug?: string
  }

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
    website?: SortOrder
    ranking?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _avg?: CompanyAvgOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
    _sum?: CompanySumOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CompanyScalarWhereWithAggregatesInput>
    OR?: Enumerable<CompanyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CompanyScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    logoUrl?: StringNullableWithAggregatesFilter | string | null
    website?: StringNullableWithAggregatesFilter | string | null
    ranking?: IntNullableWithAggregatesFilter | number | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CountryWhereInput = {
    AND?: Enumerable<CountryWhereInput>
    OR?: Enumerable<CountryWhereInput>
    NOT?: Enumerable<CountryWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    code?: StringFilter | string
    ranking?: IntNullableFilter | number | null
    states?: StateListRelationFilter
    questionsQuestionEncounters?: QuestionsQuestionEncounterListRelationFilter
    ResumesResume?: ResumesResumeListRelationFilter
  }

  export type CountryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    ranking?: SortOrder
    states?: StateOrderByRelationAggregateInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterOrderByRelationAggregateInput
    ResumesResume?: ResumesResumeOrderByRelationAggregateInput
  }

  export type CountryWhereUniqueInput = {
    id?: string
    name?: string
    code?: string
  }

  export type CountryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    ranking?: SortOrder
    _count?: CountryCountOrderByAggregateInput
    _avg?: CountryAvgOrderByAggregateInput
    _max?: CountryMaxOrderByAggregateInput
    _min?: CountryMinOrderByAggregateInput
    _sum?: CountrySumOrderByAggregateInput
  }

  export type CountryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CountryScalarWhereWithAggregatesInput>
    OR?: Enumerable<CountryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CountryScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    ranking?: IntNullableWithAggregatesFilter | number | null
  }

  export type StateWhereInput = {
    AND?: Enumerable<StateWhereInput>
    OR?: Enumerable<StateWhereInput>
    NOT?: Enumerable<StateWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    countryId?: StringFilter | string
    cities?: CityListRelationFilter
    country?: XOR<CountryRelationFilter, CountryWhereInput>
    questionsQuestionEncounters?: QuestionsQuestionEncounterListRelationFilter
  }

  export type StateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    countryId?: SortOrder
    cities?: CityOrderByRelationAggregateInput
    country?: CountryOrderByWithRelationInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterOrderByRelationAggregateInput
  }

  export type StateWhereUniqueInput = {
    id?: string
    name_countryId?: StateNameCountryIdCompoundUniqueInput
  }

  export type StateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    countryId?: SortOrder
    _count?: StateCountOrderByAggregateInput
    _max?: StateMaxOrderByAggregateInput
    _min?: StateMinOrderByAggregateInput
  }

  export type StateScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StateScalarWhereWithAggregatesInput>
    OR?: Enumerable<StateScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StateScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    countryId?: StringWithAggregatesFilter | string
  }

  export type CityWhereInput = {
    AND?: Enumerable<CityWhereInput>
    OR?: Enumerable<CityWhereInput>
    NOT?: Enumerable<CityWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    stateId?: StringFilter | string
    ranking?: IntNullableFilter | number | null
    state?: XOR<StateRelationFilter, StateWhereInput>
    questionsQuestionEncounters?: QuestionsQuestionEncounterListRelationFilter
    OffersExperience?: OffersExperienceListRelationFilter
    OffersOffer?: OffersOfferListRelationFilter
  }

  export type CityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    stateId?: SortOrder
    ranking?: SortOrder
    state?: StateOrderByWithRelationInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterOrderByRelationAggregateInput
    OffersExperience?: OffersExperienceOrderByRelationAggregateInput
    OffersOffer?: OffersOfferOrderByRelationAggregateInput
  }

  export type CityWhereUniqueInput = {
    id?: string
    name_stateId?: CityNameStateIdCompoundUniqueInput
  }

  export type CityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    stateId?: SortOrder
    ranking?: SortOrder
    _count?: CityCountOrderByAggregateInput
    _avg?: CityAvgOrderByAggregateInput
    _max?: CityMaxOrderByAggregateInput
    _min?: CityMinOrderByAggregateInput
    _sum?: CitySumOrderByAggregateInput
  }

  export type CityScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CityScalarWhereWithAggregatesInput>
    OR?: Enumerable<CityScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CityScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    stateId?: StringWithAggregatesFilter | string
    ranking?: IntNullableWithAggregatesFilter | number | null
  }

  export type ResumesResumeWhereInput = {
    AND?: Enumerable<ResumesResumeWhereInput>
    OR?: Enumerable<ResumesResumeWhereInput>
    NOT?: Enumerable<ResumesResumeWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    title?: StringFilter | string
    role?: StringFilter | string
    experience?: StringFilter | string
    locationId?: StringFilter | string
    url?: StringFilter | string
    additionalInfo?: StringNullableFilter | string | null
    isResolved?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    location?: XOR<CountryRelationFilter, CountryWhereInput>
    stars?: ResumesStarListRelationFilter
    comments?: ResumesCommentListRelationFilter
  }

  export type ResumesResumeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    role?: SortOrder
    experience?: SortOrder
    locationId?: SortOrder
    url?: SortOrder
    additionalInfo?: SortOrder
    isResolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    location?: CountryOrderByWithRelationInput
    stars?: ResumesStarOrderByRelationAggregateInput
    comments?: ResumesCommentOrderByRelationAggregateInput
  }

  export type ResumesResumeWhereUniqueInput = {
    id?: string
  }

  export type ResumesResumeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    role?: SortOrder
    experience?: SortOrder
    locationId?: SortOrder
    url?: SortOrder
    additionalInfo?: SortOrder
    isResolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ResumesResumeCountOrderByAggregateInput
    _max?: ResumesResumeMaxOrderByAggregateInput
    _min?: ResumesResumeMinOrderByAggregateInput
  }

  export type ResumesResumeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ResumesResumeScalarWhereWithAggregatesInput>
    OR?: Enumerable<ResumesResumeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ResumesResumeScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    role?: StringWithAggregatesFilter | string
    experience?: StringWithAggregatesFilter | string
    locationId?: StringWithAggregatesFilter | string
    url?: StringWithAggregatesFilter | string
    additionalInfo?: StringNullableWithAggregatesFilter | string | null
    isResolved?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ResumesStarWhereInput = {
    AND?: Enumerable<ResumesStarWhereInput>
    OR?: Enumerable<ResumesStarWhereInput>
    NOT?: Enumerable<ResumesStarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    resumeId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    resume?: XOR<ResumesResumeRelationFilter, ResumesResumeWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ResumesStarOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    createdAt?: SortOrder
    resume?: ResumesResumeOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ResumesStarWhereUniqueInput = {
    id?: string
    userId_resumeId?: ResumesStarUserIdResumeIdCompoundUniqueInput
  }

  export type ResumesStarOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    createdAt?: SortOrder
    _count?: ResumesStarCountOrderByAggregateInput
    _max?: ResumesStarMaxOrderByAggregateInput
    _min?: ResumesStarMinOrderByAggregateInput
  }

  export type ResumesStarScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ResumesStarScalarWhereWithAggregatesInput>
    OR?: Enumerable<ResumesStarScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ResumesStarScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    resumeId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ResumesCommentWhereInput = {
    AND?: Enumerable<ResumesCommentWhereInput>
    OR?: Enumerable<ResumesCommentWhereInput>
    NOT?: Enumerable<ResumesCommentWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    resumeId?: StringFilter | string
    parentId?: StringNullableFilter | string | null
    description?: StringFilter | string
    section?: EnumResumesSectionFilter | ResumesSection
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    resume?: XOR<ResumesResumeRelationFilter, ResumesResumeWhereInput>
    votes?: ResumesCommentVoteListRelationFilter
    user?: XOR<UserRelationFilter, UserWhereInput>
    parent?: XOR<ResumesCommentRelationFilter, ResumesCommentWhereInput> | null
    children?: ResumesCommentListRelationFilter
  }

  export type ResumesCommentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    parentId?: SortOrder
    description?: SortOrder
    section?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resume?: ResumesResumeOrderByWithRelationInput
    votes?: ResumesCommentVoteOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    parent?: ResumesCommentOrderByWithRelationInput
    children?: ResumesCommentOrderByRelationAggregateInput
  }

  export type ResumesCommentWhereUniqueInput = {
    id?: string
  }

  export type ResumesCommentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    parentId?: SortOrder
    description?: SortOrder
    section?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ResumesCommentCountOrderByAggregateInput
    _max?: ResumesCommentMaxOrderByAggregateInput
    _min?: ResumesCommentMinOrderByAggregateInput
  }

  export type ResumesCommentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ResumesCommentScalarWhereWithAggregatesInput>
    OR?: Enumerable<ResumesCommentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ResumesCommentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    resumeId?: StringWithAggregatesFilter | string
    parentId?: StringNullableWithAggregatesFilter | string | null
    description?: StringWithAggregatesFilter | string
    section?: EnumResumesSectionWithAggregatesFilter | ResumesSection
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ResumesCommentVoteWhereInput = {
    AND?: Enumerable<ResumesCommentVoteWhereInput>
    OR?: Enumerable<ResumesCommentVoteWhereInput>
    NOT?: Enumerable<ResumesCommentVoteWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    commentId?: StringFilter | string
    value?: EnumVoteFilter | Vote
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    comment?: XOR<ResumesCommentRelationFilter, ResumesCommentWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ResumesCommentVoteOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    commentId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comment?: ResumesCommentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ResumesCommentVoteWhereUniqueInput = {
    id?: string
    userId_commentId?: ResumesCommentVoteUserIdCommentIdCompoundUniqueInput
  }

  export type ResumesCommentVoteOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    commentId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ResumesCommentVoteCountOrderByAggregateInput
    _max?: ResumesCommentVoteMaxOrderByAggregateInput
    _min?: ResumesCommentVoteMinOrderByAggregateInput
  }

  export type ResumesCommentVoteScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ResumesCommentVoteScalarWhereWithAggregatesInput>
    OR?: Enumerable<ResumesCommentVoteScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ResumesCommentVoteScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    commentId?: StringWithAggregatesFilter | string
    value?: EnumVoteWithAggregatesFilter | Vote
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type OffersProfileWhereInput = {
    AND?: Enumerable<OffersProfileWhereInput>
    OR?: Enumerable<OffersProfileWhereInput>
    NOT?: Enumerable<OffersProfileWhereInput>
    id?: StringFilter | string
    profileName?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    background?: XOR<OffersBackgroundRelationFilter, OffersBackgroundWhereInput> | null
    editToken?: StringFilter | string
    discussion?: OffersReplyListRelationFilter
    offers?: OffersOfferListRelationFilter
    users?: UserListRelationFilter
    analysis?: XOR<OffersAnalysisRelationFilter, OffersAnalysisWhereInput> | null
  }

  export type OffersProfileOrderByWithRelationInput = {
    id?: SortOrder
    profileName?: SortOrder
    createdAt?: SortOrder
    background?: OffersBackgroundOrderByWithRelationInput
    editToken?: SortOrder
    discussion?: OffersReplyOrderByRelationAggregateInput
    offers?: OffersOfferOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    analysis?: OffersAnalysisOrderByWithRelationInput
  }

  export type OffersProfileWhereUniqueInput = {
    id?: string
    profileName?: string
  }

  export type OffersProfileOrderByWithAggregationInput = {
    id?: SortOrder
    profileName?: SortOrder
    createdAt?: SortOrder
    editToken?: SortOrder
    _count?: OffersProfileCountOrderByAggregateInput
    _max?: OffersProfileMaxOrderByAggregateInput
    _min?: OffersProfileMinOrderByAggregateInput
  }

  export type OffersProfileScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OffersProfileScalarWhereWithAggregatesInput>
    OR?: Enumerable<OffersProfileScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OffersProfileScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    profileName?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    editToken?: StringWithAggregatesFilter | string
  }

  export type OffersAdminWhereInput = {
    AND?: Enumerable<OffersAdminWhereInput>
    OR?: Enumerable<OffersAdminWhereInput>
    NOT?: Enumerable<OffersAdminWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type OffersAdminOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type OffersAdminWhereUniqueInput = {
    id?: string
    userId?: string
  }

  export type OffersAdminOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    _count?: OffersAdminCountOrderByAggregateInput
    _max?: OffersAdminMaxOrderByAggregateInput
    _min?: OffersAdminMinOrderByAggregateInput
  }

  export type OffersAdminScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OffersAdminScalarWhereWithAggregatesInput>
    OR?: Enumerable<OffersAdminScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OffersAdminScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
  }

  export type OffersBackgroundWhereInput = {
    AND?: Enumerable<OffersBackgroundWhereInput>
    OR?: Enumerable<OffersBackgroundWhereInput>
    NOT?: Enumerable<OffersBackgroundWhereInput>
    id?: StringFilter | string
    totalYoe?: IntFilter | number
    specificYoes?: OffersSpecificYoeListRelationFilter
    experiences?: OffersExperienceListRelationFilter
    educations?: OffersEducationListRelationFilter
    profile?: XOR<OffersProfileRelationFilter, OffersProfileWhereInput>
    offersProfileId?: StringFilter | string
  }

  export type OffersBackgroundOrderByWithRelationInput = {
    id?: SortOrder
    totalYoe?: SortOrder
    specificYoes?: OffersSpecificYoeOrderByRelationAggregateInput
    experiences?: OffersExperienceOrderByRelationAggregateInput
    educations?: OffersEducationOrderByRelationAggregateInput
    profile?: OffersProfileOrderByWithRelationInput
    offersProfileId?: SortOrder
  }

  export type OffersBackgroundWhereUniqueInput = {
    id?: string
    offersProfileId?: string
  }

  export type OffersBackgroundOrderByWithAggregationInput = {
    id?: SortOrder
    totalYoe?: SortOrder
    offersProfileId?: SortOrder
    _count?: OffersBackgroundCountOrderByAggregateInput
    _avg?: OffersBackgroundAvgOrderByAggregateInput
    _max?: OffersBackgroundMaxOrderByAggregateInput
    _min?: OffersBackgroundMinOrderByAggregateInput
    _sum?: OffersBackgroundSumOrderByAggregateInput
  }

  export type OffersBackgroundScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OffersBackgroundScalarWhereWithAggregatesInput>
    OR?: Enumerable<OffersBackgroundScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OffersBackgroundScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    totalYoe?: IntWithAggregatesFilter | number
    offersProfileId?: StringWithAggregatesFilter | string
  }

  export type OffersSpecificYoeWhereInput = {
    AND?: Enumerable<OffersSpecificYoeWhereInput>
    OR?: Enumerable<OffersSpecificYoeWhereInput>
    NOT?: Enumerable<OffersSpecificYoeWhereInput>
    id?: StringFilter | string
    yoe?: IntFilter | number
    domain?: StringFilter | string
    background?: XOR<OffersBackgroundRelationFilter, OffersBackgroundWhereInput>
    backgroundId?: StringFilter | string
  }

  export type OffersSpecificYoeOrderByWithRelationInput = {
    id?: SortOrder
    yoe?: SortOrder
    domain?: SortOrder
    background?: OffersBackgroundOrderByWithRelationInput
    backgroundId?: SortOrder
  }

  export type OffersSpecificYoeWhereUniqueInput = {
    id?: string
  }

  export type OffersSpecificYoeOrderByWithAggregationInput = {
    id?: SortOrder
    yoe?: SortOrder
    domain?: SortOrder
    backgroundId?: SortOrder
    _count?: OffersSpecificYoeCountOrderByAggregateInput
    _avg?: OffersSpecificYoeAvgOrderByAggregateInput
    _max?: OffersSpecificYoeMaxOrderByAggregateInput
    _min?: OffersSpecificYoeMinOrderByAggregateInput
    _sum?: OffersSpecificYoeSumOrderByAggregateInput
  }

  export type OffersSpecificYoeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OffersSpecificYoeScalarWhereWithAggregatesInput>
    OR?: Enumerable<OffersSpecificYoeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OffersSpecificYoeScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    yoe?: IntWithAggregatesFilter | number
    domain?: StringWithAggregatesFilter | string
    backgroundId?: StringWithAggregatesFilter | string
  }

  export type OffersExperienceWhereInput = {
    AND?: Enumerable<OffersExperienceWhereInput>
    OR?: Enumerable<OffersExperienceWhereInput>
    NOT?: Enumerable<OffersExperienceWhereInput>
    id?: StringFilter | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput> | null
    companyId?: StringNullableFilter | string | null
    jobType?: EnumJobTypeNullableFilter | JobType | null
    title?: StringNullableFilter | string | null
    durationInMonths?: IntNullableFilter | number | null
    location?: XOR<CityRelationFilter, CityWhereInput> | null
    cityId?: StringNullableFilter | string | null
    level?: StringNullableFilter | string | null
    totalCompensation?: XOR<OffersCurrencyRelationFilter, OffersCurrencyWhereInput> | null
    totalCompensationId?: StringNullableFilter | string | null
    monthlySalary?: XOR<OffersCurrencyRelationFilter, OffersCurrencyWhereInput> | null
    monthlySalaryId?: StringNullableFilter | string | null
    background?: XOR<OffersBackgroundRelationFilter, OffersBackgroundWhereInput>
    backgroundId?: StringFilter | string
  }

  export type OffersExperienceOrderByWithRelationInput = {
    id?: SortOrder
    company?: CompanyOrderByWithRelationInput
    companyId?: SortOrder
    jobType?: SortOrder
    title?: SortOrder
    durationInMonths?: SortOrder
    location?: CityOrderByWithRelationInput
    cityId?: SortOrder
    level?: SortOrder
    totalCompensation?: OffersCurrencyOrderByWithRelationInput
    totalCompensationId?: SortOrder
    monthlySalary?: OffersCurrencyOrderByWithRelationInput
    monthlySalaryId?: SortOrder
    background?: OffersBackgroundOrderByWithRelationInput
    backgroundId?: SortOrder
  }

  export type OffersExperienceWhereUniqueInput = {
    id?: string
    totalCompensationId?: string
    monthlySalaryId?: string
  }

  export type OffersExperienceOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    jobType?: SortOrder
    title?: SortOrder
    durationInMonths?: SortOrder
    cityId?: SortOrder
    level?: SortOrder
    totalCompensationId?: SortOrder
    monthlySalaryId?: SortOrder
    backgroundId?: SortOrder
    _count?: OffersExperienceCountOrderByAggregateInput
    _avg?: OffersExperienceAvgOrderByAggregateInput
    _max?: OffersExperienceMaxOrderByAggregateInput
    _min?: OffersExperienceMinOrderByAggregateInput
    _sum?: OffersExperienceSumOrderByAggregateInput
  }

  export type OffersExperienceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OffersExperienceScalarWhereWithAggregatesInput>
    OR?: Enumerable<OffersExperienceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OffersExperienceScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    companyId?: StringNullableWithAggregatesFilter | string | null
    jobType?: EnumJobTypeNullableWithAggregatesFilter | JobType | null
    title?: StringNullableWithAggregatesFilter | string | null
    durationInMonths?: IntNullableWithAggregatesFilter | number | null
    cityId?: StringNullableWithAggregatesFilter | string | null
    level?: StringNullableWithAggregatesFilter | string | null
    totalCompensationId?: StringNullableWithAggregatesFilter | string | null
    monthlySalaryId?: StringNullableWithAggregatesFilter | string | null
    backgroundId?: StringWithAggregatesFilter | string
  }

  export type OffersCurrencyWhereInput = {
    AND?: Enumerable<OffersCurrencyWhereInput>
    OR?: Enumerable<OffersCurrencyWhereInput>
    NOT?: Enumerable<OffersCurrencyWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    value?: FloatFilter | number
    currency?: StringFilter | string
    baseValue?: FloatFilter | number
    baseCurrency?: StringFilter | string
    OffersExperienceTotalCompensation?: XOR<OffersExperienceRelationFilter, OffersExperienceWhereInput> | null
    OffersExperienceMonthlySalary?: XOR<OffersExperienceRelationFilter, OffersExperienceWhereInput> | null
    OffersTotalCompensation?: XOR<OffersFullTimeRelationFilter, OffersFullTimeWhereInput> | null
    OffersBaseSalary?: XOR<OffersFullTimeRelationFilter, OffersFullTimeWhereInput> | null
    OffersBonus?: XOR<OffersFullTimeRelationFilter, OffersFullTimeWhereInput> | null
    OffersStocks?: XOR<OffersFullTimeRelationFilter, OffersFullTimeWhereInput> | null
    OffersMonthlySalary?: XOR<OffersInternRelationFilter, OffersInternWhereInput> | null
  }

  export type OffersCurrencyOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    value?: SortOrder
    currency?: SortOrder
    baseValue?: SortOrder
    baseCurrency?: SortOrder
    OffersExperienceTotalCompensation?: OffersExperienceOrderByWithRelationInput
    OffersExperienceMonthlySalary?: OffersExperienceOrderByWithRelationInput
    OffersTotalCompensation?: OffersFullTimeOrderByWithRelationInput
    OffersBaseSalary?: OffersFullTimeOrderByWithRelationInput
    OffersBonus?: OffersFullTimeOrderByWithRelationInput
    OffersStocks?: OffersFullTimeOrderByWithRelationInput
    OffersMonthlySalary?: OffersInternOrderByWithRelationInput
  }

  export type OffersCurrencyWhereUniqueInput = {
    id?: string
  }

  export type OffersCurrencyOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    value?: SortOrder
    currency?: SortOrder
    baseValue?: SortOrder
    baseCurrency?: SortOrder
    _count?: OffersCurrencyCountOrderByAggregateInput
    _avg?: OffersCurrencyAvgOrderByAggregateInput
    _max?: OffersCurrencyMaxOrderByAggregateInput
    _min?: OffersCurrencyMinOrderByAggregateInput
    _sum?: OffersCurrencySumOrderByAggregateInput
  }

  export type OffersCurrencyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OffersCurrencyScalarWhereWithAggregatesInput>
    OR?: Enumerable<OffersCurrencyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OffersCurrencyScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    value?: FloatWithAggregatesFilter | number
    currency?: StringWithAggregatesFilter | string
    baseValue?: FloatWithAggregatesFilter | number
    baseCurrency?: StringWithAggregatesFilter | string
  }

  export type OffersEducationWhereInput = {
    AND?: Enumerable<OffersEducationWhereInput>
    OR?: Enumerable<OffersEducationWhereInput>
    NOT?: Enumerable<OffersEducationWhereInput>
    id?: StringFilter | string
    type?: StringNullableFilter | string | null
    field?: StringNullableFilter | string | null
    school?: StringNullableFilter | string | null
    startDate?: DateTimeNullableFilter | Date | string | null
    endDate?: DateTimeNullableFilter | Date | string | null
    background?: XOR<OffersBackgroundRelationFilter, OffersBackgroundWhereInput>
    backgroundId?: StringFilter | string
  }

  export type OffersEducationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    field?: SortOrder
    school?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    background?: OffersBackgroundOrderByWithRelationInput
    backgroundId?: SortOrder
  }

  export type OffersEducationWhereUniqueInput = {
    id?: string
  }

  export type OffersEducationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    field?: SortOrder
    school?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    backgroundId?: SortOrder
    _count?: OffersEducationCountOrderByAggregateInput
    _max?: OffersEducationMaxOrderByAggregateInput
    _min?: OffersEducationMinOrderByAggregateInput
  }

  export type OffersEducationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OffersEducationScalarWhereWithAggregatesInput>
    OR?: Enumerable<OffersEducationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OffersEducationScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    type?: StringNullableWithAggregatesFilter | string | null
    field?: StringNullableWithAggregatesFilter | string | null
    school?: StringNullableWithAggregatesFilter | string | null
    startDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    backgroundId?: StringWithAggregatesFilter | string
  }

  export type OffersReplyWhereInput = {
    AND?: Enumerable<OffersReplyWhereInput>
    OR?: Enumerable<OffersReplyWhereInput>
    NOT?: Enumerable<OffersReplyWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    message?: StringFilter | string
    replyingToId?: StringNullableFilter | string | null
    replyingTo?: XOR<OffersReplyRelationFilter, OffersReplyWhereInput> | null
    replies?: OffersReplyListRelationFilter
    profile?: XOR<OffersProfileRelationFilter, OffersProfileWhereInput>
    profileId?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    userId?: StringNullableFilter | string | null
  }

  export type OffersReplyOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    message?: SortOrder
    replyingToId?: SortOrder
    replyingTo?: OffersReplyOrderByWithRelationInput
    replies?: OffersReplyOrderByRelationAggregateInput
    profile?: OffersProfileOrderByWithRelationInput
    profileId?: SortOrder
    user?: UserOrderByWithRelationInput
    userId?: SortOrder
  }

  export type OffersReplyWhereUniqueInput = {
    id?: string
  }

  export type OffersReplyOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    message?: SortOrder
    replyingToId?: SortOrder
    profileId?: SortOrder
    userId?: SortOrder
    _count?: OffersReplyCountOrderByAggregateInput
    _max?: OffersReplyMaxOrderByAggregateInput
    _min?: OffersReplyMinOrderByAggregateInput
  }

  export type OffersReplyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OffersReplyScalarWhereWithAggregatesInput>
    OR?: Enumerable<OffersReplyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OffersReplyScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    message?: StringWithAggregatesFilter | string
    replyingToId?: StringNullableWithAggregatesFilter | string | null
    profileId?: StringWithAggregatesFilter | string
    userId?: StringNullableWithAggregatesFilter | string | null
  }

  export type OffersOfferWhereInput = {
    AND?: Enumerable<OffersOfferWhereInput>
    OR?: Enumerable<OffersOfferWhereInput>
    NOT?: Enumerable<OffersOfferWhereInput>
    id?: StringFilter | string
    profile?: XOR<OffersProfileRelationFilter, OffersProfileWhereInput>
    profileId?: StringFilter | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    companyId?: StringFilter | string
    location?: XOR<CityRelationFilter, CityWhereInput>
    cityId?: StringFilter | string
    monthYearReceived?: DateTimeFilter | Date | string
    negotiationStrategy?: StringFilter | string
    comments?: StringFilter | string
    jobType?: EnumJobTypeFilter | JobType
    offersIntern?: XOR<OffersInternRelationFilter, OffersInternWhereInput> | null
    offersInternId?: StringNullableFilter | string | null
    offersFullTime?: XOR<OffersFullTimeRelationFilter, OffersFullTimeWhereInput> | null
    offersFullTimeId?: StringNullableFilter | string | null
    offersAnalysis?: XOR<OffersAnalysisRelationFilter, OffersAnalysisWhereInput> | null
    offersAnalysisUnit?: OffersAnalysisUnitListRelationFilter
    OffersAnalysisUnit?: OffersAnalysisUnitListRelationFilter
  }

  export type OffersOfferOrderByWithRelationInput = {
    id?: SortOrder
    profile?: OffersProfileOrderByWithRelationInput
    profileId?: SortOrder
    company?: CompanyOrderByWithRelationInput
    companyId?: SortOrder
    location?: CityOrderByWithRelationInput
    cityId?: SortOrder
    monthYearReceived?: SortOrder
    negotiationStrategy?: SortOrder
    comments?: SortOrder
    jobType?: SortOrder
    offersIntern?: OffersInternOrderByWithRelationInput
    offersInternId?: SortOrder
    offersFullTime?: OffersFullTimeOrderByWithRelationInput
    offersFullTimeId?: SortOrder
    offersAnalysis?: OffersAnalysisOrderByWithRelationInput
    offersAnalysisUnit?: OffersAnalysisUnitOrderByRelationAggregateInput
    OffersAnalysisUnit?: OffersAnalysisUnitOrderByRelationAggregateInput
  }

  export type OffersOfferWhereUniqueInput = {
    id?: string
    offersInternId?: string
    offersFullTimeId?: string
  }

  export type OffersOfferOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrder
    companyId?: SortOrder
    cityId?: SortOrder
    monthYearReceived?: SortOrder
    negotiationStrategy?: SortOrder
    comments?: SortOrder
    jobType?: SortOrder
    offersInternId?: SortOrder
    offersFullTimeId?: SortOrder
    _count?: OffersOfferCountOrderByAggregateInput
    _max?: OffersOfferMaxOrderByAggregateInput
    _min?: OffersOfferMinOrderByAggregateInput
  }

  export type OffersOfferScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OffersOfferScalarWhereWithAggregatesInput>
    OR?: Enumerable<OffersOfferScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OffersOfferScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    profileId?: StringWithAggregatesFilter | string
    companyId?: StringWithAggregatesFilter | string
    cityId?: StringWithAggregatesFilter | string
    monthYearReceived?: DateTimeWithAggregatesFilter | Date | string
    negotiationStrategy?: StringWithAggregatesFilter | string
    comments?: StringWithAggregatesFilter | string
    jobType?: EnumJobTypeWithAggregatesFilter | JobType
    offersInternId?: StringNullableWithAggregatesFilter | string | null
    offersFullTimeId?: StringNullableWithAggregatesFilter | string | null
  }

  export type OffersInternWhereInput = {
    AND?: Enumerable<OffersInternWhereInput>
    OR?: Enumerable<OffersInternWhereInput>
    NOT?: Enumerable<OffersInternWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    internshipCycle?: StringFilter | string
    startYear?: IntFilter | number
    monthlySalary?: XOR<OffersCurrencyRelationFilter, OffersCurrencyWhereInput>
    monthlySalaryId?: StringFilter | string
    OffersOffer?: XOR<OffersOfferRelationFilter, OffersOfferWhereInput> | null
  }

  export type OffersInternOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    internshipCycle?: SortOrder
    startYear?: SortOrder
    monthlySalary?: OffersCurrencyOrderByWithRelationInput
    monthlySalaryId?: SortOrder
    OffersOffer?: OffersOfferOrderByWithRelationInput
  }

  export type OffersInternWhereUniqueInput = {
    id?: string
    monthlySalaryId?: string
  }

  export type OffersInternOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    internshipCycle?: SortOrder
    startYear?: SortOrder
    monthlySalaryId?: SortOrder
    _count?: OffersInternCountOrderByAggregateInput
    _avg?: OffersInternAvgOrderByAggregateInput
    _max?: OffersInternMaxOrderByAggregateInput
    _min?: OffersInternMinOrderByAggregateInput
    _sum?: OffersInternSumOrderByAggregateInput
  }

  export type OffersInternScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OffersInternScalarWhereWithAggregatesInput>
    OR?: Enumerable<OffersInternScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OffersInternScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    internshipCycle?: StringWithAggregatesFilter | string
    startYear?: IntWithAggregatesFilter | number
    monthlySalaryId?: StringWithAggregatesFilter | string
  }

  export type OffersFullTimeWhereInput = {
    AND?: Enumerable<OffersFullTimeWhereInput>
    OR?: Enumerable<OffersFullTimeWhereInput>
    NOT?: Enumerable<OffersFullTimeWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    level?: StringFilter | string
    totalCompensation?: XOR<OffersCurrencyRelationFilter, OffersCurrencyWhereInput>
    totalCompensationId?: StringFilter | string
    baseSalary?: XOR<OffersCurrencyRelationFilter, OffersCurrencyWhereInput> | null
    baseSalaryId?: StringNullableFilter | string | null
    bonus?: XOR<OffersCurrencyRelationFilter, OffersCurrencyWhereInput> | null
    bonusId?: StringNullableFilter | string | null
    stocks?: XOR<OffersCurrencyRelationFilter, OffersCurrencyWhereInput> | null
    stocksId?: StringNullableFilter | string | null
    OffersOffer?: XOR<OffersOfferRelationFilter, OffersOfferWhereInput> | null
  }

  export type OffersFullTimeOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    level?: SortOrder
    totalCompensation?: OffersCurrencyOrderByWithRelationInput
    totalCompensationId?: SortOrder
    baseSalary?: OffersCurrencyOrderByWithRelationInput
    baseSalaryId?: SortOrder
    bonus?: OffersCurrencyOrderByWithRelationInput
    bonusId?: SortOrder
    stocks?: OffersCurrencyOrderByWithRelationInput
    stocksId?: SortOrder
    OffersOffer?: OffersOfferOrderByWithRelationInput
  }

  export type OffersFullTimeWhereUniqueInput = {
    id?: string
    totalCompensationId?: string
    baseSalaryId?: string
    bonusId?: string
    stocksId?: string
  }

  export type OffersFullTimeOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    level?: SortOrder
    totalCompensationId?: SortOrder
    baseSalaryId?: SortOrder
    bonusId?: SortOrder
    stocksId?: SortOrder
    _count?: OffersFullTimeCountOrderByAggregateInput
    _max?: OffersFullTimeMaxOrderByAggregateInput
    _min?: OffersFullTimeMinOrderByAggregateInput
  }

  export type OffersFullTimeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OffersFullTimeScalarWhereWithAggregatesInput>
    OR?: Enumerable<OffersFullTimeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OffersFullTimeScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    level?: StringWithAggregatesFilter | string
    totalCompensationId?: StringWithAggregatesFilter | string
    baseSalaryId?: StringNullableWithAggregatesFilter | string | null
    bonusId?: StringNullableWithAggregatesFilter | string | null
    stocksId?: StringNullableWithAggregatesFilter | string | null
  }

  export type OffersAnalysisWhereInput = {
    AND?: Enumerable<OffersAnalysisWhereInput>
    OR?: Enumerable<OffersAnalysisWhereInput>
    NOT?: Enumerable<OffersAnalysisWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    profile?: XOR<OffersProfileRelationFilter, OffersProfileWhereInput>
    profileId?: StringFilter | string
    overallHighestOffer?: XOR<OffersOfferRelationFilter, OffersOfferWhereInput>
    offerId?: StringFilter | string
    overallAnalysis?: XOR<OffersAnalysisUnitRelationFilter, OffersAnalysisUnitWhereInput>
    overallAnalysisUnitId?: StringFilter | string
    companyAnalysis?: OffersAnalysisUnitListRelationFilter
  }

  export type OffersAnalysisOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profile?: OffersProfileOrderByWithRelationInput
    profileId?: SortOrder
    overallHighestOffer?: OffersOfferOrderByWithRelationInput
    offerId?: SortOrder
    overallAnalysis?: OffersAnalysisUnitOrderByWithRelationInput
    overallAnalysisUnitId?: SortOrder
    companyAnalysis?: OffersAnalysisUnitOrderByRelationAggregateInput
  }

  export type OffersAnalysisWhereUniqueInput = {
    id?: string
    profileId?: string
    offerId?: string
  }

  export type OffersAnalysisOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrder
    offerId?: SortOrder
    overallAnalysisUnitId?: SortOrder
    _count?: OffersAnalysisCountOrderByAggregateInput
    _max?: OffersAnalysisMaxOrderByAggregateInput
    _min?: OffersAnalysisMinOrderByAggregateInput
  }

  export type OffersAnalysisScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OffersAnalysisScalarWhereWithAggregatesInput>
    OR?: Enumerable<OffersAnalysisScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OffersAnalysisScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    profileId?: StringWithAggregatesFilter | string
    offerId?: StringWithAggregatesFilter | string
    overallAnalysisUnitId?: StringWithAggregatesFilter | string
  }

  export type OffersAnalysisUnitWhereInput = {
    AND?: Enumerable<OffersAnalysisUnitWhereInput>
    OR?: Enumerable<OffersAnalysisUnitWhereInput>
    NOT?: Enumerable<OffersAnalysisUnitWhereInput>
    id?: StringFilter | string
    analysedOffer?: XOR<OffersOfferRelationFilter, OffersOfferWhereInput>
    analysedOfferId?: StringFilter | string
    percentile?: FloatFilter | number
    noOfSimilarOffers?: IntFilter | number
    topSimilarOffers?: OffersOfferListRelationFilter
    offersAnalysisOverall?: OffersAnalysisListRelationFilter
    offersAnalysisCompany?: OffersAnalysisListRelationFilter
  }

  export type OffersAnalysisUnitOrderByWithRelationInput = {
    id?: SortOrder
    analysedOffer?: OffersOfferOrderByWithRelationInput
    analysedOfferId?: SortOrder
    percentile?: SortOrder
    noOfSimilarOffers?: SortOrder
    topSimilarOffers?: OffersOfferOrderByRelationAggregateInput
    offersAnalysisOverall?: OffersAnalysisOrderByRelationAggregateInput
    offersAnalysisCompany?: OffersAnalysisOrderByRelationAggregateInput
  }

  export type OffersAnalysisUnitWhereUniqueInput = {
    id?: string
  }

  export type OffersAnalysisUnitOrderByWithAggregationInput = {
    id?: SortOrder
    analysedOfferId?: SortOrder
    percentile?: SortOrder
    noOfSimilarOffers?: SortOrder
    _count?: OffersAnalysisUnitCountOrderByAggregateInput
    _avg?: OffersAnalysisUnitAvgOrderByAggregateInput
    _max?: OffersAnalysisUnitMaxOrderByAggregateInput
    _min?: OffersAnalysisUnitMinOrderByAggregateInput
    _sum?: OffersAnalysisUnitSumOrderByAggregateInput
  }

  export type OffersAnalysisUnitScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OffersAnalysisUnitScalarWhereWithAggregatesInput>
    OR?: Enumerable<OffersAnalysisUnitScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OffersAnalysisUnitScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    analysedOfferId?: StringWithAggregatesFilter | string
    percentile?: FloatWithAggregatesFilter | number
    noOfSimilarOffers?: IntWithAggregatesFilter | number
  }

  export type QuestionsQuestionWhereInput = {
    AND?: Enumerable<QuestionsQuestionWhereInput>
    OR?: Enumerable<QuestionsQuestionWhereInput>
    NOT?: Enumerable<QuestionsQuestionWhereInput>
    id?: StringFilter | string
    userId?: StringNullableFilter | string | null
    content?: StringFilter | string
    questionType?: EnumQuestionsQuestionTypeFilter | QuestionsQuestionType
    lastSeenAt?: DateTimeNullableFilter | Date | string | null
    upvotes?: IntFilter | number
    numEncounters?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    encounters?: QuestionsQuestionEncounterListRelationFilter
    votes?: QuestionsQuestionVoteListRelationFilter
    comments?: QuestionsQuestionCommentListRelationFilter
    answers?: QuestionsAnswerListRelationFilter
    questionsListQuestionEntries?: QuestionsListQuestionEntryListRelationFilter
  }

  export type QuestionsQuestionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    questionType?: SortOrder
    lastSeenAt?: SortOrder
    upvotes?: SortOrder
    numEncounters?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    encounters?: QuestionsQuestionEncounterOrderByRelationAggregateInput
    votes?: QuestionsQuestionVoteOrderByRelationAggregateInput
    comments?: QuestionsQuestionCommentOrderByRelationAggregateInput
    answers?: QuestionsAnswerOrderByRelationAggregateInput
    questionsListQuestionEntries?: QuestionsListQuestionEntryOrderByRelationAggregateInput
  }

  export type QuestionsQuestionWhereUniqueInput = {
    id?: string
  }

  export type QuestionsQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    questionType?: SortOrder
    lastSeenAt?: SortOrder
    upvotes?: SortOrder
    numEncounters?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuestionsQuestionCountOrderByAggregateInput
    _avg?: QuestionsQuestionAvgOrderByAggregateInput
    _max?: QuestionsQuestionMaxOrderByAggregateInput
    _min?: QuestionsQuestionMinOrderByAggregateInput
    _sum?: QuestionsQuestionSumOrderByAggregateInput
  }

  export type QuestionsQuestionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QuestionsQuestionScalarWhereWithAggregatesInput>
    OR?: Enumerable<QuestionsQuestionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QuestionsQuestionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringNullableWithAggregatesFilter | string | null
    content?: StringWithAggregatesFilter | string
    questionType?: EnumQuestionsQuestionTypeWithAggregatesFilter | QuestionsQuestionType
    lastSeenAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    upvotes?: IntWithAggregatesFilter | number
    numEncounters?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type QuestionsQuestionEncounterWhereInput = {
    AND?: Enumerable<QuestionsQuestionEncounterWhereInput>
    OR?: Enumerable<QuestionsQuestionEncounterWhereInput>
    NOT?: Enumerable<QuestionsQuestionEncounterWhereInput>
    id?: StringFilter | string
    questionId?: StringFilter | string
    userId?: StringNullableFilter | string | null
    companyId?: StringNullableFilter | string | null
    countryId?: StringNullableFilter | string | null
    stateId?: StringNullableFilter | string | null
    cityId?: StringNullableFilter | string | null
    role?: StringFilter | string
    seenAt?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    country?: XOR<CountryRelationFilter, CountryWhereInput> | null
    state?: XOR<StateRelationFilter, StateWhereInput> | null
    city?: XOR<CityRelationFilter, CityWhereInput> | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    question?: XOR<QuestionsQuestionRelationFilter, QuestionsQuestionWhereInput>
  }

  export type QuestionsQuestionEncounterOrderByWithRelationInput = {
    id?: SortOrder
    questionId?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    countryId?: SortOrder
    stateId?: SortOrder
    cityId?: SortOrder
    role?: SortOrder
    seenAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    country?: CountryOrderByWithRelationInput
    state?: StateOrderByWithRelationInput
    city?: CityOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    question?: QuestionsQuestionOrderByWithRelationInput
  }

  export type QuestionsQuestionEncounterWhereUniqueInput = {
    id?: string
  }

  export type QuestionsQuestionEncounterOrderByWithAggregationInput = {
    id?: SortOrder
    questionId?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    countryId?: SortOrder
    stateId?: SortOrder
    cityId?: SortOrder
    role?: SortOrder
    seenAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuestionsQuestionEncounterCountOrderByAggregateInput
    _max?: QuestionsQuestionEncounterMaxOrderByAggregateInput
    _min?: QuestionsQuestionEncounterMinOrderByAggregateInput
  }

  export type QuestionsQuestionEncounterScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QuestionsQuestionEncounterScalarWhereWithAggregatesInput>
    OR?: Enumerable<QuestionsQuestionEncounterScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QuestionsQuestionEncounterScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    questionId?: StringWithAggregatesFilter | string
    userId?: StringNullableWithAggregatesFilter | string | null
    companyId?: StringNullableWithAggregatesFilter | string | null
    countryId?: StringNullableWithAggregatesFilter | string | null
    stateId?: StringNullableWithAggregatesFilter | string | null
    cityId?: StringNullableWithAggregatesFilter | string | null
    role?: StringWithAggregatesFilter | string
    seenAt?: DateTimeWithAggregatesFilter | Date | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type QuestionsQuestionVoteWhereInput = {
    AND?: Enumerable<QuestionsQuestionVoteWhereInput>
    OR?: Enumerable<QuestionsQuestionVoteWhereInput>
    NOT?: Enumerable<QuestionsQuestionVoteWhereInput>
    id?: StringFilter | string
    questionId?: StringFilter | string
    userId?: StringNullableFilter | string | null
    vote?: EnumVoteFilter | Vote
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    question?: XOR<QuestionsQuestionRelationFilter, QuestionsQuestionWhereInput>
  }

  export type QuestionsQuestionVoteOrderByWithRelationInput = {
    id?: SortOrder
    questionId?: SortOrder
    userId?: SortOrder
    vote?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    question?: QuestionsQuestionOrderByWithRelationInput
  }

  export type QuestionsQuestionVoteWhereUniqueInput = {
    id?: string
    questionId_userId?: QuestionsQuestionVoteQuestionIdUserIdCompoundUniqueInput
  }

  export type QuestionsQuestionVoteOrderByWithAggregationInput = {
    id?: SortOrder
    questionId?: SortOrder
    userId?: SortOrder
    vote?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuestionsQuestionVoteCountOrderByAggregateInput
    _max?: QuestionsQuestionVoteMaxOrderByAggregateInput
    _min?: QuestionsQuestionVoteMinOrderByAggregateInput
  }

  export type QuestionsQuestionVoteScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QuestionsQuestionVoteScalarWhereWithAggregatesInput>
    OR?: Enumerable<QuestionsQuestionVoteScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QuestionsQuestionVoteScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    questionId?: StringWithAggregatesFilter | string
    userId?: StringNullableWithAggregatesFilter | string | null
    vote?: EnumVoteWithAggregatesFilter | Vote
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type QuestionsQuestionCommentWhereInput = {
    AND?: Enumerable<QuestionsQuestionCommentWhereInput>
    OR?: Enumerable<QuestionsQuestionCommentWhereInput>
    NOT?: Enumerable<QuestionsQuestionCommentWhereInput>
    id?: StringFilter | string
    questionId?: StringFilter | string
    userId?: StringNullableFilter | string | null
    upvotes?: IntFilter | number
    content?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    question?: XOR<QuestionsQuestionRelationFilter, QuestionsQuestionWhereInput>
    votes?: QuestionsQuestionCommentVoteListRelationFilter
  }

  export type QuestionsQuestionCommentOrderByWithRelationInput = {
    id?: SortOrder
    questionId?: SortOrder
    userId?: SortOrder
    upvotes?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    question?: QuestionsQuestionOrderByWithRelationInput
    votes?: QuestionsQuestionCommentVoteOrderByRelationAggregateInput
  }

  export type QuestionsQuestionCommentWhereUniqueInput = {
    id?: string
  }

  export type QuestionsQuestionCommentOrderByWithAggregationInput = {
    id?: SortOrder
    questionId?: SortOrder
    userId?: SortOrder
    upvotes?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuestionsQuestionCommentCountOrderByAggregateInput
    _avg?: QuestionsQuestionCommentAvgOrderByAggregateInput
    _max?: QuestionsQuestionCommentMaxOrderByAggregateInput
    _min?: QuestionsQuestionCommentMinOrderByAggregateInput
    _sum?: QuestionsQuestionCommentSumOrderByAggregateInput
  }

  export type QuestionsQuestionCommentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QuestionsQuestionCommentScalarWhereWithAggregatesInput>
    OR?: Enumerable<QuestionsQuestionCommentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QuestionsQuestionCommentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    questionId?: StringWithAggregatesFilter | string
    userId?: StringNullableWithAggregatesFilter | string | null
    upvotes?: IntWithAggregatesFilter | number
    content?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type QuestionsQuestionCommentVoteWhereInput = {
    AND?: Enumerable<QuestionsQuestionCommentVoteWhereInput>
    OR?: Enumerable<QuestionsQuestionCommentVoteWhereInput>
    NOT?: Enumerable<QuestionsQuestionCommentVoteWhereInput>
    id?: StringFilter | string
    questionCommentId?: StringFilter | string
    userId?: StringNullableFilter | string | null
    vote?: EnumVoteFilter | Vote
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    comment?: XOR<QuestionsQuestionCommentRelationFilter, QuestionsQuestionCommentWhereInput>
  }

  export type QuestionsQuestionCommentVoteOrderByWithRelationInput = {
    id?: SortOrder
    questionCommentId?: SortOrder
    userId?: SortOrder
    vote?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    comment?: QuestionsQuestionCommentOrderByWithRelationInput
  }

  export type QuestionsQuestionCommentVoteWhereUniqueInput = {
    id?: string
    questionCommentId_userId?: QuestionsQuestionCommentVoteQuestionCommentIdUserIdCompoundUniqueInput
  }

  export type QuestionsQuestionCommentVoteOrderByWithAggregationInput = {
    id?: SortOrder
    questionCommentId?: SortOrder
    userId?: SortOrder
    vote?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuestionsQuestionCommentVoteCountOrderByAggregateInput
    _max?: QuestionsQuestionCommentVoteMaxOrderByAggregateInput
    _min?: QuestionsQuestionCommentVoteMinOrderByAggregateInput
  }

  export type QuestionsQuestionCommentVoteScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QuestionsQuestionCommentVoteScalarWhereWithAggregatesInput>
    OR?: Enumerable<QuestionsQuestionCommentVoteScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QuestionsQuestionCommentVoteScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    questionCommentId?: StringWithAggregatesFilter | string
    userId?: StringNullableWithAggregatesFilter | string | null
    vote?: EnumVoteWithAggregatesFilter | Vote
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type QuestionsAnswerWhereInput = {
    AND?: Enumerable<QuestionsAnswerWhereInput>
    OR?: Enumerable<QuestionsAnswerWhereInput>
    NOT?: Enumerable<QuestionsAnswerWhereInput>
    id?: StringFilter | string
    questionId?: StringFilter | string
    userId?: StringNullableFilter | string | null
    content?: StringFilter | string
    upvotes?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    question?: XOR<QuestionsQuestionRelationFilter, QuestionsQuestionWhereInput>
    votes?: QuestionsAnswerVoteListRelationFilter
    comments?: QuestionsAnswerCommentListRelationFilter
  }

  export type QuestionsAnswerOrderByWithRelationInput = {
    id?: SortOrder
    questionId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    upvotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    question?: QuestionsQuestionOrderByWithRelationInput
    votes?: QuestionsAnswerVoteOrderByRelationAggregateInput
    comments?: QuestionsAnswerCommentOrderByRelationAggregateInput
  }

  export type QuestionsAnswerWhereUniqueInput = {
    id?: string
  }

  export type QuestionsAnswerOrderByWithAggregationInput = {
    id?: SortOrder
    questionId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    upvotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuestionsAnswerCountOrderByAggregateInput
    _avg?: QuestionsAnswerAvgOrderByAggregateInput
    _max?: QuestionsAnswerMaxOrderByAggregateInput
    _min?: QuestionsAnswerMinOrderByAggregateInput
    _sum?: QuestionsAnswerSumOrderByAggregateInput
  }

  export type QuestionsAnswerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QuestionsAnswerScalarWhereWithAggregatesInput>
    OR?: Enumerable<QuestionsAnswerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QuestionsAnswerScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    questionId?: StringWithAggregatesFilter | string
    userId?: StringNullableWithAggregatesFilter | string | null
    content?: StringWithAggregatesFilter | string
    upvotes?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type QuestionsAnswerVoteWhereInput = {
    AND?: Enumerable<QuestionsAnswerVoteWhereInput>
    OR?: Enumerable<QuestionsAnswerVoteWhereInput>
    NOT?: Enumerable<QuestionsAnswerVoteWhereInput>
    id?: StringFilter | string
    answerId?: StringFilter | string
    userId?: StringNullableFilter | string | null
    vote?: EnumVoteFilter | Vote
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    answer?: XOR<QuestionsAnswerRelationFilter, QuestionsAnswerWhereInput>
  }

  export type QuestionsAnswerVoteOrderByWithRelationInput = {
    id?: SortOrder
    answerId?: SortOrder
    userId?: SortOrder
    vote?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    answer?: QuestionsAnswerOrderByWithRelationInput
  }

  export type QuestionsAnswerVoteWhereUniqueInput = {
    id?: string
    answerId_userId?: QuestionsAnswerVoteAnswerIdUserIdCompoundUniqueInput
  }

  export type QuestionsAnswerVoteOrderByWithAggregationInput = {
    id?: SortOrder
    answerId?: SortOrder
    userId?: SortOrder
    vote?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuestionsAnswerVoteCountOrderByAggregateInput
    _max?: QuestionsAnswerVoteMaxOrderByAggregateInput
    _min?: QuestionsAnswerVoteMinOrderByAggregateInput
  }

  export type QuestionsAnswerVoteScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QuestionsAnswerVoteScalarWhereWithAggregatesInput>
    OR?: Enumerable<QuestionsAnswerVoteScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QuestionsAnswerVoteScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    answerId?: StringWithAggregatesFilter | string
    userId?: StringNullableWithAggregatesFilter | string | null
    vote?: EnumVoteWithAggregatesFilter | Vote
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type QuestionsAnswerCommentWhereInput = {
    AND?: Enumerable<QuestionsAnswerCommentWhereInput>
    OR?: Enumerable<QuestionsAnswerCommentWhereInput>
    NOT?: Enumerable<QuestionsAnswerCommentWhereInput>
    id?: StringFilter | string
    answerId?: StringFilter | string
    userId?: StringNullableFilter | string | null
    content?: StringFilter | string
    upvotes?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    answer?: XOR<QuestionsAnswerRelationFilter, QuestionsAnswerWhereInput>
    votes?: QuestionsAnswerCommentVoteListRelationFilter
  }

  export type QuestionsAnswerCommentOrderByWithRelationInput = {
    id?: SortOrder
    answerId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    upvotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    answer?: QuestionsAnswerOrderByWithRelationInput
    votes?: QuestionsAnswerCommentVoteOrderByRelationAggregateInput
  }

  export type QuestionsAnswerCommentWhereUniqueInput = {
    id?: string
  }

  export type QuestionsAnswerCommentOrderByWithAggregationInput = {
    id?: SortOrder
    answerId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    upvotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuestionsAnswerCommentCountOrderByAggregateInput
    _avg?: QuestionsAnswerCommentAvgOrderByAggregateInput
    _max?: QuestionsAnswerCommentMaxOrderByAggregateInput
    _min?: QuestionsAnswerCommentMinOrderByAggregateInput
    _sum?: QuestionsAnswerCommentSumOrderByAggregateInput
  }

  export type QuestionsAnswerCommentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QuestionsAnswerCommentScalarWhereWithAggregatesInput>
    OR?: Enumerable<QuestionsAnswerCommentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QuestionsAnswerCommentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    answerId?: StringWithAggregatesFilter | string
    userId?: StringNullableWithAggregatesFilter | string | null
    content?: StringWithAggregatesFilter | string
    upvotes?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type QuestionsAnswerCommentVoteWhereInput = {
    AND?: Enumerable<QuestionsAnswerCommentVoteWhereInput>
    OR?: Enumerable<QuestionsAnswerCommentVoteWhereInput>
    NOT?: Enumerable<QuestionsAnswerCommentVoteWhereInput>
    id?: StringFilter | string
    answerCommentId?: StringFilter | string
    userId?: StringNullableFilter | string | null
    vote?: EnumVoteFilter | Vote
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    comment?: XOR<QuestionsAnswerCommentRelationFilter, QuestionsAnswerCommentWhereInput>
  }

  export type QuestionsAnswerCommentVoteOrderByWithRelationInput = {
    id?: SortOrder
    answerCommentId?: SortOrder
    userId?: SortOrder
    vote?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    comment?: QuestionsAnswerCommentOrderByWithRelationInput
  }

  export type QuestionsAnswerCommentVoteWhereUniqueInput = {
    id?: string
    answerCommentId_userId?: QuestionsAnswerCommentVoteAnswerCommentIdUserIdCompoundUniqueInput
  }

  export type QuestionsAnswerCommentVoteOrderByWithAggregationInput = {
    id?: SortOrder
    answerCommentId?: SortOrder
    userId?: SortOrder
    vote?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuestionsAnswerCommentVoteCountOrderByAggregateInput
    _max?: QuestionsAnswerCommentVoteMaxOrderByAggregateInput
    _min?: QuestionsAnswerCommentVoteMinOrderByAggregateInput
  }

  export type QuestionsAnswerCommentVoteScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QuestionsAnswerCommentVoteScalarWhereWithAggregatesInput>
    OR?: Enumerable<QuestionsAnswerCommentVoteScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QuestionsAnswerCommentVoteScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    answerCommentId?: StringWithAggregatesFilter | string
    userId?: StringNullableWithAggregatesFilter | string | null
    vote?: EnumVoteWithAggregatesFilter | Vote
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type QuestionsListWhereInput = {
    AND?: Enumerable<QuestionsListWhereInput>
    OR?: Enumerable<QuestionsListWhereInput>
    NOT?: Enumerable<QuestionsListWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    questionEntries?: QuestionsListQuestionEntryListRelationFilter
  }

  export type QuestionsListOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    questionEntries?: QuestionsListQuestionEntryOrderByRelationAggregateInput
  }

  export type QuestionsListWhereUniqueInput = {
    id?: string
    userId_name?: QuestionsListUserIdNameCompoundUniqueInput
  }

  export type QuestionsListOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuestionsListCountOrderByAggregateInput
    _max?: QuestionsListMaxOrderByAggregateInput
    _min?: QuestionsListMinOrderByAggregateInput
  }

  export type QuestionsListScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QuestionsListScalarWhereWithAggregatesInput>
    OR?: Enumerable<QuestionsListScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QuestionsListScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type QuestionsListQuestionEntryWhereInput = {
    AND?: Enumerable<QuestionsListQuestionEntryWhereInput>
    OR?: Enumerable<QuestionsListQuestionEntryWhereInput>
    NOT?: Enumerable<QuestionsListQuestionEntryWhereInput>
    id?: StringFilter | string
    listId?: StringFilter | string
    questionId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    list?: XOR<QuestionsListRelationFilter, QuestionsListWhereInput>
    question?: XOR<QuestionsQuestionRelationFilter, QuestionsQuestionWhereInput>
  }

  export type QuestionsListQuestionEntryOrderByWithRelationInput = {
    id?: SortOrder
    listId?: SortOrder
    questionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    list?: QuestionsListOrderByWithRelationInput
    question?: QuestionsQuestionOrderByWithRelationInput
  }

  export type QuestionsListQuestionEntryWhereUniqueInput = {
    id?: string
    listId_questionId?: QuestionsListQuestionEntryListIdQuestionIdCompoundUniqueInput
  }

  export type QuestionsListQuestionEntryOrderByWithAggregationInput = {
    id?: SortOrder
    listId?: SortOrder
    questionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuestionsListQuestionEntryCountOrderByAggregateInput
    _max?: QuestionsListQuestionEntryMaxOrderByAggregateInput
    _min?: QuestionsListQuestionEntryMinOrderByAggregateInput
  }

  export type QuestionsListQuestionEntryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QuestionsListQuestionEntryScalarWhereWithAggregatesInput>
    OR?: Enumerable<QuestionsListQuestionEntryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QuestionsListQuestionEntryScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    listId?: StringWithAggregatesFilter | string
    questionId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    todos?: TodoCreateNestedManyWithoutUserInput
    resumesResumes?: ResumesResumeCreateNestedManyWithoutUserInput
    resumesStars?: ResumesStarCreateNestedManyWithoutUserInput
    resumesComments?: ResumesCommentCreateNestedManyWithoutUserInput
    resumesCommentVotes?: ResumesCommentVoteCreateNestedManyWithoutUserInput
    questionsQuestions?: QuestionsQuestionCreateNestedManyWithoutUserInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterCreateNestedManyWithoutUserInput
    questionsQuestionVotes?: QuestionsQuestionVoteCreateNestedManyWithoutUserInput
    questionsQuestionComments?: QuestionsQuestionCommentCreateNestedManyWithoutUserInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteCreateNestedManyWithoutUserInput
    questionsAnswers?: QuestionsAnswerCreateNestedManyWithoutUserInput
    questionsAnswerVotes?: QuestionsAnswerVoteCreateNestedManyWithoutUserInput
    questionsAnswerComments?: QuestionsAnswerCommentCreateNestedManyWithoutUserInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteCreateNestedManyWithoutUserInput
    OffersProfile?: OffersProfileCreateNestedManyWithoutUsersInput
    offersDiscussion?: OffersReplyCreateNestedManyWithoutUserInput
    questionsLists?: QuestionsListCreateNestedManyWithoutUserInput
    OffersAdmin?: OffersAdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
    resumesResumes?: ResumesResumeUncheckedCreateNestedManyWithoutUserInput
    resumesStars?: ResumesStarUncheckedCreateNestedManyWithoutUserInput
    resumesComments?: ResumesCommentUncheckedCreateNestedManyWithoutUserInput
    resumesCommentVotes?: ResumesCommentVoteUncheckedCreateNestedManyWithoutUserInput
    questionsQuestions?: QuestionsQuestionUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionVotes?: QuestionsQuestionVoteUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionComments?: QuestionsQuestionCommentUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUncheckedCreateNestedManyWithoutUserInput
    questionsAnswers?: QuestionsAnswerUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerVotes?: QuestionsAnswerVoteUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerComments?: QuestionsAnswerCommentUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUncheckedCreateNestedManyWithoutUserInput
    OffersProfile?: OffersProfileUncheckedCreateNestedManyWithoutUsersInput
    offersDiscussion?: OffersReplyUncheckedCreateNestedManyWithoutUserInput
    questionsLists?: QuestionsListUncheckedCreateNestedManyWithoutUserInput
    OffersAdmin?: OffersAdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
    resumesResumes?: ResumesResumeUpdateManyWithoutUserNestedInput
    resumesStars?: ResumesStarUpdateManyWithoutUserNestedInput
    resumesComments?: ResumesCommentUpdateManyWithoutUserNestedInput
    resumesCommentVotes?: ResumesCommentVoteUpdateManyWithoutUserNestedInput
    questionsQuestions?: QuestionsQuestionUpdateManyWithoutUserNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUpdateManyWithoutUserNestedInput
    questionsQuestionVotes?: QuestionsQuestionVoteUpdateManyWithoutUserNestedInput
    questionsQuestionComments?: QuestionsQuestionCommentUpdateManyWithoutUserNestedInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUpdateManyWithoutUserNestedInput
    questionsAnswers?: QuestionsAnswerUpdateManyWithoutUserNestedInput
    questionsAnswerVotes?: QuestionsAnswerVoteUpdateManyWithoutUserNestedInput
    questionsAnswerComments?: QuestionsAnswerCommentUpdateManyWithoutUserNestedInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUpdateManyWithoutUserNestedInput
    OffersProfile?: OffersProfileUpdateManyWithoutUsersNestedInput
    offersDiscussion?: OffersReplyUpdateManyWithoutUserNestedInput
    questionsLists?: QuestionsListUpdateManyWithoutUserNestedInput
    OffersAdmin?: OffersAdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
    resumesResumes?: ResumesResumeUncheckedUpdateManyWithoutUserNestedInput
    resumesStars?: ResumesStarUncheckedUpdateManyWithoutUserNestedInput
    resumesComments?: ResumesCommentUncheckedUpdateManyWithoutUserNestedInput
    resumesCommentVotes?: ResumesCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestions?: QuestionsQuestionUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionVotes?: QuestionsQuestionVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionComments?: QuestionsQuestionCommentUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswers?: QuestionsAnswerUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerVotes?: QuestionsAnswerVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerComments?: QuestionsAnswerCommentUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    OffersProfile?: OffersProfileUncheckedUpdateManyWithoutUsersNestedInput
    offersDiscussion?: OffersReplyUncheckedUpdateManyWithoutUserNestedInput
    questionsLists?: QuestionsListUncheckedUpdateManyWithoutUserNestedInput
    OffersAdmin?: OffersAdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodoCreateInput = {
    id?: string
    text: string
    status?: TodoStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTodosInput
  }

  export type TodoUncheckedCreateInput = {
    id?: string
    userId: string
    text: string
    status?: TodoStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TodoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    status?: EnumTodoStatusFieldUpdateOperationsInput | TodoStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTodosNestedInput
  }

  export type TodoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    status?: EnumTodoStatusFieldUpdateOperationsInput | TodoStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodoCreateManyInput = {
    id?: string
    userId: string
    text: string
    status?: TodoStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TodoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    status?: EnumTodoStatusFieldUpdateOperationsInput | TodoStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    status?: EnumTodoStatusFieldUpdateOperationsInput | TodoStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logoUrl?: string | null
    website?: string | null
    ranking?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questionsQuestionEncounter?: QuestionsQuestionEncounterCreateNestedManyWithoutCompanyInput
    OffersExperience?: OffersExperienceCreateNestedManyWithoutCompanyInput
    OffersOffer?: OffersOfferCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logoUrl?: string | null
    website?: string | null
    ranking?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questionsQuestionEncounter?: QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutCompanyInput
    OffersExperience?: OffersExperienceUncheckedCreateNestedManyWithoutCompanyInput
    OffersOffer?: OffersOfferUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionsQuestionEncounter?: QuestionsQuestionEncounterUpdateManyWithoutCompanyNestedInput
    OffersExperience?: OffersExperienceUpdateManyWithoutCompanyNestedInput
    OffersOffer?: OffersOfferUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionsQuestionEncounter?: QuestionsQuestionEncounterUncheckedUpdateManyWithoutCompanyNestedInput
    OffersExperience?: OffersExperienceUncheckedUpdateManyWithoutCompanyNestedInput
    OffersOffer?: OffersOfferUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logoUrl?: string | null
    website?: string | null
    ranking?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryCreateInput = {
    id: string
    name: string
    code: string
    ranking?: number | null
    states?: StateCreateNestedManyWithoutCountryInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterCreateNestedManyWithoutCountryInput
    ResumesResume?: ResumesResumeCreateNestedManyWithoutLocationInput
  }

  export type CountryUncheckedCreateInput = {
    id: string
    name: string
    code: string
    ranking?: number | null
    states?: StateUncheckedCreateNestedManyWithoutCountryInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutCountryInput
    ResumesResume?: ResumesResumeUncheckedCreateNestedManyWithoutLocationInput
  }

  export type CountryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    states?: StateUpdateManyWithoutCountryNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUpdateManyWithoutCountryNestedInput
    ResumesResume?: ResumesResumeUpdateManyWithoutLocationNestedInput
  }

  export type CountryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    states?: StateUncheckedUpdateManyWithoutCountryNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedUpdateManyWithoutCountryNestedInput
    ResumesResume?: ResumesResumeUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type CountryCreateManyInput = {
    id: string
    name: string
    code: string
    ranking?: number | null
  }

  export type CountryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CountryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StateCreateInput = {
    id: string
    name: string
    cities?: CityCreateNestedManyWithoutStateInput
    country: CountryCreateNestedOneWithoutStatesInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterCreateNestedManyWithoutStateInput
  }

  export type StateUncheckedCreateInput = {
    id: string
    name: string
    countryId: string
    cities?: CityUncheckedCreateNestedManyWithoutStateInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutStateInput
  }

  export type StateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cities?: CityUpdateManyWithoutStateNestedInput
    country?: CountryUpdateOneRequiredWithoutStatesNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUpdateManyWithoutStateNestedInput
  }

  export type StateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    cities?: CityUncheckedUpdateManyWithoutStateNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedUpdateManyWithoutStateNestedInput
  }

  export type StateCreateManyInput = {
    id: string
    name: string
    countryId: string
  }

  export type StateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type StateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
  }

  export type CityCreateInput = {
    id: string
    name: string
    ranking?: number | null
    state: StateCreateNestedOneWithoutCitiesInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterCreateNestedManyWithoutCityInput
    OffersExperience?: OffersExperienceCreateNestedManyWithoutLocationInput
    OffersOffer?: OffersOfferCreateNestedManyWithoutLocationInput
  }

  export type CityUncheckedCreateInput = {
    id: string
    name: string
    stateId: string
    ranking?: number | null
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutCityInput
    OffersExperience?: OffersExperienceUncheckedCreateNestedManyWithoutLocationInput
    OffersOffer?: OffersOfferUncheckedCreateNestedManyWithoutLocationInput
  }

  export type CityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    state?: StateUpdateOneRequiredWithoutCitiesNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUpdateManyWithoutCityNestedInput
    OffersExperience?: OffersExperienceUpdateManyWithoutLocationNestedInput
    OffersOffer?: OffersOfferUpdateManyWithoutLocationNestedInput
  }

  export type CityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stateId?: StringFieldUpdateOperationsInput | string
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedUpdateManyWithoutCityNestedInput
    OffersExperience?: OffersExperienceUncheckedUpdateManyWithoutLocationNestedInput
    OffersOffer?: OffersOfferUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type CityCreateManyInput = {
    id: string
    name: string
    stateId: string
    ranking?: number | null
  }

  export type CityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stateId?: StringFieldUpdateOperationsInput | string
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ResumesResumeCreateInput = {
    id?: string
    title: string
    role: string
    experience: string
    url: string
    additionalInfo?: string | null
    isResolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutResumesResumesInput
    location: CountryCreateNestedOneWithoutResumesResumeInput
    stars?: ResumesStarCreateNestedManyWithoutResumeInput
    comments?: ResumesCommentCreateNestedManyWithoutResumeInput
  }

  export type ResumesResumeUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    role: string
    experience: string
    locationId: string
    url: string
    additionalInfo?: string | null
    isResolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stars?: ResumesStarUncheckedCreateNestedManyWithoutResumeInput
    comments?: ResumesCommentUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumesResumeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    experience?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutResumesResumesNestedInput
    location?: CountryUpdateOneRequiredWithoutResumesResumeNestedInput
    stars?: ResumesStarUpdateManyWithoutResumeNestedInput
    comments?: ResumesCommentUpdateManyWithoutResumeNestedInput
  }

  export type ResumesResumeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    experience?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stars?: ResumesStarUncheckedUpdateManyWithoutResumeNestedInput
    comments?: ResumesCommentUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type ResumesResumeCreateManyInput = {
    id?: string
    userId: string
    title: string
    role: string
    experience: string
    locationId: string
    url: string
    additionalInfo?: string | null
    isResolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResumesResumeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    experience?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumesResumeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    experience?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumesStarCreateInput = {
    id?: string
    createdAt?: Date | string
    resume: ResumesResumeCreateNestedOneWithoutStarsInput
    user: UserCreateNestedOneWithoutResumesStarsInput
  }

  export type ResumesStarUncheckedCreateInput = {
    id?: string
    userId: string
    resumeId: string
    createdAt?: Date | string
  }

  export type ResumesStarUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resume?: ResumesResumeUpdateOneRequiredWithoutStarsNestedInput
    user?: UserUpdateOneRequiredWithoutResumesStarsNestedInput
  }

  export type ResumesStarUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumesStarCreateManyInput = {
    id?: string
    userId: string
    resumeId: string
    createdAt?: Date | string
  }

  export type ResumesStarUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumesStarUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumesCommentCreateInput = {
    id?: string
    description: string
    section: ResumesSection
    createdAt?: Date | string
    updatedAt?: Date | string
    resume: ResumesResumeCreateNestedOneWithoutCommentsInput
    votes?: ResumesCommentVoteCreateNestedManyWithoutCommentInput
    user: UserCreateNestedOneWithoutResumesCommentsInput
    parent?: ResumesCommentCreateNestedOneWithoutChildrenInput
    children?: ResumesCommentCreateNestedManyWithoutParentInput
  }

  export type ResumesCommentUncheckedCreateInput = {
    id?: string
    userId: string
    resumeId: string
    parentId?: string | null
    description: string
    section: ResumesSection
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: ResumesCommentVoteUncheckedCreateNestedManyWithoutCommentInput
    children?: ResumesCommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type ResumesCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    section?: EnumResumesSectionFieldUpdateOperationsInput | ResumesSection
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resume?: ResumesResumeUpdateOneRequiredWithoutCommentsNestedInput
    votes?: ResumesCommentVoteUpdateManyWithoutCommentNestedInput
    user?: UserUpdateOneRequiredWithoutResumesCommentsNestedInput
    parent?: ResumesCommentUpdateOneWithoutChildrenNestedInput
    children?: ResumesCommentUpdateManyWithoutParentNestedInput
  }

  export type ResumesCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    section?: EnumResumesSectionFieldUpdateOperationsInput | ResumesSection
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: ResumesCommentVoteUncheckedUpdateManyWithoutCommentNestedInput
    children?: ResumesCommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type ResumesCommentCreateManyInput = {
    id?: string
    userId: string
    resumeId: string
    parentId?: string | null
    description: string
    section: ResumesSection
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResumesCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    section?: EnumResumesSectionFieldUpdateOperationsInput | ResumesSection
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumesCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    section?: EnumResumesSectionFieldUpdateOperationsInput | ResumesSection
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumesCommentVoteCreateInput = {
    id?: string
    value: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
    comment: ResumesCommentCreateNestedOneWithoutVotesInput
    user: UserCreateNestedOneWithoutResumesCommentVotesInput
  }

  export type ResumesCommentVoteUncheckedCreateInput = {
    id?: string
    userId: string
    commentId: string
    value: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResumesCommentVoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: ResumesCommentUpdateOneRequiredWithoutVotesNestedInput
    user?: UserUpdateOneRequiredWithoutResumesCommentVotesNestedInput
  }

  export type ResumesCommentVoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    value?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumesCommentVoteCreateManyInput = {
    id?: string
    userId: string
    commentId: string
    value: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResumesCommentVoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumesCommentVoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    value?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OffersProfileCreateInput = {
    id?: string
    profileName: string
    createdAt?: Date | string
    background?: OffersBackgroundCreateNestedOneWithoutProfileInput
    editToken: string
    discussion?: OffersReplyCreateNestedManyWithoutProfileInput
    offers?: OffersOfferCreateNestedManyWithoutProfileInput
    users?: UserCreateNestedManyWithoutOffersProfileInput
    analysis?: OffersAnalysisCreateNestedOneWithoutProfileInput
  }

  export type OffersProfileUncheckedCreateInput = {
    id?: string
    profileName: string
    createdAt?: Date | string
    background?: OffersBackgroundUncheckedCreateNestedOneWithoutProfileInput
    editToken: string
    discussion?: OffersReplyUncheckedCreateNestedManyWithoutProfileInput
    offers?: OffersOfferUncheckedCreateNestedManyWithoutProfileInput
    users?: UserUncheckedCreateNestedManyWithoutOffersProfileInput
    analysis?: OffersAnalysisUncheckedCreateNestedOneWithoutProfileInput
  }

  export type OffersProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    background?: OffersBackgroundUpdateOneWithoutProfileNestedInput
    editToken?: StringFieldUpdateOperationsInput | string
    discussion?: OffersReplyUpdateManyWithoutProfileNestedInput
    offers?: OffersOfferUpdateManyWithoutProfileNestedInput
    users?: UserUpdateManyWithoutOffersProfileNestedInput
    analysis?: OffersAnalysisUpdateOneWithoutProfileNestedInput
  }

  export type OffersProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    background?: OffersBackgroundUncheckedUpdateOneWithoutProfileNestedInput
    editToken?: StringFieldUpdateOperationsInput | string
    discussion?: OffersReplyUncheckedUpdateManyWithoutProfileNestedInput
    offers?: OffersOfferUncheckedUpdateManyWithoutProfileNestedInput
    users?: UserUncheckedUpdateManyWithoutOffersProfileNestedInput
    analysis?: OffersAnalysisUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type OffersProfileCreateManyInput = {
    id?: string
    profileName: string
    createdAt?: Date | string
    editToken: string
  }

  export type OffersProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editToken?: StringFieldUpdateOperationsInput | string
  }

  export type OffersProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editToken?: StringFieldUpdateOperationsInput | string
  }

  export type OffersAdminCreateInput = {
    id?: string
    user: UserCreateNestedOneWithoutOffersAdminInput
  }

  export type OffersAdminUncheckedCreateInput = {
    id?: string
    userId: string
  }

  export type OffersAdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutOffersAdminNestedInput
  }

  export type OffersAdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type OffersAdminCreateManyInput = {
    id?: string
    userId: string
  }

  export type OffersAdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type OffersAdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type OffersBackgroundCreateInput = {
    id?: string
    totalYoe?: number
    specificYoes?: OffersSpecificYoeCreateNestedManyWithoutBackgroundInput
    experiences?: OffersExperienceCreateNestedManyWithoutBackgroundInput
    educations?: OffersEducationCreateNestedManyWithoutBackgroundInput
    profile: OffersProfileCreateNestedOneWithoutBackgroundInput
  }

  export type OffersBackgroundUncheckedCreateInput = {
    id?: string
    totalYoe?: number
    specificYoes?: OffersSpecificYoeUncheckedCreateNestedManyWithoutBackgroundInput
    experiences?: OffersExperienceUncheckedCreateNestedManyWithoutBackgroundInput
    educations?: OffersEducationUncheckedCreateNestedManyWithoutBackgroundInput
    offersProfileId: string
  }

  export type OffersBackgroundUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalYoe?: IntFieldUpdateOperationsInput | number
    specificYoes?: OffersSpecificYoeUpdateManyWithoutBackgroundNestedInput
    experiences?: OffersExperienceUpdateManyWithoutBackgroundNestedInput
    educations?: OffersEducationUpdateManyWithoutBackgroundNestedInput
    profile?: OffersProfileUpdateOneRequiredWithoutBackgroundNestedInput
  }

  export type OffersBackgroundUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalYoe?: IntFieldUpdateOperationsInput | number
    specificYoes?: OffersSpecificYoeUncheckedUpdateManyWithoutBackgroundNestedInput
    experiences?: OffersExperienceUncheckedUpdateManyWithoutBackgroundNestedInput
    educations?: OffersEducationUncheckedUpdateManyWithoutBackgroundNestedInput
    offersProfileId?: StringFieldUpdateOperationsInput | string
  }

  export type OffersBackgroundCreateManyInput = {
    id?: string
    totalYoe?: number
    offersProfileId: string
  }

  export type OffersBackgroundUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalYoe?: IntFieldUpdateOperationsInput | number
  }

  export type OffersBackgroundUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalYoe?: IntFieldUpdateOperationsInput | number
    offersProfileId?: StringFieldUpdateOperationsInput | string
  }

  export type OffersSpecificYoeCreateInput = {
    id?: string
    yoe: number
    domain: string
    background: OffersBackgroundCreateNestedOneWithoutSpecificYoesInput
  }

  export type OffersSpecificYoeUncheckedCreateInput = {
    id?: string
    yoe: number
    domain: string
    backgroundId: string
  }

  export type OffersSpecificYoeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    yoe?: IntFieldUpdateOperationsInput | number
    domain?: StringFieldUpdateOperationsInput | string
    background?: OffersBackgroundUpdateOneRequiredWithoutSpecificYoesNestedInput
  }

  export type OffersSpecificYoeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    yoe?: IntFieldUpdateOperationsInput | number
    domain?: StringFieldUpdateOperationsInput | string
    backgroundId?: StringFieldUpdateOperationsInput | string
  }

  export type OffersSpecificYoeCreateManyInput = {
    id?: string
    yoe: number
    domain: string
    backgroundId: string
  }

  export type OffersSpecificYoeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    yoe?: IntFieldUpdateOperationsInput | number
    domain?: StringFieldUpdateOperationsInput | string
  }

  export type OffersSpecificYoeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    yoe?: IntFieldUpdateOperationsInput | number
    domain?: StringFieldUpdateOperationsInput | string
    backgroundId?: StringFieldUpdateOperationsInput | string
  }

  export type OffersExperienceCreateInput = {
    id?: string
    company?: CompanyCreateNestedOneWithoutOffersExperienceInput
    jobType?: JobType | null
    title?: string | null
    durationInMonths?: number | null
    location?: CityCreateNestedOneWithoutOffersExperienceInput
    level?: string | null
    totalCompensation?: OffersCurrencyCreateNestedOneWithoutOffersExperienceTotalCompensationInput
    monthlySalary?: OffersCurrencyCreateNestedOneWithoutOffersExperienceMonthlySalaryInput
    background: OffersBackgroundCreateNestedOneWithoutExperiencesInput
  }

  export type OffersExperienceUncheckedCreateInput = {
    id?: string
    companyId?: string | null
    jobType?: JobType | null
    title?: string | null
    durationInMonths?: number | null
    cityId?: string | null
    level?: string | null
    totalCompensationId?: string | null
    monthlySalaryId?: string | null
    backgroundId: string
  }

  export type OffersExperienceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: CompanyUpdateOneWithoutOffersExperienceNestedInput
    jobType?: NullableEnumJobTypeFieldUpdateOperationsInput | JobType | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    durationInMonths?: NullableIntFieldUpdateOperationsInput | number | null
    location?: CityUpdateOneWithoutOffersExperienceNestedInput
    level?: NullableStringFieldUpdateOperationsInput | string | null
    totalCompensation?: OffersCurrencyUpdateOneWithoutOffersExperienceTotalCompensationNestedInput
    monthlySalary?: OffersCurrencyUpdateOneWithoutOffersExperienceMonthlySalaryNestedInput
    background?: OffersBackgroundUpdateOneRequiredWithoutExperiencesNestedInput
  }

  export type OffersExperienceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    jobType?: NullableEnumJobTypeFieldUpdateOperationsInput | JobType | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    durationInMonths?: NullableIntFieldUpdateOperationsInput | number | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    totalCompensationId?: NullableStringFieldUpdateOperationsInput | string | null
    monthlySalaryId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundId?: StringFieldUpdateOperationsInput | string
  }

  export type OffersExperienceCreateManyInput = {
    id?: string
    companyId?: string | null
    jobType?: JobType | null
    title?: string | null
    durationInMonths?: number | null
    cityId?: string | null
    level?: string | null
    totalCompensationId?: string | null
    monthlySalaryId?: string | null
    backgroundId: string
  }

  export type OffersExperienceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobType?: NullableEnumJobTypeFieldUpdateOperationsInput | JobType | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    durationInMonths?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OffersExperienceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    jobType?: NullableEnumJobTypeFieldUpdateOperationsInput | JobType | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    durationInMonths?: NullableIntFieldUpdateOperationsInput | number | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    totalCompensationId?: NullableStringFieldUpdateOperationsInput | string | null
    monthlySalaryId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundId?: StringFieldUpdateOperationsInput | string
  }

  export type OffersCurrencyCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    value: number
    currency: string
    baseValue: number
    baseCurrency?: string
    OffersExperienceTotalCompensation?: OffersExperienceCreateNestedOneWithoutTotalCompensationInput
    OffersExperienceMonthlySalary?: OffersExperienceCreateNestedOneWithoutMonthlySalaryInput
    OffersTotalCompensation?: OffersFullTimeCreateNestedOneWithoutTotalCompensationInput
    OffersBaseSalary?: OffersFullTimeCreateNestedOneWithoutBaseSalaryInput
    OffersBonus?: OffersFullTimeCreateNestedOneWithoutBonusInput
    OffersStocks?: OffersFullTimeCreateNestedOneWithoutStocksInput
    OffersMonthlySalary?: OffersInternCreateNestedOneWithoutMonthlySalaryInput
  }

  export type OffersCurrencyUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    value: number
    currency: string
    baseValue: number
    baseCurrency?: string
    OffersExperienceTotalCompensation?: OffersExperienceUncheckedCreateNestedOneWithoutTotalCompensationInput
    OffersExperienceMonthlySalary?: OffersExperienceUncheckedCreateNestedOneWithoutMonthlySalaryInput
    OffersTotalCompensation?: OffersFullTimeUncheckedCreateNestedOneWithoutTotalCompensationInput
    OffersBaseSalary?: OffersFullTimeUncheckedCreateNestedOneWithoutBaseSalaryInput
    OffersBonus?: OffersFullTimeUncheckedCreateNestedOneWithoutBonusInput
    OffersStocks?: OffersFullTimeUncheckedCreateNestedOneWithoutStocksInput
    OffersMonthlySalary?: OffersInternUncheckedCreateNestedOneWithoutMonthlySalaryInput
  }

  export type OffersCurrencyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    baseValue?: FloatFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    OffersExperienceTotalCompensation?: OffersExperienceUpdateOneWithoutTotalCompensationNestedInput
    OffersExperienceMonthlySalary?: OffersExperienceUpdateOneWithoutMonthlySalaryNestedInput
    OffersTotalCompensation?: OffersFullTimeUpdateOneWithoutTotalCompensationNestedInput
    OffersBaseSalary?: OffersFullTimeUpdateOneWithoutBaseSalaryNestedInput
    OffersBonus?: OffersFullTimeUpdateOneWithoutBonusNestedInput
    OffersStocks?: OffersFullTimeUpdateOneWithoutStocksNestedInput
    OffersMonthlySalary?: OffersInternUpdateOneWithoutMonthlySalaryNestedInput
  }

  export type OffersCurrencyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    baseValue?: FloatFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    OffersExperienceTotalCompensation?: OffersExperienceUncheckedUpdateOneWithoutTotalCompensationNestedInput
    OffersExperienceMonthlySalary?: OffersExperienceUncheckedUpdateOneWithoutMonthlySalaryNestedInput
    OffersTotalCompensation?: OffersFullTimeUncheckedUpdateOneWithoutTotalCompensationNestedInput
    OffersBaseSalary?: OffersFullTimeUncheckedUpdateOneWithoutBaseSalaryNestedInput
    OffersBonus?: OffersFullTimeUncheckedUpdateOneWithoutBonusNestedInput
    OffersStocks?: OffersFullTimeUncheckedUpdateOneWithoutStocksNestedInput
    OffersMonthlySalary?: OffersInternUncheckedUpdateOneWithoutMonthlySalaryNestedInput
  }

  export type OffersCurrencyCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    value: number
    currency: string
    baseValue: number
    baseCurrency?: string
  }

  export type OffersCurrencyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    baseValue?: FloatFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
  }

  export type OffersCurrencyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    baseValue?: FloatFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
  }

  export type OffersEducationCreateInput = {
    id?: string
    type?: string | null
    field?: string | null
    school?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    background: OffersBackgroundCreateNestedOneWithoutEducationsInput
  }

  export type OffersEducationUncheckedCreateInput = {
    id?: string
    type?: string | null
    field?: string | null
    school?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    backgroundId: string
  }

  export type OffersEducationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    field?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    background?: OffersBackgroundUpdateOneRequiredWithoutEducationsNestedInput
  }

  export type OffersEducationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    field?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    backgroundId?: StringFieldUpdateOperationsInput | string
  }

  export type OffersEducationCreateManyInput = {
    id?: string
    type?: string | null
    field?: string | null
    school?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    backgroundId: string
  }

  export type OffersEducationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    field?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OffersEducationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    field?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    backgroundId?: StringFieldUpdateOperationsInput | string
  }

  export type OffersReplyCreateInput = {
    id?: string
    createdAt?: Date | string
    message: string
    replyingTo?: OffersReplyCreateNestedOneWithoutRepliesInput
    replies?: OffersReplyCreateNestedManyWithoutReplyingToInput
    profile: OffersProfileCreateNestedOneWithoutDiscussionInput
    user?: UserCreateNestedOneWithoutOffersDiscussionInput
  }

  export type OffersReplyUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    message: string
    replyingToId?: string | null
    replies?: OffersReplyUncheckedCreateNestedManyWithoutReplyingToInput
    profileId: string
    userId?: string | null
  }

  export type OffersReplyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    replyingTo?: OffersReplyUpdateOneWithoutRepliesNestedInput
    replies?: OffersReplyUpdateManyWithoutReplyingToNestedInput
    profile?: OffersProfileUpdateOneRequiredWithoutDiscussionNestedInput
    user?: UserUpdateOneWithoutOffersDiscussionNestedInput
  }

  export type OffersReplyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    replyingToId?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: OffersReplyUncheckedUpdateManyWithoutReplyingToNestedInput
    profileId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OffersReplyCreateManyInput = {
    id?: string
    createdAt?: Date | string
    message: string
    replyingToId?: string | null
    profileId: string
    userId?: string | null
  }

  export type OffersReplyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
  }

  export type OffersReplyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    replyingToId?: NullableStringFieldUpdateOperationsInput | string | null
    profileId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OffersOfferCreateInput = {
    id?: string
    profile: OffersProfileCreateNestedOneWithoutOffersInput
    company: CompanyCreateNestedOneWithoutOffersOfferInput
    location: CityCreateNestedOneWithoutOffersOfferInput
    monthYearReceived: Date | string
    negotiationStrategy: string
    comments: string
    jobType: JobType
    offersIntern?: OffersInternCreateNestedOneWithoutOffersOfferInput
    offersFullTime?: OffersFullTimeCreateNestedOneWithoutOffersOfferInput
    offersAnalysis?: OffersAnalysisCreateNestedOneWithoutOverallHighestOfferInput
    offersAnalysisUnit?: OffersAnalysisUnitCreateNestedManyWithoutTopSimilarOffersInput
    OffersAnalysisUnit?: OffersAnalysisUnitCreateNestedManyWithoutAnalysedOfferInput
  }

  export type OffersOfferUncheckedCreateInput = {
    id?: string
    profileId: string
    companyId: string
    cityId: string
    monthYearReceived: Date | string
    negotiationStrategy: string
    comments: string
    jobType: JobType
    offersInternId?: string | null
    offersFullTimeId?: string | null
    offersAnalysis?: OffersAnalysisUncheckedCreateNestedOneWithoutOverallHighestOfferInput
    offersAnalysisUnit?: OffersAnalysisUnitUncheckedCreateNestedManyWithoutTopSimilarOffersInput
    OffersAnalysisUnit?: OffersAnalysisUnitUncheckedCreateNestedManyWithoutAnalysedOfferInput
  }

  export type OffersOfferUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile?: OffersProfileUpdateOneRequiredWithoutOffersNestedInput
    company?: CompanyUpdateOneRequiredWithoutOffersOfferNestedInput
    location?: CityUpdateOneRequiredWithoutOffersOfferNestedInput
    monthYearReceived?: DateTimeFieldUpdateOperationsInput | Date | string
    negotiationStrategy?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | JobType
    offersIntern?: OffersInternUpdateOneWithoutOffersOfferNestedInput
    offersFullTime?: OffersFullTimeUpdateOneWithoutOffersOfferNestedInput
    offersAnalysis?: OffersAnalysisUpdateOneWithoutOverallHighestOfferNestedInput
    offersAnalysisUnit?: OffersAnalysisUnitUpdateManyWithoutTopSimilarOffersNestedInput
    OffersAnalysisUnit?: OffersAnalysisUnitUpdateManyWithoutAnalysedOfferNestedInput
  }

  export type OffersOfferUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    monthYearReceived?: DateTimeFieldUpdateOperationsInput | Date | string
    negotiationStrategy?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | JobType
    offersInternId?: NullableStringFieldUpdateOperationsInput | string | null
    offersFullTimeId?: NullableStringFieldUpdateOperationsInput | string | null
    offersAnalysis?: OffersAnalysisUncheckedUpdateOneWithoutOverallHighestOfferNestedInput
    offersAnalysisUnit?: OffersAnalysisUnitUncheckedUpdateManyWithoutTopSimilarOffersNestedInput
    OffersAnalysisUnit?: OffersAnalysisUnitUncheckedUpdateManyWithoutAnalysedOfferNestedInput
  }

  export type OffersOfferCreateManyInput = {
    id?: string
    profileId: string
    companyId: string
    cityId: string
    monthYearReceived: Date | string
    negotiationStrategy: string
    comments: string
    jobType: JobType
    offersInternId?: string | null
    offersFullTimeId?: string | null
  }

  export type OffersOfferUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    monthYearReceived?: DateTimeFieldUpdateOperationsInput | Date | string
    negotiationStrategy?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | JobType
  }

  export type OffersOfferUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    monthYearReceived?: DateTimeFieldUpdateOperationsInput | Date | string
    negotiationStrategy?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | JobType
    offersInternId?: NullableStringFieldUpdateOperationsInput | string | null
    offersFullTimeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OffersInternCreateInput = {
    id?: string
    title: string
    internshipCycle: string
    startYear: number
    monthlySalary: OffersCurrencyCreateNestedOneWithoutOffersMonthlySalaryInput
    OffersOffer?: OffersOfferCreateNestedOneWithoutOffersInternInput
  }

  export type OffersInternUncheckedCreateInput = {
    id?: string
    title: string
    internshipCycle: string
    startYear: number
    monthlySalaryId: string
    OffersOffer?: OffersOfferUncheckedCreateNestedOneWithoutOffersInternInput
  }

  export type OffersInternUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    internshipCycle?: StringFieldUpdateOperationsInput | string
    startYear?: IntFieldUpdateOperationsInput | number
    monthlySalary?: OffersCurrencyUpdateOneRequiredWithoutOffersMonthlySalaryNestedInput
    OffersOffer?: OffersOfferUpdateOneWithoutOffersInternNestedInput
  }

  export type OffersInternUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    internshipCycle?: StringFieldUpdateOperationsInput | string
    startYear?: IntFieldUpdateOperationsInput | number
    monthlySalaryId?: StringFieldUpdateOperationsInput | string
    OffersOffer?: OffersOfferUncheckedUpdateOneWithoutOffersInternNestedInput
  }

  export type OffersInternCreateManyInput = {
    id?: string
    title: string
    internshipCycle: string
    startYear: number
    monthlySalaryId: string
  }

  export type OffersInternUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    internshipCycle?: StringFieldUpdateOperationsInput | string
    startYear?: IntFieldUpdateOperationsInput | number
  }

  export type OffersInternUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    internshipCycle?: StringFieldUpdateOperationsInput | string
    startYear?: IntFieldUpdateOperationsInput | number
    monthlySalaryId?: StringFieldUpdateOperationsInput | string
  }

  export type OffersFullTimeCreateInput = {
    id?: string
    title: string
    level: string
    totalCompensation: OffersCurrencyCreateNestedOneWithoutOffersTotalCompensationInput
    baseSalary?: OffersCurrencyCreateNestedOneWithoutOffersBaseSalaryInput
    bonus?: OffersCurrencyCreateNestedOneWithoutOffersBonusInput
    stocks?: OffersCurrencyCreateNestedOneWithoutOffersStocksInput
    OffersOffer?: OffersOfferCreateNestedOneWithoutOffersFullTimeInput
  }

  export type OffersFullTimeUncheckedCreateInput = {
    id?: string
    title: string
    level: string
    totalCompensationId: string
    baseSalaryId?: string | null
    bonusId?: string | null
    stocksId?: string | null
    OffersOffer?: OffersOfferUncheckedCreateNestedOneWithoutOffersFullTimeInput
  }

  export type OffersFullTimeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    totalCompensation?: OffersCurrencyUpdateOneRequiredWithoutOffersTotalCompensationNestedInput
    baseSalary?: OffersCurrencyUpdateOneWithoutOffersBaseSalaryNestedInput
    bonus?: OffersCurrencyUpdateOneWithoutOffersBonusNestedInput
    stocks?: OffersCurrencyUpdateOneWithoutOffersStocksNestedInput
    OffersOffer?: OffersOfferUpdateOneWithoutOffersFullTimeNestedInput
  }

  export type OffersFullTimeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    totalCompensationId?: StringFieldUpdateOperationsInput | string
    baseSalaryId?: NullableStringFieldUpdateOperationsInput | string | null
    bonusId?: NullableStringFieldUpdateOperationsInput | string | null
    stocksId?: NullableStringFieldUpdateOperationsInput | string | null
    OffersOffer?: OffersOfferUncheckedUpdateOneWithoutOffersFullTimeNestedInput
  }

  export type OffersFullTimeCreateManyInput = {
    id?: string
    title: string
    level: string
    totalCompensationId: string
    baseSalaryId?: string | null
    bonusId?: string | null
    stocksId?: string | null
  }

  export type OffersFullTimeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
  }

  export type OffersFullTimeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    totalCompensationId?: StringFieldUpdateOperationsInput | string
    baseSalaryId?: NullableStringFieldUpdateOperationsInput | string | null
    bonusId?: NullableStringFieldUpdateOperationsInput | string | null
    stocksId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OffersAnalysisCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: OffersProfileCreateNestedOneWithoutAnalysisInput
    overallHighestOffer: OffersOfferCreateNestedOneWithoutOffersAnalysisInput
    overallAnalysis: OffersAnalysisUnitCreateNestedOneWithoutOffersAnalysisOverallInput
    companyAnalysis?: OffersAnalysisUnitCreateNestedManyWithoutOffersAnalysisCompanyInput
  }

  export type OffersAnalysisUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId: string
    offerId: string
    overallAnalysisUnitId: string
    companyAnalysis?: OffersAnalysisUnitUncheckedCreateNestedManyWithoutOffersAnalysisCompanyInput
  }

  export type OffersAnalysisUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: OffersProfileUpdateOneRequiredWithoutAnalysisNestedInput
    overallHighestOffer?: OffersOfferUpdateOneRequiredWithoutOffersAnalysisNestedInput
    overallAnalysis?: OffersAnalysisUnitUpdateOneRequiredWithoutOffersAnalysisOverallNestedInput
    companyAnalysis?: OffersAnalysisUnitUpdateManyWithoutOffersAnalysisCompanyNestedInput
  }

  export type OffersAnalysisUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: StringFieldUpdateOperationsInput | string
    offerId?: StringFieldUpdateOperationsInput | string
    overallAnalysisUnitId?: StringFieldUpdateOperationsInput | string
    companyAnalysis?: OffersAnalysisUnitUncheckedUpdateManyWithoutOffersAnalysisCompanyNestedInput
  }

  export type OffersAnalysisCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId: string
    offerId: string
    overallAnalysisUnitId: string
  }

  export type OffersAnalysisUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OffersAnalysisUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: StringFieldUpdateOperationsInput | string
    offerId?: StringFieldUpdateOperationsInput | string
    overallAnalysisUnitId?: StringFieldUpdateOperationsInput | string
  }

  export type OffersAnalysisUnitCreateInput = {
    id?: string
    analysedOffer: OffersOfferCreateNestedOneWithoutOffersAnalysisUnitInput
    percentile: number
    noOfSimilarOffers: number
    topSimilarOffers?: OffersOfferCreateNestedManyWithoutOffersAnalysisUnitInput
    offersAnalysisOverall?: OffersAnalysisCreateNestedManyWithoutOverallAnalysisInput
    offersAnalysisCompany?: OffersAnalysisCreateNestedManyWithoutCompanyAnalysisInput
  }

  export type OffersAnalysisUnitUncheckedCreateInput = {
    id?: string
    analysedOfferId: string
    percentile: number
    noOfSimilarOffers: number
    topSimilarOffers?: OffersOfferUncheckedCreateNestedManyWithoutOffersAnalysisUnitInput
    offersAnalysisOverall?: OffersAnalysisUncheckedCreateNestedManyWithoutOverallAnalysisInput
    offersAnalysisCompany?: OffersAnalysisUncheckedCreateNestedManyWithoutCompanyAnalysisInput
  }

  export type OffersAnalysisUnitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    analysedOffer?: OffersOfferUpdateOneRequiredWithoutOffersAnalysisUnitNestedInput
    percentile?: FloatFieldUpdateOperationsInput | number
    noOfSimilarOffers?: IntFieldUpdateOperationsInput | number
    topSimilarOffers?: OffersOfferUpdateManyWithoutOffersAnalysisUnitNestedInput
    offersAnalysisOverall?: OffersAnalysisUpdateManyWithoutOverallAnalysisNestedInput
    offersAnalysisCompany?: OffersAnalysisUpdateManyWithoutCompanyAnalysisNestedInput
  }

  export type OffersAnalysisUnitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    analysedOfferId?: StringFieldUpdateOperationsInput | string
    percentile?: FloatFieldUpdateOperationsInput | number
    noOfSimilarOffers?: IntFieldUpdateOperationsInput | number
    topSimilarOffers?: OffersOfferUncheckedUpdateManyWithoutOffersAnalysisUnitNestedInput
    offersAnalysisOverall?: OffersAnalysisUncheckedUpdateManyWithoutOverallAnalysisNestedInput
    offersAnalysisCompany?: OffersAnalysisUncheckedUpdateManyWithoutCompanyAnalysisNestedInput
  }

  export type OffersAnalysisUnitCreateManyInput = {
    id?: string
    analysedOfferId: string
    percentile: number
    noOfSimilarOffers: number
  }

  export type OffersAnalysisUnitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    percentile?: FloatFieldUpdateOperationsInput | number
    noOfSimilarOffers?: IntFieldUpdateOperationsInput | number
  }

  export type OffersAnalysisUnitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    analysedOfferId?: StringFieldUpdateOperationsInput | string
    percentile?: FloatFieldUpdateOperationsInput | number
    noOfSimilarOffers?: IntFieldUpdateOperationsInput | number
  }

  export type QuestionsQuestionCreateInput = {
    id?: string
    content: string
    questionType: QuestionsQuestionType
    lastSeenAt?: Date | string | null
    upvotes?: number
    numEncounters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutQuestionsQuestionsInput
    encounters?: QuestionsQuestionEncounterCreateNestedManyWithoutQuestionInput
    votes?: QuestionsQuestionVoteCreateNestedManyWithoutQuestionInput
    comments?: QuestionsQuestionCommentCreateNestedManyWithoutQuestionInput
    answers?: QuestionsAnswerCreateNestedManyWithoutQuestionInput
    questionsListQuestionEntries?: QuestionsListQuestionEntryCreateNestedManyWithoutQuestionInput
  }

  export type QuestionsQuestionUncheckedCreateInput = {
    id?: string
    userId?: string | null
    content: string
    questionType: QuestionsQuestionType
    lastSeenAt?: Date | string | null
    upvotes?: number
    numEncounters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    encounters?: QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutQuestionInput
    votes?: QuestionsQuestionVoteUncheckedCreateNestedManyWithoutQuestionInput
    comments?: QuestionsQuestionCommentUncheckedCreateNestedManyWithoutQuestionInput
    answers?: QuestionsAnswerUncheckedCreateNestedManyWithoutQuestionInput
    questionsListQuestionEntries?: QuestionsListQuestionEntryUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionsQuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionsQuestionTypeFieldUpdateOperationsInput | QuestionsQuestionType
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    numEncounters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutQuestionsQuestionsNestedInput
    encounters?: QuestionsQuestionEncounterUpdateManyWithoutQuestionNestedInput
    votes?: QuestionsQuestionVoteUpdateManyWithoutQuestionNestedInput
    comments?: QuestionsQuestionCommentUpdateManyWithoutQuestionNestedInput
    answers?: QuestionsAnswerUpdateManyWithoutQuestionNestedInput
    questionsListQuestionEntries?: QuestionsListQuestionEntryUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionsQuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionsQuestionTypeFieldUpdateOperationsInput | QuestionsQuestionType
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    numEncounters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounters?: QuestionsQuestionEncounterUncheckedUpdateManyWithoutQuestionNestedInput
    votes?: QuestionsQuestionVoteUncheckedUpdateManyWithoutQuestionNestedInput
    comments?: QuestionsQuestionCommentUncheckedUpdateManyWithoutQuestionNestedInput
    answers?: QuestionsAnswerUncheckedUpdateManyWithoutQuestionNestedInput
    questionsListQuestionEntries?: QuestionsListQuestionEntryUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionsQuestionCreateManyInput = {
    id?: string
    userId?: string | null
    content: string
    questionType: QuestionsQuestionType
    lastSeenAt?: Date | string | null
    upvotes?: number
    numEncounters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsQuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionsQuestionTypeFieldUpdateOperationsInput | QuestionsQuestionType
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    numEncounters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsQuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionsQuestionTypeFieldUpdateOperationsInput | QuestionsQuestionType
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    numEncounters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsQuestionEncounterCreateInput = {
    id?: string
    role: string
    seenAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    country?: CountryCreateNestedOneWithoutQuestionsQuestionEncountersInput
    state?: StateCreateNestedOneWithoutQuestionsQuestionEncountersInput
    city?: CityCreateNestedOneWithoutQuestionsQuestionEncountersInput
    company?: CompanyCreateNestedOneWithoutQuestionsQuestionEncounterInput
    user?: UserCreateNestedOneWithoutQuestionsQuestionEncountersInput
    question: QuestionsQuestionCreateNestedOneWithoutEncountersInput
  }

  export type QuestionsQuestionEncounterUncheckedCreateInput = {
    id?: string
    questionId: string
    userId?: string | null
    companyId?: string | null
    countryId?: string | null
    stateId?: string | null
    cityId?: string | null
    role: string
    seenAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsQuestionEncounterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    seenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: CountryUpdateOneWithoutQuestionsQuestionEncountersNestedInput
    state?: StateUpdateOneWithoutQuestionsQuestionEncountersNestedInput
    city?: CityUpdateOneWithoutQuestionsQuestionEncountersNestedInput
    company?: CompanyUpdateOneWithoutQuestionsQuestionEncounterNestedInput
    user?: UserUpdateOneWithoutQuestionsQuestionEncountersNestedInput
    question?: QuestionsQuestionUpdateOneRequiredWithoutEncountersNestedInput
  }

  export type QuestionsQuestionEncounterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    countryId?: NullableStringFieldUpdateOperationsInput | string | null
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    seenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsQuestionEncounterCreateManyInput = {
    id?: string
    questionId: string
    userId?: string | null
    companyId?: string | null
    countryId?: string | null
    stateId?: string | null
    cityId?: string | null
    role: string
    seenAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsQuestionEncounterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    seenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsQuestionEncounterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    countryId?: NullableStringFieldUpdateOperationsInput | string | null
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    seenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsQuestionVoteCreateInput = {
    id?: string
    vote: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutQuestionsQuestionVotesInput
    question: QuestionsQuestionCreateNestedOneWithoutVotesInput
  }

  export type QuestionsQuestionVoteUncheckedCreateInput = {
    id?: string
    questionId: string
    userId?: string | null
    vote: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsQuestionVoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vote?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutQuestionsQuestionVotesNestedInput
    question?: QuestionsQuestionUpdateOneRequiredWithoutVotesNestedInput
  }

  export type QuestionsQuestionVoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    vote?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsQuestionVoteCreateManyInput = {
    id?: string
    questionId: string
    userId?: string | null
    vote: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsQuestionVoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    vote?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsQuestionVoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    vote?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsQuestionCommentCreateInput = {
    id?: string
    upvotes?: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutQuestionsQuestionCommentsInput
    question: QuestionsQuestionCreateNestedOneWithoutCommentsInput
    votes?: QuestionsQuestionCommentVoteCreateNestedManyWithoutCommentInput
  }

  export type QuestionsQuestionCommentUncheckedCreateInput = {
    id?: string
    questionId: string
    userId?: string | null
    upvotes?: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: QuestionsQuestionCommentVoteUncheckedCreateNestedManyWithoutCommentInput
  }

  export type QuestionsQuestionCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutQuestionsQuestionCommentsNestedInput
    question?: QuestionsQuestionUpdateOneRequiredWithoutCommentsNestedInput
    votes?: QuestionsQuestionCommentVoteUpdateManyWithoutCommentNestedInput
  }

  export type QuestionsQuestionCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: QuestionsQuestionCommentVoteUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type QuestionsQuestionCommentCreateManyInput = {
    id?: string
    questionId: string
    userId?: string | null
    upvotes?: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsQuestionCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsQuestionCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsQuestionCommentVoteCreateInput = {
    id?: string
    vote: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutQuestionsQuestionCommentVotesInput
    comment: QuestionsQuestionCommentCreateNestedOneWithoutVotesInput
  }

  export type QuestionsQuestionCommentVoteUncheckedCreateInput = {
    id?: string
    questionCommentId: string
    userId?: string | null
    vote: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsQuestionCommentVoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vote?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutQuestionsQuestionCommentVotesNestedInput
    comment?: QuestionsQuestionCommentUpdateOneRequiredWithoutVotesNestedInput
  }

  export type QuestionsQuestionCommentVoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionCommentId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    vote?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsQuestionCommentVoteCreateManyInput = {
    id?: string
    questionCommentId: string
    userId?: string | null
    vote: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsQuestionCommentVoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    vote?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsQuestionCommentVoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionCommentId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    vote?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsAnswerCreateInput = {
    id?: string
    content: string
    upvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutQuestionsAnswersInput
    question: QuestionsQuestionCreateNestedOneWithoutAnswersInput
    votes?: QuestionsAnswerVoteCreateNestedManyWithoutAnswerInput
    comments?: QuestionsAnswerCommentCreateNestedManyWithoutAnswerInput
  }

  export type QuestionsAnswerUncheckedCreateInput = {
    id?: string
    questionId: string
    userId?: string | null
    content: string
    upvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: QuestionsAnswerVoteUncheckedCreateNestedManyWithoutAnswerInput
    comments?: QuestionsAnswerCommentUncheckedCreateNestedManyWithoutAnswerInput
  }

  export type QuestionsAnswerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutQuestionsAnswersNestedInput
    question?: QuestionsQuestionUpdateOneRequiredWithoutAnswersNestedInput
    votes?: QuestionsAnswerVoteUpdateManyWithoutAnswerNestedInput
    comments?: QuestionsAnswerCommentUpdateManyWithoutAnswerNestedInput
  }

  export type QuestionsAnswerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: QuestionsAnswerVoteUncheckedUpdateManyWithoutAnswerNestedInput
    comments?: QuestionsAnswerCommentUncheckedUpdateManyWithoutAnswerNestedInput
  }

  export type QuestionsAnswerCreateManyInput = {
    id?: string
    questionId: string
    userId?: string | null
    content: string
    upvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsAnswerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsAnswerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsAnswerVoteCreateInput = {
    id?: string
    vote: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutQuestionsAnswerVotesInput
    answer: QuestionsAnswerCreateNestedOneWithoutVotesInput
  }

  export type QuestionsAnswerVoteUncheckedCreateInput = {
    id?: string
    answerId: string
    userId?: string | null
    vote: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsAnswerVoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vote?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutQuestionsAnswerVotesNestedInput
    answer?: QuestionsAnswerUpdateOneRequiredWithoutVotesNestedInput
  }

  export type QuestionsAnswerVoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    answerId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    vote?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsAnswerVoteCreateManyInput = {
    id?: string
    answerId: string
    userId?: string | null
    vote: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsAnswerVoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    vote?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsAnswerVoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    answerId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    vote?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsAnswerCommentCreateInput = {
    id?: string
    content: string
    upvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutQuestionsAnswerCommentsInput
    answer: QuestionsAnswerCreateNestedOneWithoutCommentsInput
    votes?: QuestionsAnswerCommentVoteCreateNestedManyWithoutCommentInput
  }

  export type QuestionsAnswerCommentUncheckedCreateInput = {
    id?: string
    answerId: string
    userId?: string | null
    content: string
    upvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: QuestionsAnswerCommentVoteUncheckedCreateNestedManyWithoutCommentInput
  }

  export type QuestionsAnswerCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutQuestionsAnswerCommentsNestedInput
    answer?: QuestionsAnswerUpdateOneRequiredWithoutCommentsNestedInput
    votes?: QuestionsAnswerCommentVoteUpdateManyWithoutCommentNestedInput
  }

  export type QuestionsAnswerCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    answerId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: QuestionsAnswerCommentVoteUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type QuestionsAnswerCommentCreateManyInput = {
    id?: string
    answerId: string
    userId?: string | null
    content: string
    upvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsAnswerCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsAnswerCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    answerId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsAnswerCommentVoteCreateInput = {
    id?: string
    vote: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutQuestionsAnswerCommentVotesInput
    comment: QuestionsAnswerCommentCreateNestedOneWithoutVotesInput
  }

  export type QuestionsAnswerCommentVoteUncheckedCreateInput = {
    id?: string
    answerCommentId: string
    userId?: string | null
    vote: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsAnswerCommentVoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vote?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutQuestionsAnswerCommentVotesNestedInput
    comment?: QuestionsAnswerCommentUpdateOneRequiredWithoutVotesNestedInput
  }

  export type QuestionsAnswerCommentVoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    answerCommentId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    vote?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsAnswerCommentVoteCreateManyInput = {
    id?: string
    answerCommentId: string
    userId?: string | null
    vote: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsAnswerCommentVoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    vote?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsAnswerCommentVoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    answerCommentId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    vote?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsListCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutQuestionsListsInput
    questionEntries?: QuestionsListQuestionEntryCreateNestedManyWithoutListInput
  }

  export type QuestionsListUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    questionEntries?: QuestionsListQuestionEntryUncheckedCreateNestedManyWithoutListInput
  }

  export type QuestionsListUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutQuestionsListsNestedInput
    questionEntries?: QuestionsListQuestionEntryUpdateManyWithoutListNestedInput
  }

  export type QuestionsListUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionEntries?: QuestionsListQuestionEntryUncheckedUpdateManyWithoutListNestedInput
  }

  export type QuestionsListCreateManyInput = {
    id?: string
    userId: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsListUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsListUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsListQuestionEntryCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    list: QuestionsListCreateNestedOneWithoutQuestionEntriesInput
    question: QuestionsQuestionCreateNestedOneWithoutQuestionsListQuestionEntriesInput
  }

  export type QuestionsListQuestionEntryUncheckedCreateInput = {
    id?: string
    listId: string
    questionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsListQuestionEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    list?: QuestionsListUpdateOneRequiredWithoutQuestionEntriesNestedInput
    question?: QuestionsQuestionUpdateOneRequiredWithoutQuestionsListQuestionEntriesNestedInput
  }

  export type QuestionsListQuestionEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    listId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsListQuestionEntryCreateManyInput = {
    id?: string
    listId: string
    questionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsListQuestionEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsListQuestionEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    listId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type TodoListRelationFilter = {
    every?: TodoWhereInput
    some?: TodoWhereInput
    none?: TodoWhereInput
  }

  export type ResumesResumeListRelationFilter = {
    every?: ResumesResumeWhereInput
    some?: ResumesResumeWhereInput
    none?: ResumesResumeWhereInput
  }

  export type ResumesStarListRelationFilter = {
    every?: ResumesStarWhereInput
    some?: ResumesStarWhereInput
    none?: ResumesStarWhereInput
  }

  export type ResumesCommentListRelationFilter = {
    every?: ResumesCommentWhereInput
    some?: ResumesCommentWhereInput
    none?: ResumesCommentWhereInput
  }

  export type ResumesCommentVoteListRelationFilter = {
    every?: ResumesCommentVoteWhereInput
    some?: ResumesCommentVoteWhereInput
    none?: ResumesCommentVoteWhereInput
  }

  export type QuestionsQuestionListRelationFilter = {
    every?: QuestionsQuestionWhereInput
    some?: QuestionsQuestionWhereInput
    none?: QuestionsQuestionWhereInput
  }

  export type QuestionsQuestionEncounterListRelationFilter = {
    every?: QuestionsQuestionEncounterWhereInput
    some?: QuestionsQuestionEncounterWhereInput
    none?: QuestionsQuestionEncounterWhereInput
  }

  export type QuestionsQuestionVoteListRelationFilter = {
    every?: QuestionsQuestionVoteWhereInput
    some?: QuestionsQuestionVoteWhereInput
    none?: QuestionsQuestionVoteWhereInput
  }

  export type QuestionsQuestionCommentListRelationFilter = {
    every?: QuestionsQuestionCommentWhereInput
    some?: QuestionsQuestionCommentWhereInput
    none?: QuestionsQuestionCommentWhereInput
  }

  export type QuestionsQuestionCommentVoteListRelationFilter = {
    every?: QuestionsQuestionCommentVoteWhereInput
    some?: QuestionsQuestionCommentVoteWhereInput
    none?: QuestionsQuestionCommentVoteWhereInput
  }

  export type QuestionsAnswerListRelationFilter = {
    every?: QuestionsAnswerWhereInput
    some?: QuestionsAnswerWhereInput
    none?: QuestionsAnswerWhereInput
  }

  export type QuestionsAnswerVoteListRelationFilter = {
    every?: QuestionsAnswerVoteWhereInput
    some?: QuestionsAnswerVoteWhereInput
    none?: QuestionsAnswerVoteWhereInput
  }

  export type QuestionsAnswerCommentListRelationFilter = {
    every?: QuestionsAnswerCommentWhereInput
    some?: QuestionsAnswerCommentWhereInput
    none?: QuestionsAnswerCommentWhereInput
  }

  export type QuestionsAnswerCommentVoteListRelationFilter = {
    every?: QuestionsAnswerCommentVoteWhereInput
    some?: QuestionsAnswerCommentVoteWhereInput
    none?: QuestionsAnswerCommentVoteWhereInput
  }

  export type OffersProfileListRelationFilter = {
    every?: OffersProfileWhereInput
    some?: OffersProfileWhereInput
    none?: OffersProfileWhereInput
  }

  export type OffersReplyListRelationFilter = {
    every?: OffersReplyWhereInput
    some?: OffersReplyWhereInput
    none?: OffersReplyWhereInput
  }

  export type QuestionsListListRelationFilter = {
    every?: QuestionsListWhereInput
    some?: QuestionsListWhereInput
    none?: QuestionsListWhereInput
  }

  export type OffersAdminRelationFilter = {
    is?: OffersAdminWhereInput | null
    isNot?: OffersAdminWhereInput | null
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TodoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResumesResumeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResumesStarOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResumesCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResumesCommentVoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionsQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionsQuestionEncounterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionsQuestionVoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionsQuestionCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionsQuestionCommentVoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionsAnswerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionsAnswerVoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionsAnswerCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionsAnswerCommentVoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OffersProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OffersReplyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionsListOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type EnumTodoStatusFilter = {
    equals?: TodoStatus
    in?: Enumerable<TodoStatus>
    notIn?: Enumerable<TodoStatus>
    not?: NestedEnumTodoStatusFilter | TodoStatus
  }

  export type TodoCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TodoMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TodoMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTodoStatusWithAggregatesFilter = {
    equals?: TodoStatus
    in?: Enumerable<TodoStatus>
    notIn?: Enumerable<TodoStatus>
    not?: NestedEnumTodoStatusWithAggregatesFilter | TodoStatus
    _count?: NestedIntFilter
    _min?: NestedEnumTodoStatusFilter
    _max?: NestedEnumTodoStatusFilter
  }

  export type OffersExperienceListRelationFilter = {
    every?: OffersExperienceWhereInput
    some?: OffersExperienceWhereInput
    none?: OffersExperienceWhereInput
  }

  export type OffersOfferListRelationFilter = {
    every?: OffersOfferWhereInput
    some?: OffersOfferWhereInput
    none?: OffersOfferWhereInput
  }

  export type OffersExperienceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OffersOfferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
    website?: SortOrder
    ranking?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyAvgOrderByAggregateInput = {
    ranking?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
    website?: SortOrder
    ranking?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
    website?: SortOrder
    ranking?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanySumOrderByAggregateInput = {
    ranking?: SortOrder
  }

  export type StateListRelationFilter = {
    every?: StateWhereInput
    some?: StateWhereInput
    none?: StateWhereInput
  }

  export type StateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CountryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    ranking?: SortOrder
  }

  export type CountryAvgOrderByAggregateInput = {
    ranking?: SortOrder
  }

  export type CountryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    ranking?: SortOrder
  }

  export type CountryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    ranking?: SortOrder
  }

  export type CountrySumOrderByAggregateInput = {
    ranking?: SortOrder
  }

  export type CityListRelationFilter = {
    every?: CityWhereInput
    some?: CityWhereInput
    none?: CityWhereInput
  }

  export type CountryRelationFilter = {
    is?: CountryWhereInput | null
    isNot?: CountryWhereInput | null
  }

  export type CityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StateNameCountryIdCompoundUniqueInput = {
    name: string
    countryId: string
  }

  export type StateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    countryId?: SortOrder
  }

  export type StateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    countryId?: SortOrder
  }

  export type StateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    countryId?: SortOrder
  }

  export type StateRelationFilter = {
    is?: StateWhereInput
    isNot?: StateWhereInput
  }

  export type CityNameStateIdCompoundUniqueInput = {
    name: string
    stateId: string
  }

  export type CityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    stateId?: SortOrder
    ranking?: SortOrder
  }

  export type CityAvgOrderByAggregateInput = {
    ranking?: SortOrder
  }

  export type CityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    stateId?: SortOrder
    ranking?: SortOrder
  }

  export type CityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    stateId?: SortOrder
    ranking?: SortOrder
  }

  export type CitySumOrderByAggregateInput = {
    ranking?: SortOrder
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type ResumesResumeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    role?: SortOrder
    experience?: SortOrder
    locationId?: SortOrder
    url?: SortOrder
    additionalInfo?: SortOrder
    isResolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResumesResumeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    role?: SortOrder
    experience?: SortOrder
    locationId?: SortOrder
    url?: SortOrder
    additionalInfo?: SortOrder
    isResolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResumesResumeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    role?: SortOrder
    experience?: SortOrder
    locationId?: SortOrder
    url?: SortOrder
    additionalInfo?: SortOrder
    isResolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type ResumesResumeRelationFilter = {
    is?: ResumesResumeWhereInput
    isNot?: ResumesResumeWhereInput
  }

  export type ResumesStarUserIdResumeIdCompoundUniqueInput = {
    userId: string
    resumeId: string
  }

  export type ResumesStarCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    createdAt?: SortOrder
  }

  export type ResumesStarMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    createdAt?: SortOrder
  }

  export type ResumesStarMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumResumesSectionFilter = {
    equals?: ResumesSection
    in?: Enumerable<ResumesSection>
    notIn?: Enumerable<ResumesSection>
    not?: NestedEnumResumesSectionFilter | ResumesSection
  }

  export type ResumesCommentRelationFilter = {
    is?: ResumesCommentWhereInput
    isNot?: ResumesCommentWhereInput
  }

  export type ResumesCommentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    parentId?: SortOrder
    description?: SortOrder
    section?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResumesCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    parentId?: SortOrder
    description?: SortOrder
    section?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResumesCommentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    parentId?: SortOrder
    description?: SortOrder
    section?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumResumesSectionWithAggregatesFilter = {
    equals?: ResumesSection
    in?: Enumerable<ResumesSection>
    notIn?: Enumerable<ResumesSection>
    not?: NestedEnumResumesSectionWithAggregatesFilter | ResumesSection
    _count?: NestedIntFilter
    _min?: NestedEnumResumesSectionFilter
    _max?: NestedEnumResumesSectionFilter
  }

  export type EnumVoteFilter = {
    equals?: Vote
    in?: Enumerable<Vote>
    notIn?: Enumerable<Vote>
    not?: NestedEnumVoteFilter | Vote
  }

  export type ResumesCommentVoteUserIdCommentIdCompoundUniqueInput = {
    userId: string
    commentId: string
  }

  export type ResumesCommentVoteCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    commentId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResumesCommentVoteMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    commentId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResumesCommentVoteMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    commentId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumVoteWithAggregatesFilter = {
    equals?: Vote
    in?: Enumerable<Vote>
    notIn?: Enumerable<Vote>
    not?: NestedEnumVoteWithAggregatesFilter | Vote
    _count?: NestedIntFilter
    _min?: NestedEnumVoteFilter
    _max?: NestedEnumVoteFilter
  }

  export type OffersBackgroundRelationFilter = {
    is?: OffersBackgroundWhereInput
    isNot?: OffersBackgroundWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type OffersAnalysisRelationFilter = {
    is?: OffersAnalysisWhereInput | null
    isNot?: OffersAnalysisWhereInput | null
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OffersProfileCountOrderByAggregateInput = {
    id?: SortOrder
    profileName?: SortOrder
    createdAt?: SortOrder
    editToken?: SortOrder
  }

  export type OffersProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    profileName?: SortOrder
    createdAt?: SortOrder
    editToken?: SortOrder
  }

  export type OffersProfileMinOrderByAggregateInput = {
    id?: SortOrder
    profileName?: SortOrder
    createdAt?: SortOrder
    editToken?: SortOrder
  }

  export type OffersAdminCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type OffersAdminMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type OffersAdminMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type OffersSpecificYoeListRelationFilter = {
    every?: OffersSpecificYoeWhereInput
    some?: OffersSpecificYoeWhereInput
    none?: OffersSpecificYoeWhereInput
  }

  export type OffersEducationListRelationFilter = {
    every?: OffersEducationWhereInput
    some?: OffersEducationWhereInput
    none?: OffersEducationWhereInput
  }

  export type OffersProfileRelationFilter = {
    is?: OffersProfileWhereInput
    isNot?: OffersProfileWhereInput
  }

  export type OffersSpecificYoeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OffersEducationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OffersBackgroundCountOrderByAggregateInput = {
    id?: SortOrder
    totalYoe?: SortOrder
    offersProfileId?: SortOrder
  }

  export type OffersBackgroundAvgOrderByAggregateInput = {
    totalYoe?: SortOrder
  }

  export type OffersBackgroundMaxOrderByAggregateInput = {
    id?: SortOrder
    totalYoe?: SortOrder
    offersProfileId?: SortOrder
  }

  export type OffersBackgroundMinOrderByAggregateInput = {
    id?: SortOrder
    totalYoe?: SortOrder
    offersProfileId?: SortOrder
  }

  export type OffersBackgroundSumOrderByAggregateInput = {
    totalYoe?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type OffersSpecificYoeCountOrderByAggregateInput = {
    id?: SortOrder
    yoe?: SortOrder
    domain?: SortOrder
    backgroundId?: SortOrder
  }

  export type OffersSpecificYoeAvgOrderByAggregateInput = {
    yoe?: SortOrder
  }

  export type OffersSpecificYoeMaxOrderByAggregateInput = {
    id?: SortOrder
    yoe?: SortOrder
    domain?: SortOrder
    backgroundId?: SortOrder
  }

  export type OffersSpecificYoeMinOrderByAggregateInput = {
    id?: SortOrder
    yoe?: SortOrder
    domain?: SortOrder
    backgroundId?: SortOrder
  }

  export type OffersSpecificYoeSumOrderByAggregateInput = {
    yoe?: SortOrder
  }

  export type CompanyRelationFilter = {
    is?: CompanyWhereInput | null
    isNot?: CompanyWhereInput | null
  }

  export type EnumJobTypeNullableFilter = {
    equals?: JobType | null
    in?: Enumerable<JobType> | null
    notIn?: Enumerable<JobType> | null
    not?: NestedEnumJobTypeNullableFilter | JobType | null
  }

  export type CityRelationFilter = {
    is?: CityWhereInput | null
    isNot?: CityWhereInput | null
  }

  export type OffersCurrencyRelationFilter = {
    is?: OffersCurrencyWhereInput
    isNot?: OffersCurrencyWhereInput
  }

  export type OffersExperienceCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    jobType?: SortOrder
    title?: SortOrder
    durationInMonths?: SortOrder
    cityId?: SortOrder
    level?: SortOrder
    totalCompensationId?: SortOrder
    monthlySalaryId?: SortOrder
    backgroundId?: SortOrder
  }

  export type OffersExperienceAvgOrderByAggregateInput = {
    durationInMonths?: SortOrder
  }

  export type OffersExperienceMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    jobType?: SortOrder
    title?: SortOrder
    durationInMonths?: SortOrder
    cityId?: SortOrder
    level?: SortOrder
    totalCompensationId?: SortOrder
    monthlySalaryId?: SortOrder
    backgroundId?: SortOrder
  }

  export type OffersExperienceMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    jobType?: SortOrder
    title?: SortOrder
    durationInMonths?: SortOrder
    cityId?: SortOrder
    level?: SortOrder
    totalCompensationId?: SortOrder
    monthlySalaryId?: SortOrder
    backgroundId?: SortOrder
  }

  export type OffersExperienceSumOrderByAggregateInput = {
    durationInMonths?: SortOrder
  }

  export type EnumJobTypeNullableWithAggregatesFilter = {
    equals?: JobType | null
    in?: Enumerable<JobType> | null
    notIn?: Enumerable<JobType> | null
    not?: NestedEnumJobTypeNullableWithAggregatesFilter | JobType | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumJobTypeNullableFilter
    _max?: NestedEnumJobTypeNullableFilter
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type OffersExperienceRelationFilter = {
    is?: OffersExperienceWhereInput | null
    isNot?: OffersExperienceWhereInput | null
  }

  export type OffersFullTimeRelationFilter = {
    is?: OffersFullTimeWhereInput | null
    isNot?: OffersFullTimeWhereInput | null
  }

  export type OffersInternRelationFilter = {
    is?: OffersInternWhereInput | null
    isNot?: OffersInternWhereInput | null
  }

  export type OffersCurrencyCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    value?: SortOrder
    currency?: SortOrder
    baseValue?: SortOrder
    baseCurrency?: SortOrder
  }

  export type OffersCurrencyAvgOrderByAggregateInput = {
    value?: SortOrder
    baseValue?: SortOrder
  }

  export type OffersCurrencyMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    value?: SortOrder
    currency?: SortOrder
    baseValue?: SortOrder
    baseCurrency?: SortOrder
  }

  export type OffersCurrencyMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    value?: SortOrder
    currency?: SortOrder
    baseValue?: SortOrder
    baseCurrency?: SortOrder
  }

  export type OffersCurrencySumOrderByAggregateInput = {
    value?: SortOrder
    baseValue?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type OffersEducationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    field?: SortOrder
    school?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    backgroundId?: SortOrder
  }

  export type OffersEducationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    field?: SortOrder
    school?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    backgroundId?: SortOrder
  }

  export type OffersEducationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    field?: SortOrder
    school?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    backgroundId?: SortOrder
  }

  export type OffersReplyRelationFilter = {
    is?: OffersReplyWhereInput | null
    isNot?: OffersReplyWhereInput | null
  }

  export type OffersReplyCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    message?: SortOrder
    replyingToId?: SortOrder
    profileId?: SortOrder
    userId?: SortOrder
  }

  export type OffersReplyMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    message?: SortOrder
    replyingToId?: SortOrder
    profileId?: SortOrder
    userId?: SortOrder
  }

  export type OffersReplyMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    message?: SortOrder
    replyingToId?: SortOrder
    profileId?: SortOrder
    userId?: SortOrder
  }

  export type EnumJobTypeFilter = {
    equals?: JobType
    in?: Enumerable<JobType>
    notIn?: Enumerable<JobType>
    not?: NestedEnumJobTypeFilter | JobType
  }

  export type OffersAnalysisUnitListRelationFilter = {
    every?: OffersAnalysisUnitWhereInput
    some?: OffersAnalysisUnitWhereInput
    none?: OffersAnalysisUnitWhereInput
  }

  export type OffersAnalysisUnitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OffersOfferCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    companyId?: SortOrder
    cityId?: SortOrder
    monthYearReceived?: SortOrder
    negotiationStrategy?: SortOrder
    comments?: SortOrder
    jobType?: SortOrder
    offersInternId?: SortOrder
    offersFullTimeId?: SortOrder
  }

  export type OffersOfferMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    companyId?: SortOrder
    cityId?: SortOrder
    monthYearReceived?: SortOrder
    negotiationStrategy?: SortOrder
    comments?: SortOrder
    jobType?: SortOrder
    offersInternId?: SortOrder
    offersFullTimeId?: SortOrder
  }

  export type OffersOfferMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    companyId?: SortOrder
    cityId?: SortOrder
    monthYearReceived?: SortOrder
    negotiationStrategy?: SortOrder
    comments?: SortOrder
    jobType?: SortOrder
    offersInternId?: SortOrder
    offersFullTimeId?: SortOrder
  }

  export type EnumJobTypeWithAggregatesFilter = {
    equals?: JobType
    in?: Enumerable<JobType>
    notIn?: Enumerable<JobType>
    not?: NestedEnumJobTypeWithAggregatesFilter | JobType
    _count?: NestedIntFilter
    _min?: NestedEnumJobTypeFilter
    _max?: NestedEnumJobTypeFilter
  }

  export type OffersOfferRelationFilter = {
    is?: OffersOfferWhereInput
    isNot?: OffersOfferWhereInput
  }

  export type OffersInternCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    internshipCycle?: SortOrder
    startYear?: SortOrder
    monthlySalaryId?: SortOrder
  }

  export type OffersInternAvgOrderByAggregateInput = {
    startYear?: SortOrder
  }

  export type OffersInternMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    internshipCycle?: SortOrder
    startYear?: SortOrder
    monthlySalaryId?: SortOrder
  }

  export type OffersInternMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    internshipCycle?: SortOrder
    startYear?: SortOrder
    monthlySalaryId?: SortOrder
  }

  export type OffersInternSumOrderByAggregateInput = {
    startYear?: SortOrder
  }

  export type OffersFullTimeCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    level?: SortOrder
    totalCompensationId?: SortOrder
    baseSalaryId?: SortOrder
    bonusId?: SortOrder
    stocksId?: SortOrder
  }

  export type OffersFullTimeMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    level?: SortOrder
    totalCompensationId?: SortOrder
    baseSalaryId?: SortOrder
    bonusId?: SortOrder
    stocksId?: SortOrder
  }

  export type OffersFullTimeMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    level?: SortOrder
    totalCompensationId?: SortOrder
    baseSalaryId?: SortOrder
    bonusId?: SortOrder
    stocksId?: SortOrder
  }

  export type OffersAnalysisUnitRelationFilter = {
    is?: OffersAnalysisUnitWhereInput
    isNot?: OffersAnalysisUnitWhereInput
  }

  export type OffersAnalysisCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrder
    offerId?: SortOrder
    overallAnalysisUnitId?: SortOrder
  }

  export type OffersAnalysisMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrder
    offerId?: SortOrder
    overallAnalysisUnitId?: SortOrder
  }

  export type OffersAnalysisMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrder
    offerId?: SortOrder
    overallAnalysisUnitId?: SortOrder
  }

  export type OffersAnalysisListRelationFilter = {
    every?: OffersAnalysisWhereInput
    some?: OffersAnalysisWhereInput
    none?: OffersAnalysisWhereInput
  }

  export type OffersAnalysisOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OffersAnalysisUnitCountOrderByAggregateInput = {
    id?: SortOrder
    analysedOfferId?: SortOrder
    percentile?: SortOrder
    noOfSimilarOffers?: SortOrder
  }

  export type OffersAnalysisUnitAvgOrderByAggregateInput = {
    percentile?: SortOrder
    noOfSimilarOffers?: SortOrder
  }

  export type OffersAnalysisUnitMaxOrderByAggregateInput = {
    id?: SortOrder
    analysedOfferId?: SortOrder
    percentile?: SortOrder
    noOfSimilarOffers?: SortOrder
  }

  export type OffersAnalysisUnitMinOrderByAggregateInput = {
    id?: SortOrder
    analysedOfferId?: SortOrder
    percentile?: SortOrder
    noOfSimilarOffers?: SortOrder
  }

  export type OffersAnalysisUnitSumOrderByAggregateInput = {
    percentile?: SortOrder
    noOfSimilarOffers?: SortOrder
  }

  export type EnumQuestionsQuestionTypeFilter = {
    equals?: QuestionsQuestionType
    in?: Enumerable<QuestionsQuestionType>
    notIn?: Enumerable<QuestionsQuestionType>
    not?: NestedEnumQuestionsQuestionTypeFilter | QuestionsQuestionType
  }

  export type QuestionsListQuestionEntryListRelationFilter = {
    every?: QuestionsListQuestionEntryWhereInput
    some?: QuestionsListQuestionEntryWhereInput
    none?: QuestionsListQuestionEntryWhereInput
  }

  export type QuestionsListQuestionEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionsQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    questionType?: SortOrder
    lastSeenAt?: SortOrder
    upvotes?: SortOrder
    numEncounters?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionsQuestionAvgOrderByAggregateInput = {
    upvotes?: SortOrder
    numEncounters?: SortOrder
  }

  export type QuestionsQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    questionType?: SortOrder
    lastSeenAt?: SortOrder
    upvotes?: SortOrder
    numEncounters?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionsQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    questionType?: SortOrder
    lastSeenAt?: SortOrder
    upvotes?: SortOrder
    numEncounters?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionsQuestionSumOrderByAggregateInput = {
    upvotes?: SortOrder
    numEncounters?: SortOrder
  }

  export type EnumQuestionsQuestionTypeWithAggregatesFilter = {
    equals?: QuestionsQuestionType
    in?: Enumerable<QuestionsQuestionType>
    notIn?: Enumerable<QuestionsQuestionType>
    not?: NestedEnumQuestionsQuestionTypeWithAggregatesFilter | QuestionsQuestionType
    _count?: NestedIntFilter
    _min?: NestedEnumQuestionsQuestionTypeFilter
    _max?: NestedEnumQuestionsQuestionTypeFilter
  }

  export type QuestionsQuestionRelationFilter = {
    is?: QuestionsQuestionWhereInput
    isNot?: QuestionsQuestionWhereInput
  }

  export type QuestionsQuestionEncounterCountOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    countryId?: SortOrder
    stateId?: SortOrder
    cityId?: SortOrder
    role?: SortOrder
    seenAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionsQuestionEncounterMaxOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    countryId?: SortOrder
    stateId?: SortOrder
    cityId?: SortOrder
    role?: SortOrder
    seenAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionsQuestionEncounterMinOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    countryId?: SortOrder
    stateId?: SortOrder
    cityId?: SortOrder
    role?: SortOrder
    seenAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionsQuestionVoteQuestionIdUserIdCompoundUniqueInput = {
    questionId: string
    userId: string
  }

  export type QuestionsQuestionVoteCountOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    userId?: SortOrder
    vote?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionsQuestionVoteMaxOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    userId?: SortOrder
    vote?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionsQuestionVoteMinOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    userId?: SortOrder
    vote?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionsQuestionCommentCountOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    userId?: SortOrder
    upvotes?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionsQuestionCommentAvgOrderByAggregateInput = {
    upvotes?: SortOrder
  }

  export type QuestionsQuestionCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    userId?: SortOrder
    upvotes?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionsQuestionCommentMinOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    userId?: SortOrder
    upvotes?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionsQuestionCommentSumOrderByAggregateInput = {
    upvotes?: SortOrder
  }

  export type QuestionsQuestionCommentRelationFilter = {
    is?: QuestionsQuestionCommentWhereInput
    isNot?: QuestionsQuestionCommentWhereInput
  }

  export type QuestionsQuestionCommentVoteQuestionCommentIdUserIdCompoundUniqueInput = {
    questionCommentId: string
    userId: string
  }

  export type QuestionsQuestionCommentVoteCountOrderByAggregateInput = {
    id?: SortOrder
    questionCommentId?: SortOrder
    userId?: SortOrder
    vote?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionsQuestionCommentVoteMaxOrderByAggregateInput = {
    id?: SortOrder
    questionCommentId?: SortOrder
    userId?: SortOrder
    vote?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionsQuestionCommentVoteMinOrderByAggregateInput = {
    id?: SortOrder
    questionCommentId?: SortOrder
    userId?: SortOrder
    vote?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionsAnswerCountOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    upvotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionsAnswerAvgOrderByAggregateInput = {
    upvotes?: SortOrder
  }

  export type QuestionsAnswerMaxOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    upvotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionsAnswerMinOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    upvotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionsAnswerSumOrderByAggregateInput = {
    upvotes?: SortOrder
  }

  export type QuestionsAnswerRelationFilter = {
    is?: QuestionsAnswerWhereInput
    isNot?: QuestionsAnswerWhereInput
  }

  export type QuestionsAnswerVoteAnswerIdUserIdCompoundUniqueInput = {
    answerId: string
    userId: string
  }

  export type QuestionsAnswerVoteCountOrderByAggregateInput = {
    id?: SortOrder
    answerId?: SortOrder
    userId?: SortOrder
    vote?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionsAnswerVoteMaxOrderByAggregateInput = {
    id?: SortOrder
    answerId?: SortOrder
    userId?: SortOrder
    vote?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionsAnswerVoteMinOrderByAggregateInput = {
    id?: SortOrder
    answerId?: SortOrder
    userId?: SortOrder
    vote?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionsAnswerCommentCountOrderByAggregateInput = {
    id?: SortOrder
    answerId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    upvotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionsAnswerCommentAvgOrderByAggregateInput = {
    upvotes?: SortOrder
  }

  export type QuestionsAnswerCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    answerId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    upvotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionsAnswerCommentMinOrderByAggregateInput = {
    id?: SortOrder
    answerId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    upvotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionsAnswerCommentSumOrderByAggregateInput = {
    upvotes?: SortOrder
  }

  export type QuestionsAnswerCommentRelationFilter = {
    is?: QuestionsAnswerCommentWhereInput
    isNot?: QuestionsAnswerCommentWhereInput
  }

  export type QuestionsAnswerCommentVoteAnswerCommentIdUserIdCompoundUniqueInput = {
    answerCommentId: string
    userId: string
  }

  export type QuestionsAnswerCommentVoteCountOrderByAggregateInput = {
    id?: SortOrder
    answerCommentId?: SortOrder
    userId?: SortOrder
    vote?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionsAnswerCommentVoteMaxOrderByAggregateInput = {
    id?: SortOrder
    answerCommentId?: SortOrder
    userId?: SortOrder
    vote?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionsAnswerCommentVoteMinOrderByAggregateInput = {
    id?: SortOrder
    answerCommentId?: SortOrder
    userId?: SortOrder
    vote?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionsListUserIdNameCompoundUniqueInput = {
    userId: string
    name: string
  }

  export type QuestionsListCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionsListMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionsListMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionsListRelationFilter = {
    is?: QuestionsListWhereInput
    isNot?: QuestionsListWhereInput
  }

  export type QuestionsListQuestionEntryListIdQuestionIdCompoundUniqueInput = {
    listId: string
    questionId: string
  }

  export type QuestionsListQuestionEntryCountOrderByAggregateInput = {
    id?: SortOrder
    listId?: SortOrder
    questionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionsListQuestionEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    listId?: SortOrder
    questionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionsListQuestionEntryMinOrderByAggregateInput = {
    id?: SortOrder
    listId?: SortOrder
    questionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: Enumerable<AccountWhereUniqueInput>
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<SessionCreateWithoutUserInput>, Enumerable<SessionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SessionCreateOrConnectWithoutUserInput>
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: Enumerable<SessionWhereUniqueInput>
  }

  export type TodoCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TodoCreateWithoutUserInput>, Enumerable<TodoUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TodoCreateOrConnectWithoutUserInput>
    createMany?: TodoCreateManyUserInputEnvelope
    connect?: Enumerable<TodoWhereUniqueInput>
  }

  export type ResumesResumeCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ResumesResumeCreateWithoutUserInput>, Enumerable<ResumesResumeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ResumesResumeCreateOrConnectWithoutUserInput>
    createMany?: ResumesResumeCreateManyUserInputEnvelope
    connect?: Enumerable<ResumesResumeWhereUniqueInput>
  }

  export type ResumesStarCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ResumesStarCreateWithoutUserInput>, Enumerable<ResumesStarUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ResumesStarCreateOrConnectWithoutUserInput>
    createMany?: ResumesStarCreateManyUserInputEnvelope
    connect?: Enumerable<ResumesStarWhereUniqueInput>
  }

  export type ResumesCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ResumesCommentCreateWithoutUserInput>, Enumerable<ResumesCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ResumesCommentCreateOrConnectWithoutUserInput>
    createMany?: ResumesCommentCreateManyUserInputEnvelope
    connect?: Enumerable<ResumesCommentWhereUniqueInput>
  }

  export type ResumesCommentVoteCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ResumesCommentVoteCreateWithoutUserInput>, Enumerable<ResumesCommentVoteUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ResumesCommentVoteCreateOrConnectWithoutUserInput>
    createMany?: ResumesCommentVoteCreateManyUserInputEnvelope
    connect?: Enumerable<ResumesCommentVoteWhereUniqueInput>
  }

  export type QuestionsQuestionCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<QuestionsQuestionCreateWithoutUserInput>, Enumerable<QuestionsQuestionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionCreateOrConnectWithoutUserInput>
    createMany?: QuestionsQuestionCreateManyUserInputEnvelope
    connect?: Enumerable<QuestionsQuestionWhereUniqueInput>
  }

  export type QuestionsQuestionEncounterCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<QuestionsQuestionEncounterCreateWithoutUserInput>, Enumerable<QuestionsQuestionEncounterUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionEncounterCreateOrConnectWithoutUserInput>
    createMany?: QuestionsQuestionEncounterCreateManyUserInputEnvelope
    connect?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
  }

  export type QuestionsQuestionVoteCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<QuestionsQuestionVoteCreateWithoutUserInput>, Enumerable<QuestionsQuestionVoteUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionVoteCreateOrConnectWithoutUserInput>
    createMany?: QuestionsQuestionVoteCreateManyUserInputEnvelope
    connect?: Enumerable<QuestionsQuestionVoteWhereUniqueInput>
  }

  export type QuestionsQuestionCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<QuestionsQuestionCommentCreateWithoutUserInput>, Enumerable<QuestionsQuestionCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionCommentCreateOrConnectWithoutUserInput>
    createMany?: QuestionsQuestionCommentCreateManyUserInputEnvelope
    connect?: Enumerable<QuestionsQuestionCommentWhereUniqueInput>
  }

  export type QuestionsQuestionCommentVoteCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<QuestionsQuestionCommentVoteCreateWithoutUserInput>, Enumerable<QuestionsQuestionCommentVoteUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionCommentVoteCreateOrConnectWithoutUserInput>
    createMany?: QuestionsQuestionCommentVoteCreateManyUserInputEnvelope
    connect?: Enumerable<QuestionsQuestionCommentVoteWhereUniqueInput>
  }

  export type QuestionsAnswerCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<QuestionsAnswerCreateWithoutUserInput>, Enumerable<QuestionsAnswerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QuestionsAnswerCreateOrConnectWithoutUserInput>
    createMany?: QuestionsAnswerCreateManyUserInputEnvelope
    connect?: Enumerable<QuestionsAnswerWhereUniqueInput>
  }

  export type QuestionsAnswerVoteCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<QuestionsAnswerVoteCreateWithoutUserInput>, Enumerable<QuestionsAnswerVoteUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QuestionsAnswerVoteCreateOrConnectWithoutUserInput>
    createMany?: QuestionsAnswerVoteCreateManyUserInputEnvelope
    connect?: Enumerable<QuestionsAnswerVoteWhereUniqueInput>
  }

  export type QuestionsAnswerCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<QuestionsAnswerCommentCreateWithoutUserInput>, Enumerable<QuestionsAnswerCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QuestionsAnswerCommentCreateOrConnectWithoutUserInput>
    createMany?: QuestionsAnswerCommentCreateManyUserInputEnvelope
    connect?: Enumerable<QuestionsAnswerCommentWhereUniqueInput>
  }

  export type QuestionsAnswerCommentVoteCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<QuestionsAnswerCommentVoteCreateWithoutUserInput>, Enumerable<QuestionsAnswerCommentVoteUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QuestionsAnswerCommentVoteCreateOrConnectWithoutUserInput>
    createMany?: QuestionsAnswerCommentVoteCreateManyUserInputEnvelope
    connect?: Enumerable<QuestionsAnswerCommentVoteWhereUniqueInput>
  }

  export type OffersProfileCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<OffersProfileCreateWithoutUsersInput>, Enumerable<OffersProfileUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<OffersProfileCreateOrConnectWithoutUsersInput>
    connect?: Enumerable<OffersProfileWhereUniqueInput>
  }

  export type OffersReplyCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<OffersReplyCreateWithoutUserInput>, Enumerable<OffersReplyUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OffersReplyCreateOrConnectWithoutUserInput>
    createMany?: OffersReplyCreateManyUserInputEnvelope
    connect?: Enumerable<OffersReplyWhereUniqueInput>
  }

  export type QuestionsListCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<QuestionsListCreateWithoutUserInput>, Enumerable<QuestionsListUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QuestionsListCreateOrConnectWithoutUserInput>
    createMany?: QuestionsListCreateManyUserInputEnvelope
    connect?: Enumerable<QuestionsListWhereUniqueInput>
  }

  export type OffersAdminCreateNestedOneWithoutUserInput = {
    create?: XOR<OffersAdminCreateWithoutUserInput, OffersAdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: OffersAdminCreateOrConnectWithoutUserInput
    connect?: OffersAdminWhereUniqueInput
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: Enumerable<AccountWhereUniqueInput>
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<SessionCreateWithoutUserInput>, Enumerable<SessionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SessionCreateOrConnectWithoutUserInput>
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: Enumerable<SessionWhereUniqueInput>
  }

  export type TodoUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TodoCreateWithoutUserInput>, Enumerable<TodoUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TodoCreateOrConnectWithoutUserInput>
    createMany?: TodoCreateManyUserInputEnvelope
    connect?: Enumerable<TodoWhereUniqueInput>
  }

  export type ResumesResumeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ResumesResumeCreateWithoutUserInput>, Enumerable<ResumesResumeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ResumesResumeCreateOrConnectWithoutUserInput>
    createMany?: ResumesResumeCreateManyUserInputEnvelope
    connect?: Enumerable<ResumesResumeWhereUniqueInput>
  }

  export type ResumesStarUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ResumesStarCreateWithoutUserInput>, Enumerable<ResumesStarUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ResumesStarCreateOrConnectWithoutUserInput>
    createMany?: ResumesStarCreateManyUserInputEnvelope
    connect?: Enumerable<ResumesStarWhereUniqueInput>
  }

  export type ResumesCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ResumesCommentCreateWithoutUserInput>, Enumerable<ResumesCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ResumesCommentCreateOrConnectWithoutUserInput>
    createMany?: ResumesCommentCreateManyUserInputEnvelope
    connect?: Enumerable<ResumesCommentWhereUniqueInput>
  }

  export type ResumesCommentVoteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ResumesCommentVoteCreateWithoutUserInput>, Enumerable<ResumesCommentVoteUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ResumesCommentVoteCreateOrConnectWithoutUserInput>
    createMany?: ResumesCommentVoteCreateManyUserInputEnvelope
    connect?: Enumerable<ResumesCommentVoteWhereUniqueInput>
  }

  export type QuestionsQuestionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<QuestionsQuestionCreateWithoutUserInput>, Enumerable<QuestionsQuestionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionCreateOrConnectWithoutUserInput>
    createMany?: QuestionsQuestionCreateManyUserInputEnvelope
    connect?: Enumerable<QuestionsQuestionWhereUniqueInput>
  }

  export type QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<QuestionsQuestionEncounterCreateWithoutUserInput>, Enumerable<QuestionsQuestionEncounterUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionEncounterCreateOrConnectWithoutUserInput>
    createMany?: QuestionsQuestionEncounterCreateManyUserInputEnvelope
    connect?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
  }

  export type QuestionsQuestionVoteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<QuestionsQuestionVoteCreateWithoutUserInput>, Enumerable<QuestionsQuestionVoteUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionVoteCreateOrConnectWithoutUserInput>
    createMany?: QuestionsQuestionVoteCreateManyUserInputEnvelope
    connect?: Enumerable<QuestionsQuestionVoteWhereUniqueInput>
  }

  export type QuestionsQuestionCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<QuestionsQuestionCommentCreateWithoutUserInput>, Enumerable<QuestionsQuestionCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionCommentCreateOrConnectWithoutUserInput>
    createMany?: QuestionsQuestionCommentCreateManyUserInputEnvelope
    connect?: Enumerable<QuestionsQuestionCommentWhereUniqueInput>
  }

  export type QuestionsQuestionCommentVoteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<QuestionsQuestionCommentVoteCreateWithoutUserInput>, Enumerable<QuestionsQuestionCommentVoteUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionCommentVoteCreateOrConnectWithoutUserInput>
    createMany?: QuestionsQuestionCommentVoteCreateManyUserInputEnvelope
    connect?: Enumerable<QuestionsQuestionCommentVoteWhereUniqueInput>
  }

  export type QuestionsAnswerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<QuestionsAnswerCreateWithoutUserInput>, Enumerable<QuestionsAnswerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QuestionsAnswerCreateOrConnectWithoutUserInput>
    createMany?: QuestionsAnswerCreateManyUserInputEnvelope
    connect?: Enumerable<QuestionsAnswerWhereUniqueInput>
  }

  export type QuestionsAnswerVoteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<QuestionsAnswerVoteCreateWithoutUserInput>, Enumerable<QuestionsAnswerVoteUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QuestionsAnswerVoteCreateOrConnectWithoutUserInput>
    createMany?: QuestionsAnswerVoteCreateManyUserInputEnvelope
    connect?: Enumerable<QuestionsAnswerVoteWhereUniqueInput>
  }

  export type QuestionsAnswerCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<QuestionsAnswerCommentCreateWithoutUserInput>, Enumerable<QuestionsAnswerCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QuestionsAnswerCommentCreateOrConnectWithoutUserInput>
    createMany?: QuestionsAnswerCommentCreateManyUserInputEnvelope
    connect?: Enumerable<QuestionsAnswerCommentWhereUniqueInput>
  }

  export type QuestionsAnswerCommentVoteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<QuestionsAnswerCommentVoteCreateWithoutUserInput>, Enumerable<QuestionsAnswerCommentVoteUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QuestionsAnswerCommentVoteCreateOrConnectWithoutUserInput>
    createMany?: QuestionsAnswerCommentVoteCreateManyUserInputEnvelope
    connect?: Enumerable<QuestionsAnswerCommentVoteWhereUniqueInput>
  }

  export type OffersProfileUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<OffersProfileCreateWithoutUsersInput>, Enumerable<OffersProfileUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<OffersProfileCreateOrConnectWithoutUsersInput>
    connect?: Enumerable<OffersProfileWhereUniqueInput>
  }

  export type OffersReplyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<OffersReplyCreateWithoutUserInput>, Enumerable<OffersReplyUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OffersReplyCreateOrConnectWithoutUserInput>
    createMany?: OffersReplyCreateManyUserInputEnvelope
    connect?: Enumerable<OffersReplyWhereUniqueInput>
  }

  export type QuestionsListUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<QuestionsListCreateWithoutUserInput>, Enumerable<QuestionsListUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QuestionsListCreateOrConnectWithoutUserInput>
    createMany?: QuestionsListCreateManyUserInputEnvelope
    connect?: Enumerable<QuestionsListWhereUniqueInput>
  }

  export type OffersAdminUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<OffersAdminCreateWithoutUserInput, OffersAdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: OffersAdminCreateOrConnectWithoutUserInput
    connect?: OffersAdminWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AccountUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    set?: Enumerable<AccountWhereUniqueInput>
    disconnect?: Enumerable<AccountWhereUniqueInput>
    delete?: Enumerable<AccountWhereUniqueInput>
    connect?: Enumerable<AccountWhereUniqueInput>
    update?: Enumerable<AccountUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AccountUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AccountScalarWhereInput>
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<SessionCreateWithoutUserInput>, Enumerable<SessionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SessionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<SessionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: SessionCreateManyUserInputEnvelope
    set?: Enumerable<SessionWhereUniqueInput>
    disconnect?: Enumerable<SessionWhereUniqueInput>
    delete?: Enumerable<SessionWhereUniqueInput>
    connect?: Enumerable<SessionWhereUniqueInput>
    update?: Enumerable<SessionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<SessionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<SessionScalarWhereInput>
  }

  export type TodoUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<TodoCreateWithoutUserInput>, Enumerable<TodoUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TodoCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TodoUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TodoCreateManyUserInputEnvelope
    set?: Enumerable<TodoWhereUniqueInput>
    disconnect?: Enumerable<TodoWhereUniqueInput>
    delete?: Enumerable<TodoWhereUniqueInput>
    connect?: Enumerable<TodoWhereUniqueInput>
    update?: Enumerable<TodoUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TodoUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TodoScalarWhereInput>
  }

  export type ResumesResumeUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ResumesResumeCreateWithoutUserInput>, Enumerable<ResumesResumeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ResumesResumeCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ResumesResumeUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ResumesResumeCreateManyUserInputEnvelope
    set?: Enumerable<ResumesResumeWhereUniqueInput>
    disconnect?: Enumerable<ResumesResumeWhereUniqueInput>
    delete?: Enumerable<ResumesResumeWhereUniqueInput>
    connect?: Enumerable<ResumesResumeWhereUniqueInput>
    update?: Enumerable<ResumesResumeUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ResumesResumeUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ResumesResumeScalarWhereInput>
  }

  export type ResumesStarUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ResumesStarCreateWithoutUserInput>, Enumerable<ResumesStarUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ResumesStarCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ResumesStarUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ResumesStarCreateManyUserInputEnvelope
    set?: Enumerable<ResumesStarWhereUniqueInput>
    disconnect?: Enumerable<ResumesStarWhereUniqueInput>
    delete?: Enumerable<ResumesStarWhereUniqueInput>
    connect?: Enumerable<ResumesStarWhereUniqueInput>
    update?: Enumerable<ResumesStarUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ResumesStarUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ResumesStarScalarWhereInput>
  }

  export type ResumesCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ResumesCommentCreateWithoutUserInput>, Enumerable<ResumesCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ResumesCommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ResumesCommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ResumesCommentCreateManyUserInputEnvelope
    set?: Enumerable<ResumesCommentWhereUniqueInput>
    disconnect?: Enumerable<ResumesCommentWhereUniqueInput>
    delete?: Enumerable<ResumesCommentWhereUniqueInput>
    connect?: Enumerable<ResumesCommentWhereUniqueInput>
    update?: Enumerable<ResumesCommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ResumesCommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ResumesCommentScalarWhereInput>
  }

  export type ResumesCommentVoteUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ResumesCommentVoteCreateWithoutUserInput>, Enumerable<ResumesCommentVoteUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ResumesCommentVoteCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ResumesCommentVoteUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ResumesCommentVoteCreateManyUserInputEnvelope
    set?: Enumerable<ResumesCommentVoteWhereUniqueInput>
    disconnect?: Enumerable<ResumesCommentVoteWhereUniqueInput>
    delete?: Enumerable<ResumesCommentVoteWhereUniqueInput>
    connect?: Enumerable<ResumesCommentVoteWhereUniqueInput>
    update?: Enumerable<ResumesCommentVoteUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ResumesCommentVoteUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ResumesCommentVoteScalarWhereInput>
  }

  export type QuestionsQuestionUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<QuestionsQuestionCreateWithoutUserInput>, Enumerable<QuestionsQuestionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<QuestionsQuestionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: QuestionsQuestionCreateManyUserInputEnvelope
    set?: Enumerable<QuestionsQuestionWhereUniqueInput>
    disconnect?: Enumerable<QuestionsQuestionWhereUniqueInput>
    delete?: Enumerable<QuestionsQuestionWhereUniqueInput>
    connect?: Enumerable<QuestionsQuestionWhereUniqueInput>
    update?: Enumerable<QuestionsQuestionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<QuestionsQuestionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<QuestionsQuestionScalarWhereInput>
  }

  export type QuestionsQuestionEncounterUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<QuestionsQuestionEncounterCreateWithoutUserInput>, Enumerable<QuestionsQuestionEncounterUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionEncounterCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<QuestionsQuestionEncounterUpsertWithWhereUniqueWithoutUserInput>
    createMany?: QuestionsQuestionEncounterCreateManyUserInputEnvelope
    set?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    disconnect?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    delete?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    connect?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    update?: Enumerable<QuestionsQuestionEncounterUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<QuestionsQuestionEncounterUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<QuestionsQuestionEncounterScalarWhereInput>
  }

  export type QuestionsQuestionVoteUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<QuestionsQuestionVoteCreateWithoutUserInput>, Enumerable<QuestionsQuestionVoteUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionVoteCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<QuestionsQuestionVoteUpsertWithWhereUniqueWithoutUserInput>
    createMany?: QuestionsQuestionVoteCreateManyUserInputEnvelope
    set?: Enumerable<QuestionsQuestionVoteWhereUniqueInput>
    disconnect?: Enumerable<QuestionsQuestionVoteWhereUniqueInput>
    delete?: Enumerable<QuestionsQuestionVoteWhereUniqueInput>
    connect?: Enumerable<QuestionsQuestionVoteWhereUniqueInput>
    update?: Enumerable<QuestionsQuestionVoteUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<QuestionsQuestionVoteUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<QuestionsQuestionVoteScalarWhereInput>
  }

  export type QuestionsQuestionCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<QuestionsQuestionCommentCreateWithoutUserInput>, Enumerable<QuestionsQuestionCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionCommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<QuestionsQuestionCommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: QuestionsQuestionCommentCreateManyUserInputEnvelope
    set?: Enumerable<QuestionsQuestionCommentWhereUniqueInput>
    disconnect?: Enumerable<QuestionsQuestionCommentWhereUniqueInput>
    delete?: Enumerable<QuestionsQuestionCommentWhereUniqueInput>
    connect?: Enumerable<QuestionsQuestionCommentWhereUniqueInput>
    update?: Enumerable<QuestionsQuestionCommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<QuestionsQuestionCommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<QuestionsQuestionCommentScalarWhereInput>
  }

  export type QuestionsQuestionCommentVoteUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<QuestionsQuestionCommentVoteCreateWithoutUserInput>, Enumerable<QuestionsQuestionCommentVoteUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionCommentVoteCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<QuestionsQuestionCommentVoteUpsertWithWhereUniqueWithoutUserInput>
    createMany?: QuestionsQuestionCommentVoteCreateManyUserInputEnvelope
    set?: Enumerable<QuestionsQuestionCommentVoteWhereUniqueInput>
    disconnect?: Enumerable<QuestionsQuestionCommentVoteWhereUniqueInput>
    delete?: Enumerable<QuestionsQuestionCommentVoteWhereUniqueInput>
    connect?: Enumerable<QuestionsQuestionCommentVoteWhereUniqueInput>
    update?: Enumerable<QuestionsQuestionCommentVoteUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<QuestionsQuestionCommentVoteUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<QuestionsQuestionCommentVoteScalarWhereInput>
  }

  export type QuestionsAnswerUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<QuestionsAnswerCreateWithoutUserInput>, Enumerable<QuestionsAnswerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QuestionsAnswerCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<QuestionsAnswerUpsertWithWhereUniqueWithoutUserInput>
    createMany?: QuestionsAnswerCreateManyUserInputEnvelope
    set?: Enumerable<QuestionsAnswerWhereUniqueInput>
    disconnect?: Enumerable<QuestionsAnswerWhereUniqueInput>
    delete?: Enumerable<QuestionsAnswerWhereUniqueInput>
    connect?: Enumerable<QuestionsAnswerWhereUniqueInput>
    update?: Enumerable<QuestionsAnswerUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<QuestionsAnswerUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<QuestionsAnswerScalarWhereInput>
  }

  export type QuestionsAnswerVoteUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<QuestionsAnswerVoteCreateWithoutUserInput>, Enumerable<QuestionsAnswerVoteUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QuestionsAnswerVoteCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<QuestionsAnswerVoteUpsertWithWhereUniqueWithoutUserInput>
    createMany?: QuestionsAnswerVoteCreateManyUserInputEnvelope
    set?: Enumerable<QuestionsAnswerVoteWhereUniqueInput>
    disconnect?: Enumerable<QuestionsAnswerVoteWhereUniqueInput>
    delete?: Enumerable<QuestionsAnswerVoteWhereUniqueInput>
    connect?: Enumerable<QuestionsAnswerVoteWhereUniqueInput>
    update?: Enumerable<QuestionsAnswerVoteUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<QuestionsAnswerVoteUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<QuestionsAnswerVoteScalarWhereInput>
  }

  export type QuestionsAnswerCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<QuestionsAnswerCommentCreateWithoutUserInput>, Enumerable<QuestionsAnswerCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QuestionsAnswerCommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<QuestionsAnswerCommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: QuestionsAnswerCommentCreateManyUserInputEnvelope
    set?: Enumerable<QuestionsAnswerCommentWhereUniqueInput>
    disconnect?: Enumerable<QuestionsAnswerCommentWhereUniqueInput>
    delete?: Enumerable<QuestionsAnswerCommentWhereUniqueInput>
    connect?: Enumerable<QuestionsAnswerCommentWhereUniqueInput>
    update?: Enumerable<QuestionsAnswerCommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<QuestionsAnswerCommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<QuestionsAnswerCommentScalarWhereInput>
  }

  export type QuestionsAnswerCommentVoteUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<QuestionsAnswerCommentVoteCreateWithoutUserInput>, Enumerable<QuestionsAnswerCommentVoteUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QuestionsAnswerCommentVoteCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<QuestionsAnswerCommentVoteUpsertWithWhereUniqueWithoutUserInput>
    createMany?: QuestionsAnswerCommentVoteCreateManyUserInputEnvelope
    set?: Enumerable<QuestionsAnswerCommentVoteWhereUniqueInput>
    disconnect?: Enumerable<QuestionsAnswerCommentVoteWhereUniqueInput>
    delete?: Enumerable<QuestionsAnswerCommentVoteWhereUniqueInput>
    connect?: Enumerable<QuestionsAnswerCommentVoteWhereUniqueInput>
    update?: Enumerable<QuestionsAnswerCommentVoteUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<QuestionsAnswerCommentVoteUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<QuestionsAnswerCommentVoteScalarWhereInput>
  }

  export type OffersProfileUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<OffersProfileCreateWithoutUsersInput>, Enumerable<OffersProfileUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<OffersProfileCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<OffersProfileUpsertWithWhereUniqueWithoutUsersInput>
    set?: Enumerable<OffersProfileWhereUniqueInput>
    disconnect?: Enumerable<OffersProfileWhereUniqueInput>
    delete?: Enumerable<OffersProfileWhereUniqueInput>
    connect?: Enumerable<OffersProfileWhereUniqueInput>
    update?: Enumerable<OffersProfileUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<OffersProfileUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<OffersProfileScalarWhereInput>
  }

  export type OffersReplyUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<OffersReplyCreateWithoutUserInput>, Enumerable<OffersReplyUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OffersReplyCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<OffersReplyUpsertWithWhereUniqueWithoutUserInput>
    createMany?: OffersReplyCreateManyUserInputEnvelope
    set?: Enumerable<OffersReplyWhereUniqueInput>
    disconnect?: Enumerable<OffersReplyWhereUniqueInput>
    delete?: Enumerable<OffersReplyWhereUniqueInput>
    connect?: Enumerable<OffersReplyWhereUniqueInput>
    update?: Enumerable<OffersReplyUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<OffersReplyUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<OffersReplyScalarWhereInput>
  }

  export type QuestionsListUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<QuestionsListCreateWithoutUserInput>, Enumerable<QuestionsListUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QuestionsListCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<QuestionsListUpsertWithWhereUniqueWithoutUserInput>
    createMany?: QuestionsListCreateManyUserInputEnvelope
    set?: Enumerable<QuestionsListWhereUniqueInput>
    disconnect?: Enumerable<QuestionsListWhereUniqueInput>
    delete?: Enumerable<QuestionsListWhereUniqueInput>
    connect?: Enumerable<QuestionsListWhereUniqueInput>
    update?: Enumerable<QuestionsListUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<QuestionsListUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<QuestionsListScalarWhereInput>
  }

  export type OffersAdminUpdateOneWithoutUserNestedInput = {
    create?: XOR<OffersAdminCreateWithoutUserInput, OffersAdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: OffersAdminCreateOrConnectWithoutUserInput
    upsert?: OffersAdminUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: OffersAdminWhereUniqueInput
    update?: XOR<OffersAdminUpdateWithoutUserInput, OffersAdminUncheckedUpdateWithoutUserInput>
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AccountUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    set?: Enumerable<AccountWhereUniqueInput>
    disconnect?: Enumerable<AccountWhereUniqueInput>
    delete?: Enumerable<AccountWhereUniqueInput>
    connect?: Enumerable<AccountWhereUniqueInput>
    update?: Enumerable<AccountUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AccountUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AccountScalarWhereInput>
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<SessionCreateWithoutUserInput>, Enumerable<SessionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SessionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<SessionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: SessionCreateManyUserInputEnvelope
    set?: Enumerable<SessionWhereUniqueInput>
    disconnect?: Enumerable<SessionWhereUniqueInput>
    delete?: Enumerable<SessionWhereUniqueInput>
    connect?: Enumerable<SessionWhereUniqueInput>
    update?: Enumerable<SessionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<SessionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<SessionScalarWhereInput>
  }

  export type TodoUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<TodoCreateWithoutUserInput>, Enumerable<TodoUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TodoCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TodoUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TodoCreateManyUserInputEnvelope
    set?: Enumerable<TodoWhereUniqueInput>
    disconnect?: Enumerable<TodoWhereUniqueInput>
    delete?: Enumerable<TodoWhereUniqueInput>
    connect?: Enumerable<TodoWhereUniqueInput>
    update?: Enumerable<TodoUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TodoUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TodoScalarWhereInput>
  }

  export type ResumesResumeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ResumesResumeCreateWithoutUserInput>, Enumerable<ResumesResumeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ResumesResumeCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ResumesResumeUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ResumesResumeCreateManyUserInputEnvelope
    set?: Enumerable<ResumesResumeWhereUniqueInput>
    disconnect?: Enumerable<ResumesResumeWhereUniqueInput>
    delete?: Enumerable<ResumesResumeWhereUniqueInput>
    connect?: Enumerable<ResumesResumeWhereUniqueInput>
    update?: Enumerable<ResumesResumeUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ResumesResumeUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ResumesResumeScalarWhereInput>
  }

  export type ResumesStarUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ResumesStarCreateWithoutUserInput>, Enumerable<ResumesStarUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ResumesStarCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ResumesStarUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ResumesStarCreateManyUserInputEnvelope
    set?: Enumerable<ResumesStarWhereUniqueInput>
    disconnect?: Enumerable<ResumesStarWhereUniqueInput>
    delete?: Enumerable<ResumesStarWhereUniqueInput>
    connect?: Enumerable<ResumesStarWhereUniqueInput>
    update?: Enumerable<ResumesStarUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ResumesStarUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ResumesStarScalarWhereInput>
  }

  export type ResumesCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ResumesCommentCreateWithoutUserInput>, Enumerable<ResumesCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ResumesCommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ResumesCommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ResumesCommentCreateManyUserInputEnvelope
    set?: Enumerable<ResumesCommentWhereUniqueInput>
    disconnect?: Enumerable<ResumesCommentWhereUniqueInput>
    delete?: Enumerable<ResumesCommentWhereUniqueInput>
    connect?: Enumerable<ResumesCommentWhereUniqueInput>
    update?: Enumerable<ResumesCommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ResumesCommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ResumesCommentScalarWhereInput>
  }

  export type ResumesCommentVoteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ResumesCommentVoteCreateWithoutUserInput>, Enumerable<ResumesCommentVoteUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ResumesCommentVoteCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ResumesCommentVoteUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ResumesCommentVoteCreateManyUserInputEnvelope
    set?: Enumerable<ResumesCommentVoteWhereUniqueInput>
    disconnect?: Enumerable<ResumesCommentVoteWhereUniqueInput>
    delete?: Enumerable<ResumesCommentVoteWhereUniqueInput>
    connect?: Enumerable<ResumesCommentVoteWhereUniqueInput>
    update?: Enumerable<ResumesCommentVoteUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ResumesCommentVoteUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ResumesCommentVoteScalarWhereInput>
  }

  export type QuestionsQuestionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<QuestionsQuestionCreateWithoutUserInput>, Enumerable<QuestionsQuestionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<QuestionsQuestionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: QuestionsQuestionCreateManyUserInputEnvelope
    set?: Enumerable<QuestionsQuestionWhereUniqueInput>
    disconnect?: Enumerable<QuestionsQuestionWhereUniqueInput>
    delete?: Enumerable<QuestionsQuestionWhereUniqueInput>
    connect?: Enumerable<QuestionsQuestionWhereUniqueInput>
    update?: Enumerable<QuestionsQuestionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<QuestionsQuestionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<QuestionsQuestionScalarWhereInput>
  }

  export type QuestionsQuestionEncounterUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<QuestionsQuestionEncounterCreateWithoutUserInput>, Enumerable<QuestionsQuestionEncounterUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionEncounterCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<QuestionsQuestionEncounterUpsertWithWhereUniqueWithoutUserInput>
    createMany?: QuestionsQuestionEncounterCreateManyUserInputEnvelope
    set?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    disconnect?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    delete?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    connect?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    update?: Enumerable<QuestionsQuestionEncounterUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<QuestionsQuestionEncounterUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<QuestionsQuestionEncounterScalarWhereInput>
  }

  export type QuestionsQuestionVoteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<QuestionsQuestionVoteCreateWithoutUserInput>, Enumerable<QuestionsQuestionVoteUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionVoteCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<QuestionsQuestionVoteUpsertWithWhereUniqueWithoutUserInput>
    createMany?: QuestionsQuestionVoteCreateManyUserInputEnvelope
    set?: Enumerable<QuestionsQuestionVoteWhereUniqueInput>
    disconnect?: Enumerable<QuestionsQuestionVoteWhereUniqueInput>
    delete?: Enumerable<QuestionsQuestionVoteWhereUniqueInput>
    connect?: Enumerable<QuestionsQuestionVoteWhereUniqueInput>
    update?: Enumerable<QuestionsQuestionVoteUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<QuestionsQuestionVoteUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<QuestionsQuestionVoteScalarWhereInput>
  }

  export type QuestionsQuestionCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<QuestionsQuestionCommentCreateWithoutUserInput>, Enumerable<QuestionsQuestionCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionCommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<QuestionsQuestionCommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: QuestionsQuestionCommentCreateManyUserInputEnvelope
    set?: Enumerable<QuestionsQuestionCommentWhereUniqueInput>
    disconnect?: Enumerable<QuestionsQuestionCommentWhereUniqueInput>
    delete?: Enumerable<QuestionsQuestionCommentWhereUniqueInput>
    connect?: Enumerable<QuestionsQuestionCommentWhereUniqueInput>
    update?: Enumerable<QuestionsQuestionCommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<QuestionsQuestionCommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<QuestionsQuestionCommentScalarWhereInput>
  }

  export type QuestionsQuestionCommentVoteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<QuestionsQuestionCommentVoteCreateWithoutUserInput>, Enumerable<QuestionsQuestionCommentVoteUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionCommentVoteCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<QuestionsQuestionCommentVoteUpsertWithWhereUniqueWithoutUserInput>
    createMany?: QuestionsQuestionCommentVoteCreateManyUserInputEnvelope
    set?: Enumerable<QuestionsQuestionCommentVoteWhereUniqueInput>
    disconnect?: Enumerable<QuestionsQuestionCommentVoteWhereUniqueInput>
    delete?: Enumerable<QuestionsQuestionCommentVoteWhereUniqueInput>
    connect?: Enumerable<QuestionsQuestionCommentVoteWhereUniqueInput>
    update?: Enumerable<QuestionsQuestionCommentVoteUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<QuestionsQuestionCommentVoteUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<QuestionsQuestionCommentVoteScalarWhereInput>
  }

  export type QuestionsAnswerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<QuestionsAnswerCreateWithoutUserInput>, Enumerable<QuestionsAnswerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QuestionsAnswerCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<QuestionsAnswerUpsertWithWhereUniqueWithoutUserInput>
    createMany?: QuestionsAnswerCreateManyUserInputEnvelope
    set?: Enumerable<QuestionsAnswerWhereUniqueInput>
    disconnect?: Enumerable<QuestionsAnswerWhereUniqueInput>
    delete?: Enumerable<QuestionsAnswerWhereUniqueInput>
    connect?: Enumerable<QuestionsAnswerWhereUniqueInput>
    update?: Enumerable<QuestionsAnswerUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<QuestionsAnswerUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<QuestionsAnswerScalarWhereInput>
  }

  export type QuestionsAnswerVoteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<QuestionsAnswerVoteCreateWithoutUserInput>, Enumerable<QuestionsAnswerVoteUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QuestionsAnswerVoteCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<QuestionsAnswerVoteUpsertWithWhereUniqueWithoutUserInput>
    createMany?: QuestionsAnswerVoteCreateManyUserInputEnvelope
    set?: Enumerable<QuestionsAnswerVoteWhereUniqueInput>
    disconnect?: Enumerable<QuestionsAnswerVoteWhereUniqueInput>
    delete?: Enumerable<QuestionsAnswerVoteWhereUniqueInput>
    connect?: Enumerable<QuestionsAnswerVoteWhereUniqueInput>
    update?: Enumerable<QuestionsAnswerVoteUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<QuestionsAnswerVoteUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<QuestionsAnswerVoteScalarWhereInput>
  }

  export type QuestionsAnswerCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<QuestionsAnswerCommentCreateWithoutUserInput>, Enumerable<QuestionsAnswerCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QuestionsAnswerCommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<QuestionsAnswerCommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: QuestionsAnswerCommentCreateManyUserInputEnvelope
    set?: Enumerable<QuestionsAnswerCommentWhereUniqueInput>
    disconnect?: Enumerable<QuestionsAnswerCommentWhereUniqueInput>
    delete?: Enumerable<QuestionsAnswerCommentWhereUniqueInput>
    connect?: Enumerable<QuestionsAnswerCommentWhereUniqueInput>
    update?: Enumerable<QuestionsAnswerCommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<QuestionsAnswerCommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<QuestionsAnswerCommentScalarWhereInput>
  }

  export type QuestionsAnswerCommentVoteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<QuestionsAnswerCommentVoteCreateWithoutUserInput>, Enumerable<QuestionsAnswerCommentVoteUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QuestionsAnswerCommentVoteCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<QuestionsAnswerCommentVoteUpsertWithWhereUniqueWithoutUserInput>
    createMany?: QuestionsAnswerCommentVoteCreateManyUserInputEnvelope
    set?: Enumerable<QuestionsAnswerCommentVoteWhereUniqueInput>
    disconnect?: Enumerable<QuestionsAnswerCommentVoteWhereUniqueInput>
    delete?: Enumerable<QuestionsAnswerCommentVoteWhereUniqueInput>
    connect?: Enumerable<QuestionsAnswerCommentVoteWhereUniqueInput>
    update?: Enumerable<QuestionsAnswerCommentVoteUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<QuestionsAnswerCommentVoteUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<QuestionsAnswerCommentVoteScalarWhereInput>
  }

  export type OffersProfileUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<OffersProfileCreateWithoutUsersInput>, Enumerable<OffersProfileUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<OffersProfileCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<OffersProfileUpsertWithWhereUniqueWithoutUsersInput>
    set?: Enumerable<OffersProfileWhereUniqueInput>
    disconnect?: Enumerable<OffersProfileWhereUniqueInput>
    delete?: Enumerable<OffersProfileWhereUniqueInput>
    connect?: Enumerable<OffersProfileWhereUniqueInput>
    update?: Enumerable<OffersProfileUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<OffersProfileUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<OffersProfileScalarWhereInput>
  }

  export type OffersReplyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<OffersReplyCreateWithoutUserInput>, Enumerable<OffersReplyUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OffersReplyCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<OffersReplyUpsertWithWhereUniqueWithoutUserInput>
    createMany?: OffersReplyCreateManyUserInputEnvelope
    set?: Enumerable<OffersReplyWhereUniqueInput>
    disconnect?: Enumerable<OffersReplyWhereUniqueInput>
    delete?: Enumerable<OffersReplyWhereUniqueInput>
    connect?: Enumerable<OffersReplyWhereUniqueInput>
    update?: Enumerable<OffersReplyUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<OffersReplyUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<OffersReplyScalarWhereInput>
  }

  export type QuestionsListUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<QuestionsListCreateWithoutUserInput>, Enumerable<QuestionsListUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QuestionsListCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<QuestionsListUpsertWithWhereUniqueWithoutUserInput>
    createMany?: QuestionsListCreateManyUserInputEnvelope
    set?: Enumerable<QuestionsListWhereUniqueInput>
    disconnect?: Enumerable<QuestionsListWhereUniqueInput>
    delete?: Enumerable<QuestionsListWhereUniqueInput>
    connect?: Enumerable<QuestionsListWhereUniqueInput>
    update?: Enumerable<QuestionsListUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<QuestionsListUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<QuestionsListScalarWhereInput>
  }

  export type OffersAdminUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<OffersAdminCreateWithoutUserInput, OffersAdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: OffersAdminCreateOrConnectWithoutUserInput
    upsert?: OffersAdminUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: OffersAdminWhereUniqueInput
    update?: XOR<OffersAdminUpdateWithoutUserInput, OffersAdminUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutTodosInput = {
    create?: XOR<UserCreateWithoutTodosInput, UserUncheckedCreateWithoutTodosInput>
    connectOrCreate?: UserCreateOrConnectWithoutTodosInput
    connect?: UserWhereUniqueInput
  }

  export type EnumTodoStatusFieldUpdateOperationsInput = {
    set?: TodoStatus
  }

  export type UserUpdateOneRequiredWithoutTodosNestedInput = {
    create?: XOR<UserCreateWithoutTodosInput, UserUncheckedCreateWithoutTodosInput>
    connectOrCreate?: UserCreateOrConnectWithoutTodosInput
    upsert?: UserUpsertWithoutTodosInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutTodosInput, UserUncheckedUpdateWithoutTodosInput>
  }

  export type QuestionsQuestionEncounterCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<QuestionsQuestionEncounterCreateWithoutCompanyInput>, Enumerable<QuestionsQuestionEncounterUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionEncounterCreateOrConnectWithoutCompanyInput>
    createMany?: QuestionsQuestionEncounterCreateManyCompanyInputEnvelope
    connect?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
  }

  export type OffersExperienceCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<OffersExperienceCreateWithoutCompanyInput>, Enumerable<OffersExperienceUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<OffersExperienceCreateOrConnectWithoutCompanyInput>
    createMany?: OffersExperienceCreateManyCompanyInputEnvelope
    connect?: Enumerable<OffersExperienceWhereUniqueInput>
  }

  export type OffersOfferCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<OffersOfferCreateWithoutCompanyInput>, Enumerable<OffersOfferUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<OffersOfferCreateOrConnectWithoutCompanyInput>
    createMany?: OffersOfferCreateManyCompanyInputEnvelope
    connect?: Enumerable<OffersOfferWhereUniqueInput>
  }

  export type QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<QuestionsQuestionEncounterCreateWithoutCompanyInput>, Enumerable<QuestionsQuestionEncounterUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionEncounterCreateOrConnectWithoutCompanyInput>
    createMany?: QuestionsQuestionEncounterCreateManyCompanyInputEnvelope
    connect?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
  }

  export type OffersExperienceUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<OffersExperienceCreateWithoutCompanyInput>, Enumerable<OffersExperienceUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<OffersExperienceCreateOrConnectWithoutCompanyInput>
    createMany?: OffersExperienceCreateManyCompanyInputEnvelope
    connect?: Enumerable<OffersExperienceWhereUniqueInput>
  }

  export type OffersOfferUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<OffersOfferCreateWithoutCompanyInput>, Enumerable<OffersOfferUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<OffersOfferCreateOrConnectWithoutCompanyInput>
    createMany?: OffersOfferCreateManyCompanyInputEnvelope
    connect?: Enumerable<OffersOfferWhereUniqueInput>
  }

  export type QuestionsQuestionEncounterUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<Enumerable<QuestionsQuestionEncounterCreateWithoutCompanyInput>, Enumerable<QuestionsQuestionEncounterUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionEncounterCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<QuestionsQuestionEncounterUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: QuestionsQuestionEncounterCreateManyCompanyInputEnvelope
    set?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    disconnect?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    delete?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    connect?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    update?: Enumerable<QuestionsQuestionEncounterUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<QuestionsQuestionEncounterUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<QuestionsQuestionEncounterScalarWhereInput>
  }

  export type OffersExperienceUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<Enumerable<OffersExperienceCreateWithoutCompanyInput>, Enumerable<OffersExperienceUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<OffersExperienceCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<OffersExperienceUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: OffersExperienceCreateManyCompanyInputEnvelope
    set?: Enumerable<OffersExperienceWhereUniqueInput>
    disconnect?: Enumerable<OffersExperienceWhereUniqueInput>
    delete?: Enumerable<OffersExperienceWhereUniqueInput>
    connect?: Enumerable<OffersExperienceWhereUniqueInput>
    update?: Enumerable<OffersExperienceUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<OffersExperienceUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<OffersExperienceScalarWhereInput>
  }

  export type OffersOfferUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<Enumerable<OffersOfferCreateWithoutCompanyInput>, Enumerable<OffersOfferUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<OffersOfferCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<OffersOfferUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: OffersOfferCreateManyCompanyInputEnvelope
    set?: Enumerable<OffersOfferWhereUniqueInput>
    disconnect?: Enumerable<OffersOfferWhereUniqueInput>
    delete?: Enumerable<OffersOfferWhereUniqueInput>
    connect?: Enumerable<OffersOfferWhereUniqueInput>
    update?: Enumerable<OffersOfferUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<OffersOfferUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<OffersOfferScalarWhereInput>
  }

  export type QuestionsQuestionEncounterUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<Enumerable<QuestionsQuestionEncounterCreateWithoutCompanyInput>, Enumerable<QuestionsQuestionEncounterUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionEncounterCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<QuestionsQuestionEncounterUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: QuestionsQuestionEncounterCreateManyCompanyInputEnvelope
    set?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    disconnect?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    delete?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    connect?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    update?: Enumerable<QuestionsQuestionEncounterUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<QuestionsQuestionEncounterUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<QuestionsQuestionEncounterScalarWhereInput>
  }

  export type OffersExperienceUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<Enumerable<OffersExperienceCreateWithoutCompanyInput>, Enumerable<OffersExperienceUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<OffersExperienceCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<OffersExperienceUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: OffersExperienceCreateManyCompanyInputEnvelope
    set?: Enumerable<OffersExperienceWhereUniqueInput>
    disconnect?: Enumerable<OffersExperienceWhereUniqueInput>
    delete?: Enumerable<OffersExperienceWhereUniqueInput>
    connect?: Enumerable<OffersExperienceWhereUniqueInput>
    update?: Enumerable<OffersExperienceUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<OffersExperienceUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<OffersExperienceScalarWhereInput>
  }

  export type OffersOfferUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<Enumerable<OffersOfferCreateWithoutCompanyInput>, Enumerable<OffersOfferUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<OffersOfferCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<OffersOfferUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: OffersOfferCreateManyCompanyInputEnvelope
    set?: Enumerable<OffersOfferWhereUniqueInput>
    disconnect?: Enumerable<OffersOfferWhereUniqueInput>
    delete?: Enumerable<OffersOfferWhereUniqueInput>
    connect?: Enumerable<OffersOfferWhereUniqueInput>
    update?: Enumerable<OffersOfferUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<OffersOfferUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<OffersOfferScalarWhereInput>
  }

  export type StateCreateNestedManyWithoutCountryInput = {
    create?: XOR<Enumerable<StateCreateWithoutCountryInput>, Enumerable<StateUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<StateCreateOrConnectWithoutCountryInput>
    createMany?: StateCreateManyCountryInputEnvelope
    connect?: Enumerable<StateWhereUniqueInput>
  }

  export type QuestionsQuestionEncounterCreateNestedManyWithoutCountryInput = {
    create?: XOR<Enumerable<QuestionsQuestionEncounterCreateWithoutCountryInput>, Enumerable<QuestionsQuestionEncounterUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionEncounterCreateOrConnectWithoutCountryInput>
    createMany?: QuestionsQuestionEncounterCreateManyCountryInputEnvelope
    connect?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
  }

  export type ResumesResumeCreateNestedManyWithoutLocationInput = {
    create?: XOR<Enumerable<ResumesResumeCreateWithoutLocationInput>, Enumerable<ResumesResumeUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<ResumesResumeCreateOrConnectWithoutLocationInput>
    createMany?: ResumesResumeCreateManyLocationInputEnvelope
    connect?: Enumerable<ResumesResumeWhereUniqueInput>
  }

  export type StateUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<Enumerable<StateCreateWithoutCountryInput>, Enumerable<StateUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<StateCreateOrConnectWithoutCountryInput>
    createMany?: StateCreateManyCountryInputEnvelope
    connect?: Enumerable<StateWhereUniqueInput>
  }

  export type QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<Enumerable<QuestionsQuestionEncounterCreateWithoutCountryInput>, Enumerable<QuestionsQuestionEncounterUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionEncounterCreateOrConnectWithoutCountryInput>
    createMany?: QuestionsQuestionEncounterCreateManyCountryInputEnvelope
    connect?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
  }

  export type ResumesResumeUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<Enumerable<ResumesResumeCreateWithoutLocationInput>, Enumerable<ResumesResumeUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<ResumesResumeCreateOrConnectWithoutLocationInput>
    createMany?: ResumesResumeCreateManyLocationInputEnvelope
    connect?: Enumerable<ResumesResumeWhereUniqueInput>
  }

  export type StateUpdateManyWithoutCountryNestedInput = {
    create?: XOR<Enumerable<StateCreateWithoutCountryInput>, Enumerable<StateUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<StateCreateOrConnectWithoutCountryInput>
    upsert?: Enumerable<StateUpsertWithWhereUniqueWithoutCountryInput>
    createMany?: StateCreateManyCountryInputEnvelope
    set?: Enumerable<StateWhereUniqueInput>
    disconnect?: Enumerable<StateWhereUniqueInput>
    delete?: Enumerable<StateWhereUniqueInput>
    connect?: Enumerable<StateWhereUniqueInput>
    update?: Enumerable<StateUpdateWithWhereUniqueWithoutCountryInput>
    updateMany?: Enumerable<StateUpdateManyWithWhereWithoutCountryInput>
    deleteMany?: Enumerable<StateScalarWhereInput>
  }

  export type QuestionsQuestionEncounterUpdateManyWithoutCountryNestedInput = {
    create?: XOR<Enumerable<QuestionsQuestionEncounterCreateWithoutCountryInput>, Enumerable<QuestionsQuestionEncounterUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionEncounterCreateOrConnectWithoutCountryInput>
    upsert?: Enumerable<QuestionsQuestionEncounterUpsertWithWhereUniqueWithoutCountryInput>
    createMany?: QuestionsQuestionEncounterCreateManyCountryInputEnvelope
    set?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    disconnect?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    delete?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    connect?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    update?: Enumerable<QuestionsQuestionEncounterUpdateWithWhereUniqueWithoutCountryInput>
    updateMany?: Enumerable<QuestionsQuestionEncounterUpdateManyWithWhereWithoutCountryInput>
    deleteMany?: Enumerable<QuestionsQuestionEncounterScalarWhereInput>
  }

  export type ResumesResumeUpdateManyWithoutLocationNestedInput = {
    create?: XOR<Enumerable<ResumesResumeCreateWithoutLocationInput>, Enumerable<ResumesResumeUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<ResumesResumeCreateOrConnectWithoutLocationInput>
    upsert?: Enumerable<ResumesResumeUpsertWithWhereUniqueWithoutLocationInput>
    createMany?: ResumesResumeCreateManyLocationInputEnvelope
    set?: Enumerable<ResumesResumeWhereUniqueInput>
    disconnect?: Enumerable<ResumesResumeWhereUniqueInput>
    delete?: Enumerable<ResumesResumeWhereUniqueInput>
    connect?: Enumerable<ResumesResumeWhereUniqueInput>
    update?: Enumerable<ResumesResumeUpdateWithWhereUniqueWithoutLocationInput>
    updateMany?: Enumerable<ResumesResumeUpdateManyWithWhereWithoutLocationInput>
    deleteMany?: Enumerable<ResumesResumeScalarWhereInput>
  }

  export type StateUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<Enumerable<StateCreateWithoutCountryInput>, Enumerable<StateUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<StateCreateOrConnectWithoutCountryInput>
    upsert?: Enumerable<StateUpsertWithWhereUniqueWithoutCountryInput>
    createMany?: StateCreateManyCountryInputEnvelope
    set?: Enumerable<StateWhereUniqueInput>
    disconnect?: Enumerable<StateWhereUniqueInput>
    delete?: Enumerable<StateWhereUniqueInput>
    connect?: Enumerable<StateWhereUniqueInput>
    update?: Enumerable<StateUpdateWithWhereUniqueWithoutCountryInput>
    updateMany?: Enumerable<StateUpdateManyWithWhereWithoutCountryInput>
    deleteMany?: Enumerable<StateScalarWhereInput>
  }

  export type QuestionsQuestionEncounterUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<Enumerable<QuestionsQuestionEncounterCreateWithoutCountryInput>, Enumerable<QuestionsQuestionEncounterUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionEncounterCreateOrConnectWithoutCountryInput>
    upsert?: Enumerable<QuestionsQuestionEncounterUpsertWithWhereUniqueWithoutCountryInput>
    createMany?: QuestionsQuestionEncounterCreateManyCountryInputEnvelope
    set?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    disconnect?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    delete?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    connect?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    update?: Enumerable<QuestionsQuestionEncounterUpdateWithWhereUniqueWithoutCountryInput>
    updateMany?: Enumerable<QuestionsQuestionEncounterUpdateManyWithWhereWithoutCountryInput>
    deleteMany?: Enumerable<QuestionsQuestionEncounterScalarWhereInput>
  }

  export type ResumesResumeUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<Enumerable<ResumesResumeCreateWithoutLocationInput>, Enumerable<ResumesResumeUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<ResumesResumeCreateOrConnectWithoutLocationInput>
    upsert?: Enumerable<ResumesResumeUpsertWithWhereUniqueWithoutLocationInput>
    createMany?: ResumesResumeCreateManyLocationInputEnvelope
    set?: Enumerable<ResumesResumeWhereUniqueInput>
    disconnect?: Enumerable<ResumesResumeWhereUniqueInput>
    delete?: Enumerable<ResumesResumeWhereUniqueInput>
    connect?: Enumerable<ResumesResumeWhereUniqueInput>
    update?: Enumerable<ResumesResumeUpdateWithWhereUniqueWithoutLocationInput>
    updateMany?: Enumerable<ResumesResumeUpdateManyWithWhereWithoutLocationInput>
    deleteMany?: Enumerable<ResumesResumeScalarWhereInput>
  }

  export type CityCreateNestedManyWithoutStateInput = {
    create?: XOR<Enumerable<CityCreateWithoutStateInput>, Enumerable<CityUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<CityCreateOrConnectWithoutStateInput>
    createMany?: CityCreateManyStateInputEnvelope
    connect?: Enumerable<CityWhereUniqueInput>
  }

  export type CountryCreateNestedOneWithoutStatesInput = {
    create?: XOR<CountryCreateWithoutStatesInput, CountryUncheckedCreateWithoutStatesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutStatesInput
    connect?: CountryWhereUniqueInput
  }

  export type QuestionsQuestionEncounterCreateNestedManyWithoutStateInput = {
    create?: XOR<Enumerable<QuestionsQuestionEncounterCreateWithoutStateInput>, Enumerable<QuestionsQuestionEncounterUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionEncounterCreateOrConnectWithoutStateInput>
    createMany?: QuestionsQuestionEncounterCreateManyStateInputEnvelope
    connect?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
  }

  export type CityUncheckedCreateNestedManyWithoutStateInput = {
    create?: XOR<Enumerable<CityCreateWithoutStateInput>, Enumerable<CityUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<CityCreateOrConnectWithoutStateInput>
    createMany?: CityCreateManyStateInputEnvelope
    connect?: Enumerable<CityWhereUniqueInput>
  }

  export type QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutStateInput = {
    create?: XOR<Enumerable<QuestionsQuestionEncounterCreateWithoutStateInput>, Enumerable<QuestionsQuestionEncounterUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionEncounterCreateOrConnectWithoutStateInput>
    createMany?: QuestionsQuestionEncounterCreateManyStateInputEnvelope
    connect?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
  }

  export type CityUpdateManyWithoutStateNestedInput = {
    create?: XOR<Enumerable<CityCreateWithoutStateInput>, Enumerable<CityUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<CityCreateOrConnectWithoutStateInput>
    upsert?: Enumerable<CityUpsertWithWhereUniqueWithoutStateInput>
    createMany?: CityCreateManyStateInputEnvelope
    set?: Enumerable<CityWhereUniqueInput>
    disconnect?: Enumerable<CityWhereUniqueInput>
    delete?: Enumerable<CityWhereUniqueInput>
    connect?: Enumerable<CityWhereUniqueInput>
    update?: Enumerable<CityUpdateWithWhereUniqueWithoutStateInput>
    updateMany?: Enumerable<CityUpdateManyWithWhereWithoutStateInput>
    deleteMany?: Enumerable<CityScalarWhereInput>
  }

  export type CountryUpdateOneRequiredWithoutStatesNestedInput = {
    create?: XOR<CountryCreateWithoutStatesInput, CountryUncheckedCreateWithoutStatesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutStatesInput
    upsert?: CountryUpsertWithoutStatesInput
    connect?: CountryWhereUniqueInput
    update?: XOR<CountryUpdateWithoutStatesInput, CountryUncheckedUpdateWithoutStatesInput>
  }

  export type QuestionsQuestionEncounterUpdateManyWithoutStateNestedInput = {
    create?: XOR<Enumerable<QuestionsQuestionEncounterCreateWithoutStateInput>, Enumerable<QuestionsQuestionEncounterUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionEncounterCreateOrConnectWithoutStateInput>
    upsert?: Enumerable<QuestionsQuestionEncounterUpsertWithWhereUniqueWithoutStateInput>
    createMany?: QuestionsQuestionEncounterCreateManyStateInputEnvelope
    set?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    disconnect?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    delete?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    connect?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    update?: Enumerable<QuestionsQuestionEncounterUpdateWithWhereUniqueWithoutStateInput>
    updateMany?: Enumerable<QuestionsQuestionEncounterUpdateManyWithWhereWithoutStateInput>
    deleteMany?: Enumerable<QuestionsQuestionEncounterScalarWhereInput>
  }

  export type CityUncheckedUpdateManyWithoutStateNestedInput = {
    create?: XOR<Enumerable<CityCreateWithoutStateInput>, Enumerable<CityUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<CityCreateOrConnectWithoutStateInput>
    upsert?: Enumerable<CityUpsertWithWhereUniqueWithoutStateInput>
    createMany?: CityCreateManyStateInputEnvelope
    set?: Enumerable<CityWhereUniqueInput>
    disconnect?: Enumerable<CityWhereUniqueInput>
    delete?: Enumerable<CityWhereUniqueInput>
    connect?: Enumerable<CityWhereUniqueInput>
    update?: Enumerable<CityUpdateWithWhereUniqueWithoutStateInput>
    updateMany?: Enumerable<CityUpdateManyWithWhereWithoutStateInput>
    deleteMany?: Enumerable<CityScalarWhereInput>
  }

  export type QuestionsQuestionEncounterUncheckedUpdateManyWithoutStateNestedInput = {
    create?: XOR<Enumerable<QuestionsQuestionEncounterCreateWithoutStateInput>, Enumerable<QuestionsQuestionEncounterUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionEncounterCreateOrConnectWithoutStateInput>
    upsert?: Enumerable<QuestionsQuestionEncounterUpsertWithWhereUniqueWithoutStateInput>
    createMany?: QuestionsQuestionEncounterCreateManyStateInputEnvelope
    set?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    disconnect?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    delete?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    connect?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    update?: Enumerable<QuestionsQuestionEncounterUpdateWithWhereUniqueWithoutStateInput>
    updateMany?: Enumerable<QuestionsQuestionEncounterUpdateManyWithWhereWithoutStateInput>
    deleteMany?: Enumerable<QuestionsQuestionEncounterScalarWhereInput>
  }

  export type StateCreateNestedOneWithoutCitiesInput = {
    create?: XOR<StateCreateWithoutCitiesInput, StateUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: StateCreateOrConnectWithoutCitiesInput
    connect?: StateWhereUniqueInput
  }

  export type QuestionsQuestionEncounterCreateNestedManyWithoutCityInput = {
    create?: XOR<Enumerable<QuestionsQuestionEncounterCreateWithoutCityInput>, Enumerable<QuestionsQuestionEncounterUncheckedCreateWithoutCityInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionEncounterCreateOrConnectWithoutCityInput>
    createMany?: QuestionsQuestionEncounterCreateManyCityInputEnvelope
    connect?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
  }

  export type OffersExperienceCreateNestedManyWithoutLocationInput = {
    create?: XOR<Enumerable<OffersExperienceCreateWithoutLocationInput>, Enumerable<OffersExperienceUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<OffersExperienceCreateOrConnectWithoutLocationInput>
    createMany?: OffersExperienceCreateManyLocationInputEnvelope
    connect?: Enumerable<OffersExperienceWhereUniqueInput>
  }

  export type OffersOfferCreateNestedManyWithoutLocationInput = {
    create?: XOR<Enumerable<OffersOfferCreateWithoutLocationInput>, Enumerable<OffersOfferUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<OffersOfferCreateOrConnectWithoutLocationInput>
    createMany?: OffersOfferCreateManyLocationInputEnvelope
    connect?: Enumerable<OffersOfferWhereUniqueInput>
  }

  export type QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<Enumerable<QuestionsQuestionEncounterCreateWithoutCityInput>, Enumerable<QuestionsQuestionEncounterUncheckedCreateWithoutCityInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionEncounterCreateOrConnectWithoutCityInput>
    createMany?: QuestionsQuestionEncounterCreateManyCityInputEnvelope
    connect?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
  }

  export type OffersExperienceUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<Enumerable<OffersExperienceCreateWithoutLocationInput>, Enumerable<OffersExperienceUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<OffersExperienceCreateOrConnectWithoutLocationInput>
    createMany?: OffersExperienceCreateManyLocationInputEnvelope
    connect?: Enumerable<OffersExperienceWhereUniqueInput>
  }

  export type OffersOfferUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<Enumerable<OffersOfferCreateWithoutLocationInput>, Enumerable<OffersOfferUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<OffersOfferCreateOrConnectWithoutLocationInput>
    createMany?: OffersOfferCreateManyLocationInputEnvelope
    connect?: Enumerable<OffersOfferWhereUniqueInput>
  }

  export type StateUpdateOneRequiredWithoutCitiesNestedInput = {
    create?: XOR<StateCreateWithoutCitiesInput, StateUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: StateCreateOrConnectWithoutCitiesInput
    upsert?: StateUpsertWithoutCitiesInput
    connect?: StateWhereUniqueInput
    update?: XOR<StateUpdateWithoutCitiesInput, StateUncheckedUpdateWithoutCitiesInput>
  }

  export type QuestionsQuestionEncounterUpdateManyWithoutCityNestedInput = {
    create?: XOR<Enumerable<QuestionsQuestionEncounterCreateWithoutCityInput>, Enumerable<QuestionsQuestionEncounterUncheckedCreateWithoutCityInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionEncounterCreateOrConnectWithoutCityInput>
    upsert?: Enumerable<QuestionsQuestionEncounterUpsertWithWhereUniqueWithoutCityInput>
    createMany?: QuestionsQuestionEncounterCreateManyCityInputEnvelope
    set?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    disconnect?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    delete?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    connect?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    update?: Enumerable<QuestionsQuestionEncounterUpdateWithWhereUniqueWithoutCityInput>
    updateMany?: Enumerable<QuestionsQuestionEncounterUpdateManyWithWhereWithoutCityInput>
    deleteMany?: Enumerable<QuestionsQuestionEncounterScalarWhereInput>
  }

  export type OffersExperienceUpdateManyWithoutLocationNestedInput = {
    create?: XOR<Enumerable<OffersExperienceCreateWithoutLocationInput>, Enumerable<OffersExperienceUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<OffersExperienceCreateOrConnectWithoutLocationInput>
    upsert?: Enumerable<OffersExperienceUpsertWithWhereUniqueWithoutLocationInput>
    createMany?: OffersExperienceCreateManyLocationInputEnvelope
    set?: Enumerable<OffersExperienceWhereUniqueInput>
    disconnect?: Enumerable<OffersExperienceWhereUniqueInput>
    delete?: Enumerable<OffersExperienceWhereUniqueInput>
    connect?: Enumerable<OffersExperienceWhereUniqueInput>
    update?: Enumerable<OffersExperienceUpdateWithWhereUniqueWithoutLocationInput>
    updateMany?: Enumerable<OffersExperienceUpdateManyWithWhereWithoutLocationInput>
    deleteMany?: Enumerable<OffersExperienceScalarWhereInput>
  }

  export type OffersOfferUpdateManyWithoutLocationNestedInput = {
    create?: XOR<Enumerable<OffersOfferCreateWithoutLocationInput>, Enumerable<OffersOfferUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<OffersOfferCreateOrConnectWithoutLocationInput>
    upsert?: Enumerable<OffersOfferUpsertWithWhereUniqueWithoutLocationInput>
    createMany?: OffersOfferCreateManyLocationInputEnvelope
    set?: Enumerable<OffersOfferWhereUniqueInput>
    disconnect?: Enumerable<OffersOfferWhereUniqueInput>
    delete?: Enumerable<OffersOfferWhereUniqueInput>
    connect?: Enumerable<OffersOfferWhereUniqueInput>
    update?: Enumerable<OffersOfferUpdateWithWhereUniqueWithoutLocationInput>
    updateMany?: Enumerable<OffersOfferUpdateManyWithWhereWithoutLocationInput>
    deleteMany?: Enumerable<OffersOfferScalarWhereInput>
  }

  export type QuestionsQuestionEncounterUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<Enumerable<QuestionsQuestionEncounterCreateWithoutCityInput>, Enumerable<QuestionsQuestionEncounterUncheckedCreateWithoutCityInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionEncounterCreateOrConnectWithoutCityInput>
    upsert?: Enumerable<QuestionsQuestionEncounterUpsertWithWhereUniqueWithoutCityInput>
    createMany?: QuestionsQuestionEncounterCreateManyCityInputEnvelope
    set?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    disconnect?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    delete?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    connect?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    update?: Enumerable<QuestionsQuestionEncounterUpdateWithWhereUniqueWithoutCityInput>
    updateMany?: Enumerable<QuestionsQuestionEncounterUpdateManyWithWhereWithoutCityInput>
    deleteMany?: Enumerable<QuestionsQuestionEncounterScalarWhereInput>
  }

  export type OffersExperienceUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<Enumerable<OffersExperienceCreateWithoutLocationInput>, Enumerable<OffersExperienceUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<OffersExperienceCreateOrConnectWithoutLocationInput>
    upsert?: Enumerable<OffersExperienceUpsertWithWhereUniqueWithoutLocationInput>
    createMany?: OffersExperienceCreateManyLocationInputEnvelope
    set?: Enumerable<OffersExperienceWhereUniqueInput>
    disconnect?: Enumerable<OffersExperienceWhereUniqueInput>
    delete?: Enumerable<OffersExperienceWhereUniqueInput>
    connect?: Enumerable<OffersExperienceWhereUniqueInput>
    update?: Enumerable<OffersExperienceUpdateWithWhereUniqueWithoutLocationInput>
    updateMany?: Enumerable<OffersExperienceUpdateManyWithWhereWithoutLocationInput>
    deleteMany?: Enumerable<OffersExperienceScalarWhereInput>
  }

  export type OffersOfferUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<Enumerable<OffersOfferCreateWithoutLocationInput>, Enumerable<OffersOfferUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<OffersOfferCreateOrConnectWithoutLocationInput>
    upsert?: Enumerable<OffersOfferUpsertWithWhereUniqueWithoutLocationInput>
    createMany?: OffersOfferCreateManyLocationInputEnvelope
    set?: Enumerable<OffersOfferWhereUniqueInput>
    disconnect?: Enumerable<OffersOfferWhereUniqueInput>
    delete?: Enumerable<OffersOfferWhereUniqueInput>
    connect?: Enumerable<OffersOfferWhereUniqueInput>
    update?: Enumerable<OffersOfferUpdateWithWhereUniqueWithoutLocationInput>
    updateMany?: Enumerable<OffersOfferUpdateManyWithWhereWithoutLocationInput>
    deleteMany?: Enumerable<OffersOfferScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutResumesResumesInput = {
    create?: XOR<UserCreateWithoutResumesResumesInput, UserUncheckedCreateWithoutResumesResumesInput>
    connectOrCreate?: UserCreateOrConnectWithoutResumesResumesInput
    connect?: UserWhereUniqueInput
  }

  export type CountryCreateNestedOneWithoutResumesResumeInput = {
    create?: XOR<CountryCreateWithoutResumesResumeInput, CountryUncheckedCreateWithoutResumesResumeInput>
    connectOrCreate?: CountryCreateOrConnectWithoutResumesResumeInput
    connect?: CountryWhereUniqueInput
  }

  export type ResumesStarCreateNestedManyWithoutResumeInput = {
    create?: XOR<Enumerable<ResumesStarCreateWithoutResumeInput>, Enumerable<ResumesStarUncheckedCreateWithoutResumeInput>>
    connectOrCreate?: Enumerable<ResumesStarCreateOrConnectWithoutResumeInput>
    createMany?: ResumesStarCreateManyResumeInputEnvelope
    connect?: Enumerable<ResumesStarWhereUniqueInput>
  }

  export type ResumesCommentCreateNestedManyWithoutResumeInput = {
    create?: XOR<Enumerable<ResumesCommentCreateWithoutResumeInput>, Enumerable<ResumesCommentUncheckedCreateWithoutResumeInput>>
    connectOrCreate?: Enumerable<ResumesCommentCreateOrConnectWithoutResumeInput>
    createMany?: ResumesCommentCreateManyResumeInputEnvelope
    connect?: Enumerable<ResumesCommentWhereUniqueInput>
  }

  export type ResumesStarUncheckedCreateNestedManyWithoutResumeInput = {
    create?: XOR<Enumerable<ResumesStarCreateWithoutResumeInput>, Enumerable<ResumesStarUncheckedCreateWithoutResumeInput>>
    connectOrCreate?: Enumerable<ResumesStarCreateOrConnectWithoutResumeInput>
    createMany?: ResumesStarCreateManyResumeInputEnvelope
    connect?: Enumerable<ResumesStarWhereUniqueInput>
  }

  export type ResumesCommentUncheckedCreateNestedManyWithoutResumeInput = {
    create?: XOR<Enumerable<ResumesCommentCreateWithoutResumeInput>, Enumerable<ResumesCommentUncheckedCreateWithoutResumeInput>>
    connectOrCreate?: Enumerable<ResumesCommentCreateOrConnectWithoutResumeInput>
    createMany?: ResumesCommentCreateManyResumeInputEnvelope
    connect?: Enumerable<ResumesCommentWhereUniqueInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutResumesResumesNestedInput = {
    create?: XOR<UserCreateWithoutResumesResumesInput, UserUncheckedCreateWithoutResumesResumesInput>
    connectOrCreate?: UserCreateOrConnectWithoutResumesResumesInput
    upsert?: UserUpsertWithoutResumesResumesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutResumesResumesInput, UserUncheckedUpdateWithoutResumesResumesInput>
  }

  export type CountryUpdateOneRequiredWithoutResumesResumeNestedInput = {
    create?: XOR<CountryCreateWithoutResumesResumeInput, CountryUncheckedCreateWithoutResumesResumeInput>
    connectOrCreate?: CountryCreateOrConnectWithoutResumesResumeInput
    upsert?: CountryUpsertWithoutResumesResumeInput
    connect?: CountryWhereUniqueInput
    update?: XOR<CountryUpdateWithoutResumesResumeInput, CountryUncheckedUpdateWithoutResumesResumeInput>
  }

  export type ResumesStarUpdateManyWithoutResumeNestedInput = {
    create?: XOR<Enumerable<ResumesStarCreateWithoutResumeInput>, Enumerable<ResumesStarUncheckedCreateWithoutResumeInput>>
    connectOrCreate?: Enumerable<ResumesStarCreateOrConnectWithoutResumeInput>
    upsert?: Enumerable<ResumesStarUpsertWithWhereUniqueWithoutResumeInput>
    createMany?: ResumesStarCreateManyResumeInputEnvelope
    set?: Enumerable<ResumesStarWhereUniqueInput>
    disconnect?: Enumerable<ResumesStarWhereUniqueInput>
    delete?: Enumerable<ResumesStarWhereUniqueInput>
    connect?: Enumerable<ResumesStarWhereUniqueInput>
    update?: Enumerable<ResumesStarUpdateWithWhereUniqueWithoutResumeInput>
    updateMany?: Enumerable<ResumesStarUpdateManyWithWhereWithoutResumeInput>
    deleteMany?: Enumerable<ResumesStarScalarWhereInput>
  }

  export type ResumesCommentUpdateManyWithoutResumeNestedInput = {
    create?: XOR<Enumerable<ResumesCommentCreateWithoutResumeInput>, Enumerable<ResumesCommentUncheckedCreateWithoutResumeInput>>
    connectOrCreate?: Enumerable<ResumesCommentCreateOrConnectWithoutResumeInput>
    upsert?: Enumerable<ResumesCommentUpsertWithWhereUniqueWithoutResumeInput>
    createMany?: ResumesCommentCreateManyResumeInputEnvelope
    set?: Enumerable<ResumesCommentWhereUniqueInput>
    disconnect?: Enumerable<ResumesCommentWhereUniqueInput>
    delete?: Enumerable<ResumesCommentWhereUniqueInput>
    connect?: Enumerable<ResumesCommentWhereUniqueInput>
    update?: Enumerable<ResumesCommentUpdateWithWhereUniqueWithoutResumeInput>
    updateMany?: Enumerable<ResumesCommentUpdateManyWithWhereWithoutResumeInput>
    deleteMany?: Enumerable<ResumesCommentScalarWhereInput>
  }

  export type ResumesStarUncheckedUpdateManyWithoutResumeNestedInput = {
    create?: XOR<Enumerable<ResumesStarCreateWithoutResumeInput>, Enumerable<ResumesStarUncheckedCreateWithoutResumeInput>>
    connectOrCreate?: Enumerable<ResumesStarCreateOrConnectWithoutResumeInput>
    upsert?: Enumerable<ResumesStarUpsertWithWhereUniqueWithoutResumeInput>
    createMany?: ResumesStarCreateManyResumeInputEnvelope
    set?: Enumerable<ResumesStarWhereUniqueInput>
    disconnect?: Enumerable<ResumesStarWhereUniqueInput>
    delete?: Enumerable<ResumesStarWhereUniqueInput>
    connect?: Enumerable<ResumesStarWhereUniqueInput>
    update?: Enumerable<ResumesStarUpdateWithWhereUniqueWithoutResumeInput>
    updateMany?: Enumerable<ResumesStarUpdateManyWithWhereWithoutResumeInput>
    deleteMany?: Enumerable<ResumesStarScalarWhereInput>
  }

  export type ResumesCommentUncheckedUpdateManyWithoutResumeNestedInput = {
    create?: XOR<Enumerable<ResumesCommentCreateWithoutResumeInput>, Enumerable<ResumesCommentUncheckedCreateWithoutResumeInput>>
    connectOrCreate?: Enumerable<ResumesCommentCreateOrConnectWithoutResumeInput>
    upsert?: Enumerable<ResumesCommentUpsertWithWhereUniqueWithoutResumeInput>
    createMany?: ResumesCommentCreateManyResumeInputEnvelope
    set?: Enumerable<ResumesCommentWhereUniqueInput>
    disconnect?: Enumerable<ResumesCommentWhereUniqueInput>
    delete?: Enumerable<ResumesCommentWhereUniqueInput>
    connect?: Enumerable<ResumesCommentWhereUniqueInput>
    update?: Enumerable<ResumesCommentUpdateWithWhereUniqueWithoutResumeInput>
    updateMany?: Enumerable<ResumesCommentUpdateManyWithWhereWithoutResumeInput>
    deleteMany?: Enumerable<ResumesCommentScalarWhereInput>
  }

  export type ResumesResumeCreateNestedOneWithoutStarsInput = {
    create?: XOR<ResumesResumeCreateWithoutStarsInput, ResumesResumeUncheckedCreateWithoutStarsInput>
    connectOrCreate?: ResumesResumeCreateOrConnectWithoutStarsInput
    connect?: ResumesResumeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutResumesStarsInput = {
    create?: XOR<UserCreateWithoutResumesStarsInput, UserUncheckedCreateWithoutResumesStarsInput>
    connectOrCreate?: UserCreateOrConnectWithoutResumesStarsInput
    connect?: UserWhereUniqueInput
  }

  export type ResumesResumeUpdateOneRequiredWithoutStarsNestedInput = {
    create?: XOR<ResumesResumeCreateWithoutStarsInput, ResumesResumeUncheckedCreateWithoutStarsInput>
    connectOrCreate?: ResumesResumeCreateOrConnectWithoutStarsInput
    upsert?: ResumesResumeUpsertWithoutStarsInput
    connect?: ResumesResumeWhereUniqueInput
    update?: XOR<ResumesResumeUpdateWithoutStarsInput, ResumesResumeUncheckedUpdateWithoutStarsInput>
  }

  export type UserUpdateOneRequiredWithoutResumesStarsNestedInput = {
    create?: XOR<UserCreateWithoutResumesStarsInput, UserUncheckedCreateWithoutResumesStarsInput>
    connectOrCreate?: UserCreateOrConnectWithoutResumesStarsInput
    upsert?: UserUpsertWithoutResumesStarsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutResumesStarsInput, UserUncheckedUpdateWithoutResumesStarsInput>
  }

  export type ResumesResumeCreateNestedOneWithoutCommentsInput = {
    create?: XOR<ResumesResumeCreateWithoutCommentsInput, ResumesResumeUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ResumesResumeCreateOrConnectWithoutCommentsInput
    connect?: ResumesResumeWhereUniqueInput
  }

  export type ResumesCommentVoteCreateNestedManyWithoutCommentInput = {
    create?: XOR<Enumerable<ResumesCommentVoteCreateWithoutCommentInput>, Enumerable<ResumesCommentVoteUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<ResumesCommentVoteCreateOrConnectWithoutCommentInput>
    createMany?: ResumesCommentVoteCreateManyCommentInputEnvelope
    connect?: Enumerable<ResumesCommentVoteWhereUniqueInput>
  }

  export type UserCreateNestedOneWithoutResumesCommentsInput = {
    create?: XOR<UserCreateWithoutResumesCommentsInput, UserUncheckedCreateWithoutResumesCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutResumesCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type ResumesCommentCreateNestedOneWithoutChildrenInput = {
    create?: XOR<ResumesCommentCreateWithoutChildrenInput, ResumesCommentUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: ResumesCommentCreateOrConnectWithoutChildrenInput
    connect?: ResumesCommentWhereUniqueInput
  }

  export type ResumesCommentCreateNestedManyWithoutParentInput = {
    create?: XOR<Enumerable<ResumesCommentCreateWithoutParentInput>, Enumerable<ResumesCommentUncheckedCreateWithoutParentInput>>
    connectOrCreate?: Enumerable<ResumesCommentCreateOrConnectWithoutParentInput>
    createMany?: ResumesCommentCreateManyParentInputEnvelope
    connect?: Enumerable<ResumesCommentWhereUniqueInput>
  }

  export type ResumesCommentVoteUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<Enumerable<ResumesCommentVoteCreateWithoutCommentInput>, Enumerable<ResumesCommentVoteUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<ResumesCommentVoteCreateOrConnectWithoutCommentInput>
    createMany?: ResumesCommentVoteCreateManyCommentInputEnvelope
    connect?: Enumerable<ResumesCommentVoteWhereUniqueInput>
  }

  export type ResumesCommentUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<Enumerable<ResumesCommentCreateWithoutParentInput>, Enumerable<ResumesCommentUncheckedCreateWithoutParentInput>>
    connectOrCreate?: Enumerable<ResumesCommentCreateOrConnectWithoutParentInput>
    createMany?: ResumesCommentCreateManyParentInputEnvelope
    connect?: Enumerable<ResumesCommentWhereUniqueInput>
  }

  export type EnumResumesSectionFieldUpdateOperationsInput = {
    set?: ResumesSection
  }

  export type ResumesResumeUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<ResumesResumeCreateWithoutCommentsInput, ResumesResumeUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ResumesResumeCreateOrConnectWithoutCommentsInput
    upsert?: ResumesResumeUpsertWithoutCommentsInput
    connect?: ResumesResumeWhereUniqueInput
    update?: XOR<ResumesResumeUpdateWithoutCommentsInput, ResumesResumeUncheckedUpdateWithoutCommentsInput>
  }

  export type ResumesCommentVoteUpdateManyWithoutCommentNestedInput = {
    create?: XOR<Enumerable<ResumesCommentVoteCreateWithoutCommentInput>, Enumerable<ResumesCommentVoteUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<ResumesCommentVoteCreateOrConnectWithoutCommentInput>
    upsert?: Enumerable<ResumesCommentVoteUpsertWithWhereUniqueWithoutCommentInput>
    createMany?: ResumesCommentVoteCreateManyCommentInputEnvelope
    set?: Enumerable<ResumesCommentVoteWhereUniqueInput>
    disconnect?: Enumerable<ResumesCommentVoteWhereUniqueInput>
    delete?: Enumerable<ResumesCommentVoteWhereUniqueInput>
    connect?: Enumerable<ResumesCommentVoteWhereUniqueInput>
    update?: Enumerable<ResumesCommentVoteUpdateWithWhereUniqueWithoutCommentInput>
    updateMany?: Enumerable<ResumesCommentVoteUpdateManyWithWhereWithoutCommentInput>
    deleteMany?: Enumerable<ResumesCommentVoteScalarWhereInput>
  }

  export type UserUpdateOneRequiredWithoutResumesCommentsNestedInput = {
    create?: XOR<UserCreateWithoutResumesCommentsInput, UserUncheckedCreateWithoutResumesCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutResumesCommentsInput
    upsert?: UserUpsertWithoutResumesCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutResumesCommentsInput, UserUncheckedUpdateWithoutResumesCommentsInput>
  }

  export type ResumesCommentUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<ResumesCommentCreateWithoutChildrenInput, ResumesCommentUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: ResumesCommentCreateOrConnectWithoutChildrenInput
    upsert?: ResumesCommentUpsertWithoutChildrenInput
    disconnect?: boolean
    delete?: boolean
    connect?: ResumesCommentWhereUniqueInput
    update?: XOR<ResumesCommentUpdateWithoutChildrenInput, ResumesCommentUncheckedUpdateWithoutChildrenInput>
  }

  export type ResumesCommentUpdateManyWithoutParentNestedInput = {
    create?: XOR<Enumerable<ResumesCommentCreateWithoutParentInput>, Enumerable<ResumesCommentUncheckedCreateWithoutParentInput>>
    connectOrCreate?: Enumerable<ResumesCommentCreateOrConnectWithoutParentInput>
    upsert?: Enumerable<ResumesCommentUpsertWithWhereUniqueWithoutParentInput>
    createMany?: ResumesCommentCreateManyParentInputEnvelope
    set?: Enumerable<ResumesCommentWhereUniqueInput>
    disconnect?: Enumerable<ResumesCommentWhereUniqueInput>
    delete?: Enumerable<ResumesCommentWhereUniqueInput>
    connect?: Enumerable<ResumesCommentWhereUniqueInput>
    update?: Enumerable<ResumesCommentUpdateWithWhereUniqueWithoutParentInput>
    updateMany?: Enumerable<ResumesCommentUpdateManyWithWhereWithoutParentInput>
    deleteMany?: Enumerable<ResumesCommentScalarWhereInput>
  }

  export type ResumesCommentVoteUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<Enumerable<ResumesCommentVoteCreateWithoutCommentInput>, Enumerable<ResumesCommentVoteUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<ResumesCommentVoteCreateOrConnectWithoutCommentInput>
    upsert?: Enumerable<ResumesCommentVoteUpsertWithWhereUniqueWithoutCommentInput>
    createMany?: ResumesCommentVoteCreateManyCommentInputEnvelope
    set?: Enumerable<ResumesCommentVoteWhereUniqueInput>
    disconnect?: Enumerable<ResumesCommentVoteWhereUniqueInput>
    delete?: Enumerable<ResumesCommentVoteWhereUniqueInput>
    connect?: Enumerable<ResumesCommentVoteWhereUniqueInput>
    update?: Enumerable<ResumesCommentVoteUpdateWithWhereUniqueWithoutCommentInput>
    updateMany?: Enumerable<ResumesCommentVoteUpdateManyWithWhereWithoutCommentInput>
    deleteMany?: Enumerable<ResumesCommentVoteScalarWhereInput>
  }

  export type ResumesCommentUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<Enumerable<ResumesCommentCreateWithoutParentInput>, Enumerable<ResumesCommentUncheckedCreateWithoutParentInput>>
    connectOrCreate?: Enumerable<ResumesCommentCreateOrConnectWithoutParentInput>
    upsert?: Enumerable<ResumesCommentUpsertWithWhereUniqueWithoutParentInput>
    createMany?: ResumesCommentCreateManyParentInputEnvelope
    set?: Enumerable<ResumesCommentWhereUniqueInput>
    disconnect?: Enumerable<ResumesCommentWhereUniqueInput>
    delete?: Enumerable<ResumesCommentWhereUniqueInput>
    connect?: Enumerable<ResumesCommentWhereUniqueInput>
    update?: Enumerable<ResumesCommentUpdateWithWhereUniqueWithoutParentInput>
    updateMany?: Enumerable<ResumesCommentUpdateManyWithWhereWithoutParentInput>
    deleteMany?: Enumerable<ResumesCommentScalarWhereInput>
  }

  export type ResumesCommentCreateNestedOneWithoutVotesInput = {
    create?: XOR<ResumesCommentCreateWithoutVotesInput, ResumesCommentUncheckedCreateWithoutVotesInput>
    connectOrCreate?: ResumesCommentCreateOrConnectWithoutVotesInput
    connect?: ResumesCommentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutResumesCommentVotesInput = {
    create?: XOR<UserCreateWithoutResumesCommentVotesInput, UserUncheckedCreateWithoutResumesCommentVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutResumesCommentVotesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumVoteFieldUpdateOperationsInput = {
    set?: Vote
  }

  export type ResumesCommentUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<ResumesCommentCreateWithoutVotesInput, ResumesCommentUncheckedCreateWithoutVotesInput>
    connectOrCreate?: ResumesCommentCreateOrConnectWithoutVotesInput
    upsert?: ResumesCommentUpsertWithoutVotesInput
    connect?: ResumesCommentWhereUniqueInput
    update?: XOR<ResumesCommentUpdateWithoutVotesInput, ResumesCommentUncheckedUpdateWithoutVotesInput>
  }

  export type UserUpdateOneRequiredWithoutResumesCommentVotesNestedInput = {
    create?: XOR<UserCreateWithoutResumesCommentVotesInput, UserUncheckedCreateWithoutResumesCommentVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutResumesCommentVotesInput
    upsert?: UserUpsertWithoutResumesCommentVotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutResumesCommentVotesInput, UserUncheckedUpdateWithoutResumesCommentVotesInput>
  }

  export type OffersBackgroundCreateNestedOneWithoutProfileInput = {
    create?: XOR<OffersBackgroundCreateWithoutProfileInput, OffersBackgroundUncheckedCreateWithoutProfileInput>
    connectOrCreate?: OffersBackgroundCreateOrConnectWithoutProfileInput
    connect?: OffersBackgroundWhereUniqueInput
  }

  export type OffersReplyCreateNestedManyWithoutProfileInput = {
    create?: XOR<Enumerable<OffersReplyCreateWithoutProfileInput>, Enumerable<OffersReplyUncheckedCreateWithoutProfileInput>>
    connectOrCreate?: Enumerable<OffersReplyCreateOrConnectWithoutProfileInput>
    createMany?: OffersReplyCreateManyProfileInputEnvelope
    connect?: Enumerable<OffersReplyWhereUniqueInput>
  }

  export type OffersOfferCreateNestedManyWithoutProfileInput = {
    create?: XOR<Enumerable<OffersOfferCreateWithoutProfileInput>, Enumerable<OffersOfferUncheckedCreateWithoutProfileInput>>
    connectOrCreate?: Enumerable<OffersOfferCreateOrConnectWithoutProfileInput>
    createMany?: OffersOfferCreateManyProfileInputEnvelope
    connect?: Enumerable<OffersOfferWhereUniqueInput>
  }

  export type UserCreateNestedManyWithoutOffersProfileInput = {
    create?: XOR<Enumerable<UserCreateWithoutOffersProfileInput>, Enumerable<UserUncheckedCreateWithoutOffersProfileInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutOffersProfileInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type OffersAnalysisCreateNestedOneWithoutProfileInput = {
    create?: XOR<OffersAnalysisCreateWithoutProfileInput, OffersAnalysisUncheckedCreateWithoutProfileInput>
    connectOrCreate?: OffersAnalysisCreateOrConnectWithoutProfileInput
    connect?: OffersAnalysisWhereUniqueInput
  }

  export type OffersBackgroundUncheckedCreateNestedOneWithoutProfileInput = {
    create?: XOR<OffersBackgroundCreateWithoutProfileInput, OffersBackgroundUncheckedCreateWithoutProfileInput>
    connectOrCreate?: OffersBackgroundCreateOrConnectWithoutProfileInput
    connect?: OffersBackgroundWhereUniqueInput
  }

  export type OffersReplyUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<Enumerable<OffersReplyCreateWithoutProfileInput>, Enumerable<OffersReplyUncheckedCreateWithoutProfileInput>>
    connectOrCreate?: Enumerable<OffersReplyCreateOrConnectWithoutProfileInput>
    createMany?: OffersReplyCreateManyProfileInputEnvelope
    connect?: Enumerable<OffersReplyWhereUniqueInput>
  }

  export type OffersOfferUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<Enumerable<OffersOfferCreateWithoutProfileInput>, Enumerable<OffersOfferUncheckedCreateWithoutProfileInput>>
    connectOrCreate?: Enumerable<OffersOfferCreateOrConnectWithoutProfileInput>
    createMany?: OffersOfferCreateManyProfileInputEnvelope
    connect?: Enumerable<OffersOfferWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedManyWithoutOffersProfileInput = {
    create?: XOR<Enumerable<UserCreateWithoutOffersProfileInput>, Enumerable<UserUncheckedCreateWithoutOffersProfileInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutOffersProfileInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type OffersAnalysisUncheckedCreateNestedOneWithoutProfileInput = {
    create?: XOR<OffersAnalysisCreateWithoutProfileInput, OffersAnalysisUncheckedCreateWithoutProfileInput>
    connectOrCreate?: OffersAnalysisCreateOrConnectWithoutProfileInput
    connect?: OffersAnalysisWhereUniqueInput
  }

  export type OffersBackgroundUpdateOneWithoutProfileNestedInput = {
    create?: XOR<OffersBackgroundCreateWithoutProfileInput, OffersBackgroundUncheckedCreateWithoutProfileInput>
    connectOrCreate?: OffersBackgroundCreateOrConnectWithoutProfileInput
    upsert?: OffersBackgroundUpsertWithoutProfileInput
    disconnect?: boolean
    delete?: boolean
    connect?: OffersBackgroundWhereUniqueInput
    update?: XOR<OffersBackgroundUpdateWithoutProfileInput, OffersBackgroundUncheckedUpdateWithoutProfileInput>
  }

  export type OffersReplyUpdateManyWithoutProfileNestedInput = {
    create?: XOR<Enumerable<OffersReplyCreateWithoutProfileInput>, Enumerable<OffersReplyUncheckedCreateWithoutProfileInput>>
    connectOrCreate?: Enumerable<OffersReplyCreateOrConnectWithoutProfileInput>
    upsert?: Enumerable<OffersReplyUpsertWithWhereUniqueWithoutProfileInput>
    createMany?: OffersReplyCreateManyProfileInputEnvelope
    set?: Enumerable<OffersReplyWhereUniqueInput>
    disconnect?: Enumerable<OffersReplyWhereUniqueInput>
    delete?: Enumerable<OffersReplyWhereUniqueInput>
    connect?: Enumerable<OffersReplyWhereUniqueInput>
    update?: Enumerable<OffersReplyUpdateWithWhereUniqueWithoutProfileInput>
    updateMany?: Enumerable<OffersReplyUpdateManyWithWhereWithoutProfileInput>
    deleteMany?: Enumerable<OffersReplyScalarWhereInput>
  }

  export type OffersOfferUpdateManyWithoutProfileNestedInput = {
    create?: XOR<Enumerable<OffersOfferCreateWithoutProfileInput>, Enumerable<OffersOfferUncheckedCreateWithoutProfileInput>>
    connectOrCreate?: Enumerable<OffersOfferCreateOrConnectWithoutProfileInput>
    upsert?: Enumerable<OffersOfferUpsertWithWhereUniqueWithoutProfileInput>
    createMany?: OffersOfferCreateManyProfileInputEnvelope
    set?: Enumerable<OffersOfferWhereUniqueInput>
    disconnect?: Enumerable<OffersOfferWhereUniqueInput>
    delete?: Enumerable<OffersOfferWhereUniqueInput>
    connect?: Enumerable<OffersOfferWhereUniqueInput>
    update?: Enumerable<OffersOfferUpdateWithWhereUniqueWithoutProfileInput>
    updateMany?: Enumerable<OffersOfferUpdateManyWithWhereWithoutProfileInput>
    deleteMany?: Enumerable<OffersOfferScalarWhereInput>
  }

  export type UserUpdateManyWithoutOffersProfileNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutOffersProfileInput>, Enumerable<UserUncheckedCreateWithoutOffersProfileInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutOffersProfileInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutOffersProfileInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutOffersProfileInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutOffersProfileInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type OffersAnalysisUpdateOneWithoutProfileNestedInput = {
    create?: XOR<OffersAnalysisCreateWithoutProfileInput, OffersAnalysisUncheckedCreateWithoutProfileInput>
    connectOrCreate?: OffersAnalysisCreateOrConnectWithoutProfileInput
    upsert?: OffersAnalysisUpsertWithoutProfileInput
    disconnect?: boolean
    delete?: boolean
    connect?: OffersAnalysisWhereUniqueInput
    update?: XOR<OffersAnalysisUpdateWithoutProfileInput, OffersAnalysisUncheckedUpdateWithoutProfileInput>
  }

  export type OffersBackgroundUncheckedUpdateOneWithoutProfileNestedInput = {
    create?: XOR<OffersBackgroundCreateWithoutProfileInput, OffersBackgroundUncheckedCreateWithoutProfileInput>
    connectOrCreate?: OffersBackgroundCreateOrConnectWithoutProfileInput
    upsert?: OffersBackgroundUpsertWithoutProfileInput
    disconnect?: boolean
    delete?: boolean
    connect?: OffersBackgroundWhereUniqueInput
    update?: XOR<OffersBackgroundUpdateWithoutProfileInput, OffersBackgroundUncheckedUpdateWithoutProfileInput>
  }

  export type OffersReplyUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<Enumerable<OffersReplyCreateWithoutProfileInput>, Enumerable<OffersReplyUncheckedCreateWithoutProfileInput>>
    connectOrCreate?: Enumerable<OffersReplyCreateOrConnectWithoutProfileInput>
    upsert?: Enumerable<OffersReplyUpsertWithWhereUniqueWithoutProfileInput>
    createMany?: OffersReplyCreateManyProfileInputEnvelope
    set?: Enumerable<OffersReplyWhereUniqueInput>
    disconnect?: Enumerable<OffersReplyWhereUniqueInput>
    delete?: Enumerable<OffersReplyWhereUniqueInput>
    connect?: Enumerable<OffersReplyWhereUniqueInput>
    update?: Enumerable<OffersReplyUpdateWithWhereUniqueWithoutProfileInput>
    updateMany?: Enumerable<OffersReplyUpdateManyWithWhereWithoutProfileInput>
    deleteMany?: Enumerable<OffersReplyScalarWhereInput>
  }

  export type OffersOfferUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<Enumerable<OffersOfferCreateWithoutProfileInput>, Enumerable<OffersOfferUncheckedCreateWithoutProfileInput>>
    connectOrCreate?: Enumerable<OffersOfferCreateOrConnectWithoutProfileInput>
    upsert?: Enumerable<OffersOfferUpsertWithWhereUniqueWithoutProfileInput>
    createMany?: OffersOfferCreateManyProfileInputEnvelope
    set?: Enumerable<OffersOfferWhereUniqueInput>
    disconnect?: Enumerable<OffersOfferWhereUniqueInput>
    delete?: Enumerable<OffersOfferWhereUniqueInput>
    connect?: Enumerable<OffersOfferWhereUniqueInput>
    update?: Enumerable<OffersOfferUpdateWithWhereUniqueWithoutProfileInput>
    updateMany?: Enumerable<OffersOfferUpdateManyWithWhereWithoutProfileInput>
    deleteMany?: Enumerable<OffersOfferScalarWhereInput>
  }

  export type UserUncheckedUpdateManyWithoutOffersProfileNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutOffersProfileInput>, Enumerable<UserUncheckedCreateWithoutOffersProfileInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutOffersProfileInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutOffersProfileInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutOffersProfileInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutOffersProfileInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type OffersAnalysisUncheckedUpdateOneWithoutProfileNestedInput = {
    create?: XOR<OffersAnalysisCreateWithoutProfileInput, OffersAnalysisUncheckedCreateWithoutProfileInput>
    connectOrCreate?: OffersAnalysisCreateOrConnectWithoutProfileInput
    upsert?: OffersAnalysisUpsertWithoutProfileInput
    disconnect?: boolean
    delete?: boolean
    connect?: OffersAnalysisWhereUniqueInput
    update?: XOR<OffersAnalysisUpdateWithoutProfileInput, OffersAnalysisUncheckedUpdateWithoutProfileInput>
  }

  export type UserCreateNestedOneWithoutOffersAdminInput = {
    create?: XOR<UserCreateWithoutOffersAdminInput, UserUncheckedCreateWithoutOffersAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutOffersAdminInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutOffersAdminNestedInput = {
    create?: XOR<UserCreateWithoutOffersAdminInput, UserUncheckedCreateWithoutOffersAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutOffersAdminInput
    upsert?: UserUpsertWithoutOffersAdminInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutOffersAdminInput, UserUncheckedUpdateWithoutOffersAdminInput>
  }

  export type OffersSpecificYoeCreateNestedManyWithoutBackgroundInput = {
    create?: XOR<Enumerable<OffersSpecificYoeCreateWithoutBackgroundInput>, Enumerable<OffersSpecificYoeUncheckedCreateWithoutBackgroundInput>>
    connectOrCreate?: Enumerable<OffersSpecificYoeCreateOrConnectWithoutBackgroundInput>
    createMany?: OffersSpecificYoeCreateManyBackgroundInputEnvelope
    connect?: Enumerable<OffersSpecificYoeWhereUniqueInput>
  }

  export type OffersExperienceCreateNestedManyWithoutBackgroundInput = {
    create?: XOR<Enumerable<OffersExperienceCreateWithoutBackgroundInput>, Enumerable<OffersExperienceUncheckedCreateWithoutBackgroundInput>>
    connectOrCreate?: Enumerable<OffersExperienceCreateOrConnectWithoutBackgroundInput>
    createMany?: OffersExperienceCreateManyBackgroundInputEnvelope
    connect?: Enumerable<OffersExperienceWhereUniqueInput>
  }

  export type OffersEducationCreateNestedManyWithoutBackgroundInput = {
    create?: XOR<Enumerable<OffersEducationCreateWithoutBackgroundInput>, Enumerable<OffersEducationUncheckedCreateWithoutBackgroundInput>>
    connectOrCreate?: Enumerable<OffersEducationCreateOrConnectWithoutBackgroundInput>
    createMany?: OffersEducationCreateManyBackgroundInputEnvelope
    connect?: Enumerable<OffersEducationWhereUniqueInput>
  }

  export type OffersProfileCreateNestedOneWithoutBackgroundInput = {
    create?: XOR<OffersProfileCreateWithoutBackgroundInput, OffersProfileUncheckedCreateWithoutBackgroundInput>
    connectOrCreate?: OffersProfileCreateOrConnectWithoutBackgroundInput
    connect?: OffersProfileWhereUniqueInput
  }

  export type OffersSpecificYoeUncheckedCreateNestedManyWithoutBackgroundInput = {
    create?: XOR<Enumerable<OffersSpecificYoeCreateWithoutBackgroundInput>, Enumerable<OffersSpecificYoeUncheckedCreateWithoutBackgroundInput>>
    connectOrCreate?: Enumerable<OffersSpecificYoeCreateOrConnectWithoutBackgroundInput>
    createMany?: OffersSpecificYoeCreateManyBackgroundInputEnvelope
    connect?: Enumerable<OffersSpecificYoeWhereUniqueInput>
  }

  export type OffersExperienceUncheckedCreateNestedManyWithoutBackgroundInput = {
    create?: XOR<Enumerable<OffersExperienceCreateWithoutBackgroundInput>, Enumerable<OffersExperienceUncheckedCreateWithoutBackgroundInput>>
    connectOrCreate?: Enumerable<OffersExperienceCreateOrConnectWithoutBackgroundInput>
    createMany?: OffersExperienceCreateManyBackgroundInputEnvelope
    connect?: Enumerable<OffersExperienceWhereUniqueInput>
  }

  export type OffersEducationUncheckedCreateNestedManyWithoutBackgroundInput = {
    create?: XOR<Enumerable<OffersEducationCreateWithoutBackgroundInput>, Enumerable<OffersEducationUncheckedCreateWithoutBackgroundInput>>
    connectOrCreate?: Enumerable<OffersEducationCreateOrConnectWithoutBackgroundInput>
    createMany?: OffersEducationCreateManyBackgroundInputEnvelope
    connect?: Enumerable<OffersEducationWhereUniqueInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OffersSpecificYoeUpdateManyWithoutBackgroundNestedInput = {
    create?: XOR<Enumerable<OffersSpecificYoeCreateWithoutBackgroundInput>, Enumerable<OffersSpecificYoeUncheckedCreateWithoutBackgroundInput>>
    connectOrCreate?: Enumerable<OffersSpecificYoeCreateOrConnectWithoutBackgroundInput>
    upsert?: Enumerable<OffersSpecificYoeUpsertWithWhereUniqueWithoutBackgroundInput>
    createMany?: OffersSpecificYoeCreateManyBackgroundInputEnvelope
    set?: Enumerable<OffersSpecificYoeWhereUniqueInput>
    disconnect?: Enumerable<OffersSpecificYoeWhereUniqueInput>
    delete?: Enumerable<OffersSpecificYoeWhereUniqueInput>
    connect?: Enumerable<OffersSpecificYoeWhereUniqueInput>
    update?: Enumerable<OffersSpecificYoeUpdateWithWhereUniqueWithoutBackgroundInput>
    updateMany?: Enumerable<OffersSpecificYoeUpdateManyWithWhereWithoutBackgroundInput>
    deleteMany?: Enumerable<OffersSpecificYoeScalarWhereInput>
  }

  export type OffersExperienceUpdateManyWithoutBackgroundNestedInput = {
    create?: XOR<Enumerable<OffersExperienceCreateWithoutBackgroundInput>, Enumerable<OffersExperienceUncheckedCreateWithoutBackgroundInput>>
    connectOrCreate?: Enumerable<OffersExperienceCreateOrConnectWithoutBackgroundInput>
    upsert?: Enumerable<OffersExperienceUpsertWithWhereUniqueWithoutBackgroundInput>
    createMany?: OffersExperienceCreateManyBackgroundInputEnvelope
    set?: Enumerable<OffersExperienceWhereUniqueInput>
    disconnect?: Enumerable<OffersExperienceWhereUniqueInput>
    delete?: Enumerable<OffersExperienceWhereUniqueInput>
    connect?: Enumerable<OffersExperienceWhereUniqueInput>
    update?: Enumerable<OffersExperienceUpdateWithWhereUniqueWithoutBackgroundInput>
    updateMany?: Enumerable<OffersExperienceUpdateManyWithWhereWithoutBackgroundInput>
    deleteMany?: Enumerable<OffersExperienceScalarWhereInput>
  }

  export type OffersEducationUpdateManyWithoutBackgroundNestedInput = {
    create?: XOR<Enumerable<OffersEducationCreateWithoutBackgroundInput>, Enumerable<OffersEducationUncheckedCreateWithoutBackgroundInput>>
    connectOrCreate?: Enumerable<OffersEducationCreateOrConnectWithoutBackgroundInput>
    upsert?: Enumerable<OffersEducationUpsertWithWhereUniqueWithoutBackgroundInput>
    createMany?: OffersEducationCreateManyBackgroundInputEnvelope
    set?: Enumerable<OffersEducationWhereUniqueInput>
    disconnect?: Enumerable<OffersEducationWhereUniqueInput>
    delete?: Enumerable<OffersEducationWhereUniqueInput>
    connect?: Enumerable<OffersEducationWhereUniqueInput>
    update?: Enumerable<OffersEducationUpdateWithWhereUniqueWithoutBackgroundInput>
    updateMany?: Enumerable<OffersEducationUpdateManyWithWhereWithoutBackgroundInput>
    deleteMany?: Enumerable<OffersEducationScalarWhereInput>
  }

  export type OffersProfileUpdateOneRequiredWithoutBackgroundNestedInput = {
    create?: XOR<OffersProfileCreateWithoutBackgroundInput, OffersProfileUncheckedCreateWithoutBackgroundInput>
    connectOrCreate?: OffersProfileCreateOrConnectWithoutBackgroundInput
    upsert?: OffersProfileUpsertWithoutBackgroundInput
    connect?: OffersProfileWhereUniqueInput
    update?: XOR<OffersProfileUpdateWithoutBackgroundInput, OffersProfileUncheckedUpdateWithoutBackgroundInput>
  }

  export type OffersSpecificYoeUncheckedUpdateManyWithoutBackgroundNestedInput = {
    create?: XOR<Enumerable<OffersSpecificYoeCreateWithoutBackgroundInput>, Enumerable<OffersSpecificYoeUncheckedCreateWithoutBackgroundInput>>
    connectOrCreate?: Enumerable<OffersSpecificYoeCreateOrConnectWithoutBackgroundInput>
    upsert?: Enumerable<OffersSpecificYoeUpsertWithWhereUniqueWithoutBackgroundInput>
    createMany?: OffersSpecificYoeCreateManyBackgroundInputEnvelope
    set?: Enumerable<OffersSpecificYoeWhereUniqueInput>
    disconnect?: Enumerable<OffersSpecificYoeWhereUniqueInput>
    delete?: Enumerable<OffersSpecificYoeWhereUniqueInput>
    connect?: Enumerable<OffersSpecificYoeWhereUniqueInput>
    update?: Enumerable<OffersSpecificYoeUpdateWithWhereUniqueWithoutBackgroundInput>
    updateMany?: Enumerable<OffersSpecificYoeUpdateManyWithWhereWithoutBackgroundInput>
    deleteMany?: Enumerable<OffersSpecificYoeScalarWhereInput>
  }

  export type OffersExperienceUncheckedUpdateManyWithoutBackgroundNestedInput = {
    create?: XOR<Enumerable<OffersExperienceCreateWithoutBackgroundInput>, Enumerable<OffersExperienceUncheckedCreateWithoutBackgroundInput>>
    connectOrCreate?: Enumerable<OffersExperienceCreateOrConnectWithoutBackgroundInput>
    upsert?: Enumerable<OffersExperienceUpsertWithWhereUniqueWithoutBackgroundInput>
    createMany?: OffersExperienceCreateManyBackgroundInputEnvelope
    set?: Enumerable<OffersExperienceWhereUniqueInput>
    disconnect?: Enumerable<OffersExperienceWhereUniqueInput>
    delete?: Enumerable<OffersExperienceWhereUniqueInput>
    connect?: Enumerable<OffersExperienceWhereUniqueInput>
    update?: Enumerable<OffersExperienceUpdateWithWhereUniqueWithoutBackgroundInput>
    updateMany?: Enumerable<OffersExperienceUpdateManyWithWhereWithoutBackgroundInput>
    deleteMany?: Enumerable<OffersExperienceScalarWhereInput>
  }

  export type OffersEducationUncheckedUpdateManyWithoutBackgroundNestedInput = {
    create?: XOR<Enumerable<OffersEducationCreateWithoutBackgroundInput>, Enumerable<OffersEducationUncheckedCreateWithoutBackgroundInput>>
    connectOrCreate?: Enumerable<OffersEducationCreateOrConnectWithoutBackgroundInput>
    upsert?: Enumerable<OffersEducationUpsertWithWhereUniqueWithoutBackgroundInput>
    createMany?: OffersEducationCreateManyBackgroundInputEnvelope
    set?: Enumerable<OffersEducationWhereUniqueInput>
    disconnect?: Enumerable<OffersEducationWhereUniqueInput>
    delete?: Enumerable<OffersEducationWhereUniqueInput>
    connect?: Enumerable<OffersEducationWhereUniqueInput>
    update?: Enumerable<OffersEducationUpdateWithWhereUniqueWithoutBackgroundInput>
    updateMany?: Enumerable<OffersEducationUpdateManyWithWhereWithoutBackgroundInput>
    deleteMany?: Enumerable<OffersEducationScalarWhereInput>
  }

  export type OffersBackgroundCreateNestedOneWithoutSpecificYoesInput = {
    create?: XOR<OffersBackgroundCreateWithoutSpecificYoesInput, OffersBackgroundUncheckedCreateWithoutSpecificYoesInput>
    connectOrCreate?: OffersBackgroundCreateOrConnectWithoutSpecificYoesInput
    connect?: OffersBackgroundWhereUniqueInput
  }

  export type OffersBackgroundUpdateOneRequiredWithoutSpecificYoesNestedInput = {
    create?: XOR<OffersBackgroundCreateWithoutSpecificYoesInput, OffersBackgroundUncheckedCreateWithoutSpecificYoesInput>
    connectOrCreate?: OffersBackgroundCreateOrConnectWithoutSpecificYoesInput
    upsert?: OffersBackgroundUpsertWithoutSpecificYoesInput
    connect?: OffersBackgroundWhereUniqueInput
    update?: XOR<OffersBackgroundUpdateWithoutSpecificYoesInput, OffersBackgroundUncheckedUpdateWithoutSpecificYoesInput>
  }

  export type CompanyCreateNestedOneWithoutOffersExperienceInput = {
    create?: XOR<CompanyCreateWithoutOffersExperienceInput, CompanyUncheckedCreateWithoutOffersExperienceInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutOffersExperienceInput
    connect?: CompanyWhereUniqueInput
  }

  export type CityCreateNestedOneWithoutOffersExperienceInput = {
    create?: XOR<CityCreateWithoutOffersExperienceInput, CityUncheckedCreateWithoutOffersExperienceInput>
    connectOrCreate?: CityCreateOrConnectWithoutOffersExperienceInput
    connect?: CityWhereUniqueInput
  }

  export type OffersCurrencyCreateNestedOneWithoutOffersExperienceTotalCompensationInput = {
    create?: XOR<OffersCurrencyCreateWithoutOffersExperienceTotalCompensationInput, OffersCurrencyUncheckedCreateWithoutOffersExperienceTotalCompensationInput>
    connectOrCreate?: OffersCurrencyCreateOrConnectWithoutOffersExperienceTotalCompensationInput
    connect?: OffersCurrencyWhereUniqueInput
  }

  export type OffersCurrencyCreateNestedOneWithoutOffersExperienceMonthlySalaryInput = {
    create?: XOR<OffersCurrencyCreateWithoutOffersExperienceMonthlySalaryInput, OffersCurrencyUncheckedCreateWithoutOffersExperienceMonthlySalaryInput>
    connectOrCreate?: OffersCurrencyCreateOrConnectWithoutOffersExperienceMonthlySalaryInput
    connect?: OffersCurrencyWhereUniqueInput
  }

  export type OffersBackgroundCreateNestedOneWithoutExperiencesInput = {
    create?: XOR<OffersBackgroundCreateWithoutExperiencesInput, OffersBackgroundUncheckedCreateWithoutExperiencesInput>
    connectOrCreate?: OffersBackgroundCreateOrConnectWithoutExperiencesInput
    connect?: OffersBackgroundWhereUniqueInput
  }

  export type CompanyUpdateOneWithoutOffersExperienceNestedInput = {
    create?: XOR<CompanyCreateWithoutOffersExperienceInput, CompanyUncheckedCreateWithoutOffersExperienceInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutOffersExperienceInput
    upsert?: CompanyUpsertWithoutOffersExperienceInput
    disconnect?: boolean
    delete?: boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<CompanyUpdateWithoutOffersExperienceInput, CompanyUncheckedUpdateWithoutOffersExperienceInput>
  }

  export type NullableEnumJobTypeFieldUpdateOperationsInput = {
    set?: JobType | null
  }

  export type CityUpdateOneWithoutOffersExperienceNestedInput = {
    create?: XOR<CityCreateWithoutOffersExperienceInput, CityUncheckedCreateWithoutOffersExperienceInput>
    connectOrCreate?: CityCreateOrConnectWithoutOffersExperienceInput
    upsert?: CityUpsertWithoutOffersExperienceInput
    disconnect?: boolean
    delete?: boolean
    connect?: CityWhereUniqueInput
    update?: XOR<CityUpdateWithoutOffersExperienceInput, CityUncheckedUpdateWithoutOffersExperienceInput>
  }

  export type OffersCurrencyUpdateOneWithoutOffersExperienceTotalCompensationNestedInput = {
    create?: XOR<OffersCurrencyCreateWithoutOffersExperienceTotalCompensationInput, OffersCurrencyUncheckedCreateWithoutOffersExperienceTotalCompensationInput>
    connectOrCreate?: OffersCurrencyCreateOrConnectWithoutOffersExperienceTotalCompensationInput
    upsert?: OffersCurrencyUpsertWithoutOffersExperienceTotalCompensationInput
    disconnect?: boolean
    delete?: boolean
    connect?: OffersCurrencyWhereUniqueInput
    update?: XOR<OffersCurrencyUpdateWithoutOffersExperienceTotalCompensationInput, OffersCurrencyUncheckedUpdateWithoutOffersExperienceTotalCompensationInput>
  }

  export type OffersCurrencyUpdateOneWithoutOffersExperienceMonthlySalaryNestedInput = {
    create?: XOR<OffersCurrencyCreateWithoutOffersExperienceMonthlySalaryInput, OffersCurrencyUncheckedCreateWithoutOffersExperienceMonthlySalaryInput>
    connectOrCreate?: OffersCurrencyCreateOrConnectWithoutOffersExperienceMonthlySalaryInput
    upsert?: OffersCurrencyUpsertWithoutOffersExperienceMonthlySalaryInput
    disconnect?: boolean
    delete?: boolean
    connect?: OffersCurrencyWhereUniqueInput
    update?: XOR<OffersCurrencyUpdateWithoutOffersExperienceMonthlySalaryInput, OffersCurrencyUncheckedUpdateWithoutOffersExperienceMonthlySalaryInput>
  }

  export type OffersBackgroundUpdateOneRequiredWithoutExperiencesNestedInput = {
    create?: XOR<OffersBackgroundCreateWithoutExperiencesInput, OffersBackgroundUncheckedCreateWithoutExperiencesInput>
    connectOrCreate?: OffersBackgroundCreateOrConnectWithoutExperiencesInput
    upsert?: OffersBackgroundUpsertWithoutExperiencesInput
    connect?: OffersBackgroundWhereUniqueInput
    update?: XOR<OffersBackgroundUpdateWithoutExperiencesInput, OffersBackgroundUncheckedUpdateWithoutExperiencesInput>
  }

  export type OffersExperienceCreateNestedOneWithoutTotalCompensationInput = {
    create?: XOR<OffersExperienceCreateWithoutTotalCompensationInput, OffersExperienceUncheckedCreateWithoutTotalCompensationInput>
    connectOrCreate?: OffersExperienceCreateOrConnectWithoutTotalCompensationInput
    connect?: OffersExperienceWhereUniqueInput
  }

  export type OffersExperienceCreateNestedOneWithoutMonthlySalaryInput = {
    create?: XOR<OffersExperienceCreateWithoutMonthlySalaryInput, OffersExperienceUncheckedCreateWithoutMonthlySalaryInput>
    connectOrCreate?: OffersExperienceCreateOrConnectWithoutMonthlySalaryInput
    connect?: OffersExperienceWhereUniqueInput
  }

  export type OffersFullTimeCreateNestedOneWithoutTotalCompensationInput = {
    create?: XOR<OffersFullTimeCreateWithoutTotalCompensationInput, OffersFullTimeUncheckedCreateWithoutTotalCompensationInput>
    connectOrCreate?: OffersFullTimeCreateOrConnectWithoutTotalCompensationInput
    connect?: OffersFullTimeWhereUniqueInput
  }

  export type OffersFullTimeCreateNestedOneWithoutBaseSalaryInput = {
    create?: XOR<OffersFullTimeCreateWithoutBaseSalaryInput, OffersFullTimeUncheckedCreateWithoutBaseSalaryInput>
    connectOrCreate?: OffersFullTimeCreateOrConnectWithoutBaseSalaryInput
    connect?: OffersFullTimeWhereUniqueInput
  }

  export type OffersFullTimeCreateNestedOneWithoutBonusInput = {
    create?: XOR<OffersFullTimeCreateWithoutBonusInput, OffersFullTimeUncheckedCreateWithoutBonusInput>
    connectOrCreate?: OffersFullTimeCreateOrConnectWithoutBonusInput
    connect?: OffersFullTimeWhereUniqueInput
  }

  export type OffersFullTimeCreateNestedOneWithoutStocksInput = {
    create?: XOR<OffersFullTimeCreateWithoutStocksInput, OffersFullTimeUncheckedCreateWithoutStocksInput>
    connectOrCreate?: OffersFullTimeCreateOrConnectWithoutStocksInput
    connect?: OffersFullTimeWhereUniqueInput
  }

  export type OffersInternCreateNestedOneWithoutMonthlySalaryInput = {
    create?: XOR<OffersInternCreateWithoutMonthlySalaryInput, OffersInternUncheckedCreateWithoutMonthlySalaryInput>
    connectOrCreate?: OffersInternCreateOrConnectWithoutMonthlySalaryInput
    connect?: OffersInternWhereUniqueInput
  }

  export type OffersExperienceUncheckedCreateNestedOneWithoutTotalCompensationInput = {
    create?: XOR<OffersExperienceCreateWithoutTotalCompensationInput, OffersExperienceUncheckedCreateWithoutTotalCompensationInput>
    connectOrCreate?: OffersExperienceCreateOrConnectWithoutTotalCompensationInput
    connect?: OffersExperienceWhereUniqueInput
  }

  export type OffersExperienceUncheckedCreateNestedOneWithoutMonthlySalaryInput = {
    create?: XOR<OffersExperienceCreateWithoutMonthlySalaryInput, OffersExperienceUncheckedCreateWithoutMonthlySalaryInput>
    connectOrCreate?: OffersExperienceCreateOrConnectWithoutMonthlySalaryInput
    connect?: OffersExperienceWhereUniqueInput
  }

  export type OffersFullTimeUncheckedCreateNestedOneWithoutTotalCompensationInput = {
    create?: XOR<OffersFullTimeCreateWithoutTotalCompensationInput, OffersFullTimeUncheckedCreateWithoutTotalCompensationInput>
    connectOrCreate?: OffersFullTimeCreateOrConnectWithoutTotalCompensationInput
    connect?: OffersFullTimeWhereUniqueInput
  }

  export type OffersFullTimeUncheckedCreateNestedOneWithoutBaseSalaryInput = {
    create?: XOR<OffersFullTimeCreateWithoutBaseSalaryInput, OffersFullTimeUncheckedCreateWithoutBaseSalaryInput>
    connectOrCreate?: OffersFullTimeCreateOrConnectWithoutBaseSalaryInput
    connect?: OffersFullTimeWhereUniqueInput
  }

  export type OffersFullTimeUncheckedCreateNestedOneWithoutBonusInput = {
    create?: XOR<OffersFullTimeCreateWithoutBonusInput, OffersFullTimeUncheckedCreateWithoutBonusInput>
    connectOrCreate?: OffersFullTimeCreateOrConnectWithoutBonusInput
    connect?: OffersFullTimeWhereUniqueInput
  }

  export type OffersFullTimeUncheckedCreateNestedOneWithoutStocksInput = {
    create?: XOR<OffersFullTimeCreateWithoutStocksInput, OffersFullTimeUncheckedCreateWithoutStocksInput>
    connectOrCreate?: OffersFullTimeCreateOrConnectWithoutStocksInput
    connect?: OffersFullTimeWhereUniqueInput
  }

  export type OffersInternUncheckedCreateNestedOneWithoutMonthlySalaryInput = {
    create?: XOR<OffersInternCreateWithoutMonthlySalaryInput, OffersInternUncheckedCreateWithoutMonthlySalaryInput>
    connectOrCreate?: OffersInternCreateOrConnectWithoutMonthlySalaryInput
    connect?: OffersInternWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OffersExperienceUpdateOneWithoutTotalCompensationNestedInput = {
    create?: XOR<OffersExperienceCreateWithoutTotalCompensationInput, OffersExperienceUncheckedCreateWithoutTotalCompensationInput>
    connectOrCreate?: OffersExperienceCreateOrConnectWithoutTotalCompensationInput
    upsert?: OffersExperienceUpsertWithoutTotalCompensationInput
    disconnect?: boolean
    delete?: boolean
    connect?: OffersExperienceWhereUniqueInput
    update?: XOR<OffersExperienceUpdateWithoutTotalCompensationInput, OffersExperienceUncheckedUpdateWithoutTotalCompensationInput>
  }

  export type OffersExperienceUpdateOneWithoutMonthlySalaryNestedInput = {
    create?: XOR<OffersExperienceCreateWithoutMonthlySalaryInput, OffersExperienceUncheckedCreateWithoutMonthlySalaryInput>
    connectOrCreate?: OffersExperienceCreateOrConnectWithoutMonthlySalaryInput
    upsert?: OffersExperienceUpsertWithoutMonthlySalaryInput
    disconnect?: boolean
    delete?: boolean
    connect?: OffersExperienceWhereUniqueInput
    update?: XOR<OffersExperienceUpdateWithoutMonthlySalaryInput, OffersExperienceUncheckedUpdateWithoutMonthlySalaryInput>
  }

  export type OffersFullTimeUpdateOneWithoutTotalCompensationNestedInput = {
    create?: XOR<OffersFullTimeCreateWithoutTotalCompensationInput, OffersFullTimeUncheckedCreateWithoutTotalCompensationInput>
    connectOrCreate?: OffersFullTimeCreateOrConnectWithoutTotalCompensationInput
    upsert?: OffersFullTimeUpsertWithoutTotalCompensationInput
    disconnect?: boolean
    delete?: boolean
    connect?: OffersFullTimeWhereUniqueInput
    update?: XOR<OffersFullTimeUpdateWithoutTotalCompensationInput, OffersFullTimeUncheckedUpdateWithoutTotalCompensationInput>
  }

  export type OffersFullTimeUpdateOneWithoutBaseSalaryNestedInput = {
    create?: XOR<OffersFullTimeCreateWithoutBaseSalaryInput, OffersFullTimeUncheckedCreateWithoutBaseSalaryInput>
    connectOrCreate?: OffersFullTimeCreateOrConnectWithoutBaseSalaryInput
    upsert?: OffersFullTimeUpsertWithoutBaseSalaryInput
    disconnect?: boolean
    delete?: boolean
    connect?: OffersFullTimeWhereUniqueInput
    update?: XOR<OffersFullTimeUpdateWithoutBaseSalaryInput, OffersFullTimeUncheckedUpdateWithoutBaseSalaryInput>
  }

  export type OffersFullTimeUpdateOneWithoutBonusNestedInput = {
    create?: XOR<OffersFullTimeCreateWithoutBonusInput, OffersFullTimeUncheckedCreateWithoutBonusInput>
    connectOrCreate?: OffersFullTimeCreateOrConnectWithoutBonusInput
    upsert?: OffersFullTimeUpsertWithoutBonusInput
    disconnect?: boolean
    delete?: boolean
    connect?: OffersFullTimeWhereUniqueInput
    update?: XOR<OffersFullTimeUpdateWithoutBonusInput, OffersFullTimeUncheckedUpdateWithoutBonusInput>
  }

  export type OffersFullTimeUpdateOneWithoutStocksNestedInput = {
    create?: XOR<OffersFullTimeCreateWithoutStocksInput, OffersFullTimeUncheckedCreateWithoutStocksInput>
    connectOrCreate?: OffersFullTimeCreateOrConnectWithoutStocksInput
    upsert?: OffersFullTimeUpsertWithoutStocksInput
    disconnect?: boolean
    delete?: boolean
    connect?: OffersFullTimeWhereUniqueInput
    update?: XOR<OffersFullTimeUpdateWithoutStocksInput, OffersFullTimeUncheckedUpdateWithoutStocksInput>
  }

  export type OffersInternUpdateOneWithoutMonthlySalaryNestedInput = {
    create?: XOR<OffersInternCreateWithoutMonthlySalaryInput, OffersInternUncheckedCreateWithoutMonthlySalaryInput>
    connectOrCreate?: OffersInternCreateOrConnectWithoutMonthlySalaryInput
    upsert?: OffersInternUpsertWithoutMonthlySalaryInput
    disconnect?: boolean
    delete?: boolean
    connect?: OffersInternWhereUniqueInput
    update?: XOR<OffersInternUpdateWithoutMonthlySalaryInput, OffersInternUncheckedUpdateWithoutMonthlySalaryInput>
  }

  export type OffersExperienceUncheckedUpdateOneWithoutTotalCompensationNestedInput = {
    create?: XOR<OffersExperienceCreateWithoutTotalCompensationInput, OffersExperienceUncheckedCreateWithoutTotalCompensationInput>
    connectOrCreate?: OffersExperienceCreateOrConnectWithoutTotalCompensationInput
    upsert?: OffersExperienceUpsertWithoutTotalCompensationInput
    disconnect?: boolean
    delete?: boolean
    connect?: OffersExperienceWhereUniqueInput
    update?: XOR<OffersExperienceUpdateWithoutTotalCompensationInput, OffersExperienceUncheckedUpdateWithoutTotalCompensationInput>
  }

  export type OffersExperienceUncheckedUpdateOneWithoutMonthlySalaryNestedInput = {
    create?: XOR<OffersExperienceCreateWithoutMonthlySalaryInput, OffersExperienceUncheckedCreateWithoutMonthlySalaryInput>
    connectOrCreate?: OffersExperienceCreateOrConnectWithoutMonthlySalaryInput
    upsert?: OffersExperienceUpsertWithoutMonthlySalaryInput
    disconnect?: boolean
    delete?: boolean
    connect?: OffersExperienceWhereUniqueInput
    update?: XOR<OffersExperienceUpdateWithoutMonthlySalaryInput, OffersExperienceUncheckedUpdateWithoutMonthlySalaryInput>
  }

  export type OffersFullTimeUncheckedUpdateOneWithoutTotalCompensationNestedInput = {
    create?: XOR<OffersFullTimeCreateWithoutTotalCompensationInput, OffersFullTimeUncheckedCreateWithoutTotalCompensationInput>
    connectOrCreate?: OffersFullTimeCreateOrConnectWithoutTotalCompensationInput
    upsert?: OffersFullTimeUpsertWithoutTotalCompensationInput
    disconnect?: boolean
    delete?: boolean
    connect?: OffersFullTimeWhereUniqueInput
    update?: XOR<OffersFullTimeUpdateWithoutTotalCompensationInput, OffersFullTimeUncheckedUpdateWithoutTotalCompensationInput>
  }

  export type OffersFullTimeUncheckedUpdateOneWithoutBaseSalaryNestedInput = {
    create?: XOR<OffersFullTimeCreateWithoutBaseSalaryInput, OffersFullTimeUncheckedCreateWithoutBaseSalaryInput>
    connectOrCreate?: OffersFullTimeCreateOrConnectWithoutBaseSalaryInput
    upsert?: OffersFullTimeUpsertWithoutBaseSalaryInput
    disconnect?: boolean
    delete?: boolean
    connect?: OffersFullTimeWhereUniqueInput
    update?: XOR<OffersFullTimeUpdateWithoutBaseSalaryInput, OffersFullTimeUncheckedUpdateWithoutBaseSalaryInput>
  }

  export type OffersFullTimeUncheckedUpdateOneWithoutBonusNestedInput = {
    create?: XOR<OffersFullTimeCreateWithoutBonusInput, OffersFullTimeUncheckedCreateWithoutBonusInput>
    connectOrCreate?: OffersFullTimeCreateOrConnectWithoutBonusInput
    upsert?: OffersFullTimeUpsertWithoutBonusInput
    disconnect?: boolean
    delete?: boolean
    connect?: OffersFullTimeWhereUniqueInput
    update?: XOR<OffersFullTimeUpdateWithoutBonusInput, OffersFullTimeUncheckedUpdateWithoutBonusInput>
  }

  export type OffersFullTimeUncheckedUpdateOneWithoutStocksNestedInput = {
    create?: XOR<OffersFullTimeCreateWithoutStocksInput, OffersFullTimeUncheckedCreateWithoutStocksInput>
    connectOrCreate?: OffersFullTimeCreateOrConnectWithoutStocksInput
    upsert?: OffersFullTimeUpsertWithoutStocksInput
    disconnect?: boolean
    delete?: boolean
    connect?: OffersFullTimeWhereUniqueInput
    update?: XOR<OffersFullTimeUpdateWithoutStocksInput, OffersFullTimeUncheckedUpdateWithoutStocksInput>
  }

  export type OffersInternUncheckedUpdateOneWithoutMonthlySalaryNestedInput = {
    create?: XOR<OffersInternCreateWithoutMonthlySalaryInput, OffersInternUncheckedCreateWithoutMonthlySalaryInput>
    connectOrCreate?: OffersInternCreateOrConnectWithoutMonthlySalaryInput
    upsert?: OffersInternUpsertWithoutMonthlySalaryInput
    disconnect?: boolean
    delete?: boolean
    connect?: OffersInternWhereUniqueInput
    update?: XOR<OffersInternUpdateWithoutMonthlySalaryInput, OffersInternUncheckedUpdateWithoutMonthlySalaryInput>
  }

  export type OffersBackgroundCreateNestedOneWithoutEducationsInput = {
    create?: XOR<OffersBackgroundCreateWithoutEducationsInput, OffersBackgroundUncheckedCreateWithoutEducationsInput>
    connectOrCreate?: OffersBackgroundCreateOrConnectWithoutEducationsInput
    connect?: OffersBackgroundWhereUniqueInput
  }

  export type OffersBackgroundUpdateOneRequiredWithoutEducationsNestedInput = {
    create?: XOR<OffersBackgroundCreateWithoutEducationsInput, OffersBackgroundUncheckedCreateWithoutEducationsInput>
    connectOrCreate?: OffersBackgroundCreateOrConnectWithoutEducationsInput
    upsert?: OffersBackgroundUpsertWithoutEducationsInput
    connect?: OffersBackgroundWhereUniqueInput
    update?: XOR<OffersBackgroundUpdateWithoutEducationsInput, OffersBackgroundUncheckedUpdateWithoutEducationsInput>
  }

  export type OffersReplyCreateNestedOneWithoutRepliesInput = {
    create?: XOR<OffersReplyCreateWithoutRepliesInput, OffersReplyUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: OffersReplyCreateOrConnectWithoutRepliesInput
    connect?: OffersReplyWhereUniqueInput
  }

  export type OffersReplyCreateNestedManyWithoutReplyingToInput = {
    create?: XOR<Enumerable<OffersReplyCreateWithoutReplyingToInput>, Enumerable<OffersReplyUncheckedCreateWithoutReplyingToInput>>
    connectOrCreate?: Enumerable<OffersReplyCreateOrConnectWithoutReplyingToInput>
    createMany?: OffersReplyCreateManyReplyingToInputEnvelope
    connect?: Enumerable<OffersReplyWhereUniqueInput>
  }

  export type OffersProfileCreateNestedOneWithoutDiscussionInput = {
    create?: XOR<OffersProfileCreateWithoutDiscussionInput, OffersProfileUncheckedCreateWithoutDiscussionInput>
    connectOrCreate?: OffersProfileCreateOrConnectWithoutDiscussionInput
    connect?: OffersProfileWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOffersDiscussionInput = {
    create?: XOR<UserCreateWithoutOffersDiscussionInput, UserUncheckedCreateWithoutOffersDiscussionInput>
    connectOrCreate?: UserCreateOrConnectWithoutOffersDiscussionInput
    connect?: UserWhereUniqueInput
  }

  export type OffersReplyUncheckedCreateNestedManyWithoutReplyingToInput = {
    create?: XOR<Enumerable<OffersReplyCreateWithoutReplyingToInput>, Enumerable<OffersReplyUncheckedCreateWithoutReplyingToInput>>
    connectOrCreate?: Enumerable<OffersReplyCreateOrConnectWithoutReplyingToInput>
    createMany?: OffersReplyCreateManyReplyingToInputEnvelope
    connect?: Enumerable<OffersReplyWhereUniqueInput>
  }

  export type OffersReplyUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<OffersReplyCreateWithoutRepliesInput, OffersReplyUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: OffersReplyCreateOrConnectWithoutRepliesInput
    upsert?: OffersReplyUpsertWithoutRepliesInput
    disconnect?: boolean
    delete?: boolean
    connect?: OffersReplyWhereUniqueInput
    update?: XOR<OffersReplyUpdateWithoutRepliesInput, OffersReplyUncheckedUpdateWithoutRepliesInput>
  }

  export type OffersReplyUpdateManyWithoutReplyingToNestedInput = {
    create?: XOR<Enumerable<OffersReplyCreateWithoutReplyingToInput>, Enumerable<OffersReplyUncheckedCreateWithoutReplyingToInput>>
    connectOrCreate?: Enumerable<OffersReplyCreateOrConnectWithoutReplyingToInput>
    upsert?: Enumerable<OffersReplyUpsertWithWhereUniqueWithoutReplyingToInput>
    createMany?: OffersReplyCreateManyReplyingToInputEnvelope
    set?: Enumerable<OffersReplyWhereUniqueInput>
    disconnect?: Enumerable<OffersReplyWhereUniqueInput>
    delete?: Enumerable<OffersReplyWhereUniqueInput>
    connect?: Enumerable<OffersReplyWhereUniqueInput>
    update?: Enumerable<OffersReplyUpdateWithWhereUniqueWithoutReplyingToInput>
    updateMany?: Enumerable<OffersReplyUpdateManyWithWhereWithoutReplyingToInput>
    deleteMany?: Enumerable<OffersReplyScalarWhereInput>
  }

  export type OffersProfileUpdateOneRequiredWithoutDiscussionNestedInput = {
    create?: XOR<OffersProfileCreateWithoutDiscussionInput, OffersProfileUncheckedCreateWithoutDiscussionInput>
    connectOrCreate?: OffersProfileCreateOrConnectWithoutDiscussionInput
    upsert?: OffersProfileUpsertWithoutDiscussionInput
    connect?: OffersProfileWhereUniqueInput
    update?: XOR<OffersProfileUpdateWithoutDiscussionInput, OffersProfileUncheckedUpdateWithoutDiscussionInput>
  }

  export type UserUpdateOneWithoutOffersDiscussionNestedInput = {
    create?: XOR<UserCreateWithoutOffersDiscussionInput, UserUncheckedCreateWithoutOffersDiscussionInput>
    connectOrCreate?: UserCreateOrConnectWithoutOffersDiscussionInput
    upsert?: UserUpsertWithoutOffersDiscussionInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutOffersDiscussionInput, UserUncheckedUpdateWithoutOffersDiscussionInput>
  }

  export type OffersReplyUncheckedUpdateManyWithoutReplyingToNestedInput = {
    create?: XOR<Enumerable<OffersReplyCreateWithoutReplyingToInput>, Enumerable<OffersReplyUncheckedCreateWithoutReplyingToInput>>
    connectOrCreate?: Enumerable<OffersReplyCreateOrConnectWithoutReplyingToInput>
    upsert?: Enumerable<OffersReplyUpsertWithWhereUniqueWithoutReplyingToInput>
    createMany?: OffersReplyCreateManyReplyingToInputEnvelope
    set?: Enumerable<OffersReplyWhereUniqueInput>
    disconnect?: Enumerable<OffersReplyWhereUniqueInput>
    delete?: Enumerable<OffersReplyWhereUniqueInput>
    connect?: Enumerable<OffersReplyWhereUniqueInput>
    update?: Enumerable<OffersReplyUpdateWithWhereUniqueWithoutReplyingToInput>
    updateMany?: Enumerable<OffersReplyUpdateManyWithWhereWithoutReplyingToInput>
    deleteMany?: Enumerable<OffersReplyScalarWhereInput>
  }

  export type OffersProfileCreateNestedOneWithoutOffersInput = {
    create?: XOR<OffersProfileCreateWithoutOffersInput, OffersProfileUncheckedCreateWithoutOffersInput>
    connectOrCreate?: OffersProfileCreateOrConnectWithoutOffersInput
    connect?: OffersProfileWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutOffersOfferInput = {
    create?: XOR<CompanyCreateWithoutOffersOfferInput, CompanyUncheckedCreateWithoutOffersOfferInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutOffersOfferInput
    connect?: CompanyWhereUniqueInput
  }

  export type CityCreateNestedOneWithoutOffersOfferInput = {
    create?: XOR<CityCreateWithoutOffersOfferInput, CityUncheckedCreateWithoutOffersOfferInput>
    connectOrCreate?: CityCreateOrConnectWithoutOffersOfferInput
    connect?: CityWhereUniqueInput
  }

  export type OffersInternCreateNestedOneWithoutOffersOfferInput = {
    create?: XOR<OffersInternCreateWithoutOffersOfferInput, OffersInternUncheckedCreateWithoutOffersOfferInput>
    connectOrCreate?: OffersInternCreateOrConnectWithoutOffersOfferInput
    connect?: OffersInternWhereUniqueInput
  }

  export type OffersFullTimeCreateNestedOneWithoutOffersOfferInput = {
    create?: XOR<OffersFullTimeCreateWithoutOffersOfferInput, OffersFullTimeUncheckedCreateWithoutOffersOfferInput>
    connectOrCreate?: OffersFullTimeCreateOrConnectWithoutOffersOfferInput
    connect?: OffersFullTimeWhereUniqueInput
  }

  export type OffersAnalysisCreateNestedOneWithoutOverallHighestOfferInput = {
    create?: XOR<OffersAnalysisCreateWithoutOverallHighestOfferInput, OffersAnalysisUncheckedCreateWithoutOverallHighestOfferInput>
    connectOrCreate?: OffersAnalysisCreateOrConnectWithoutOverallHighestOfferInput
    connect?: OffersAnalysisWhereUniqueInput
  }

  export type OffersAnalysisUnitCreateNestedManyWithoutTopSimilarOffersInput = {
    create?: XOR<Enumerable<OffersAnalysisUnitCreateWithoutTopSimilarOffersInput>, Enumerable<OffersAnalysisUnitUncheckedCreateWithoutTopSimilarOffersInput>>
    connectOrCreate?: Enumerable<OffersAnalysisUnitCreateOrConnectWithoutTopSimilarOffersInput>
    connect?: Enumerable<OffersAnalysisUnitWhereUniqueInput>
  }

  export type OffersAnalysisUnitCreateNestedManyWithoutAnalysedOfferInput = {
    create?: XOR<Enumerable<OffersAnalysisUnitCreateWithoutAnalysedOfferInput>, Enumerable<OffersAnalysisUnitUncheckedCreateWithoutAnalysedOfferInput>>
    connectOrCreate?: Enumerable<OffersAnalysisUnitCreateOrConnectWithoutAnalysedOfferInput>
    createMany?: OffersAnalysisUnitCreateManyAnalysedOfferInputEnvelope
    connect?: Enumerable<OffersAnalysisUnitWhereUniqueInput>
  }

  export type OffersAnalysisUncheckedCreateNestedOneWithoutOverallHighestOfferInput = {
    create?: XOR<OffersAnalysisCreateWithoutOverallHighestOfferInput, OffersAnalysisUncheckedCreateWithoutOverallHighestOfferInput>
    connectOrCreate?: OffersAnalysisCreateOrConnectWithoutOverallHighestOfferInput
    connect?: OffersAnalysisWhereUniqueInput
  }

  export type OffersAnalysisUnitUncheckedCreateNestedManyWithoutTopSimilarOffersInput = {
    create?: XOR<Enumerable<OffersAnalysisUnitCreateWithoutTopSimilarOffersInput>, Enumerable<OffersAnalysisUnitUncheckedCreateWithoutTopSimilarOffersInput>>
    connectOrCreate?: Enumerable<OffersAnalysisUnitCreateOrConnectWithoutTopSimilarOffersInput>
    connect?: Enumerable<OffersAnalysisUnitWhereUniqueInput>
  }

  export type OffersAnalysisUnitUncheckedCreateNestedManyWithoutAnalysedOfferInput = {
    create?: XOR<Enumerable<OffersAnalysisUnitCreateWithoutAnalysedOfferInput>, Enumerable<OffersAnalysisUnitUncheckedCreateWithoutAnalysedOfferInput>>
    connectOrCreate?: Enumerable<OffersAnalysisUnitCreateOrConnectWithoutAnalysedOfferInput>
    createMany?: OffersAnalysisUnitCreateManyAnalysedOfferInputEnvelope
    connect?: Enumerable<OffersAnalysisUnitWhereUniqueInput>
  }

  export type OffersProfileUpdateOneRequiredWithoutOffersNestedInput = {
    create?: XOR<OffersProfileCreateWithoutOffersInput, OffersProfileUncheckedCreateWithoutOffersInput>
    connectOrCreate?: OffersProfileCreateOrConnectWithoutOffersInput
    upsert?: OffersProfileUpsertWithoutOffersInput
    connect?: OffersProfileWhereUniqueInput
    update?: XOR<OffersProfileUpdateWithoutOffersInput, OffersProfileUncheckedUpdateWithoutOffersInput>
  }

  export type CompanyUpdateOneRequiredWithoutOffersOfferNestedInput = {
    create?: XOR<CompanyCreateWithoutOffersOfferInput, CompanyUncheckedCreateWithoutOffersOfferInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutOffersOfferInput
    upsert?: CompanyUpsertWithoutOffersOfferInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<CompanyUpdateWithoutOffersOfferInput, CompanyUncheckedUpdateWithoutOffersOfferInput>
  }

  export type CityUpdateOneRequiredWithoutOffersOfferNestedInput = {
    create?: XOR<CityCreateWithoutOffersOfferInput, CityUncheckedCreateWithoutOffersOfferInput>
    connectOrCreate?: CityCreateOrConnectWithoutOffersOfferInput
    upsert?: CityUpsertWithoutOffersOfferInput
    connect?: CityWhereUniqueInput
    update?: XOR<CityUpdateWithoutOffersOfferInput, CityUncheckedUpdateWithoutOffersOfferInput>
  }

  export type EnumJobTypeFieldUpdateOperationsInput = {
    set?: JobType
  }

  export type OffersInternUpdateOneWithoutOffersOfferNestedInput = {
    create?: XOR<OffersInternCreateWithoutOffersOfferInput, OffersInternUncheckedCreateWithoutOffersOfferInput>
    connectOrCreate?: OffersInternCreateOrConnectWithoutOffersOfferInput
    upsert?: OffersInternUpsertWithoutOffersOfferInput
    disconnect?: boolean
    delete?: boolean
    connect?: OffersInternWhereUniqueInput
    update?: XOR<OffersInternUpdateWithoutOffersOfferInput, OffersInternUncheckedUpdateWithoutOffersOfferInput>
  }

  export type OffersFullTimeUpdateOneWithoutOffersOfferNestedInput = {
    create?: XOR<OffersFullTimeCreateWithoutOffersOfferInput, OffersFullTimeUncheckedCreateWithoutOffersOfferInput>
    connectOrCreate?: OffersFullTimeCreateOrConnectWithoutOffersOfferInput
    upsert?: OffersFullTimeUpsertWithoutOffersOfferInput
    disconnect?: boolean
    delete?: boolean
    connect?: OffersFullTimeWhereUniqueInput
    update?: XOR<OffersFullTimeUpdateWithoutOffersOfferInput, OffersFullTimeUncheckedUpdateWithoutOffersOfferInput>
  }

  export type OffersAnalysisUpdateOneWithoutOverallHighestOfferNestedInput = {
    create?: XOR<OffersAnalysisCreateWithoutOverallHighestOfferInput, OffersAnalysisUncheckedCreateWithoutOverallHighestOfferInput>
    connectOrCreate?: OffersAnalysisCreateOrConnectWithoutOverallHighestOfferInput
    upsert?: OffersAnalysisUpsertWithoutOverallHighestOfferInput
    disconnect?: boolean
    delete?: boolean
    connect?: OffersAnalysisWhereUniqueInput
    update?: XOR<OffersAnalysisUpdateWithoutOverallHighestOfferInput, OffersAnalysisUncheckedUpdateWithoutOverallHighestOfferInput>
  }

  export type OffersAnalysisUnitUpdateManyWithoutTopSimilarOffersNestedInput = {
    create?: XOR<Enumerable<OffersAnalysisUnitCreateWithoutTopSimilarOffersInput>, Enumerable<OffersAnalysisUnitUncheckedCreateWithoutTopSimilarOffersInput>>
    connectOrCreate?: Enumerable<OffersAnalysisUnitCreateOrConnectWithoutTopSimilarOffersInput>
    upsert?: Enumerable<OffersAnalysisUnitUpsertWithWhereUniqueWithoutTopSimilarOffersInput>
    set?: Enumerable<OffersAnalysisUnitWhereUniqueInput>
    disconnect?: Enumerable<OffersAnalysisUnitWhereUniqueInput>
    delete?: Enumerable<OffersAnalysisUnitWhereUniqueInput>
    connect?: Enumerable<OffersAnalysisUnitWhereUniqueInput>
    update?: Enumerable<OffersAnalysisUnitUpdateWithWhereUniqueWithoutTopSimilarOffersInput>
    updateMany?: Enumerable<OffersAnalysisUnitUpdateManyWithWhereWithoutTopSimilarOffersInput>
    deleteMany?: Enumerable<OffersAnalysisUnitScalarWhereInput>
  }

  export type OffersAnalysisUnitUpdateManyWithoutAnalysedOfferNestedInput = {
    create?: XOR<Enumerable<OffersAnalysisUnitCreateWithoutAnalysedOfferInput>, Enumerable<OffersAnalysisUnitUncheckedCreateWithoutAnalysedOfferInput>>
    connectOrCreate?: Enumerable<OffersAnalysisUnitCreateOrConnectWithoutAnalysedOfferInput>
    upsert?: Enumerable<OffersAnalysisUnitUpsertWithWhereUniqueWithoutAnalysedOfferInput>
    createMany?: OffersAnalysisUnitCreateManyAnalysedOfferInputEnvelope
    set?: Enumerable<OffersAnalysisUnitWhereUniqueInput>
    disconnect?: Enumerable<OffersAnalysisUnitWhereUniqueInput>
    delete?: Enumerable<OffersAnalysisUnitWhereUniqueInput>
    connect?: Enumerable<OffersAnalysisUnitWhereUniqueInput>
    update?: Enumerable<OffersAnalysisUnitUpdateWithWhereUniqueWithoutAnalysedOfferInput>
    updateMany?: Enumerable<OffersAnalysisUnitUpdateManyWithWhereWithoutAnalysedOfferInput>
    deleteMany?: Enumerable<OffersAnalysisUnitScalarWhereInput>
  }

  export type OffersAnalysisUncheckedUpdateOneWithoutOverallHighestOfferNestedInput = {
    create?: XOR<OffersAnalysisCreateWithoutOverallHighestOfferInput, OffersAnalysisUncheckedCreateWithoutOverallHighestOfferInput>
    connectOrCreate?: OffersAnalysisCreateOrConnectWithoutOverallHighestOfferInput
    upsert?: OffersAnalysisUpsertWithoutOverallHighestOfferInput
    disconnect?: boolean
    delete?: boolean
    connect?: OffersAnalysisWhereUniqueInput
    update?: XOR<OffersAnalysisUpdateWithoutOverallHighestOfferInput, OffersAnalysisUncheckedUpdateWithoutOverallHighestOfferInput>
  }

  export type OffersAnalysisUnitUncheckedUpdateManyWithoutTopSimilarOffersNestedInput = {
    create?: XOR<Enumerable<OffersAnalysisUnitCreateWithoutTopSimilarOffersInput>, Enumerable<OffersAnalysisUnitUncheckedCreateWithoutTopSimilarOffersInput>>
    connectOrCreate?: Enumerable<OffersAnalysisUnitCreateOrConnectWithoutTopSimilarOffersInput>
    upsert?: Enumerable<OffersAnalysisUnitUpsertWithWhereUniqueWithoutTopSimilarOffersInput>
    set?: Enumerable<OffersAnalysisUnitWhereUniqueInput>
    disconnect?: Enumerable<OffersAnalysisUnitWhereUniqueInput>
    delete?: Enumerable<OffersAnalysisUnitWhereUniqueInput>
    connect?: Enumerable<OffersAnalysisUnitWhereUniqueInput>
    update?: Enumerable<OffersAnalysisUnitUpdateWithWhereUniqueWithoutTopSimilarOffersInput>
    updateMany?: Enumerable<OffersAnalysisUnitUpdateManyWithWhereWithoutTopSimilarOffersInput>
    deleteMany?: Enumerable<OffersAnalysisUnitScalarWhereInput>
  }

  export type OffersAnalysisUnitUncheckedUpdateManyWithoutAnalysedOfferNestedInput = {
    create?: XOR<Enumerable<OffersAnalysisUnitCreateWithoutAnalysedOfferInput>, Enumerable<OffersAnalysisUnitUncheckedCreateWithoutAnalysedOfferInput>>
    connectOrCreate?: Enumerable<OffersAnalysisUnitCreateOrConnectWithoutAnalysedOfferInput>
    upsert?: Enumerable<OffersAnalysisUnitUpsertWithWhereUniqueWithoutAnalysedOfferInput>
    createMany?: OffersAnalysisUnitCreateManyAnalysedOfferInputEnvelope
    set?: Enumerable<OffersAnalysisUnitWhereUniqueInput>
    disconnect?: Enumerable<OffersAnalysisUnitWhereUniqueInput>
    delete?: Enumerable<OffersAnalysisUnitWhereUniqueInput>
    connect?: Enumerable<OffersAnalysisUnitWhereUniqueInput>
    update?: Enumerable<OffersAnalysisUnitUpdateWithWhereUniqueWithoutAnalysedOfferInput>
    updateMany?: Enumerable<OffersAnalysisUnitUpdateManyWithWhereWithoutAnalysedOfferInput>
    deleteMany?: Enumerable<OffersAnalysisUnitScalarWhereInput>
  }

  export type OffersCurrencyCreateNestedOneWithoutOffersMonthlySalaryInput = {
    create?: XOR<OffersCurrencyCreateWithoutOffersMonthlySalaryInput, OffersCurrencyUncheckedCreateWithoutOffersMonthlySalaryInput>
    connectOrCreate?: OffersCurrencyCreateOrConnectWithoutOffersMonthlySalaryInput
    connect?: OffersCurrencyWhereUniqueInput
  }

  export type OffersOfferCreateNestedOneWithoutOffersInternInput = {
    create?: XOR<OffersOfferCreateWithoutOffersInternInput, OffersOfferUncheckedCreateWithoutOffersInternInput>
    connectOrCreate?: OffersOfferCreateOrConnectWithoutOffersInternInput
    connect?: OffersOfferWhereUniqueInput
  }

  export type OffersOfferUncheckedCreateNestedOneWithoutOffersInternInput = {
    create?: XOR<OffersOfferCreateWithoutOffersInternInput, OffersOfferUncheckedCreateWithoutOffersInternInput>
    connectOrCreate?: OffersOfferCreateOrConnectWithoutOffersInternInput
    connect?: OffersOfferWhereUniqueInput
  }

  export type OffersCurrencyUpdateOneRequiredWithoutOffersMonthlySalaryNestedInput = {
    create?: XOR<OffersCurrencyCreateWithoutOffersMonthlySalaryInput, OffersCurrencyUncheckedCreateWithoutOffersMonthlySalaryInput>
    connectOrCreate?: OffersCurrencyCreateOrConnectWithoutOffersMonthlySalaryInput
    upsert?: OffersCurrencyUpsertWithoutOffersMonthlySalaryInput
    connect?: OffersCurrencyWhereUniqueInput
    update?: XOR<OffersCurrencyUpdateWithoutOffersMonthlySalaryInput, OffersCurrencyUncheckedUpdateWithoutOffersMonthlySalaryInput>
  }

  export type OffersOfferUpdateOneWithoutOffersInternNestedInput = {
    create?: XOR<OffersOfferCreateWithoutOffersInternInput, OffersOfferUncheckedCreateWithoutOffersInternInput>
    connectOrCreate?: OffersOfferCreateOrConnectWithoutOffersInternInput
    upsert?: OffersOfferUpsertWithoutOffersInternInput
    disconnect?: boolean
    delete?: boolean
    connect?: OffersOfferWhereUniqueInput
    update?: XOR<OffersOfferUpdateWithoutOffersInternInput, OffersOfferUncheckedUpdateWithoutOffersInternInput>
  }

  export type OffersOfferUncheckedUpdateOneWithoutOffersInternNestedInput = {
    create?: XOR<OffersOfferCreateWithoutOffersInternInput, OffersOfferUncheckedCreateWithoutOffersInternInput>
    connectOrCreate?: OffersOfferCreateOrConnectWithoutOffersInternInput
    upsert?: OffersOfferUpsertWithoutOffersInternInput
    disconnect?: boolean
    delete?: boolean
    connect?: OffersOfferWhereUniqueInput
    update?: XOR<OffersOfferUpdateWithoutOffersInternInput, OffersOfferUncheckedUpdateWithoutOffersInternInput>
  }

  export type OffersCurrencyCreateNestedOneWithoutOffersTotalCompensationInput = {
    create?: XOR<OffersCurrencyCreateWithoutOffersTotalCompensationInput, OffersCurrencyUncheckedCreateWithoutOffersTotalCompensationInput>
    connectOrCreate?: OffersCurrencyCreateOrConnectWithoutOffersTotalCompensationInput
    connect?: OffersCurrencyWhereUniqueInput
  }

  export type OffersCurrencyCreateNestedOneWithoutOffersBaseSalaryInput = {
    create?: XOR<OffersCurrencyCreateWithoutOffersBaseSalaryInput, OffersCurrencyUncheckedCreateWithoutOffersBaseSalaryInput>
    connectOrCreate?: OffersCurrencyCreateOrConnectWithoutOffersBaseSalaryInput
    connect?: OffersCurrencyWhereUniqueInput
  }

  export type OffersCurrencyCreateNestedOneWithoutOffersBonusInput = {
    create?: XOR<OffersCurrencyCreateWithoutOffersBonusInput, OffersCurrencyUncheckedCreateWithoutOffersBonusInput>
    connectOrCreate?: OffersCurrencyCreateOrConnectWithoutOffersBonusInput
    connect?: OffersCurrencyWhereUniqueInput
  }

  export type OffersCurrencyCreateNestedOneWithoutOffersStocksInput = {
    create?: XOR<OffersCurrencyCreateWithoutOffersStocksInput, OffersCurrencyUncheckedCreateWithoutOffersStocksInput>
    connectOrCreate?: OffersCurrencyCreateOrConnectWithoutOffersStocksInput
    connect?: OffersCurrencyWhereUniqueInput
  }

  export type OffersOfferCreateNestedOneWithoutOffersFullTimeInput = {
    create?: XOR<OffersOfferCreateWithoutOffersFullTimeInput, OffersOfferUncheckedCreateWithoutOffersFullTimeInput>
    connectOrCreate?: OffersOfferCreateOrConnectWithoutOffersFullTimeInput
    connect?: OffersOfferWhereUniqueInput
  }

  export type OffersOfferUncheckedCreateNestedOneWithoutOffersFullTimeInput = {
    create?: XOR<OffersOfferCreateWithoutOffersFullTimeInput, OffersOfferUncheckedCreateWithoutOffersFullTimeInput>
    connectOrCreate?: OffersOfferCreateOrConnectWithoutOffersFullTimeInput
    connect?: OffersOfferWhereUniqueInput
  }

  export type OffersCurrencyUpdateOneRequiredWithoutOffersTotalCompensationNestedInput = {
    create?: XOR<OffersCurrencyCreateWithoutOffersTotalCompensationInput, OffersCurrencyUncheckedCreateWithoutOffersTotalCompensationInput>
    connectOrCreate?: OffersCurrencyCreateOrConnectWithoutOffersTotalCompensationInput
    upsert?: OffersCurrencyUpsertWithoutOffersTotalCompensationInput
    connect?: OffersCurrencyWhereUniqueInput
    update?: XOR<OffersCurrencyUpdateWithoutOffersTotalCompensationInput, OffersCurrencyUncheckedUpdateWithoutOffersTotalCompensationInput>
  }

  export type OffersCurrencyUpdateOneWithoutOffersBaseSalaryNestedInput = {
    create?: XOR<OffersCurrencyCreateWithoutOffersBaseSalaryInput, OffersCurrencyUncheckedCreateWithoutOffersBaseSalaryInput>
    connectOrCreate?: OffersCurrencyCreateOrConnectWithoutOffersBaseSalaryInput
    upsert?: OffersCurrencyUpsertWithoutOffersBaseSalaryInput
    disconnect?: boolean
    delete?: boolean
    connect?: OffersCurrencyWhereUniqueInput
    update?: XOR<OffersCurrencyUpdateWithoutOffersBaseSalaryInput, OffersCurrencyUncheckedUpdateWithoutOffersBaseSalaryInput>
  }

  export type OffersCurrencyUpdateOneWithoutOffersBonusNestedInput = {
    create?: XOR<OffersCurrencyCreateWithoutOffersBonusInput, OffersCurrencyUncheckedCreateWithoutOffersBonusInput>
    connectOrCreate?: OffersCurrencyCreateOrConnectWithoutOffersBonusInput
    upsert?: OffersCurrencyUpsertWithoutOffersBonusInput
    disconnect?: boolean
    delete?: boolean
    connect?: OffersCurrencyWhereUniqueInput
    update?: XOR<OffersCurrencyUpdateWithoutOffersBonusInput, OffersCurrencyUncheckedUpdateWithoutOffersBonusInput>
  }

  export type OffersCurrencyUpdateOneWithoutOffersStocksNestedInput = {
    create?: XOR<OffersCurrencyCreateWithoutOffersStocksInput, OffersCurrencyUncheckedCreateWithoutOffersStocksInput>
    connectOrCreate?: OffersCurrencyCreateOrConnectWithoutOffersStocksInput
    upsert?: OffersCurrencyUpsertWithoutOffersStocksInput
    disconnect?: boolean
    delete?: boolean
    connect?: OffersCurrencyWhereUniqueInput
    update?: XOR<OffersCurrencyUpdateWithoutOffersStocksInput, OffersCurrencyUncheckedUpdateWithoutOffersStocksInput>
  }

  export type OffersOfferUpdateOneWithoutOffersFullTimeNestedInput = {
    create?: XOR<OffersOfferCreateWithoutOffersFullTimeInput, OffersOfferUncheckedCreateWithoutOffersFullTimeInput>
    connectOrCreate?: OffersOfferCreateOrConnectWithoutOffersFullTimeInput
    upsert?: OffersOfferUpsertWithoutOffersFullTimeInput
    disconnect?: boolean
    delete?: boolean
    connect?: OffersOfferWhereUniqueInput
    update?: XOR<OffersOfferUpdateWithoutOffersFullTimeInput, OffersOfferUncheckedUpdateWithoutOffersFullTimeInput>
  }

  export type OffersOfferUncheckedUpdateOneWithoutOffersFullTimeNestedInput = {
    create?: XOR<OffersOfferCreateWithoutOffersFullTimeInput, OffersOfferUncheckedCreateWithoutOffersFullTimeInput>
    connectOrCreate?: OffersOfferCreateOrConnectWithoutOffersFullTimeInput
    upsert?: OffersOfferUpsertWithoutOffersFullTimeInput
    disconnect?: boolean
    delete?: boolean
    connect?: OffersOfferWhereUniqueInput
    update?: XOR<OffersOfferUpdateWithoutOffersFullTimeInput, OffersOfferUncheckedUpdateWithoutOffersFullTimeInput>
  }

  export type OffersProfileCreateNestedOneWithoutAnalysisInput = {
    create?: XOR<OffersProfileCreateWithoutAnalysisInput, OffersProfileUncheckedCreateWithoutAnalysisInput>
    connectOrCreate?: OffersProfileCreateOrConnectWithoutAnalysisInput
    connect?: OffersProfileWhereUniqueInput
  }

  export type OffersOfferCreateNestedOneWithoutOffersAnalysisInput = {
    create?: XOR<OffersOfferCreateWithoutOffersAnalysisInput, OffersOfferUncheckedCreateWithoutOffersAnalysisInput>
    connectOrCreate?: OffersOfferCreateOrConnectWithoutOffersAnalysisInput
    connect?: OffersOfferWhereUniqueInput
  }

  export type OffersAnalysisUnitCreateNestedOneWithoutOffersAnalysisOverallInput = {
    create?: XOR<OffersAnalysisUnitCreateWithoutOffersAnalysisOverallInput, OffersAnalysisUnitUncheckedCreateWithoutOffersAnalysisOverallInput>
    connectOrCreate?: OffersAnalysisUnitCreateOrConnectWithoutOffersAnalysisOverallInput
    connect?: OffersAnalysisUnitWhereUniqueInput
  }

  export type OffersAnalysisUnitCreateNestedManyWithoutOffersAnalysisCompanyInput = {
    create?: XOR<Enumerable<OffersAnalysisUnitCreateWithoutOffersAnalysisCompanyInput>, Enumerable<OffersAnalysisUnitUncheckedCreateWithoutOffersAnalysisCompanyInput>>
    connectOrCreate?: Enumerable<OffersAnalysisUnitCreateOrConnectWithoutOffersAnalysisCompanyInput>
    connect?: Enumerable<OffersAnalysisUnitWhereUniqueInput>
  }

  export type OffersAnalysisUnitUncheckedCreateNestedManyWithoutOffersAnalysisCompanyInput = {
    create?: XOR<Enumerable<OffersAnalysisUnitCreateWithoutOffersAnalysisCompanyInput>, Enumerable<OffersAnalysisUnitUncheckedCreateWithoutOffersAnalysisCompanyInput>>
    connectOrCreate?: Enumerable<OffersAnalysisUnitCreateOrConnectWithoutOffersAnalysisCompanyInput>
    connect?: Enumerable<OffersAnalysisUnitWhereUniqueInput>
  }

  export type OffersProfileUpdateOneRequiredWithoutAnalysisNestedInput = {
    create?: XOR<OffersProfileCreateWithoutAnalysisInput, OffersProfileUncheckedCreateWithoutAnalysisInput>
    connectOrCreate?: OffersProfileCreateOrConnectWithoutAnalysisInput
    upsert?: OffersProfileUpsertWithoutAnalysisInput
    connect?: OffersProfileWhereUniqueInput
    update?: XOR<OffersProfileUpdateWithoutAnalysisInput, OffersProfileUncheckedUpdateWithoutAnalysisInput>
  }

  export type OffersOfferUpdateOneRequiredWithoutOffersAnalysisNestedInput = {
    create?: XOR<OffersOfferCreateWithoutOffersAnalysisInput, OffersOfferUncheckedCreateWithoutOffersAnalysisInput>
    connectOrCreate?: OffersOfferCreateOrConnectWithoutOffersAnalysisInput
    upsert?: OffersOfferUpsertWithoutOffersAnalysisInput
    connect?: OffersOfferWhereUniqueInput
    update?: XOR<OffersOfferUpdateWithoutOffersAnalysisInput, OffersOfferUncheckedUpdateWithoutOffersAnalysisInput>
  }

  export type OffersAnalysisUnitUpdateOneRequiredWithoutOffersAnalysisOverallNestedInput = {
    create?: XOR<OffersAnalysisUnitCreateWithoutOffersAnalysisOverallInput, OffersAnalysisUnitUncheckedCreateWithoutOffersAnalysisOverallInput>
    connectOrCreate?: OffersAnalysisUnitCreateOrConnectWithoutOffersAnalysisOverallInput
    upsert?: OffersAnalysisUnitUpsertWithoutOffersAnalysisOverallInput
    connect?: OffersAnalysisUnitWhereUniqueInput
    update?: XOR<OffersAnalysisUnitUpdateWithoutOffersAnalysisOverallInput, OffersAnalysisUnitUncheckedUpdateWithoutOffersAnalysisOverallInput>
  }

  export type OffersAnalysisUnitUpdateManyWithoutOffersAnalysisCompanyNestedInput = {
    create?: XOR<Enumerable<OffersAnalysisUnitCreateWithoutOffersAnalysisCompanyInput>, Enumerable<OffersAnalysisUnitUncheckedCreateWithoutOffersAnalysisCompanyInput>>
    connectOrCreate?: Enumerable<OffersAnalysisUnitCreateOrConnectWithoutOffersAnalysisCompanyInput>
    upsert?: Enumerable<OffersAnalysisUnitUpsertWithWhereUniqueWithoutOffersAnalysisCompanyInput>
    set?: Enumerable<OffersAnalysisUnitWhereUniqueInput>
    disconnect?: Enumerable<OffersAnalysisUnitWhereUniqueInput>
    delete?: Enumerable<OffersAnalysisUnitWhereUniqueInput>
    connect?: Enumerable<OffersAnalysisUnitWhereUniqueInput>
    update?: Enumerable<OffersAnalysisUnitUpdateWithWhereUniqueWithoutOffersAnalysisCompanyInput>
    updateMany?: Enumerable<OffersAnalysisUnitUpdateManyWithWhereWithoutOffersAnalysisCompanyInput>
    deleteMany?: Enumerable<OffersAnalysisUnitScalarWhereInput>
  }

  export type OffersAnalysisUnitUncheckedUpdateManyWithoutOffersAnalysisCompanyNestedInput = {
    create?: XOR<Enumerable<OffersAnalysisUnitCreateWithoutOffersAnalysisCompanyInput>, Enumerable<OffersAnalysisUnitUncheckedCreateWithoutOffersAnalysisCompanyInput>>
    connectOrCreate?: Enumerable<OffersAnalysisUnitCreateOrConnectWithoutOffersAnalysisCompanyInput>
    upsert?: Enumerable<OffersAnalysisUnitUpsertWithWhereUniqueWithoutOffersAnalysisCompanyInput>
    set?: Enumerable<OffersAnalysisUnitWhereUniqueInput>
    disconnect?: Enumerable<OffersAnalysisUnitWhereUniqueInput>
    delete?: Enumerable<OffersAnalysisUnitWhereUniqueInput>
    connect?: Enumerable<OffersAnalysisUnitWhereUniqueInput>
    update?: Enumerable<OffersAnalysisUnitUpdateWithWhereUniqueWithoutOffersAnalysisCompanyInput>
    updateMany?: Enumerable<OffersAnalysisUnitUpdateManyWithWhereWithoutOffersAnalysisCompanyInput>
    deleteMany?: Enumerable<OffersAnalysisUnitScalarWhereInput>
  }

  export type OffersOfferCreateNestedOneWithoutOffersAnalysisUnitInput = {
    create?: XOR<OffersOfferCreateWithoutOffersAnalysisUnitInput, OffersOfferUncheckedCreateWithoutOffersAnalysisUnitInput>
    connectOrCreate?: OffersOfferCreateOrConnectWithoutOffersAnalysisUnitInput
    connect?: OffersOfferWhereUniqueInput
  }

  export type OffersOfferCreateNestedManyWithoutOffersAnalysisUnitInput = {
    create?: XOR<Enumerable<OffersOfferCreateWithoutOffersAnalysisUnitInput>, Enumerable<OffersOfferUncheckedCreateWithoutOffersAnalysisUnitInput>>
    connectOrCreate?: Enumerable<OffersOfferCreateOrConnectWithoutOffersAnalysisUnitInput>
    connect?: Enumerable<OffersOfferWhereUniqueInput>
  }

  export type OffersAnalysisCreateNestedManyWithoutOverallAnalysisInput = {
    create?: XOR<Enumerable<OffersAnalysisCreateWithoutOverallAnalysisInput>, Enumerable<OffersAnalysisUncheckedCreateWithoutOverallAnalysisInput>>
    connectOrCreate?: Enumerable<OffersAnalysisCreateOrConnectWithoutOverallAnalysisInput>
    createMany?: OffersAnalysisCreateManyOverallAnalysisInputEnvelope
    connect?: Enumerable<OffersAnalysisWhereUniqueInput>
  }

  export type OffersAnalysisCreateNestedManyWithoutCompanyAnalysisInput = {
    create?: XOR<Enumerable<OffersAnalysisCreateWithoutCompanyAnalysisInput>, Enumerable<OffersAnalysisUncheckedCreateWithoutCompanyAnalysisInput>>
    connectOrCreate?: Enumerable<OffersAnalysisCreateOrConnectWithoutCompanyAnalysisInput>
    connect?: Enumerable<OffersAnalysisWhereUniqueInput>
  }

  export type OffersOfferUncheckedCreateNestedManyWithoutOffersAnalysisUnitInput = {
    create?: XOR<Enumerable<OffersOfferCreateWithoutOffersAnalysisUnitInput>, Enumerable<OffersOfferUncheckedCreateWithoutOffersAnalysisUnitInput>>
    connectOrCreate?: Enumerable<OffersOfferCreateOrConnectWithoutOffersAnalysisUnitInput>
    connect?: Enumerable<OffersOfferWhereUniqueInput>
  }

  export type OffersAnalysisUncheckedCreateNestedManyWithoutOverallAnalysisInput = {
    create?: XOR<Enumerable<OffersAnalysisCreateWithoutOverallAnalysisInput>, Enumerable<OffersAnalysisUncheckedCreateWithoutOverallAnalysisInput>>
    connectOrCreate?: Enumerable<OffersAnalysisCreateOrConnectWithoutOverallAnalysisInput>
    createMany?: OffersAnalysisCreateManyOverallAnalysisInputEnvelope
    connect?: Enumerable<OffersAnalysisWhereUniqueInput>
  }

  export type OffersAnalysisUncheckedCreateNestedManyWithoutCompanyAnalysisInput = {
    create?: XOR<Enumerable<OffersAnalysisCreateWithoutCompanyAnalysisInput>, Enumerable<OffersAnalysisUncheckedCreateWithoutCompanyAnalysisInput>>
    connectOrCreate?: Enumerable<OffersAnalysisCreateOrConnectWithoutCompanyAnalysisInput>
    connect?: Enumerable<OffersAnalysisWhereUniqueInput>
  }

  export type OffersOfferUpdateOneRequiredWithoutOffersAnalysisUnitNestedInput = {
    create?: XOR<OffersOfferCreateWithoutOffersAnalysisUnitInput, OffersOfferUncheckedCreateWithoutOffersAnalysisUnitInput>
    connectOrCreate?: OffersOfferCreateOrConnectWithoutOffersAnalysisUnitInput
    upsert?: OffersOfferUpsertWithoutOffersAnalysisUnitInput
    connect?: OffersOfferWhereUniqueInput
    update?: XOR<OffersOfferUpdateWithoutOffersAnalysisUnitInput, OffersOfferUncheckedUpdateWithoutOffersAnalysisUnitInput>
  }

  export type OffersOfferUpdateManyWithoutOffersAnalysisUnitNestedInput = {
    create?: XOR<Enumerable<OffersOfferCreateWithoutOffersAnalysisUnitInput>, Enumerable<OffersOfferUncheckedCreateWithoutOffersAnalysisUnitInput>>
    connectOrCreate?: Enumerable<OffersOfferCreateOrConnectWithoutOffersAnalysisUnitInput>
    upsert?: Enumerable<OffersOfferUpsertWithWhereUniqueWithoutOffersAnalysisUnitInput>
    set?: Enumerable<OffersOfferWhereUniqueInput>
    disconnect?: Enumerable<OffersOfferWhereUniqueInput>
    delete?: Enumerable<OffersOfferWhereUniqueInput>
    connect?: Enumerable<OffersOfferWhereUniqueInput>
    update?: Enumerable<OffersOfferUpdateWithWhereUniqueWithoutOffersAnalysisUnitInput>
    updateMany?: Enumerable<OffersOfferUpdateManyWithWhereWithoutOffersAnalysisUnitInput>
    deleteMany?: Enumerable<OffersOfferScalarWhereInput>
  }

  export type OffersAnalysisUpdateManyWithoutOverallAnalysisNestedInput = {
    create?: XOR<Enumerable<OffersAnalysisCreateWithoutOverallAnalysisInput>, Enumerable<OffersAnalysisUncheckedCreateWithoutOverallAnalysisInput>>
    connectOrCreate?: Enumerable<OffersAnalysisCreateOrConnectWithoutOverallAnalysisInput>
    upsert?: Enumerable<OffersAnalysisUpsertWithWhereUniqueWithoutOverallAnalysisInput>
    createMany?: OffersAnalysisCreateManyOverallAnalysisInputEnvelope
    set?: Enumerable<OffersAnalysisWhereUniqueInput>
    disconnect?: Enumerable<OffersAnalysisWhereUniqueInput>
    delete?: Enumerable<OffersAnalysisWhereUniqueInput>
    connect?: Enumerable<OffersAnalysisWhereUniqueInput>
    update?: Enumerable<OffersAnalysisUpdateWithWhereUniqueWithoutOverallAnalysisInput>
    updateMany?: Enumerable<OffersAnalysisUpdateManyWithWhereWithoutOverallAnalysisInput>
    deleteMany?: Enumerable<OffersAnalysisScalarWhereInput>
  }

  export type OffersAnalysisUpdateManyWithoutCompanyAnalysisNestedInput = {
    create?: XOR<Enumerable<OffersAnalysisCreateWithoutCompanyAnalysisInput>, Enumerable<OffersAnalysisUncheckedCreateWithoutCompanyAnalysisInput>>
    connectOrCreate?: Enumerable<OffersAnalysisCreateOrConnectWithoutCompanyAnalysisInput>
    upsert?: Enumerable<OffersAnalysisUpsertWithWhereUniqueWithoutCompanyAnalysisInput>
    set?: Enumerable<OffersAnalysisWhereUniqueInput>
    disconnect?: Enumerable<OffersAnalysisWhereUniqueInput>
    delete?: Enumerable<OffersAnalysisWhereUniqueInput>
    connect?: Enumerable<OffersAnalysisWhereUniqueInput>
    update?: Enumerable<OffersAnalysisUpdateWithWhereUniqueWithoutCompanyAnalysisInput>
    updateMany?: Enumerable<OffersAnalysisUpdateManyWithWhereWithoutCompanyAnalysisInput>
    deleteMany?: Enumerable<OffersAnalysisScalarWhereInput>
  }

  export type OffersOfferUncheckedUpdateManyWithoutOffersAnalysisUnitNestedInput = {
    create?: XOR<Enumerable<OffersOfferCreateWithoutOffersAnalysisUnitInput>, Enumerable<OffersOfferUncheckedCreateWithoutOffersAnalysisUnitInput>>
    connectOrCreate?: Enumerable<OffersOfferCreateOrConnectWithoutOffersAnalysisUnitInput>
    upsert?: Enumerable<OffersOfferUpsertWithWhereUniqueWithoutOffersAnalysisUnitInput>
    set?: Enumerable<OffersOfferWhereUniqueInput>
    disconnect?: Enumerable<OffersOfferWhereUniqueInput>
    delete?: Enumerable<OffersOfferWhereUniqueInput>
    connect?: Enumerable<OffersOfferWhereUniqueInput>
    update?: Enumerable<OffersOfferUpdateWithWhereUniqueWithoutOffersAnalysisUnitInput>
    updateMany?: Enumerable<OffersOfferUpdateManyWithWhereWithoutOffersAnalysisUnitInput>
    deleteMany?: Enumerable<OffersOfferScalarWhereInput>
  }

  export type OffersAnalysisUncheckedUpdateManyWithoutOverallAnalysisNestedInput = {
    create?: XOR<Enumerable<OffersAnalysisCreateWithoutOverallAnalysisInput>, Enumerable<OffersAnalysisUncheckedCreateWithoutOverallAnalysisInput>>
    connectOrCreate?: Enumerable<OffersAnalysisCreateOrConnectWithoutOverallAnalysisInput>
    upsert?: Enumerable<OffersAnalysisUpsertWithWhereUniqueWithoutOverallAnalysisInput>
    createMany?: OffersAnalysisCreateManyOverallAnalysisInputEnvelope
    set?: Enumerable<OffersAnalysisWhereUniqueInput>
    disconnect?: Enumerable<OffersAnalysisWhereUniqueInput>
    delete?: Enumerable<OffersAnalysisWhereUniqueInput>
    connect?: Enumerable<OffersAnalysisWhereUniqueInput>
    update?: Enumerable<OffersAnalysisUpdateWithWhereUniqueWithoutOverallAnalysisInput>
    updateMany?: Enumerable<OffersAnalysisUpdateManyWithWhereWithoutOverallAnalysisInput>
    deleteMany?: Enumerable<OffersAnalysisScalarWhereInput>
  }

  export type OffersAnalysisUncheckedUpdateManyWithoutCompanyAnalysisNestedInput = {
    create?: XOR<Enumerable<OffersAnalysisCreateWithoutCompanyAnalysisInput>, Enumerable<OffersAnalysisUncheckedCreateWithoutCompanyAnalysisInput>>
    connectOrCreate?: Enumerable<OffersAnalysisCreateOrConnectWithoutCompanyAnalysisInput>
    upsert?: Enumerable<OffersAnalysisUpsertWithWhereUniqueWithoutCompanyAnalysisInput>
    set?: Enumerable<OffersAnalysisWhereUniqueInput>
    disconnect?: Enumerable<OffersAnalysisWhereUniqueInput>
    delete?: Enumerable<OffersAnalysisWhereUniqueInput>
    connect?: Enumerable<OffersAnalysisWhereUniqueInput>
    update?: Enumerable<OffersAnalysisUpdateWithWhereUniqueWithoutCompanyAnalysisInput>
    updateMany?: Enumerable<OffersAnalysisUpdateManyWithWhereWithoutCompanyAnalysisInput>
    deleteMany?: Enumerable<OffersAnalysisScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutQuestionsQuestionsInput = {
    create?: XOR<UserCreateWithoutQuestionsQuestionsInput, UserUncheckedCreateWithoutQuestionsQuestionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuestionsQuestionsInput
    connect?: UserWhereUniqueInput
  }

  export type QuestionsQuestionEncounterCreateNestedManyWithoutQuestionInput = {
    create?: XOR<Enumerable<QuestionsQuestionEncounterCreateWithoutQuestionInput>, Enumerable<QuestionsQuestionEncounterUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionEncounterCreateOrConnectWithoutQuestionInput>
    createMany?: QuestionsQuestionEncounterCreateManyQuestionInputEnvelope
    connect?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
  }

  export type QuestionsQuestionVoteCreateNestedManyWithoutQuestionInput = {
    create?: XOR<Enumerable<QuestionsQuestionVoteCreateWithoutQuestionInput>, Enumerable<QuestionsQuestionVoteUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionVoteCreateOrConnectWithoutQuestionInput>
    createMany?: QuestionsQuestionVoteCreateManyQuestionInputEnvelope
    connect?: Enumerable<QuestionsQuestionVoteWhereUniqueInput>
  }

  export type QuestionsQuestionCommentCreateNestedManyWithoutQuestionInput = {
    create?: XOR<Enumerable<QuestionsQuestionCommentCreateWithoutQuestionInput>, Enumerable<QuestionsQuestionCommentUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionCommentCreateOrConnectWithoutQuestionInput>
    createMany?: QuestionsQuestionCommentCreateManyQuestionInputEnvelope
    connect?: Enumerable<QuestionsQuestionCommentWhereUniqueInput>
  }

  export type QuestionsAnswerCreateNestedManyWithoutQuestionInput = {
    create?: XOR<Enumerable<QuestionsAnswerCreateWithoutQuestionInput>, Enumerable<QuestionsAnswerUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<QuestionsAnswerCreateOrConnectWithoutQuestionInput>
    createMany?: QuestionsAnswerCreateManyQuestionInputEnvelope
    connect?: Enumerable<QuestionsAnswerWhereUniqueInput>
  }

  export type QuestionsListQuestionEntryCreateNestedManyWithoutQuestionInput = {
    create?: XOR<Enumerable<QuestionsListQuestionEntryCreateWithoutQuestionInput>, Enumerable<QuestionsListQuestionEntryUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<QuestionsListQuestionEntryCreateOrConnectWithoutQuestionInput>
    createMany?: QuestionsListQuestionEntryCreateManyQuestionInputEnvelope
    connect?: Enumerable<QuestionsListQuestionEntryWhereUniqueInput>
  }

  export type QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<Enumerable<QuestionsQuestionEncounterCreateWithoutQuestionInput>, Enumerable<QuestionsQuestionEncounterUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionEncounterCreateOrConnectWithoutQuestionInput>
    createMany?: QuestionsQuestionEncounterCreateManyQuestionInputEnvelope
    connect?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
  }

  export type QuestionsQuestionVoteUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<Enumerable<QuestionsQuestionVoteCreateWithoutQuestionInput>, Enumerable<QuestionsQuestionVoteUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionVoteCreateOrConnectWithoutQuestionInput>
    createMany?: QuestionsQuestionVoteCreateManyQuestionInputEnvelope
    connect?: Enumerable<QuestionsQuestionVoteWhereUniqueInput>
  }

  export type QuestionsQuestionCommentUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<Enumerable<QuestionsQuestionCommentCreateWithoutQuestionInput>, Enumerable<QuestionsQuestionCommentUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionCommentCreateOrConnectWithoutQuestionInput>
    createMany?: QuestionsQuestionCommentCreateManyQuestionInputEnvelope
    connect?: Enumerable<QuestionsQuestionCommentWhereUniqueInput>
  }

  export type QuestionsAnswerUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<Enumerable<QuestionsAnswerCreateWithoutQuestionInput>, Enumerable<QuestionsAnswerUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<QuestionsAnswerCreateOrConnectWithoutQuestionInput>
    createMany?: QuestionsAnswerCreateManyQuestionInputEnvelope
    connect?: Enumerable<QuestionsAnswerWhereUniqueInput>
  }

  export type QuestionsListQuestionEntryUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<Enumerable<QuestionsListQuestionEntryCreateWithoutQuestionInput>, Enumerable<QuestionsListQuestionEntryUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<QuestionsListQuestionEntryCreateOrConnectWithoutQuestionInput>
    createMany?: QuestionsListQuestionEntryCreateManyQuestionInputEnvelope
    connect?: Enumerable<QuestionsListQuestionEntryWhereUniqueInput>
  }

  export type EnumQuestionsQuestionTypeFieldUpdateOperationsInput = {
    set?: QuestionsQuestionType
  }

  export type UserUpdateOneWithoutQuestionsQuestionsNestedInput = {
    create?: XOR<UserCreateWithoutQuestionsQuestionsInput, UserUncheckedCreateWithoutQuestionsQuestionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuestionsQuestionsInput
    upsert?: UserUpsertWithoutQuestionsQuestionsInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutQuestionsQuestionsInput, UserUncheckedUpdateWithoutQuestionsQuestionsInput>
  }

  export type QuestionsQuestionEncounterUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<Enumerable<QuestionsQuestionEncounterCreateWithoutQuestionInput>, Enumerable<QuestionsQuestionEncounterUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionEncounterCreateOrConnectWithoutQuestionInput>
    upsert?: Enumerable<QuestionsQuestionEncounterUpsertWithWhereUniqueWithoutQuestionInput>
    createMany?: QuestionsQuestionEncounterCreateManyQuestionInputEnvelope
    set?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    disconnect?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    delete?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    connect?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    update?: Enumerable<QuestionsQuestionEncounterUpdateWithWhereUniqueWithoutQuestionInput>
    updateMany?: Enumerable<QuestionsQuestionEncounterUpdateManyWithWhereWithoutQuestionInput>
    deleteMany?: Enumerable<QuestionsQuestionEncounterScalarWhereInput>
  }

  export type QuestionsQuestionVoteUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<Enumerable<QuestionsQuestionVoteCreateWithoutQuestionInput>, Enumerable<QuestionsQuestionVoteUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionVoteCreateOrConnectWithoutQuestionInput>
    upsert?: Enumerable<QuestionsQuestionVoteUpsertWithWhereUniqueWithoutQuestionInput>
    createMany?: QuestionsQuestionVoteCreateManyQuestionInputEnvelope
    set?: Enumerable<QuestionsQuestionVoteWhereUniqueInput>
    disconnect?: Enumerable<QuestionsQuestionVoteWhereUniqueInput>
    delete?: Enumerable<QuestionsQuestionVoteWhereUniqueInput>
    connect?: Enumerable<QuestionsQuestionVoteWhereUniqueInput>
    update?: Enumerable<QuestionsQuestionVoteUpdateWithWhereUniqueWithoutQuestionInput>
    updateMany?: Enumerable<QuestionsQuestionVoteUpdateManyWithWhereWithoutQuestionInput>
    deleteMany?: Enumerable<QuestionsQuestionVoteScalarWhereInput>
  }

  export type QuestionsQuestionCommentUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<Enumerable<QuestionsQuestionCommentCreateWithoutQuestionInput>, Enumerable<QuestionsQuestionCommentUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionCommentCreateOrConnectWithoutQuestionInput>
    upsert?: Enumerable<QuestionsQuestionCommentUpsertWithWhereUniqueWithoutQuestionInput>
    createMany?: QuestionsQuestionCommentCreateManyQuestionInputEnvelope
    set?: Enumerable<QuestionsQuestionCommentWhereUniqueInput>
    disconnect?: Enumerable<QuestionsQuestionCommentWhereUniqueInput>
    delete?: Enumerable<QuestionsQuestionCommentWhereUniqueInput>
    connect?: Enumerable<QuestionsQuestionCommentWhereUniqueInput>
    update?: Enumerable<QuestionsQuestionCommentUpdateWithWhereUniqueWithoutQuestionInput>
    updateMany?: Enumerable<QuestionsQuestionCommentUpdateManyWithWhereWithoutQuestionInput>
    deleteMany?: Enumerable<QuestionsQuestionCommentScalarWhereInput>
  }

  export type QuestionsAnswerUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<Enumerable<QuestionsAnswerCreateWithoutQuestionInput>, Enumerable<QuestionsAnswerUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<QuestionsAnswerCreateOrConnectWithoutQuestionInput>
    upsert?: Enumerable<QuestionsAnswerUpsertWithWhereUniqueWithoutQuestionInput>
    createMany?: QuestionsAnswerCreateManyQuestionInputEnvelope
    set?: Enumerable<QuestionsAnswerWhereUniqueInput>
    disconnect?: Enumerable<QuestionsAnswerWhereUniqueInput>
    delete?: Enumerable<QuestionsAnswerWhereUniqueInput>
    connect?: Enumerable<QuestionsAnswerWhereUniqueInput>
    update?: Enumerable<QuestionsAnswerUpdateWithWhereUniqueWithoutQuestionInput>
    updateMany?: Enumerable<QuestionsAnswerUpdateManyWithWhereWithoutQuestionInput>
    deleteMany?: Enumerable<QuestionsAnswerScalarWhereInput>
  }

  export type QuestionsListQuestionEntryUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<Enumerable<QuestionsListQuestionEntryCreateWithoutQuestionInput>, Enumerable<QuestionsListQuestionEntryUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<QuestionsListQuestionEntryCreateOrConnectWithoutQuestionInput>
    upsert?: Enumerable<QuestionsListQuestionEntryUpsertWithWhereUniqueWithoutQuestionInput>
    createMany?: QuestionsListQuestionEntryCreateManyQuestionInputEnvelope
    set?: Enumerable<QuestionsListQuestionEntryWhereUniqueInput>
    disconnect?: Enumerable<QuestionsListQuestionEntryWhereUniqueInput>
    delete?: Enumerable<QuestionsListQuestionEntryWhereUniqueInput>
    connect?: Enumerable<QuestionsListQuestionEntryWhereUniqueInput>
    update?: Enumerable<QuestionsListQuestionEntryUpdateWithWhereUniqueWithoutQuestionInput>
    updateMany?: Enumerable<QuestionsListQuestionEntryUpdateManyWithWhereWithoutQuestionInput>
    deleteMany?: Enumerable<QuestionsListQuestionEntryScalarWhereInput>
  }

  export type QuestionsQuestionEncounterUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<Enumerable<QuestionsQuestionEncounterCreateWithoutQuestionInput>, Enumerable<QuestionsQuestionEncounterUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionEncounterCreateOrConnectWithoutQuestionInput>
    upsert?: Enumerable<QuestionsQuestionEncounterUpsertWithWhereUniqueWithoutQuestionInput>
    createMany?: QuestionsQuestionEncounterCreateManyQuestionInputEnvelope
    set?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    disconnect?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    delete?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    connect?: Enumerable<QuestionsQuestionEncounterWhereUniqueInput>
    update?: Enumerable<QuestionsQuestionEncounterUpdateWithWhereUniqueWithoutQuestionInput>
    updateMany?: Enumerable<QuestionsQuestionEncounterUpdateManyWithWhereWithoutQuestionInput>
    deleteMany?: Enumerable<QuestionsQuestionEncounterScalarWhereInput>
  }

  export type QuestionsQuestionVoteUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<Enumerable<QuestionsQuestionVoteCreateWithoutQuestionInput>, Enumerable<QuestionsQuestionVoteUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionVoteCreateOrConnectWithoutQuestionInput>
    upsert?: Enumerable<QuestionsQuestionVoteUpsertWithWhereUniqueWithoutQuestionInput>
    createMany?: QuestionsQuestionVoteCreateManyQuestionInputEnvelope
    set?: Enumerable<QuestionsQuestionVoteWhereUniqueInput>
    disconnect?: Enumerable<QuestionsQuestionVoteWhereUniqueInput>
    delete?: Enumerable<QuestionsQuestionVoteWhereUniqueInput>
    connect?: Enumerable<QuestionsQuestionVoteWhereUniqueInput>
    update?: Enumerable<QuestionsQuestionVoteUpdateWithWhereUniqueWithoutQuestionInput>
    updateMany?: Enumerable<QuestionsQuestionVoteUpdateManyWithWhereWithoutQuestionInput>
    deleteMany?: Enumerable<QuestionsQuestionVoteScalarWhereInput>
  }

  export type QuestionsQuestionCommentUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<Enumerable<QuestionsQuestionCommentCreateWithoutQuestionInput>, Enumerable<QuestionsQuestionCommentUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionCommentCreateOrConnectWithoutQuestionInput>
    upsert?: Enumerable<QuestionsQuestionCommentUpsertWithWhereUniqueWithoutQuestionInput>
    createMany?: QuestionsQuestionCommentCreateManyQuestionInputEnvelope
    set?: Enumerable<QuestionsQuestionCommentWhereUniqueInput>
    disconnect?: Enumerable<QuestionsQuestionCommentWhereUniqueInput>
    delete?: Enumerable<QuestionsQuestionCommentWhereUniqueInput>
    connect?: Enumerable<QuestionsQuestionCommentWhereUniqueInput>
    update?: Enumerable<QuestionsQuestionCommentUpdateWithWhereUniqueWithoutQuestionInput>
    updateMany?: Enumerable<QuestionsQuestionCommentUpdateManyWithWhereWithoutQuestionInput>
    deleteMany?: Enumerable<QuestionsQuestionCommentScalarWhereInput>
  }

  export type QuestionsAnswerUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<Enumerable<QuestionsAnswerCreateWithoutQuestionInput>, Enumerable<QuestionsAnswerUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<QuestionsAnswerCreateOrConnectWithoutQuestionInput>
    upsert?: Enumerable<QuestionsAnswerUpsertWithWhereUniqueWithoutQuestionInput>
    createMany?: QuestionsAnswerCreateManyQuestionInputEnvelope
    set?: Enumerable<QuestionsAnswerWhereUniqueInput>
    disconnect?: Enumerable<QuestionsAnswerWhereUniqueInput>
    delete?: Enumerable<QuestionsAnswerWhereUniqueInput>
    connect?: Enumerable<QuestionsAnswerWhereUniqueInput>
    update?: Enumerable<QuestionsAnswerUpdateWithWhereUniqueWithoutQuestionInput>
    updateMany?: Enumerable<QuestionsAnswerUpdateManyWithWhereWithoutQuestionInput>
    deleteMany?: Enumerable<QuestionsAnswerScalarWhereInput>
  }

  export type QuestionsListQuestionEntryUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<Enumerable<QuestionsListQuestionEntryCreateWithoutQuestionInput>, Enumerable<QuestionsListQuestionEntryUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<QuestionsListQuestionEntryCreateOrConnectWithoutQuestionInput>
    upsert?: Enumerable<QuestionsListQuestionEntryUpsertWithWhereUniqueWithoutQuestionInput>
    createMany?: QuestionsListQuestionEntryCreateManyQuestionInputEnvelope
    set?: Enumerable<QuestionsListQuestionEntryWhereUniqueInput>
    disconnect?: Enumerable<QuestionsListQuestionEntryWhereUniqueInput>
    delete?: Enumerable<QuestionsListQuestionEntryWhereUniqueInput>
    connect?: Enumerable<QuestionsListQuestionEntryWhereUniqueInput>
    update?: Enumerable<QuestionsListQuestionEntryUpdateWithWhereUniqueWithoutQuestionInput>
    updateMany?: Enumerable<QuestionsListQuestionEntryUpdateManyWithWhereWithoutQuestionInput>
    deleteMany?: Enumerable<QuestionsListQuestionEntryScalarWhereInput>
  }

  export type CountryCreateNestedOneWithoutQuestionsQuestionEncountersInput = {
    create?: XOR<CountryCreateWithoutQuestionsQuestionEncountersInput, CountryUncheckedCreateWithoutQuestionsQuestionEncountersInput>
    connectOrCreate?: CountryCreateOrConnectWithoutQuestionsQuestionEncountersInput
    connect?: CountryWhereUniqueInput
  }

  export type StateCreateNestedOneWithoutQuestionsQuestionEncountersInput = {
    create?: XOR<StateCreateWithoutQuestionsQuestionEncountersInput, StateUncheckedCreateWithoutQuestionsQuestionEncountersInput>
    connectOrCreate?: StateCreateOrConnectWithoutQuestionsQuestionEncountersInput
    connect?: StateWhereUniqueInput
  }

  export type CityCreateNestedOneWithoutQuestionsQuestionEncountersInput = {
    create?: XOR<CityCreateWithoutQuestionsQuestionEncountersInput, CityUncheckedCreateWithoutQuestionsQuestionEncountersInput>
    connectOrCreate?: CityCreateOrConnectWithoutQuestionsQuestionEncountersInput
    connect?: CityWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutQuestionsQuestionEncounterInput = {
    create?: XOR<CompanyCreateWithoutQuestionsQuestionEncounterInput, CompanyUncheckedCreateWithoutQuestionsQuestionEncounterInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutQuestionsQuestionEncounterInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutQuestionsQuestionEncountersInput = {
    create?: XOR<UserCreateWithoutQuestionsQuestionEncountersInput, UserUncheckedCreateWithoutQuestionsQuestionEncountersInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuestionsQuestionEncountersInput
    connect?: UserWhereUniqueInput
  }

  export type QuestionsQuestionCreateNestedOneWithoutEncountersInput = {
    create?: XOR<QuestionsQuestionCreateWithoutEncountersInput, QuestionsQuestionUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: QuestionsQuestionCreateOrConnectWithoutEncountersInput
    connect?: QuestionsQuestionWhereUniqueInput
  }

  export type CountryUpdateOneWithoutQuestionsQuestionEncountersNestedInput = {
    create?: XOR<CountryCreateWithoutQuestionsQuestionEncountersInput, CountryUncheckedCreateWithoutQuestionsQuestionEncountersInput>
    connectOrCreate?: CountryCreateOrConnectWithoutQuestionsQuestionEncountersInput
    upsert?: CountryUpsertWithoutQuestionsQuestionEncountersInput
    disconnect?: boolean
    delete?: boolean
    connect?: CountryWhereUniqueInput
    update?: XOR<CountryUpdateWithoutQuestionsQuestionEncountersInput, CountryUncheckedUpdateWithoutQuestionsQuestionEncountersInput>
  }

  export type StateUpdateOneWithoutQuestionsQuestionEncountersNestedInput = {
    create?: XOR<StateCreateWithoutQuestionsQuestionEncountersInput, StateUncheckedCreateWithoutQuestionsQuestionEncountersInput>
    connectOrCreate?: StateCreateOrConnectWithoutQuestionsQuestionEncountersInput
    upsert?: StateUpsertWithoutQuestionsQuestionEncountersInput
    disconnect?: boolean
    delete?: boolean
    connect?: StateWhereUniqueInput
    update?: XOR<StateUpdateWithoutQuestionsQuestionEncountersInput, StateUncheckedUpdateWithoutQuestionsQuestionEncountersInput>
  }

  export type CityUpdateOneWithoutQuestionsQuestionEncountersNestedInput = {
    create?: XOR<CityCreateWithoutQuestionsQuestionEncountersInput, CityUncheckedCreateWithoutQuestionsQuestionEncountersInput>
    connectOrCreate?: CityCreateOrConnectWithoutQuestionsQuestionEncountersInput
    upsert?: CityUpsertWithoutQuestionsQuestionEncountersInput
    disconnect?: boolean
    delete?: boolean
    connect?: CityWhereUniqueInput
    update?: XOR<CityUpdateWithoutQuestionsQuestionEncountersInput, CityUncheckedUpdateWithoutQuestionsQuestionEncountersInput>
  }

  export type CompanyUpdateOneWithoutQuestionsQuestionEncounterNestedInput = {
    create?: XOR<CompanyCreateWithoutQuestionsQuestionEncounterInput, CompanyUncheckedCreateWithoutQuestionsQuestionEncounterInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutQuestionsQuestionEncounterInput
    upsert?: CompanyUpsertWithoutQuestionsQuestionEncounterInput
    disconnect?: boolean
    delete?: boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<CompanyUpdateWithoutQuestionsQuestionEncounterInput, CompanyUncheckedUpdateWithoutQuestionsQuestionEncounterInput>
  }

  export type UserUpdateOneWithoutQuestionsQuestionEncountersNestedInput = {
    create?: XOR<UserCreateWithoutQuestionsQuestionEncountersInput, UserUncheckedCreateWithoutQuestionsQuestionEncountersInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuestionsQuestionEncountersInput
    upsert?: UserUpsertWithoutQuestionsQuestionEncountersInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutQuestionsQuestionEncountersInput, UserUncheckedUpdateWithoutQuestionsQuestionEncountersInput>
  }

  export type QuestionsQuestionUpdateOneRequiredWithoutEncountersNestedInput = {
    create?: XOR<QuestionsQuestionCreateWithoutEncountersInput, QuestionsQuestionUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: QuestionsQuestionCreateOrConnectWithoutEncountersInput
    upsert?: QuestionsQuestionUpsertWithoutEncountersInput
    connect?: QuestionsQuestionWhereUniqueInput
    update?: XOR<QuestionsQuestionUpdateWithoutEncountersInput, QuestionsQuestionUncheckedUpdateWithoutEncountersInput>
  }

  export type UserCreateNestedOneWithoutQuestionsQuestionVotesInput = {
    create?: XOR<UserCreateWithoutQuestionsQuestionVotesInput, UserUncheckedCreateWithoutQuestionsQuestionVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuestionsQuestionVotesInput
    connect?: UserWhereUniqueInput
  }

  export type QuestionsQuestionCreateNestedOneWithoutVotesInput = {
    create?: XOR<QuestionsQuestionCreateWithoutVotesInput, QuestionsQuestionUncheckedCreateWithoutVotesInput>
    connectOrCreate?: QuestionsQuestionCreateOrConnectWithoutVotesInput
    connect?: QuestionsQuestionWhereUniqueInput
  }

  export type UserUpdateOneWithoutQuestionsQuestionVotesNestedInput = {
    create?: XOR<UserCreateWithoutQuestionsQuestionVotesInput, UserUncheckedCreateWithoutQuestionsQuestionVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuestionsQuestionVotesInput
    upsert?: UserUpsertWithoutQuestionsQuestionVotesInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutQuestionsQuestionVotesInput, UserUncheckedUpdateWithoutQuestionsQuestionVotesInput>
  }

  export type QuestionsQuestionUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<QuestionsQuestionCreateWithoutVotesInput, QuestionsQuestionUncheckedCreateWithoutVotesInput>
    connectOrCreate?: QuestionsQuestionCreateOrConnectWithoutVotesInput
    upsert?: QuestionsQuestionUpsertWithoutVotesInput
    connect?: QuestionsQuestionWhereUniqueInput
    update?: XOR<QuestionsQuestionUpdateWithoutVotesInput, QuestionsQuestionUncheckedUpdateWithoutVotesInput>
  }

  export type UserCreateNestedOneWithoutQuestionsQuestionCommentsInput = {
    create?: XOR<UserCreateWithoutQuestionsQuestionCommentsInput, UserUncheckedCreateWithoutQuestionsQuestionCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuestionsQuestionCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type QuestionsQuestionCreateNestedOneWithoutCommentsInput = {
    create?: XOR<QuestionsQuestionCreateWithoutCommentsInput, QuestionsQuestionUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: QuestionsQuestionCreateOrConnectWithoutCommentsInput
    connect?: QuestionsQuestionWhereUniqueInput
  }

  export type QuestionsQuestionCommentVoteCreateNestedManyWithoutCommentInput = {
    create?: XOR<Enumerable<QuestionsQuestionCommentVoteCreateWithoutCommentInput>, Enumerable<QuestionsQuestionCommentVoteUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionCommentVoteCreateOrConnectWithoutCommentInput>
    createMany?: QuestionsQuestionCommentVoteCreateManyCommentInputEnvelope
    connect?: Enumerable<QuestionsQuestionCommentVoteWhereUniqueInput>
  }

  export type QuestionsQuestionCommentVoteUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<Enumerable<QuestionsQuestionCommentVoteCreateWithoutCommentInput>, Enumerable<QuestionsQuestionCommentVoteUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionCommentVoteCreateOrConnectWithoutCommentInput>
    createMany?: QuestionsQuestionCommentVoteCreateManyCommentInputEnvelope
    connect?: Enumerable<QuestionsQuestionCommentVoteWhereUniqueInput>
  }

  export type UserUpdateOneWithoutQuestionsQuestionCommentsNestedInput = {
    create?: XOR<UserCreateWithoutQuestionsQuestionCommentsInput, UserUncheckedCreateWithoutQuestionsQuestionCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuestionsQuestionCommentsInput
    upsert?: UserUpsertWithoutQuestionsQuestionCommentsInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutQuestionsQuestionCommentsInput, UserUncheckedUpdateWithoutQuestionsQuestionCommentsInput>
  }

  export type QuestionsQuestionUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<QuestionsQuestionCreateWithoutCommentsInput, QuestionsQuestionUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: QuestionsQuestionCreateOrConnectWithoutCommentsInput
    upsert?: QuestionsQuestionUpsertWithoutCommentsInput
    connect?: QuestionsQuestionWhereUniqueInput
    update?: XOR<QuestionsQuestionUpdateWithoutCommentsInput, QuestionsQuestionUncheckedUpdateWithoutCommentsInput>
  }

  export type QuestionsQuestionCommentVoteUpdateManyWithoutCommentNestedInput = {
    create?: XOR<Enumerable<QuestionsQuestionCommentVoteCreateWithoutCommentInput>, Enumerable<QuestionsQuestionCommentVoteUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionCommentVoteCreateOrConnectWithoutCommentInput>
    upsert?: Enumerable<QuestionsQuestionCommentVoteUpsertWithWhereUniqueWithoutCommentInput>
    createMany?: QuestionsQuestionCommentVoteCreateManyCommentInputEnvelope
    set?: Enumerable<QuestionsQuestionCommentVoteWhereUniqueInput>
    disconnect?: Enumerable<QuestionsQuestionCommentVoteWhereUniqueInput>
    delete?: Enumerable<QuestionsQuestionCommentVoteWhereUniqueInput>
    connect?: Enumerable<QuestionsQuestionCommentVoteWhereUniqueInput>
    update?: Enumerable<QuestionsQuestionCommentVoteUpdateWithWhereUniqueWithoutCommentInput>
    updateMany?: Enumerable<QuestionsQuestionCommentVoteUpdateManyWithWhereWithoutCommentInput>
    deleteMany?: Enumerable<QuestionsQuestionCommentVoteScalarWhereInput>
  }

  export type QuestionsQuestionCommentVoteUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<Enumerable<QuestionsQuestionCommentVoteCreateWithoutCommentInput>, Enumerable<QuestionsQuestionCommentVoteUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<QuestionsQuestionCommentVoteCreateOrConnectWithoutCommentInput>
    upsert?: Enumerable<QuestionsQuestionCommentVoteUpsertWithWhereUniqueWithoutCommentInput>
    createMany?: QuestionsQuestionCommentVoteCreateManyCommentInputEnvelope
    set?: Enumerable<QuestionsQuestionCommentVoteWhereUniqueInput>
    disconnect?: Enumerable<QuestionsQuestionCommentVoteWhereUniqueInput>
    delete?: Enumerable<QuestionsQuestionCommentVoteWhereUniqueInput>
    connect?: Enumerable<QuestionsQuestionCommentVoteWhereUniqueInput>
    update?: Enumerable<QuestionsQuestionCommentVoteUpdateWithWhereUniqueWithoutCommentInput>
    updateMany?: Enumerable<QuestionsQuestionCommentVoteUpdateManyWithWhereWithoutCommentInput>
    deleteMany?: Enumerable<QuestionsQuestionCommentVoteScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutQuestionsQuestionCommentVotesInput = {
    create?: XOR<UserCreateWithoutQuestionsQuestionCommentVotesInput, UserUncheckedCreateWithoutQuestionsQuestionCommentVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuestionsQuestionCommentVotesInput
    connect?: UserWhereUniqueInput
  }

  export type QuestionsQuestionCommentCreateNestedOneWithoutVotesInput = {
    create?: XOR<QuestionsQuestionCommentCreateWithoutVotesInput, QuestionsQuestionCommentUncheckedCreateWithoutVotesInput>
    connectOrCreate?: QuestionsQuestionCommentCreateOrConnectWithoutVotesInput
    connect?: QuestionsQuestionCommentWhereUniqueInput
  }

  export type UserUpdateOneWithoutQuestionsQuestionCommentVotesNestedInput = {
    create?: XOR<UserCreateWithoutQuestionsQuestionCommentVotesInput, UserUncheckedCreateWithoutQuestionsQuestionCommentVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuestionsQuestionCommentVotesInput
    upsert?: UserUpsertWithoutQuestionsQuestionCommentVotesInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutQuestionsQuestionCommentVotesInput, UserUncheckedUpdateWithoutQuestionsQuestionCommentVotesInput>
  }

  export type QuestionsQuestionCommentUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<QuestionsQuestionCommentCreateWithoutVotesInput, QuestionsQuestionCommentUncheckedCreateWithoutVotesInput>
    connectOrCreate?: QuestionsQuestionCommentCreateOrConnectWithoutVotesInput
    upsert?: QuestionsQuestionCommentUpsertWithoutVotesInput
    connect?: QuestionsQuestionCommentWhereUniqueInput
    update?: XOR<QuestionsQuestionCommentUpdateWithoutVotesInput, QuestionsQuestionCommentUncheckedUpdateWithoutVotesInput>
  }

  export type UserCreateNestedOneWithoutQuestionsAnswersInput = {
    create?: XOR<UserCreateWithoutQuestionsAnswersInput, UserUncheckedCreateWithoutQuestionsAnswersInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuestionsAnswersInput
    connect?: UserWhereUniqueInput
  }

  export type QuestionsQuestionCreateNestedOneWithoutAnswersInput = {
    create?: XOR<QuestionsQuestionCreateWithoutAnswersInput, QuestionsQuestionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: QuestionsQuestionCreateOrConnectWithoutAnswersInput
    connect?: QuestionsQuestionWhereUniqueInput
  }

  export type QuestionsAnswerVoteCreateNestedManyWithoutAnswerInput = {
    create?: XOR<Enumerable<QuestionsAnswerVoteCreateWithoutAnswerInput>, Enumerable<QuestionsAnswerVoteUncheckedCreateWithoutAnswerInput>>
    connectOrCreate?: Enumerable<QuestionsAnswerVoteCreateOrConnectWithoutAnswerInput>
    createMany?: QuestionsAnswerVoteCreateManyAnswerInputEnvelope
    connect?: Enumerable<QuestionsAnswerVoteWhereUniqueInput>
  }

  export type QuestionsAnswerCommentCreateNestedManyWithoutAnswerInput = {
    create?: XOR<Enumerable<QuestionsAnswerCommentCreateWithoutAnswerInput>, Enumerable<QuestionsAnswerCommentUncheckedCreateWithoutAnswerInput>>
    connectOrCreate?: Enumerable<QuestionsAnswerCommentCreateOrConnectWithoutAnswerInput>
    createMany?: QuestionsAnswerCommentCreateManyAnswerInputEnvelope
    connect?: Enumerable<QuestionsAnswerCommentWhereUniqueInput>
  }

  export type QuestionsAnswerVoteUncheckedCreateNestedManyWithoutAnswerInput = {
    create?: XOR<Enumerable<QuestionsAnswerVoteCreateWithoutAnswerInput>, Enumerable<QuestionsAnswerVoteUncheckedCreateWithoutAnswerInput>>
    connectOrCreate?: Enumerable<QuestionsAnswerVoteCreateOrConnectWithoutAnswerInput>
    createMany?: QuestionsAnswerVoteCreateManyAnswerInputEnvelope
    connect?: Enumerable<QuestionsAnswerVoteWhereUniqueInput>
  }

  export type QuestionsAnswerCommentUncheckedCreateNestedManyWithoutAnswerInput = {
    create?: XOR<Enumerable<QuestionsAnswerCommentCreateWithoutAnswerInput>, Enumerable<QuestionsAnswerCommentUncheckedCreateWithoutAnswerInput>>
    connectOrCreate?: Enumerable<QuestionsAnswerCommentCreateOrConnectWithoutAnswerInput>
    createMany?: QuestionsAnswerCommentCreateManyAnswerInputEnvelope
    connect?: Enumerable<QuestionsAnswerCommentWhereUniqueInput>
  }

  export type UserUpdateOneWithoutQuestionsAnswersNestedInput = {
    create?: XOR<UserCreateWithoutQuestionsAnswersInput, UserUncheckedCreateWithoutQuestionsAnswersInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuestionsAnswersInput
    upsert?: UserUpsertWithoutQuestionsAnswersInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutQuestionsAnswersInput, UserUncheckedUpdateWithoutQuestionsAnswersInput>
  }

  export type QuestionsQuestionUpdateOneRequiredWithoutAnswersNestedInput = {
    create?: XOR<QuestionsQuestionCreateWithoutAnswersInput, QuestionsQuestionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: QuestionsQuestionCreateOrConnectWithoutAnswersInput
    upsert?: QuestionsQuestionUpsertWithoutAnswersInput
    connect?: QuestionsQuestionWhereUniqueInput
    update?: XOR<QuestionsQuestionUpdateWithoutAnswersInput, QuestionsQuestionUncheckedUpdateWithoutAnswersInput>
  }

  export type QuestionsAnswerVoteUpdateManyWithoutAnswerNestedInput = {
    create?: XOR<Enumerable<QuestionsAnswerVoteCreateWithoutAnswerInput>, Enumerable<QuestionsAnswerVoteUncheckedCreateWithoutAnswerInput>>
    connectOrCreate?: Enumerable<QuestionsAnswerVoteCreateOrConnectWithoutAnswerInput>
    upsert?: Enumerable<QuestionsAnswerVoteUpsertWithWhereUniqueWithoutAnswerInput>
    createMany?: QuestionsAnswerVoteCreateManyAnswerInputEnvelope
    set?: Enumerable<QuestionsAnswerVoteWhereUniqueInput>
    disconnect?: Enumerable<QuestionsAnswerVoteWhereUniqueInput>
    delete?: Enumerable<QuestionsAnswerVoteWhereUniqueInput>
    connect?: Enumerable<QuestionsAnswerVoteWhereUniqueInput>
    update?: Enumerable<QuestionsAnswerVoteUpdateWithWhereUniqueWithoutAnswerInput>
    updateMany?: Enumerable<QuestionsAnswerVoteUpdateManyWithWhereWithoutAnswerInput>
    deleteMany?: Enumerable<QuestionsAnswerVoteScalarWhereInput>
  }

  export type QuestionsAnswerCommentUpdateManyWithoutAnswerNestedInput = {
    create?: XOR<Enumerable<QuestionsAnswerCommentCreateWithoutAnswerInput>, Enumerable<QuestionsAnswerCommentUncheckedCreateWithoutAnswerInput>>
    connectOrCreate?: Enumerable<QuestionsAnswerCommentCreateOrConnectWithoutAnswerInput>
    upsert?: Enumerable<QuestionsAnswerCommentUpsertWithWhereUniqueWithoutAnswerInput>
    createMany?: QuestionsAnswerCommentCreateManyAnswerInputEnvelope
    set?: Enumerable<QuestionsAnswerCommentWhereUniqueInput>
    disconnect?: Enumerable<QuestionsAnswerCommentWhereUniqueInput>
    delete?: Enumerable<QuestionsAnswerCommentWhereUniqueInput>
    connect?: Enumerable<QuestionsAnswerCommentWhereUniqueInput>
    update?: Enumerable<QuestionsAnswerCommentUpdateWithWhereUniqueWithoutAnswerInput>
    updateMany?: Enumerable<QuestionsAnswerCommentUpdateManyWithWhereWithoutAnswerInput>
    deleteMany?: Enumerable<QuestionsAnswerCommentScalarWhereInput>
  }

  export type QuestionsAnswerVoteUncheckedUpdateManyWithoutAnswerNestedInput = {
    create?: XOR<Enumerable<QuestionsAnswerVoteCreateWithoutAnswerInput>, Enumerable<QuestionsAnswerVoteUncheckedCreateWithoutAnswerInput>>
    connectOrCreate?: Enumerable<QuestionsAnswerVoteCreateOrConnectWithoutAnswerInput>
    upsert?: Enumerable<QuestionsAnswerVoteUpsertWithWhereUniqueWithoutAnswerInput>
    createMany?: QuestionsAnswerVoteCreateManyAnswerInputEnvelope
    set?: Enumerable<QuestionsAnswerVoteWhereUniqueInput>
    disconnect?: Enumerable<QuestionsAnswerVoteWhereUniqueInput>
    delete?: Enumerable<QuestionsAnswerVoteWhereUniqueInput>
    connect?: Enumerable<QuestionsAnswerVoteWhereUniqueInput>
    update?: Enumerable<QuestionsAnswerVoteUpdateWithWhereUniqueWithoutAnswerInput>
    updateMany?: Enumerable<QuestionsAnswerVoteUpdateManyWithWhereWithoutAnswerInput>
    deleteMany?: Enumerable<QuestionsAnswerVoteScalarWhereInput>
  }

  export type QuestionsAnswerCommentUncheckedUpdateManyWithoutAnswerNestedInput = {
    create?: XOR<Enumerable<QuestionsAnswerCommentCreateWithoutAnswerInput>, Enumerable<QuestionsAnswerCommentUncheckedCreateWithoutAnswerInput>>
    connectOrCreate?: Enumerable<QuestionsAnswerCommentCreateOrConnectWithoutAnswerInput>
    upsert?: Enumerable<QuestionsAnswerCommentUpsertWithWhereUniqueWithoutAnswerInput>
    createMany?: QuestionsAnswerCommentCreateManyAnswerInputEnvelope
    set?: Enumerable<QuestionsAnswerCommentWhereUniqueInput>
    disconnect?: Enumerable<QuestionsAnswerCommentWhereUniqueInput>
    delete?: Enumerable<QuestionsAnswerCommentWhereUniqueInput>
    connect?: Enumerable<QuestionsAnswerCommentWhereUniqueInput>
    update?: Enumerable<QuestionsAnswerCommentUpdateWithWhereUniqueWithoutAnswerInput>
    updateMany?: Enumerable<QuestionsAnswerCommentUpdateManyWithWhereWithoutAnswerInput>
    deleteMany?: Enumerable<QuestionsAnswerCommentScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutQuestionsAnswerVotesInput = {
    create?: XOR<UserCreateWithoutQuestionsAnswerVotesInput, UserUncheckedCreateWithoutQuestionsAnswerVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuestionsAnswerVotesInput
    connect?: UserWhereUniqueInput
  }

  export type QuestionsAnswerCreateNestedOneWithoutVotesInput = {
    create?: XOR<QuestionsAnswerCreateWithoutVotesInput, QuestionsAnswerUncheckedCreateWithoutVotesInput>
    connectOrCreate?: QuestionsAnswerCreateOrConnectWithoutVotesInput
    connect?: QuestionsAnswerWhereUniqueInput
  }

  export type UserUpdateOneWithoutQuestionsAnswerVotesNestedInput = {
    create?: XOR<UserCreateWithoutQuestionsAnswerVotesInput, UserUncheckedCreateWithoutQuestionsAnswerVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuestionsAnswerVotesInput
    upsert?: UserUpsertWithoutQuestionsAnswerVotesInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutQuestionsAnswerVotesInput, UserUncheckedUpdateWithoutQuestionsAnswerVotesInput>
  }

  export type QuestionsAnswerUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<QuestionsAnswerCreateWithoutVotesInput, QuestionsAnswerUncheckedCreateWithoutVotesInput>
    connectOrCreate?: QuestionsAnswerCreateOrConnectWithoutVotesInput
    upsert?: QuestionsAnswerUpsertWithoutVotesInput
    connect?: QuestionsAnswerWhereUniqueInput
    update?: XOR<QuestionsAnswerUpdateWithoutVotesInput, QuestionsAnswerUncheckedUpdateWithoutVotesInput>
  }

  export type UserCreateNestedOneWithoutQuestionsAnswerCommentsInput = {
    create?: XOR<UserCreateWithoutQuestionsAnswerCommentsInput, UserUncheckedCreateWithoutQuestionsAnswerCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuestionsAnswerCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type QuestionsAnswerCreateNestedOneWithoutCommentsInput = {
    create?: XOR<QuestionsAnswerCreateWithoutCommentsInput, QuestionsAnswerUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: QuestionsAnswerCreateOrConnectWithoutCommentsInput
    connect?: QuestionsAnswerWhereUniqueInput
  }

  export type QuestionsAnswerCommentVoteCreateNestedManyWithoutCommentInput = {
    create?: XOR<Enumerable<QuestionsAnswerCommentVoteCreateWithoutCommentInput>, Enumerable<QuestionsAnswerCommentVoteUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<QuestionsAnswerCommentVoteCreateOrConnectWithoutCommentInput>
    createMany?: QuestionsAnswerCommentVoteCreateManyCommentInputEnvelope
    connect?: Enumerable<QuestionsAnswerCommentVoteWhereUniqueInput>
  }

  export type QuestionsAnswerCommentVoteUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<Enumerable<QuestionsAnswerCommentVoteCreateWithoutCommentInput>, Enumerable<QuestionsAnswerCommentVoteUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<QuestionsAnswerCommentVoteCreateOrConnectWithoutCommentInput>
    createMany?: QuestionsAnswerCommentVoteCreateManyCommentInputEnvelope
    connect?: Enumerable<QuestionsAnswerCommentVoteWhereUniqueInput>
  }

  export type UserUpdateOneWithoutQuestionsAnswerCommentsNestedInput = {
    create?: XOR<UserCreateWithoutQuestionsAnswerCommentsInput, UserUncheckedCreateWithoutQuestionsAnswerCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuestionsAnswerCommentsInput
    upsert?: UserUpsertWithoutQuestionsAnswerCommentsInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutQuestionsAnswerCommentsInput, UserUncheckedUpdateWithoutQuestionsAnswerCommentsInput>
  }

  export type QuestionsAnswerUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<QuestionsAnswerCreateWithoutCommentsInput, QuestionsAnswerUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: QuestionsAnswerCreateOrConnectWithoutCommentsInput
    upsert?: QuestionsAnswerUpsertWithoutCommentsInput
    connect?: QuestionsAnswerWhereUniqueInput
    update?: XOR<QuestionsAnswerUpdateWithoutCommentsInput, QuestionsAnswerUncheckedUpdateWithoutCommentsInput>
  }

  export type QuestionsAnswerCommentVoteUpdateManyWithoutCommentNestedInput = {
    create?: XOR<Enumerable<QuestionsAnswerCommentVoteCreateWithoutCommentInput>, Enumerable<QuestionsAnswerCommentVoteUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<QuestionsAnswerCommentVoteCreateOrConnectWithoutCommentInput>
    upsert?: Enumerable<QuestionsAnswerCommentVoteUpsertWithWhereUniqueWithoutCommentInput>
    createMany?: QuestionsAnswerCommentVoteCreateManyCommentInputEnvelope
    set?: Enumerable<QuestionsAnswerCommentVoteWhereUniqueInput>
    disconnect?: Enumerable<QuestionsAnswerCommentVoteWhereUniqueInput>
    delete?: Enumerable<QuestionsAnswerCommentVoteWhereUniqueInput>
    connect?: Enumerable<QuestionsAnswerCommentVoteWhereUniqueInput>
    update?: Enumerable<QuestionsAnswerCommentVoteUpdateWithWhereUniqueWithoutCommentInput>
    updateMany?: Enumerable<QuestionsAnswerCommentVoteUpdateManyWithWhereWithoutCommentInput>
    deleteMany?: Enumerable<QuestionsAnswerCommentVoteScalarWhereInput>
  }

  export type QuestionsAnswerCommentVoteUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<Enumerable<QuestionsAnswerCommentVoteCreateWithoutCommentInput>, Enumerable<QuestionsAnswerCommentVoteUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<QuestionsAnswerCommentVoteCreateOrConnectWithoutCommentInput>
    upsert?: Enumerable<QuestionsAnswerCommentVoteUpsertWithWhereUniqueWithoutCommentInput>
    createMany?: QuestionsAnswerCommentVoteCreateManyCommentInputEnvelope
    set?: Enumerable<QuestionsAnswerCommentVoteWhereUniqueInput>
    disconnect?: Enumerable<QuestionsAnswerCommentVoteWhereUniqueInput>
    delete?: Enumerable<QuestionsAnswerCommentVoteWhereUniqueInput>
    connect?: Enumerable<QuestionsAnswerCommentVoteWhereUniqueInput>
    update?: Enumerable<QuestionsAnswerCommentVoteUpdateWithWhereUniqueWithoutCommentInput>
    updateMany?: Enumerable<QuestionsAnswerCommentVoteUpdateManyWithWhereWithoutCommentInput>
    deleteMany?: Enumerable<QuestionsAnswerCommentVoteScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutQuestionsAnswerCommentVotesInput = {
    create?: XOR<UserCreateWithoutQuestionsAnswerCommentVotesInput, UserUncheckedCreateWithoutQuestionsAnswerCommentVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuestionsAnswerCommentVotesInput
    connect?: UserWhereUniqueInput
  }

  export type QuestionsAnswerCommentCreateNestedOneWithoutVotesInput = {
    create?: XOR<QuestionsAnswerCommentCreateWithoutVotesInput, QuestionsAnswerCommentUncheckedCreateWithoutVotesInput>
    connectOrCreate?: QuestionsAnswerCommentCreateOrConnectWithoutVotesInput
    connect?: QuestionsAnswerCommentWhereUniqueInput
  }

  export type UserUpdateOneWithoutQuestionsAnswerCommentVotesNestedInput = {
    create?: XOR<UserCreateWithoutQuestionsAnswerCommentVotesInput, UserUncheckedCreateWithoutQuestionsAnswerCommentVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuestionsAnswerCommentVotesInput
    upsert?: UserUpsertWithoutQuestionsAnswerCommentVotesInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutQuestionsAnswerCommentVotesInput, UserUncheckedUpdateWithoutQuestionsAnswerCommentVotesInput>
  }

  export type QuestionsAnswerCommentUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<QuestionsAnswerCommentCreateWithoutVotesInput, QuestionsAnswerCommentUncheckedCreateWithoutVotesInput>
    connectOrCreate?: QuestionsAnswerCommentCreateOrConnectWithoutVotesInput
    upsert?: QuestionsAnswerCommentUpsertWithoutVotesInput
    connect?: QuestionsAnswerCommentWhereUniqueInput
    update?: XOR<QuestionsAnswerCommentUpdateWithoutVotesInput, QuestionsAnswerCommentUncheckedUpdateWithoutVotesInput>
  }

  export type UserCreateNestedOneWithoutQuestionsListsInput = {
    create?: XOR<UserCreateWithoutQuestionsListsInput, UserUncheckedCreateWithoutQuestionsListsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuestionsListsInput
    connect?: UserWhereUniqueInput
  }

  export type QuestionsListQuestionEntryCreateNestedManyWithoutListInput = {
    create?: XOR<Enumerable<QuestionsListQuestionEntryCreateWithoutListInput>, Enumerable<QuestionsListQuestionEntryUncheckedCreateWithoutListInput>>
    connectOrCreate?: Enumerable<QuestionsListQuestionEntryCreateOrConnectWithoutListInput>
    createMany?: QuestionsListQuestionEntryCreateManyListInputEnvelope
    connect?: Enumerable<QuestionsListQuestionEntryWhereUniqueInput>
  }

  export type QuestionsListQuestionEntryUncheckedCreateNestedManyWithoutListInput = {
    create?: XOR<Enumerable<QuestionsListQuestionEntryCreateWithoutListInput>, Enumerable<QuestionsListQuestionEntryUncheckedCreateWithoutListInput>>
    connectOrCreate?: Enumerable<QuestionsListQuestionEntryCreateOrConnectWithoutListInput>
    createMany?: QuestionsListQuestionEntryCreateManyListInputEnvelope
    connect?: Enumerable<QuestionsListQuestionEntryWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutQuestionsListsNestedInput = {
    create?: XOR<UserCreateWithoutQuestionsListsInput, UserUncheckedCreateWithoutQuestionsListsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuestionsListsInput
    upsert?: UserUpsertWithoutQuestionsListsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutQuestionsListsInput, UserUncheckedUpdateWithoutQuestionsListsInput>
  }

  export type QuestionsListQuestionEntryUpdateManyWithoutListNestedInput = {
    create?: XOR<Enumerable<QuestionsListQuestionEntryCreateWithoutListInput>, Enumerable<QuestionsListQuestionEntryUncheckedCreateWithoutListInput>>
    connectOrCreate?: Enumerable<QuestionsListQuestionEntryCreateOrConnectWithoutListInput>
    upsert?: Enumerable<QuestionsListQuestionEntryUpsertWithWhereUniqueWithoutListInput>
    createMany?: QuestionsListQuestionEntryCreateManyListInputEnvelope
    set?: Enumerable<QuestionsListQuestionEntryWhereUniqueInput>
    disconnect?: Enumerable<QuestionsListQuestionEntryWhereUniqueInput>
    delete?: Enumerable<QuestionsListQuestionEntryWhereUniqueInput>
    connect?: Enumerable<QuestionsListQuestionEntryWhereUniqueInput>
    update?: Enumerable<QuestionsListQuestionEntryUpdateWithWhereUniqueWithoutListInput>
    updateMany?: Enumerable<QuestionsListQuestionEntryUpdateManyWithWhereWithoutListInput>
    deleteMany?: Enumerable<QuestionsListQuestionEntryScalarWhereInput>
  }

  export type QuestionsListQuestionEntryUncheckedUpdateManyWithoutListNestedInput = {
    create?: XOR<Enumerable<QuestionsListQuestionEntryCreateWithoutListInput>, Enumerable<QuestionsListQuestionEntryUncheckedCreateWithoutListInput>>
    connectOrCreate?: Enumerable<QuestionsListQuestionEntryCreateOrConnectWithoutListInput>
    upsert?: Enumerable<QuestionsListQuestionEntryUpsertWithWhereUniqueWithoutListInput>
    createMany?: QuestionsListQuestionEntryCreateManyListInputEnvelope
    set?: Enumerable<QuestionsListQuestionEntryWhereUniqueInput>
    disconnect?: Enumerable<QuestionsListQuestionEntryWhereUniqueInput>
    delete?: Enumerable<QuestionsListQuestionEntryWhereUniqueInput>
    connect?: Enumerable<QuestionsListQuestionEntryWhereUniqueInput>
    update?: Enumerable<QuestionsListQuestionEntryUpdateWithWhereUniqueWithoutListInput>
    updateMany?: Enumerable<QuestionsListQuestionEntryUpdateManyWithWhereWithoutListInput>
    deleteMany?: Enumerable<QuestionsListQuestionEntryScalarWhereInput>
  }

  export type QuestionsListCreateNestedOneWithoutQuestionEntriesInput = {
    create?: XOR<QuestionsListCreateWithoutQuestionEntriesInput, QuestionsListUncheckedCreateWithoutQuestionEntriesInput>
    connectOrCreate?: QuestionsListCreateOrConnectWithoutQuestionEntriesInput
    connect?: QuestionsListWhereUniqueInput
  }

  export type QuestionsQuestionCreateNestedOneWithoutQuestionsListQuestionEntriesInput = {
    create?: XOR<QuestionsQuestionCreateWithoutQuestionsListQuestionEntriesInput, QuestionsQuestionUncheckedCreateWithoutQuestionsListQuestionEntriesInput>
    connectOrCreate?: QuestionsQuestionCreateOrConnectWithoutQuestionsListQuestionEntriesInput
    connect?: QuestionsQuestionWhereUniqueInput
  }

  export type QuestionsListUpdateOneRequiredWithoutQuestionEntriesNestedInput = {
    create?: XOR<QuestionsListCreateWithoutQuestionEntriesInput, QuestionsListUncheckedCreateWithoutQuestionEntriesInput>
    connectOrCreate?: QuestionsListCreateOrConnectWithoutQuestionEntriesInput
    upsert?: QuestionsListUpsertWithoutQuestionEntriesInput
    connect?: QuestionsListWhereUniqueInput
    update?: XOR<QuestionsListUpdateWithoutQuestionEntriesInput, QuestionsListUncheckedUpdateWithoutQuestionEntriesInput>
  }

  export type QuestionsQuestionUpdateOneRequiredWithoutQuestionsListQuestionEntriesNestedInput = {
    create?: XOR<QuestionsQuestionCreateWithoutQuestionsListQuestionEntriesInput, QuestionsQuestionUncheckedCreateWithoutQuestionsListQuestionEntriesInput>
    connectOrCreate?: QuestionsQuestionCreateOrConnectWithoutQuestionsListQuestionEntriesInput
    upsert?: QuestionsQuestionUpsertWithoutQuestionsListQuestionEntriesInput
    connect?: QuestionsQuestionWhereUniqueInput
    update?: XOR<QuestionsQuestionUpdateWithoutQuestionsListQuestionEntriesInput, QuestionsQuestionUncheckedUpdateWithoutQuestionsListQuestionEntriesInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedEnumTodoStatusFilter = {
    equals?: TodoStatus
    in?: Enumerable<TodoStatus>
    notIn?: Enumerable<TodoStatus>
    not?: NestedEnumTodoStatusFilter | TodoStatus
  }

  export type NestedEnumTodoStatusWithAggregatesFilter = {
    equals?: TodoStatus
    in?: Enumerable<TodoStatus>
    notIn?: Enumerable<TodoStatus>
    not?: NestedEnumTodoStatusWithAggregatesFilter | TodoStatus
    _count?: NestedIntFilter
    _min?: NestedEnumTodoStatusFilter
    _max?: NestedEnumTodoStatusFilter
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedEnumResumesSectionFilter = {
    equals?: ResumesSection
    in?: Enumerable<ResumesSection>
    notIn?: Enumerable<ResumesSection>
    not?: NestedEnumResumesSectionFilter | ResumesSection
  }

  export type NestedEnumResumesSectionWithAggregatesFilter = {
    equals?: ResumesSection
    in?: Enumerable<ResumesSection>
    notIn?: Enumerable<ResumesSection>
    not?: NestedEnumResumesSectionWithAggregatesFilter | ResumesSection
    _count?: NestedIntFilter
    _min?: NestedEnumResumesSectionFilter
    _max?: NestedEnumResumesSectionFilter
  }

  export type NestedEnumVoteFilter = {
    equals?: Vote
    in?: Enumerable<Vote>
    notIn?: Enumerable<Vote>
    not?: NestedEnumVoteFilter | Vote
  }

  export type NestedEnumVoteWithAggregatesFilter = {
    equals?: Vote
    in?: Enumerable<Vote>
    notIn?: Enumerable<Vote>
    not?: NestedEnumVoteWithAggregatesFilter | Vote
    _count?: NestedIntFilter
    _min?: NestedEnumVoteFilter
    _max?: NestedEnumVoteFilter
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedEnumJobTypeNullableFilter = {
    equals?: JobType | null
    in?: Enumerable<JobType> | null
    notIn?: Enumerable<JobType> | null
    not?: NestedEnumJobTypeNullableFilter | JobType | null
  }

  export type NestedEnumJobTypeNullableWithAggregatesFilter = {
    equals?: JobType | null
    in?: Enumerable<JobType> | null
    notIn?: Enumerable<JobType> | null
    not?: NestedEnumJobTypeNullableWithAggregatesFilter | JobType | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumJobTypeNullableFilter
    _max?: NestedEnumJobTypeNullableFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedEnumJobTypeFilter = {
    equals?: JobType
    in?: Enumerable<JobType>
    notIn?: Enumerable<JobType>
    not?: NestedEnumJobTypeFilter | JobType
  }

  export type NestedEnumJobTypeWithAggregatesFilter = {
    equals?: JobType
    in?: Enumerable<JobType>
    notIn?: Enumerable<JobType>
    not?: NestedEnumJobTypeWithAggregatesFilter | JobType
    _count?: NestedIntFilter
    _min?: NestedEnumJobTypeFilter
    _max?: NestedEnumJobTypeFilter
  }

  export type NestedEnumQuestionsQuestionTypeFilter = {
    equals?: QuestionsQuestionType
    in?: Enumerable<QuestionsQuestionType>
    notIn?: Enumerable<QuestionsQuestionType>
    not?: NestedEnumQuestionsQuestionTypeFilter | QuestionsQuestionType
  }

  export type NestedEnumQuestionsQuestionTypeWithAggregatesFilter = {
    equals?: QuestionsQuestionType
    in?: Enumerable<QuestionsQuestionType>
    notIn?: Enumerable<QuestionsQuestionType>
    not?: NestedEnumQuestionsQuestionTypeWithAggregatesFilter | QuestionsQuestionType
    _count?: NestedIntFilter
    _min?: NestedEnumQuestionsQuestionTypeFilter
    _max?: NestedEnumQuestionsQuestionTypeFilter
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    todos?: TodoCreateNestedManyWithoutUserInput
    resumesResumes?: ResumesResumeCreateNestedManyWithoutUserInput
    resumesStars?: ResumesStarCreateNestedManyWithoutUserInput
    resumesComments?: ResumesCommentCreateNestedManyWithoutUserInput
    resumesCommentVotes?: ResumesCommentVoteCreateNestedManyWithoutUserInput
    questionsQuestions?: QuestionsQuestionCreateNestedManyWithoutUserInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterCreateNestedManyWithoutUserInput
    questionsQuestionVotes?: QuestionsQuestionVoteCreateNestedManyWithoutUserInput
    questionsQuestionComments?: QuestionsQuestionCommentCreateNestedManyWithoutUserInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteCreateNestedManyWithoutUserInput
    questionsAnswers?: QuestionsAnswerCreateNestedManyWithoutUserInput
    questionsAnswerVotes?: QuestionsAnswerVoteCreateNestedManyWithoutUserInput
    questionsAnswerComments?: QuestionsAnswerCommentCreateNestedManyWithoutUserInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteCreateNestedManyWithoutUserInput
    OffersProfile?: OffersProfileCreateNestedManyWithoutUsersInput
    offersDiscussion?: OffersReplyCreateNestedManyWithoutUserInput
    questionsLists?: QuestionsListCreateNestedManyWithoutUserInput
    OffersAdmin?: OffersAdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
    resumesResumes?: ResumesResumeUncheckedCreateNestedManyWithoutUserInput
    resumesStars?: ResumesStarUncheckedCreateNestedManyWithoutUserInput
    resumesComments?: ResumesCommentUncheckedCreateNestedManyWithoutUserInput
    resumesCommentVotes?: ResumesCommentVoteUncheckedCreateNestedManyWithoutUserInput
    questionsQuestions?: QuestionsQuestionUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionVotes?: QuestionsQuestionVoteUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionComments?: QuestionsQuestionCommentUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUncheckedCreateNestedManyWithoutUserInput
    questionsAnswers?: QuestionsAnswerUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerVotes?: QuestionsAnswerVoteUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerComments?: QuestionsAnswerCommentUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUncheckedCreateNestedManyWithoutUserInput
    OffersProfile?: OffersProfileUncheckedCreateNestedManyWithoutUsersInput
    offersDiscussion?: OffersReplyUncheckedCreateNestedManyWithoutUserInput
    questionsLists?: QuestionsListUncheckedCreateNestedManyWithoutUserInput
    OffersAdmin?: OffersAdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
    resumesResumes?: ResumesResumeUpdateManyWithoutUserNestedInput
    resumesStars?: ResumesStarUpdateManyWithoutUserNestedInput
    resumesComments?: ResumesCommentUpdateManyWithoutUserNestedInput
    resumesCommentVotes?: ResumesCommentVoteUpdateManyWithoutUserNestedInput
    questionsQuestions?: QuestionsQuestionUpdateManyWithoutUserNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUpdateManyWithoutUserNestedInput
    questionsQuestionVotes?: QuestionsQuestionVoteUpdateManyWithoutUserNestedInput
    questionsQuestionComments?: QuestionsQuestionCommentUpdateManyWithoutUserNestedInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUpdateManyWithoutUserNestedInput
    questionsAnswers?: QuestionsAnswerUpdateManyWithoutUserNestedInput
    questionsAnswerVotes?: QuestionsAnswerVoteUpdateManyWithoutUserNestedInput
    questionsAnswerComments?: QuestionsAnswerCommentUpdateManyWithoutUserNestedInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUpdateManyWithoutUserNestedInput
    OffersProfile?: OffersProfileUpdateManyWithoutUsersNestedInput
    offersDiscussion?: OffersReplyUpdateManyWithoutUserNestedInput
    questionsLists?: QuestionsListUpdateManyWithoutUserNestedInput
    OffersAdmin?: OffersAdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
    resumesResumes?: ResumesResumeUncheckedUpdateManyWithoutUserNestedInput
    resumesStars?: ResumesStarUncheckedUpdateManyWithoutUserNestedInput
    resumesComments?: ResumesCommentUncheckedUpdateManyWithoutUserNestedInput
    resumesCommentVotes?: ResumesCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestions?: QuestionsQuestionUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionVotes?: QuestionsQuestionVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionComments?: QuestionsQuestionCommentUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswers?: QuestionsAnswerUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerVotes?: QuestionsAnswerVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerComments?: QuestionsAnswerCommentUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    OffersProfile?: OffersProfileUncheckedUpdateManyWithoutUsersNestedInput
    offersDiscussion?: OffersReplyUncheckedUpdateManyWithoutUserNestedInput
    questionsLists?: QuestionsListUncheckedUpdateManyWithoutUserNestedInput
    OffersAdmin?: OffersAdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    todos?: TodoCreateNestedManyWithoutUserInput
    resumesResumes?: ResumesResumeCreateNestedManyWithoutUserInput
    resumesStars?: ResumesStarCreateNestedManyWithoutUserInput
    resumesComments?: ResumesCommentCreateNestedManyWithoutUserInput
    resumesCommentVotes?: ResumesCommentVoteCreateNestedManyWithoutUserInput
    questionsQuestions?: QuestionsQuestionCreateNestedManyWithoutUserInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterCreateNestedManyWithoutUserInput
    questionsQuestionVotes?: QuestionsQuestionVoteCreateNestedManyWithoutUserInput
    questionsQuestionComments?: QuestionsQuestionCommentCreateNestedManyWithoutUserInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteCreateNestedManyWithoutUserInput
    questionsAnswers?: QuestionsAnswerCreateNestedManyWithoutUserInput
    questionsAnswerVotes?: QuestionsAnswerVoteCreateNestedManyWithoutUserInput
    questionsAnswerComments?: QuestionsAnswerCommentCreateNestedManyWithoutUserInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteCreateNestedManyWithoutUserInput
    OffersProfile?: OffersProfileCreateNestedManyWithoutUsersInput
    offersDiscussion?: OffersReplyCreateNestedManyWithoutUserInput
    questionsLists?: QuestionsListCreateNestedManyWithoutUserInput
    OffersAdmin?: OffersAdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
    resumesResumes?: ResumesResumeUncheckedCreateNestedManyWithoutUserInput
    resumesStars?: ResumesStarUncheckedCreateNestedManyWithoutUserInput
    resumesComments?: ResumesCommentUncheckedCreateNestedManyWithoutUserInput
    resumesCommentVotes?: ResumesCommentVoteUncheckedCreateNestedManyWithoutUserInput
    questionsQuestions?: QuestionsQuestionUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionVotes?: QuestionsQuestionVoteUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionComments?: QuestionsQuestionCommentUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUncheckedCreateNestedManyWithoutUserInput
    questionsAnswers?: QuestionsAnswerUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerVotes?: QuestionsAnswerVoteUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerComments?: QuestionsAnswerCommentUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUncheckedCreateNestedManyWithoutUserInput
    OffersProfile?: OffersProfileUncheckedCreateNestedManyWithoutUsersInput
    offersDiscussion?: OffersReplyUncheckedCreateNestedManyWithoutUserInput
    questionsLists?: QuestionsListUncheckedCreateNestedManyWithoutUserInput
    OffersAdmin?: OffersAdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
    resumesResumes?: ResumesResumeUpdateManyWithoutUserNestedInput
    resumesStars?: ResumesStarUpdateManyWithoutUserNestedInput
    resumesComments?: ResumesCommentUpdateManyWithoutUserNestedInput
    resumesCommentVotes?: ResumesCommentVoteUpdateManyWithoutUserNestedInput
    questionsQuestions?: QuestionsQuestionUpdateManyWithoutUserNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUpdateManyWithoutUserNestedInput
    questionsQuestionVotes?: QuestionsQuestionVoteUpdateManyWithoutUserNestedInput
    questionsQuestionComments?: QuestionsQuestionCommentUpdateManyWithoutUserNestedInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUpdateManyWithoutUserNestedInput
    questionsAnswers?: QuestionsAnswerUpdateManyWithoutUserNestedInput
    questionsAnswerVotes?: QuestionsAnswerVoteUpdateManyWithoutUserNestedInput
    questionsAnswerComments?: QuestionsAnswerCommentUpdateManyWithoutUserNestedInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUpdateManyWithoutUserNestedInput
    OffersProfile?: OffersProfileUpdateManyWithoutUsersNestedInput
    offersDiscussion?: OffersReplyUpdateManyWithoutUserNestedInput
    questionsLists?: QuestionsListUpdateManyWithoutUserNestedInput
    OffersAdmin?: OffersAdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
    resumesResumes?: ResumesResumeUncheckedUpdateManyWithoutUserNestedInput
    resumesStars?: ResumesStarUncheckedUpdateManyWithoutUserNestedInput
    resumesComments?: ResumesCommentUncheckedUpdateManyWithoutUserNestedInput
    resumesCommentVotes?: ResumesCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestions?: QuestionsQuestionUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionVotes?: QuestionsQuestionVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionComments?: QuestionsQuestionCommentUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswers?: QuestionsAnswerUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerVotes?: QuestionsAnswerVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerComments?: QuestionsAnswerCommentUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    OffersProfile?: OffersProfileUncheckedUpdateManyWithoutUsersNestedInput
    offersDiscussion?: OffersReplyUncheckedUpdateManyWithoutUserNestedInput
    questionsLists?: QuestionsListUncheckedUpdateManyWithoutUserNestedInput
    OffersAdmin?: OffersAdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: Enumerable<AccountCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: Enumerable<SessionCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type TodoCreateWithoutUserInput = {
    id?: string
    text: string
    status?: TodoStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TodoUncheckedCreateWithoutUserInput = {
    id?: string
    text: string
    status?: TodoStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TodoCreateOrConnectWithoutUserInput = {
    where: TodoWhereUniqueInput
    create: XOR<TodoCreateWithoutUserInput, TodoUncheckedCreateWithoutUserInput>
  }

  export type TodoCreateManyUserInputEnvelope = {
    data: Enumerable<TodoCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ResumesResumeCreateWithoutUserInput = {
    id?: string
    title: string
    role: string
    experience: string
    url: string
    additionalInfo?: string | null
    isResolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    location: CountryCreateNestedOneWithoutResumesResumeInput
    stars?: ResumesStarCreateNestedManyWithoutResumeInput
    comments?: ResumesCommentCreateNestedManyWithoutResumeInput
  }

  export type ResumesResumeUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    role: string
    experience: string
    locationId: string
    url: string
    additionalInfo?: string | null
    isResolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stars?: ResumesStarUncheckedCreateNestedManyWithoutResumeInput
    comments?: ResumesCommentUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumesResumeCreateOrConnectWithoutUserInput = {
    where: ResumesResumeWhereUniqueInput
    create: XOR<ResumesResumeCreateWithoutUserInput, ResumesResumeUncheckedCreateWithoutUserInput>
  }

  export type ResumesResumeCreateManyUserInputEnvelope = {
    data: Enumerable<ResumesResumeCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ResumesStarCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    resume: ResumesResumeCreateNestedOneWithoutStarsInput
  }

  export type ResumesStarUncheckedCreateWithoutUserInput = {
    id?: string
    resumeId: string
    createdAt?: Date | string
  }

  export type ResumesStarCreateOrConnectWithoutUserInput = {
    where: ResumesStarWhereUniqueInput
    create: XOR<ResumesStarCreateWithoutUserInput, ResumesStarUncheckedCreateWithoutUserInput>
  }

  export type ResumesStarCreateManyUserInputEnvelope = {
    data: Enumerable<ResumesStarCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ResumesCommentCreateWithoutUserInput = {
    id?: string
    description: string
    section: ResumesSection
    createdAt?: Date | string
    updatedAt?: Date | string
    resume: ResumesResumeCreateNestedOneWithoutCommentsInput
    votes?: ResumesCommentVoteCreateNestedManyWithoutCommentInput
    parent?: ResumesCommentCreateNestedOneWithoutChildrenInput
    children?: ResumesCommentCreateNestedManyWithoutParentInput
  }

  export type ResumesCommentUncheckedCreateWithoutUserInput = {
    id?: string
    resumeId: string
    parentId?: string | null
    description: string
    section: ResumesSection
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: ResumesCommentVoteUncheckedCreateNestedManyWithoutCommentInput
    children?: ResumesCommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type ResumesCommentCreateOrConnectWithoutUserInput = {
    where: ResumesCommentWhereUniqueInput
    create: XOR<ResumesCommentCreateWithoutUserInput, ResumesCommentUncheckedCreateWithoutUserInput>
  }

  export type ResumesCommentCreateManyUserInputEnvelope = {
    data: Enumerable<ResumesCommentCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ResumesCommentVoteCreateWithoutUserInput = {
    id?: string
    value: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
    comment: ResumesCommentCreateNestedOneWithoutVotesInput
  }

  export type ResumesCommentVoteUncheckedCreateWithoutUserInput = {
    id?: string
    commentId: string
    value: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResumesCommentVoteCreateOrConnectWithoutUserInput = {
    where: ResumesCommentVoteWhereUniqueInput
    create: XOR<ResumesCommentVoteCreateWithoutUserInput, ResumesCommentVoteUncheckedCreateWithoutUserInput>
  }

  export type ResumesCommentVoteCreateManyUserInputEnvelope = {
    data: Enumerable<ResumesCommentVoteCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type QuestionsQuestionCreateWithoutUserInput = {
    id?: string
    content: string
    questionType: QuestionsQuestionType
    lastSeenAt?: Date | string | null
    upvotes?: number
    numEncounters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    encounters?: QuestionsQuestionEncounterCreateNestedManyWithoutQuestionInput
    votes?: QuestionsQuestionVoteCreateNestedManyWithoutQuestionInput
    comments?: QuestionsQuestionCommentCreateNestedManyWithoutQuestionInput
    answers?: QuestionsAnswerCreateNestedManyWithoutQuestionInput
    questionsListQuestionEntries?: QuestionsListQuestionEntryCreateNestedManyWithoutQuestionInput
  }

  export type QuestionsQuestionUncheckedCreateWithoutUserInput = {
    id?: string
    content: string
    questionType: QuestionsQuestionType
    lastSeenAt?: Date | string | null
    upvotes?: number
    numEncounters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    encounters?: QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutQuestionInput
    votes?: QuestionsQuestionVoteUncheckedCreateNestedManyWithoutQuestionInput
    comments?: QuestionsQuestionCommentUncheckedCreateNestedManyWithoutQuestionInput
    answers?: QuestionsAnswerUncheckedCreateNestedManyWithoutQuestionInput
    questionsListQuestionEntries?: QuestionsListQuestionEntryUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionsQuestionCreateOrConnectWithoutUserInput = {
    where: QuestionsQuestionWhereUniqueInput
    create: XOR<QuestionsQuestionCreateWithoutUserInput, QuestionsQuestionUncheckedCreateWithoutUserInput>
  }

  export type QuestionsQuestionCreateManyUserInputEnvelope = {
    data: Enumerable<QuestionsQuestionCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type QuestionsQuestionEncounterCreateWithoutUserInput = {
    id?: string
    role: string
    seenAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    country?: CountryCreateNestedOneWithoutQuestionsQuestionEncountersInput
    state?: StateCreateNestedOneWithoutQuestionsQuestionEncountersInput
    city?: CityCreateNestedOneWithoutQuestionsQuestionEncountersInput
    company?: CompanyCreateNestedOneWithoutQuestionsQuestionEncounterInput
    question: QuestionsQuestionCreateNestedOneWithoutEncountersInput
  }

  export type QuestionsQuestionEncounterUncheckedCreateWithoutUserInput = {
    id?: string
    questionId: string
    companyId?: string | null
    countryId?: string | null
    stateId?: string | null
    cityId?: string | null
    role: string
    seenAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsQuestionEncounterCreateOrConnectWithoutUserInput = {
    where: QuestionsQuestionEncounterWhereUniqueInput
    create: XOR<QuestionsQuestionEncounterCreateWithoutUserInput, QuestionsQuestionEncounterUncheckedCreateWithoutUserInput>
  }

  export type QuestionsQuestionEncounterCreateManyUserInputEnvelope = {
    data: Enumerable<QuestionsQuestionEncounterCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type QuestionsQuestionVoteCreateWithoutUserInput = {
    id?: string
    vote: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
    question: QuestionsQuestionCreateNestedOneWithoutVotesInput
  }

  export type QuestionsQuestionVoteUncheckedCreateWithoutUserInput = {
    id?: string
    questionId: string
    vote: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsQuestionVoteCreateOrConnectWithoutUserInput = {
    where: QuestionsQuestionVoteWhereUniqueInput
    create: XOR<QuestionsQuestionVoteCreateWithoutUserInput, QuestionsQuestionVoteUncheckedCreateWithoutUserInput>
  }

  export type QuestionsQuestionVoteCreateManyUserInputEnvelope = {
    data: Enumerable<QuestionsQuestionVoteCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type QuestionsQuestionCommentCreateWithoutUserInput = {
    id?: string
    upvotes?: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    question: QuestionsQuestionCreateNestedOneWithoutCommentsInput
    votes?: QuestionsQuestionCommentVoteCreateNestedManyWithoutCommentInput
  }

  export type QuestionsQuestionCommentUncheckedCreateWithoutUserInput = {
    id?: string
    questionId: string
    upvotes?: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: QuestionsQuestionCommentVoteUncheckedCreateNestedManyWithoutCommentInput
  }

  export type QuestionsQuestionCommentCreateOrConnectWithoutUserInput = {
    where: QuestionsQuestionCommentWhereUniqueInput
    create: XOR<QuestionsQuestionCommentCreateWithoutUserInput, QuestionsQuestionCommentUncheckedCreateWithoutUserInput>
  }

  export type QuestionsQuestionCommentCreateManyUserInputEnvelope = {
    data: Enumerable<QuestionsQuestionCommentCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type QuestionsQuestionCommentVoteCreateWithoutUserInput = {
    id?: string
    vote: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
    comment: QuestionsQuestionCommentCreateNestedOneWithoutVotesInput
  }

  export type QuestionsQuestionCommentVoteUncheckedCreateWithoutUserInput = {
    id?: string
    questionCommentId: string
    vote: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsQuestionCommentVoteCreateOrConnectWithoutUserInput = {
    where: QuestionsQuestionCommentVoteWhereUniqueInput
    create: XOR<QuestionsQuestionCommentVoteCreateWithoutUserInput, QuestionsQuestionCommentVoteUncheckedCreateWithoutUserInput>
  }

  export type QuestionsQuestionCommentVoteCreateManyUserInputEnvelope = {
    data: Enumerable<QuestionsQuestionCommentVoteCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type QuestionsAnswerCreateWithoutUserInput = {
    id?: string
    content: string
    upvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    question: QuestionsQuestionCreateNestedOneWithoutAnswersInput
    votes?: QuestionsAnswerVoteCreateNestedManyWithoutAnswerInput
    comments?: QuestionsAnswerCommentCreateNestedManyWithoutAnswerInput
  }

  export type QuestionsAnswerUncheckedCreateWithoutUserInput = {
    id?: string
    questionId: string
    content: string
    upvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: QuestionsAnswerVoteUncheckedCreateNestedManyWithoutAnswerInput
    comments?: QuestionsAnswerCommentUncheckedCreateNestedManyWithoutAnswerInput
  }

  export type QuestionsAnswerCreateOrConnectWithoutUserInput = {
    where: QuestionsAnswerWhereUniqueInput
    create: XOR<QuestionsAnswerCreateWithoutUserInput, QuestionsAnswerUncheckedCreateWithoutUserInput>
  }

  export type QuestionsAnswerCreateManyUserInputEnvelope = {
    data: Enumerable<QuestionsAnswerCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type QuestionsAnswerVoteCreateWithoutUserInput = {
    id?: string
    vote: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
    answer: QuestionsAnswerCreateNestedOneWithoutVotesInput
  }

  export type QuestionsAnswerVoteUncheckedCreateWithoutUserInput = {
    id?: string
    answerId: string
    vote: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsAnswerVoteCreateOrConnectWithoutUserInput = {
    where: QuestionsAnswerVoteWhereUniqueInput
    create: XOR<QuestionsAnswerVoteCreateWithoutUserInput, QuestionsAnswerVoteUncheckedCreateWithoutUserInput>
  }

  export type QuestionsAnswerVoteCreateManyUserInputEnvelope = {
    data: Enumerable<QuestionsAnswerVoteCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type QuestionsAnswerCommentCreateWithoutUserInput = {
    id?: string
    content: string
    upvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    answer: QuestionsAnswerCreateNestedOneWithoutCommentsInput
    votes?: QuestionsAnswerCommentVoteCreateNestedManyWithoutCommentInput
  }

  export type QuestionsAnswerCommentUncheckedCreateWithoutUserInput = {
    id?: string
    answerId: string
    content: string
    upvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: QuestionsAnswerCommentVoteUncheckedCreateNestedManyWithoutCommentInput
  }

  export type QuestionsAnswerCommentCreateOrConnectWithoutUserInput = {
    where: QuestionsAnswerCommentWhereUniqueInput
    create: XOR<QuestionsAnswerCommentCreateWithoutUserInput, QuestionsAnswerCommentUncheckedCreateWithoutUserInput>
  }

  export type QuestionsAnswerCommentCreateManyUserInputEnvelope = {
    data: Enumerable<QuestionsAnswerCommentCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type QuestionsAnswerCommentVoteCreateWithoutUserInput = {
    id?: string
    vote: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
    comment: QuestionsAnswerCommentCreateNestedOneWithoutVotesInput
  }

  export type QuestionsAnswerCommentVoteUncheckedCreateWithoutUserInput = {
    id?: string
    answerCommentId: string
    vote: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsAnswerCommentVoteCreateOrConnectWithoutUserInput = {
    where: QuestionsAnswerCommentVoteWhereUniqueInput
    create: XOR<QuestionsAnswerCommentVoteCreateWithoutUserInput, QuestionsAnswerCommentVoteUncheckedCreateWithoutUserInput>
  }

  export type QuestionsAnswerCommentVoteCreateManyUserInputEnvelope = {
    data: Enumerable<QuestionsAnswerCommentVoteCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type OffersProfileCreateWithoutUsersInput = {
    id?: string
    profileName: string
    createdAt?: Date | string
    background?: OffersBackgroundCreateNestedOneWithoutProfileInput
    editToken: string
    discussion?: OffersReplyCreateNestedManyWithoutProfileInput
    offers?: OffersOfferCreateNestedManyWithoutProfileInput
    analysis?: OffersAnalysisCreateNestedOneWithoutProfileInput
  }

  export type OffersProfileUncheckedCreateWithoutUsersInput = {
    id?: string
    profileName: string
    createdAt?: Date | string
    background?: OffersBackgroundUncheckedCreateNestedOneWithoutProfileInput
    editToken: string
    discussion?: OffersReplyUncheckedCreateNestedManyWithoutProfileInput
    offers?: OffersOfferUncheckedCreateNestedManyWithoutProfileInput
    analysis?: OffersAnalysisUncheckedCreateNestedOneWithoutProfileInput
  }

  export type OffersProfileCreateOrConnectWithoutUsersInput = {
    where: OffersProfileWhereUniqueInput
    create: XOR<OffersProfileCreateWithoutUsersInput, OffersProfileUncheckedCreateWithoutUsersInput>
  }

  export type OffersReplyCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    message: string
    replyingTo?: OffersReplyCreateNestedOneWithoutRepliesInput
    replies?: OffersReplyCreateNestedManyWithoutReplyingToInput
    profile: OffersProfileCreateNestedOneWithoutDiscussionInput
  }

  export type OffersReplyUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    message: string
    replyingToId?: string | null
    replies?: OffersReplyUncheckedCreateNestedManyWithoutReplyingToInput
    profileId: string
  }

  export type OffersReplyCreateOrConnectWithoutUserInput = {
    where: OffersReplyWhereUniqueInput
    create: XOR<OffersReplyCreateWithoutUserInput, OffersReplyUncheckedCreateWithoutUserInput>
  }

  export type OffersReplyCreateManyUserInputEnvelope = {
    data: Enumerable<OffersReplyCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type QuestionsListCreateWithoutUserInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    questionEntries?: QuestionsListQuestionEntryCreateNestedManyWithoutListInput
  }

  export type QuestionsListUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    questionEntries?: QuestionsListQuestionEntryUncheckedCreateNestedManyWithoutListInput
  }

  export type QuestionsListCreateOrConnectWithoutUserInput = {
    where: QuestionsListWhereUniqueInput
    create: XOR<QuestionsListCreateWithoutUserInput, QuestionsListUncheckedCreateWithoutUserInput>
  }

  export type QuestionsListCreateManyUserInputEnvelope = {
    data: Enumerable<QuestionsListCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type OffersAdminCreateWithoutUserInput = {
    id?: string
  }

  export type OffersAdminUncheckedCreateWithoutUserInput = {
    id?: string
  }

  export type OffersAdminCreateOrConnectWithoutUserInput = {
    where: OffersAdminWhereUniqueInput
    create: XOR<OffersAdminCreateWithoutUserInput, OffersAdminUncheckedCreateWithoutUserInput>
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutAccountsInput>
  }

  export type AccountScalarWhereInput = {
    AND?: Enumerable<AccountScalarWhereInput>
    OR?: Enumerable<AccountScalarWhereInput>
    NOT?: Enumerable<AccountScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    type?: StringFilter | string
    provider?: StringFilter | string
    providerAccountId?: StringFilter | string
    refresh_token?: StringNullableFilter | string | null
    access_token?: StringNullableFilter | string | null
    expires_at?: IntNullableFilter | number | null
    token_type?: StringNullableFilter | string | null
    scope?: StringNullableFilter | string | null
    id_token?: StringNullableFilter | string | null
    session_state?: StringNullableFilter | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutSessionsInput>
  }

  export type SessionScalarWhereInput = {
    AND?: Enumerable<SessionScalarWhereInput>
    OR?: Enumerable<SessionScalarWhereInput>
    NOT?: Enumerable<SessionScalarWhereInput>
    id?: StringFilter | string
    sessionToken?: StringFilter | string
    userId?: StringFilter | string
    expires?: DateTimeFilter | Date | string
  }

  export type TodoUpsertWithWhereUniqueWithoutUserInput = {
    where: TodoWhereUniqueInput
    update: XOR<TodoUpdateWithoutUserInput, TodoUncheckedUpdateWithoutUserInput>
    create: XOR<TodoCreateWithoutUserInput, TodoUncheckedCreateWithoutUserInput>
  }

  export type TodoUpdateWithWhereUniqueWithoutUserInput = {
    where: TodoWhereUniqueInput
    data: XOR<TodoUpdateWithoutUserInput, TodoUncheckedUpdateWithoutUserInput>
  }

  export type TodoUpdateManyWithWhereWithoutUserInput = {
    where: TodoScalarWhereInput
    data: XOR<TodoUpdateManyMutationInput, TodoUncheckedUpdateManyWithoutTodosInput>
  }

  export type TodoScalarWhereInput = {
    AND?: Enumerable<TodoScalarWhereInput>
    OR?: Enumerable<TodoScalarWhereInput>
    NOT?: Enumerable<TodoScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    text?: StringFilter | string
    status?: EnumTodoStatusFilter | TodoStatus
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ResumesResumeUpsertWithWhereUniqueWithoutUserInput = {
    where: ResumesResumeWhereUniqueInput
    update: XOR<ResumesResumeUpdateWithoutUserInput, ResumesResumeUncheckedUpdateWithoutUserInput>
    create: XOR<ResumesResumeCreateWithoutUserInput, ResumesResumeUncheckedCreateWithoutUserInput>
  }

  export type ResumesResumeUpdateWithWhereUniqueWithoutUserInput = {
    where: ResumesResumeWhereUniqueInput
    data: XOR<ResumesResumeUpdateWithoutUserInput, ResumesResumeUncheckedUpdateWithoutUserInput>
  }

  export type ResumesResumeUpdateManyWithWhereWithoutUserInput = {
    where: ResumesResumeScalarWhereInput
    data: XOR<ResumesResumeUpdateManyMutationInput, ResumesResumeUncheckedUpdateManyWithoutResumesResumesInput>
  }

  export type ResumesResumeScalarWhereInput = {
    AND?: Enumerable<ResumesResumeScalarWhereInput>
    OR?: Enumerable<ResumesResumeScalarWhereInput>
    NOT?: Enumerable<ResumesResumeScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    title?: StringFilter | string
    role?: StringFilter | string
    experience?: StringFilter | string
    locationId?: StringFilter | string
    url?: StringFilter | string
    additionalInfo?: StringNullableFilter | string | null
    isResolved?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ResumesStarUpsertWithWhereUniqueWithoutUserInput = {
    where: ResumesStarWhereUniqueInput
    update: XOR<ResumesStarUpdateWithoutUserInput, ResumesStarUncheckedUpdateWithoutUserInput>
    create: XOR<ResumesStarCreateWithoutUserInput, ResumesStarUncheckedCreateWithoutUserInput>
  }

  export type ResumesStarUpdateWithWhereUniqueWithoutUserInput = {
    where: ResumesStarWhereUniqueInput
    data: XOR<ResumesStarUpdateWithoutUserInput, ResumesStarUncheckedUpdateWithoutUserInput>
  }

  export type ResumesStarUpdateManyWithWhereWithoutUserInput = {
    where: ResumesStarScalarWhereInput
    data: XOR<ResumesStarUpdateManyMutationInput, ResumesStarUncheckedUpdateManyWithoutResumesStarsInput>
  }

  export type ResumesStarScalarWhereInput = {
    AND?: Enumerable<ResumesStarScalarWhereInput>
    OR?: Enumerable<ResumesStarScalarWhereInput>
    NOT?: Enumerable<ResumesStarScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    resumeId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
  }

  export type ResumesCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: ResumesCommentWhereUniqueInput
    update: XOR<ResumesCommentUpdateWithoutUserInput, ResumesCommentUncheckedUpdateWithoutUserInput>
    create: XOR<ResumesCommentCreateWithoutUserInput, ResumesCommentUncheckedCreateWithoutUserInput>
  }

  export type ResumesCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: ResumesCommentWhereUniqueInput
    data: XOR<ResumesCommentUpdateWithoutUserInput, ResumesCommentUncheckedUpdateWithoutUserInput>
  }

  export type ResumesCommentUpdateManyWithWhereWithoutUserInput = {
    where: ResumesCommentScalarWhereInput
    data: XOR<ResumesCommentUpdateManyMutationInput, ResumesCommentUncheckedUpdateManyWithoutResumesCommentsInput>
  }

  export type ResumesCommentScalarWhereInput = {
    AND?: Enumerable<ResumesCommentScalarWhereInput>
    OR?: Enumerable<ResumesCommentScalarWhereInput>
    NOT?: Enumerable<ResumesCommentScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    resumeId?: StringFilter | string
    parentId?: StringNullableFilter | string | null
    description?: StringFilter | string
    section?: EnumResumesSectionFilter | ResumesSection
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ResumesCommentVoteUpsertWithWhereUniqueWithoutUserInput = {
    where: ResumesCommentVoteWhereUniqueInput
    update: XOR<ResumesCommentVoteUpdateWithoutUserInput, ResumesCommentVoteUncheckedUpdateWithoutUserInput>
    create: XOR<ResumesCommentVoteCreateWithoutUserInput, ResumesCommentVoteUncheckedCreateWithoutUserInput>
  }

  export type ResumesCommentVoteUpdateWithWhereUniqueWithoutUserInput = {
    where: ResumesCommentVoteWhereUniqueInput
    data: XOR<ResumesCommentVoteUpdateWithoutUserInput, ResumesCommentVoteUncheckedUpdateWithoutUserInput>
  }

  export type ResumesCommentVoteUpdateManyWithWhereWithoutUserInput = {
    where: ResumesCommentVoteScalarWhereInput
    data: XOR<ResumesCommentVoteUpdateManyMutationInput, ResumesCommentVoteUncheckedUpdateManyWithoutResumesCommentVotesInput>
  }

  export type ResumesCommentVoteScalarWhereInput = {
    AND?: Enumerable<ResumesCommentVoteScalarWhereInput>
    OR?: Enumerable<ResumesCommentVoteScalarWhereInput>
    NOT?: Enumerable<ResumesCommentVoteScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    commentId?: StringFilter | string
    value?: EnumVoteFilter | Vote
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type QuestionsQuestionUpsertWithWhereUniqueWithoutUserInput = {
    where: QuestionsQuestionWhereUniqueInput
    update: XOR<QuestionsQuestionUpdateWithoutUserInput, QuestionsQuestionUncheckedUpdateWithoutUserInput>
    create: XOR<QuestionsQuestionCreateWithoutUserInput, QuestionsQuestionUncheckedCreateWithoutUserInput>
  }

  export type QuestionsQuestionUpdateWithWhereUniqueWithoutUserInput = {
    where: QuestionsQuestionWhereUniqueInput
    data: XOR<QuestionsQuestionUpdateWithoutUserInput, QuestionsQuestionUncheckedUpdateWithoutUserInput>
  }

  export type QuestionsQuestionUpdateManyWithWhereWithoutUserInput = {
    where: QuestionsQuestionScalarWhereInput
    data: XOR<QuestionsQuestionUpdateManyMutationInput, QuestionsQuestionUncheckedUpdateManyWithoutQuestionsQuestionsInput>
  }

  export type QuestionsQuestionScalarWhereInput = {
    AND?: Enumerable<QuestionsQuestionScalarWhereInput>
    OR?: Enumerable<QuestionsQuestionScalarWhereInput>
    NOT?: Enumerable<QuestionsQuestionScalarWhereInput>
    id?: StringFilter | string
    userId?: StringNullableFilter | string | null
    content?: StringFilter | string
    questionType?: EnumQuestionsQuestionTypeFilter | QuestionsQuestionType
    lastSeenAt?: DateTimeNullableFilter | Date | string | null
    upvotes?: IntFilter | number
    numEncounters?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type QuestionsQuestionEncounterUpsertWithWhereUniqueWithoutUserInput = {
    where: QuestionsQuestionEncounterWhereUniqueInput
    update: XOR<QuestionsQuestionEncounterUpdateWithoutUserInput, QuestionsQuestionEncounterUncheckedUpdateWithoutUserInput>
    create: XOR<QuestionsQuestionEncounterCreateWithoutUserInput, QuestionsQuestionEncounterUncheckedCreateWithoutUserInput>
  }

  export type QuestionsQuestionEncounterUpdateWithWhereUniqueWithoutUserInput = {
    where: QuestionsQuestionEncounterWhereUniqueInput
    data: XOR<QuestionsQuestionEncounterUpdateWithoutUserInput, QuestionsQuestionEncounterUncheckedUpdateWithoutUserInput>
  }

  export type QuestionsQuestionEncounterUpdateManyWithWhereWithoutUserInput = {
    where: QuestionsQuestionEncounterScalarWhereInput
    data: XOR<QuestionsQuestionEncounterUpdateManyMutationInput, QuestionsQuestionEncounterUncheckedUpdateManyWithoutQuestionsQuestionEncountersInput>
  }

  export type QuestionsQuestionEncounterScalarWhereInput = {
    AND?: Enumerable<QuestionsQuestionEncounterScalarWhereInput>
    OR?: Enumerable<QuestionsQuestionEncounterScalarWhereInput>
    NOT?: Enumerable<QuestionsQuestionEncounterScalarWhereInput>
    id?: StringFilter | string
    questionId?: StringFilter | string
    userId?: StringNullableFilter | string | null
    companyId?: StringNullableFilter | string | null
    countryId?: StringNullableFilter | string | null
    stateId?: StringNullableFilter | string | null
    cityId?: StringNullableFilter | string | null
    role?: StringFilter | string
    seenAt?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type QuestionsQuestionVoteUpsertWithWhereUniqueWithoutUserInput = {
    where: QuestionsQuestionVoteWhereUniqueInput
    update: XOR<QuestionsQuestionVoteUpdateWithoutUserInput, QuestionsQuestionVoteUncheckedUpdateWithoutUserInput>
    create: XOR<QuestionsQuestionVoteCreateWithoutUserInput, QuestionsQuestionVoteUncheckedCreateWithoutUserInput>
  }

  export type QuestionsQuestionVoteUpdateWithWhereUniqueWithoutUserInput = {
    where: QuestionsQuestionVoteWhereUniqueInput
    data: XOR<QuestionsQuestionVoteUpdateWithoutUserInput, QuestionsQuestionVoteUncheckedUpdateWithoutUserInput>
  }

  export type QuestionsQuestionVoteUpdateManyWithWhereWithoutUserInput = {
    where: QuestionsQuestionVoteScalarWhereInput
    data: XOR<QuestionsQuestionVoteUpdateManyMutationInput, QuestionsQuestionVoteUncheckedUpdateManyWithoutQuestionsQuestionVotesInput>
  }

  export type QuestionsQuestionVoteScalarWhereInput = {
    AND?: Enumerable<QuestionsQuestionVoteScalarWhereInput>
    OR?: Enumerable<QuestionsQuestionVoteScalarWhereInput>
    NOT?: Enumerable<QuestionsQuestionVoteScalarWhereInput>
    id?: StringFilter | string
    questionId?: StringFilter | string
    userId?: StringNullableFilter | string | null
    vote?: EnumVoteFilter | Vote
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type QuestionsQuestionCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: QuestionsQuestionCommentWhereUniqueInput
    update: XOR<QuestionsQuestionCommentUpdateWithoutUserInput, QuestionsQuestionCommentUncheckedUpdateWithoutUserInput>
    create: XOR<QuestionsQuestionCommentCreateWithoutUserInput, QuestionsQuestionCommentUncheckedCreateWithoutUserInput>
  }

  export type QuestionsQuestionCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: QuestionsQuestionCommentWhereUniqueInput
    data: XOR<QuestionsQuestionCommentUpdateWithoutUserInput, QuestionsQuestionCommentUncheckedUpdateWithoutUserInput>
  }

  export type QuestionsQuestionCommentUpdateManyWithWhereWithoutUserInput = {
    where: QuestionsQuestionCommentScalarWhereInput
    data: XOR<QuestionsQuestionCommentUpdateManyMutationInput, QuestionsQuestionCommentUncheckedUpdateManyWithoutQuestionsQuestionCommentsInput>
  }

  export type QuestionsQuestionCommentScalarWhereInput = {
    AND?: Enumerable<QuestionsQuestionCommentScalarWhereInput>
    OR?: Enumerable<QuestionsQuestionCommentScalarWhereInput>
    NOT?: Enumerable<QuestionsQuestionCommentScalarWhereInput>
    id?: StringFilter | string
    questionId?: StringFilter | string
    userId?: StringNullableFilter | string | null
    upvotes?: IntFilter | number
    content?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type QuestionsQuestionCommentVoteUpsertWithWhereUniqueWithoutUserInput = {
    where: QuestionsQuestionCommentVoteWhereUniqueInput
    update: XOR<QuestionsQuestionCommentVoteUpdateWithoutUserInput, QuestionsQuestionCommentVoteUncheckedUpdateWithoutUserInput>
    create: XOR<QuestionsQuestionCommentVoteCreateWithoutUserInput, QuestionsQuestionCommentVoteUncheckedCreateWithoutUserInput>
  }

  export type QuestionsQuestionCommentVoteUpdateWithWhereUniqueWithoutUserInput = {
    where: QuestionsQuestionCommentVoteWhereUniqueInput
    data: XOR<QuestionsQuestionCommentVoteUpdateWithoutUserInput, QuestionsQuestionCommentVoteUncheckedUpdateWithoutUserInput>
  }

  export type QuestionsQuestionCommentVoteUpdateManyWithWhereWithoutUserInput = {
    where: QuestionsQuestionCommentVoteScalarWhereInput
    data: XOR<QuestionsQuestionCommentVoteUpdateManyMutationInput, QuestionsQuestionCommentVoteUncheckedUpdateManyWithoutQuestionsQuestionCommentVotesInput>
  }

  export type QuestionsQuestionCommentVoteScalarWhereInput = {
    AND?: Enumerable<QuestionsQuestionCommentVoteScalarWhereInput>
    OR?: Enumerable<QuestionsQuestionCommentVoteScalarWhereInput>
    NOT?: Enumerable<QuestionsQuestionCommentVoteScalarWhereInput>
    id?: StringFilter | string
    questionCommentId?: StringFilter | string
    userId?: StringNullableFilter | string | null
    vote?: EnumVoteFilter | Vote
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type QuestionsAnswerUpsertWithWhereUniqueWithoutUserInput = {
    where: QuestionsAnswerWhereUniqueInput
    update: XOR<QuestionsAnswerUpdateWithoutUserInput, QuestionsAnswerUncheckedUpdateWithoutUserInput>
    create: XOR<QuestionsAnswerCreateWithoutUserInput, QuestionsAnswerUncheckedCreateWithoutUserInput>
  }

  export type QuestionsAnswerUpdateWithWhereUniqueWithoutUserInput = {
    where: QuestionsAnswerWhereUniqueInput
    data: XOR<QuestionsAnswerUpdateWithoutUserInput, QuestionsAnswerUncheckedUpdateWithoutUserInput>
  }

  export type QuestionsAnswerUpdateManyWithWhereWithoutUserInput = {
    where: QuestionsAnswerScalarWhereInput
    data: XOR<QuestionsAnswerUpdateManyMutationInput, QuestionsAnswerUncheckedUpdateManyWithoutQuestionsAnswersInput>
  }

  export type QuestionsAnswerScalarWhereInput = {
    AND?: Enumerable<QuestionsAnswerScalarWhereInput>
    OR?: Enumerable<QuestionsAnswerScalarWhereInput>
    NOT?: Enumerable<QuestionsAnswerScalarWhereInput>
    id?: StringFilter | string
    questionId?: StringFilter | string
    userId?: StringNullableFilter | string | null
    content?: StringFilter | string
    upvotes?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type QuestionsAnswerVoteUpsertWithWhereUniqueWithoutUserInput = {
    where: QuestionsAnswerVoteWhereUniqueInput
    update: XOR<QuestionsAnswerVoteUpdateWithoutUserInput, QuestionsAnswerVoteUncheckedUpdateWithoutUserInput>
    create: XOR<QuestionsAnswerVoteCreateWithoutUserInput, QuestionsAnswerVoteUncheckedCreateWithoutUserInput>
  }

  export type QuestionsAnswerVoteUpdateWithWhereUniqueWithoutUserInput = {
    where: QuestionsAnswerVoteWhereUniqueInput
    data: XOR<QuestionsAnswerVoteUpdateWithoutUserInput, QuestionsAnswerVoteUncheckedUpdateWithoutUserInput>
  }

  export type QuestionsAnswerVoteUpdateManyWithWhereWithoutUserInput = {
    where: QuestionsAnswerVoteScalarWhereInput
    data: XOR<QuestionsAnswerVoteUpdateManyMutationInput, QuestionsAnswerVoteUncheckedUpdateManyWithoutQuestionsAnswerVotesInput>
  }

  export type QuestionsAnswerVoteScalarWhereInput = {
    AND?: Enumerable<QuestionsAnswerVoteScalarWhereInput>
    OR?: Enumerable<QuestionsAnswerVoteScalarWhereInput>
    NOT?: Enumerable<QuestionsAnswerVoteScalarWhereInput>
    id?: StringFilter | string
    answerId?: StringFilter | string
    userId?: StringNullableFilter | string | null
    vote?: EnumVoteFilter | Vote
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type QuestionsAnswerCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: QuestionsAnswerCommentWhereUniqueInput
    update: XOR<QuestionsAnswerCommentUpdateWithoutUserInput, QuestionsAnswerCommentUncheckedUpdateWithoutUserInput>
    create: XOR<QuestionsAnswerCommentCreateWithoutUserInput, QuestionsAnswerCommentUncheckedCreateWithoutUserInput>
  }

  export type QuestionsAnswerCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: QuestionsAnswerCommentWhereUniqueInput
    data: XOR<QuestionsAnswerCommentUpdateWithoutUserInput, QuestionsAnswerCommentUncheckedUpdateWithoutUserInput>
  }

  export type QuestionsAnswerCommentUpdateManyWithWhereWithoutUserInput = {
    where: QuestionsAnswerCommentScalarWhereInput
    data: XOR<QuestionsAnswerCommentUpdateManyMutationInput, QuestionsAnswerCommentUncheckedUpdateManyWithoutQuestionsAnswerCommentsInput>
  }

  export type QuestionsAnswerCommentScalarWhereInput = {
    AND?: Enumerable<QuestionsAnswerCommentScalarWhereInput>
    OR?: Enumerable<QuestionsAnswerCommentScalarWhereInput>
    NOT?: Enumerable<QuestionsAnswerCommentScalarWhereInput>
    id?: StringFilter | string
    answerId?: StringFilter | string
    userId?: StringNullableFilter | string | null
    content?: StringFilter | string
    upvotes?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type QuestionsAnswerCommentVoteUpsertWithWhereUniqueWithoutUserInput = {
    where: QuestionsAnswerCommentVoteWhereUniqueInput
    update: XOR<QuestionsAnswerCommentVoteUpdateWithoutUserInput, QuestionsAnswerCommentVoteUncheckedUpdateWithoutUserInput>
    create: XOR<QuestionsAnswerCommentVoteCreateWithoutUserInput, QuestionsAnswerCommentVoteUncheckedCreateWithoutUserInput>
  }

  export type QuestionsAnswerCommentVoteUpdateWithWhereUniqueWithoutUserInput = {
    where: QuestionsAnswerCommentVoteWhereUniqueInput
    data: XOR<QuestionsAnswerCommentVoteUpdateWithoutUserInput, QuestionsAnswerCommentVoteUncheckedUpdateWithoutUserInput>
  }

  export type QuestionsAnswerCommentVoteUpdateManyWithWhereWithoutUserInput = {
    where: QuestionsAnswerCommentVoteScalarWhereInput
    data: XOR<QuestionsAnswerCommentVoteUpdateManyMutationInput, QuestionsAnswerCommentVoteUncheckedUpdateManyWithoutQuestionsAnswerCommentVotesInput>
  }

  export type QuestionsAnswerCommentVoteScalarWhereInput = {
    AND?: Enumerable<QuestionsAnswerCommentVoteScalarWhereInput>
    OR?: Enumerable<QuestionsAnswerCommentVoteScalarWhereInput>
    NOT?: Enumerable<QuestionsAnswerCommentVoteScalarWhereInput>
    id?: StringFilter | string
    answerCommentId?: StringFilter | string
    userId?: StringNullableFilter | string | null
    vote?: EnumVoteFilter | Vote
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type OffersProfileUpsertWithWhereUniqueWithoutUsersInput = {
    where: OffersProfileWhereUniqueInput
    update: XOR<OffersProfileUpdateWithoutUsersInput, OffersProfileUncheckedUpdateWithoutUsersInput>
    create: XOR<OffersProfileCreateWithoutUsersInput, OffersProfileUncheckedCreateWithoutUsersInput>
  }

  export type OffersProfileUpdateWithWhereUniqueWithoutUsersInput = {
    where: OffersProfileWhereUniqueInput
    data: XOR<OffersProfileUpdateWithoutUsersInput, OffersProfileUncheckedUpdateWithoutUsersInput>
  }

  export type OffersProfileUpdateManyWithWhereWithoutUsersInput = {
    where: OffersProfileScalarWhereInput
    data: XOR<OffersProfileUpdateManyMutationInput, OffersProfileUncheckedUpdateManyWithoutOffersProfileInput>
  }

  export type OffersProfileScalarWhereInput = {
    AND?: Enumerable<OffersProfileScalarWhereInput>
    OR?: Enumerable<OffersProfileScalarWhereInput>
    NOT?: Enumerable<OffersProfileScalarWhereInput>
    id?: StringFilter | string
    profileName?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    editToken?: StringFilter | string
  }

  export type OffersReplyUpsertWithWhereUniqueWithoutUserInput = {
    where: OffersReplyWhereUniqueInput
    update: XOR<OffersReplyUpdateWithoutUserInput, OffersReplyUncheckedUpdateWithoutUserInput>
    create: XOR<OffersReplyCreateWithoutUserInput, OffersReplyUncheckedCreateWithoutUserInput>
  }

  export type OffersReplyUpdateWithWhereUniqueWithoutUserInput = {
    where: OffersReplyWhereUniqueInput
    data: XOR<OffersReplyUpdateWithoutUserInput, OffersReplyUncheckedUpdateWithoutUserInput>
  }

  export type OffersReplyUpdateManyWithWhereWithoutUserInput = {
    where: OffersReplyScalarWhereInput
    data: XOR<OffersReplyUpdateManyMutationInput, OffersReplyUncheckedUpdateManyWithoutOffersDiscussionInput>
  }

  export type OffersReplyScalarWhereInput = {
    AND?: Enumerable<OffersReplyScalarWhereInput>
    OR?: Enumerable<OffersReplyScalarWhereInput>
    NOT?: Enumerable<OffersReplyScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    message?: StringFilter | string
    replyingToId?: StringNullableFilter | string | null
    profileId?: StringFilter | string
    userId?: StringNullableFilter | string | null
  }

  export type QuestionsListUpsertWithWhereUniqueWithoutUserInput = {
    where: QuestionsListWhereUniqueInput
    update: XOR<QuestionsListUpdateWithoutUserInput, QuestionsListUncheckedUpdateWithoutUserInput>
    create: XOR<QuestionsListCreateWithoutUserInput, QuestionsListUncheckedCreateWithoutUserInput>
  }

  export type QuestionsListUpdateWithWhereUniqueWithoutUserInput = {
    where: QuestionsListWhereUniqueInput
    data: XOR<QuestionsListUpdateWithoutUserInput, QuestionsListUncheckedUpdateWithoutUserInput>
  }

  export type QuestionsListUpdateManyWithWhereWithoutUserInput = {
    where: QuestionsListScalarWhereInput
    data: XOR<QuestionsListUpdateManyMutationInput, QuestionsListUncheckedUpdateManyWithoutQuestionsListsInput>
  }

  export type QuestionsListScalarWhereInput = {
    AND?: Enumerable<QuestionsListScalarWhereInput>
    OR?: Enumerable<QuestionsListScalarWhereInput>
    NOT?: Enumerable<QuestionsListScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type OffersAdminUpsertWithoutUserInput = {
    update: XOR<OffersAdminUpdateWithoutUserInput, OffersAdminUncheckedUpdateWithoutUserInput>
    create: XOR<OffersAdminCreateWithoutUserInput, OffersAdminUncheckedCreateWithoutUserInput>
  }

  export type OffersAdminUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type OffersAdminUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateWithoutTodosInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    resumesResumes?: ResumesResumeCreateNestedManyWithoutUserInput
    resumesStars?: ResumesStarCreateNestedManyWithoutUserInput
    resumesComments?: ResumesCommentCreateNestedManyWithoutUserInput
    resumesCommentVotes?: ResumesCommentVoteCreateNestedManyWithoutUserInput
    questionsQuestions?: QuestionsQuestionCreateNestedManyWithoutUserInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterCreateNestedManyWithoutUserInput
    questionsQuestionVotes?: QuestionsQuestionVoteCreateNestedManyWithoutUserInput
    questionsQuestionComments?: QuestionsQuestionCommentCreateNestedManyWithoutUserInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteCreateNestedManyWithoutUserInput
    questionsAnswers?: QuestionsAnswerCreateNestedManyWithoutUserInput
    questionsAnswerVotes?: QuestionsAnswerVoteCreateNestedManyWithoutUserInput
    questionsAnswerComments?: QuestionsAnswerCommentCreateNestedManyWithoutUserInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteCreateNestedManyWithoutUserInput
    OffersProfile?: OffersProfileCreateNestedManyWithoutUsersInput
    offersDiscussion?: OffersReplyCreateNestedManyWithoutUserInput
    questionsLists?: QuestionsListCreateNestedManyWithoutUserInput
    OffersAdmin?: OffersAdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTodosInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    resumesResumes?: ResumesResumeUncheckedCreateNestedManyWithoutUserInput
    resumesStars?: ResumesStarUncheckedCreateNestedManyWithoutUserInput
    resumesComments?: ResumesCommentUncheckedCreateNestedManyWithoutUserInput
    resumesCommentVotes?: ResumesCommentVoteUncheckedCreateNestedManyWithoutUserInput
    questionsQuestions?: QuestionsQuestionUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionVotes?: QuestionsQuestionVoteUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionComments?: QuestionsQuestionCommentUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUncheckedCreateNestedManyWithoutUserInput
    questionsAnswers?: QuestionsAnswerUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerVotes?: QuestionsAnswerVoteUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerComments?: QuestionsAnswerCommentUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUncheckedCreateNestedManyWithoutUserInput
    OffersProfile?: OffersProfileUncheckedCreateNestedManyWithoutUsersInput
    offersDiscussion?: OffersReplyUncheckedCreateNestedManyWithoutUserInput
    questionsLists?: QuestionsListUncheckedCreateNestedManyWithoutUserInput
    OffersAdmin?: OffersAdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTodosInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTodosInput, UserUncheckedCreateWithoutTodosInput>
  }

  export type UserUpsertWithoutTodosInput = {
    update: XOR<UserUpdateWithoutTodosInput, UserUncheckedUpdateWithoutTodosInput>
    create: XOR<UserCreateWithoutTodosInput, UserUncheckedCreateWithoutTodosInput>
  }

  export type UserUpdateWithoutTodosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    resumesResumes?: ResumesResumeUpdateManyWithoutUserNestedInput
    resumesStars?: ResumesStarUpdateManyWithoutUserNestedInput
    resumesComments?: ResumesCommentUpdateManyWithoutUserNestedInput
    resumesCommentVotes?: ResumesCommentVoteUpdateManyWithoutUserNestedInput
    questionsQuestions?: QuestionsQuestionUpdateManyWithoutUserNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUpdateManyWithoutUserNestedInput
    questionsQuestionVotes?: QuestionsQuestionVoteUpdateManyWithoutUserNestedInput
    questionsQuestionComments?: QuestionsQuestionCommentUpdateManyWithoutUserNestedInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUpdateManyWithoutUserNestedInput
    questionsAnswers?: QuestionsAnswerUpdateManyWithoutUserNestedInput
    questionsAnswerVotes?: QuestionsAnswerVoteUpdateManyWithoutUserNestedInput
    questionsAnswerComments?: QuestionsAnswerCommentUpdateManyWithoutUserNestedInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUpdateManyWithoutUserNestedInput
    OffersProfile?: OffersProfileUpdateManyWithoutUsersNestedInput
    offersDiscussion?: OffersReplyUpdateManyWithoutUserNestedInput
    questionsLists?: QuestionsListUpdateManyWithoutUserNestedInput
    OffersAdmin?: OffersAdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTodosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    resumesResumes?: ResumesResumeUncheckedUpdateManyWithoutUserNestedInput
    resumesStars?: ResumesStarUncheckedUpdateManyWithoutUserNestedInput
    resumesComments?: ResumesCommentUncheckedUpdateManyWithoutUserNestedInput
    resumesCommentVotes?: ResumesCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestions?: QuestionsQuestionUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionVotes?: QuestionsQuestionVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionComments?: QuestionsQuestionCommentUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswers?: QuestionsAnswerUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerVotes?: QuestionsAnswerVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerComments?: QuestionsAnswerCommentUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    OffersProfile?: OffersProfileUncheckedUpdateManyWithoutUsersNestedInput
    offersDiscussion?: OffersReplyUncheckedUpdateManyWithoutUserNestedInput
    questionsLists?: QuestionsListUncheckedUpdateManyWithoutUserNestedInput
    OffersAdmin?: OffersAdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type QuestionsQuestionEncounterCreateWithoutCompanyInput = {
    id?: string
    role: string
    seenAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    country?: CountryCreateNestedOneWithoutQuestionsQuestionEncountersInput
    state?: StateCreateNestedOneWithoutQuestionsQuestionEncountersInput
    city?: CityCreateNestedOneWithoutQuestionsQuestionEncountersInput
    user?: UserCreateNestedOneWithoutQuestionsQuestionEncountersInput
    question: QuestionsQuestionCreateNestedOneWithoutEncountersInput
  }

  export type QuestionsQuestionEncounterUncheckedCreateWithoutCompanyInput = {
    id?: string
    questionId: string
    userId?: string | null
    countryId?: string | null
    stateId?: string | null
    cityId?: string | null
    role: string
    seenAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsQuestionEncounterCreateOrConnectWithoutCompanyInput = {
    where: QuestionsQuestionEncounterWhereUniqueInput
    create: XOR<QuestionsQuestionEncounterCreateWithoutCompanyInput, QuestionsQuestionEncounterUncheckedCreateWithoutCompanyInput>
  }

  export type QuestionsQuestionEncounterCreateManyCompanyInputEnvelope = {
    data: Enumerable<QuestionsQuestionEncounterCreateManyCompanyInput>
    skipDuplicates?: boolean
  }

  export type OffersExperienceCreateWithoutCompanyInput = {
    id?: string
    jobType?: JobType | null
    title?: string | null
    durationInMonths?: number | null
    location?: CityCreateNestedOneWithoutOffersExperienceInput
    level?: string | null
    totalCompensation?: OffersCurrencyCreateNestedOneWithoutOffersExperienceTotalCompensationInput
    monthlySalary?: OffersCurrencyCreateNestedOneWithoutOffersExperienceMonthlySalaryInput
    background: OffersBackgroundCreateNestedOneWithoutExperiencesInput
  }

  export type OffersExperienceUncheckedCreateWithoutCompanyInput = {
    id?: string
    jobType?: JobType | null
    title?: string | null
    durationInMonths?: number | null
    cityId?: string | null
    level?: string | null
    totalCompensationId?: string | null
    monthlySalaryId?: string | null
    backgroundId: string
  }

  export type OffersExperienceCreateOrConnectWithoutCompanyInput = {
    where: OffersExperienceWhereUniqueInput
    create: XOR<OffersExperienceCreateWithoutCompanyInput, OffersExperienceUncheckedCreateWithoutCompanyInput>
  }

  export type OffersExperienceCreateManyCompanyInputEnvelope = {
    data: Enumerable<OffersExperienceCreateManyCompanyInput>
    skipDuplicates?: boolean
  }

  export type OffersOfferCreateWithoutCompanyInput = {
    id?: string
    profile: OffersProfileCreateNestedOneWithoutOffersInput
    location: CityCreateNestedOneWithoutOffersOfferInput
    monthYearReceived: Date | string
    negotiationStrategy: string
    comments: string
    jobType: JobType
    offersIntern?: OffersInternCreateNestedOneWithoutOffersOfferInput
    offersFullTime?: OffersFullTimeCreateNestedOneWithoutOffersOfferInput
    offersAnalysis?: OffersAnalysisCreateNestedOneWithoutOverallHighestOfferInput
    offersAnalysisUnit?: OffersAnalysisUnitCreateNestedManyWithoutTopSimilarOffersInput
    OffersAnalysisUnit?: OffersAnalysisUnitCreateNestedManyWithoutAnalysedOfferInput
  }

  export type OffersOfferUncheckedCreateWithoutCompanyInput = {
    id?: string
    profileId: string
    cityId: string
    monthYearReceived: Date | string
    negotiationStrategy: string
    comments: string
    jobType: JobType
    offersInternId?: string | null
    offersFullTimeId?: string | null
    offersAnalysis?: OffersAnalysisUncheckedCreateNestedOneWithoutOverallHighestOfferInput
    offersAnalysisUnit?: OffersAnalysisUnitUncheckedCreateNestedManyWithoutTopSimilarOffersInput
    OffersAnalysisUnit?: OffersAnalysisUnitUncheckedCreateNestedManyWithoutAnalysedOfferInput
  }

  export type OffersOfferCreateOrConnectWithoutCompanyInput = {
    where: OffersOfferWhereUniqueInput
    create: XOR<OffersOfferCreateWithoutCompanyInput, OffersOfferUncheckedCreateWithoutCompanyInput>
  }

  export type OffersOfferCreateManyCompanyInputEnvelope = {
    data: Enumerable<OffersOfferCreateManyCompanyInput>
    skipDuplicates?: boolean
  }

  export type QuestionsQuestionEncounterUpsertWithWhereUniqueWithoutCompanyInput = {
    where: QuestionsQuestionEncounterWhereUniqueInput
    update: XOR<QuestionsQuestionEncounterUpdateWithoutCompanyInput, QuestionsQuestionEncounterUncheckedUpdateWithoutCompanyInput>
    create: XOR<QuestionsQuestionEncounterCreateWithoutCompanyInput, QuestionsQuestionEncounterUncheckedCreateWithoutCompanyInput>
  }

  export type QuestionsQuestionEncounterUpdateWithWhereUniqueWithoutCompanyInput = {
    where: QuestionsQuestionEncounterWhereUniqueInput
    data: XOR<QuestionsQuestionEncounterUpdateWithoutCompanyInput, QuestionsQuestionEncounterUncheckedUpdateWithoutCompanyInput>
  }

  export type QuestionsQuestionEncounterUpdateManyWithWhereWithoutCompanyInput = {
    where: QuestionsQuestionEncounterScalarWhereInput
    data: XOR<QuestionsQuestionEncounterUpdateManyMutationInput, QuestionsQuestionEncounterUncheckedUpdateManyWithoutQuestionsQuestionEncounterInput>
  }

  export type OffersExperienceUpsertWithWhereUniqueWithoutCompanyInput = {
    where: OffersExperienceWhereUniqueInput
    update: XOR<OffersExperienceUpdateWithoutCompanyInput, OffersExperienceUncheckedUpdateWithoutCompanyInput>
    create: XOR<OffersExperienceCreateWithoutCompanyInput, OffersExperienceUncheckedCreateWithoutCompanyInput>
  }

  export type OffersExperienceUpdateWithWhereUniqueWithoutCompanyInput = {
    where: OffersExperienceWhereUniqueInput
    data: XOR<OffersExperienceUpdateWithoutCompanyInput, OffersExperienceUncheckedUpdateWithoutCompanyInput>
  }

  export type OffersExperienceUpdateManyWithWhereWithoutCompanyInput = {
    where: OffersExperienceScalarWhereInput
    data: XOR<OffersExperienceUpdateManyMutationInput, OffersExperienceUncheckedUpdateManyWithoutOffersExperienceInput>
  }

  export type OffersExperienceScalarWhereInput = {
    AND?: Enumerable<OffersExperienceScalarWhereInput>
    OR?: Enumerable<OffersExperienceScalarWhereInput>
    NOT?: Enumerable<OffersExperienceScalarWhereInput>
    id?: StringFilter | string
    companyId?: StringNullableFilter | string | null
    jobType?: EnumJobTypeNullableFilter | JobType | null
    title?: StringNullableFilter | string | null
    durationInMonths?: IntNullableFilter | number | null
    cityId?: StringNullableFilter | string | null
    level?: StringNullableFilter | string | null
    totalCompensationId?: StringNullableFilter | string | null
    monthlySalaryId?: StringNullableFilter | string | null
    backgroundId?: StringFilter | string
  }

  export type OffersOfferUpsertWithWhereUniqueWithoutCompanyInput = {
    where: OffersOfferWhereUniqueInput
    update: XOR<OffersOfferUpdateWithoutCompanyInput, OffersOfferUncheckedUpdateWithoutCompanyInput>
    create: XOR<OffersOfferCreateWithoutCompanyInput, OffersOfferUncheckedCreateWithoutCompanyInput>
  }

  export type OffersOfferUpdateWithWhereUniqueWithoutCompanyInput = {
    where: OffersOfferWhereUniqueInput
    data: XOR<OffersOfferUpdateWithoutCompanyInput, OffersOfferUncheckedUpdateWithoutCompanyInput>
  }

  export type OffersOfferUpdateManyWithWhereWithoutCompanyInput = {
    where: OffersOfferScalarWhereInput
    data: XOR<OffersOfferUpdateManyMutationInput, OffersOfferUncheckedUpdateManyWithoutOffersOfferInput>
  }

  export type OffersOfferScalarWhereInput = {
    AND?: Enumerable<OffersOfferScalarWhereInput>
    OR?: Enumerable<OffersOfferScalarWhereInput>
    NOT?: Enumerable<OffersOfferScalarWhereInput>
    id?: StringFilter | string
    profileId?: StringFilter | string
    companyId?: StringFilter | string
    cityId?: StringFilter | string
    monthYearReceived?: DateTimeFilter | Date | string
    negotiationStrategy?: StringFilter | string
    comments?: StringFilter | string
    jobType?: EnumJobTypeFilter | JobType
    offersInternId?: StringNullableFilter | string | null
    offersFullTimeId?: StringNullableFilter | string | null
  }

  export type StateCreateWithoutCountryInput = {
    id: string
    name: string
    cities?: CityCreateNestedManyWithoutStateInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterCreateNestedManyWithoutStateInput
  }

  export type StateUncheckedCreateWithoutCountryInput = {
    id: string
    name: string
    cities?: CityUncheckedCreateNestedManyWithoutStateInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutStateInput
  }

  export type StateCreateOrConnectWithoutCountryInput = {
    where: StateWhereUniqueInput
    create: XOR<StateCreateWithoutCountryInput, StateUncheckedCreateWithoutCountryInput>
  }

  export type StateCreateManyCountryInputEnvelope = {
    data: Enumerable<StateCreateManyCountryInput>
    skipDuplicates?: boolean
  }

  export type QuestionsQuestionEncounterCreateWithoutCountryInput = {
    id?: string
    role: string
    seenAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    state?: StateCreateNestedOneWithoutQuestionsQuestionEncountersInput
    city?: CityCreateNestedOneWithoutQuestionsQuestionEncountersInput
    company?: CompanyCreateNestedOneWithoutQuestionsQuestionEncounterInput
    user?: UserCreateNestedOneWithoutQuestionsQuestionEncountersInput
    question: QuestionsQuestionCreateNestedOneWithoutEncountersInput
  }

  export type QuestionsQuestionEncounterUncheckedCreateWithoutCountryInput = {
    id?: string
    questionId: string
    userId?: string | null
    companyId?: string | null
    stateId?: string | null
    cityId?: string | null
    role: string
    seenAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsQuestionEncounterCreateOrConnectWithoutCountryInput = {
    where: QuestionsQuestionEncounterWhereUniqueInput
    create: XOR<QuestionsQuestionEncounterCreateWithoutCountryInput, QuestionsQuestionEncounterUncheckedCreateWithoutCountryInput>
  }

  export type QuestionsQuestionEncounterCreateManyCountryInputEnvelope = {
    data: Enumerable<QuestionsQuestionEncounterCreateManyCountryInput>
    skipDuplicates?: boolean
  }

  export type ResumesResumeCreateWithoutLocationInput = {
    id?: string
    title: string
    role: string
    experience: string
    url: string
    additionalInfo?: string | null
    isResolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutResumesResumesInput
    stars?: ResumesStarCreateNestedManyWithoutResumeInput
    comments?: ResumesCommentCreateNestedManyWithoutResumeInput
  }

  export type ResumesResumeUncheckedCreateWithoutLocationInput = {
    id?: string
    userId: string
    title: string
    role: string
    experience: string
    url: string
    additionalInfo?: string | null
    isResolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stars?: ResumesStarUncheckedCreateNestedManyWithoutResumeInput
    comments?: ResumesCommentUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumesResumeCreateOrConnectWithoutLocationInput = {
    where: ResumesResumeWhereUniqueInput
    create: XOR<ResumesResumeCreateWithoutLocationInput, ResumesResumeUncheckedCreateWithoutLocationInput>
  }

  export type ResumesResumeCreateManyLocationInputEnvelope = {
    data: Enumerable<ResumesResumeCreateManyLocationInput>
    skipDuplicates?: boolean
  }

  export type StateUpsertWithWhereUniqueWithoutCountryInput = {
    where: StateWhereUniqueInput
    update: XOR<StateUpdateWithoutCountryInput, StateUncheckedUpdateWithoutCountryInput>
    create: XOR<StateCreateWithoutCountryInput, StateUncheckedCreateWithoutCountryInput>
  }

  export type StateUpdateWithWhereUniqueWithoutCountryInput = {
    where: StateWhereUniqueInput
    data: XOR<StateUpdateWithoutCountryInput, StateUncheckedUpdateWithoutCountryInput>
  }

  export type StateUpdateManyWithWhereWithoutCountryInput = {
    where: StateScalarWhereInput
    data: XOR<StateUpdateManyMutationInput, StateUncheckedUpdateManyWithoutStatesInput>
  }

  export type StateScalarWhereInput = {
    AND?: Enumerable<StateScalarWhereInput>
    OR?: Enumerable<StateScalarWhereInput>
    NOT?: Enumerable<StateScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    countryId?: StringFilter | string
  }

  export type QuestionsQuestionEncounterUpsertWithWhereUniqueWithoutCountryInput = {
    where: QuestionsQuestionEncounterWhereUniqueInput
    update: XOR<QuestionsQuestionEncounterUpdateWithoutCountryInput, QuestionsQuestionEncounterUncheckedUpdateWithoutCountryInput>
    create: XOR<QuestionsQuestionEncounterCreateWithoutCountryInput, QuestionsQuestionEncounterUncheckedCreateWithoutCountryInput>
  }

  export type QuestionsQuestionEncounterUpdateWithWhereUniqueWithoutCountryInput = {
    where: QuestionsQuestionEncounterWhereUniqueInput
    data: XOR<QuestionsQuestionEncounterUpdateWithoutCountryInput, QuestionsQuestionEncounterUncheckedUpdateWithoutCountryInput>
  }

  export type QuestionsQuestionEncounterUpdateManyWithWhereWithoutCountryInput = {
    where: QuestionsQuestionEncounterScalarWhereInput
    data: XOR<QuestionsQuestionEncounterUpdateManyMutationInput, QuestionsQuestionEncounterUncheckedUpdateManyWithoutQuestionsQuestionEncountersInput>
  }

  export type ResumesResumeUpsertWithWhereUniqueWithoutLocationInput = {
    where: ResumesResumeWhereUniqueInput
    update: XOR<ResumesResumeUpdateWithoutLocationInput, ResumesResumeUncheckedUpdateWithoutLocationInput>
    create: XOR<ResumesResumeCreateWithoutLocationInput, ResumesResumeUncheckedCreateWithoutLocationInput>
  }

  export type ResumesResumeUpdateWithWhereUniqueWithoutLocationInput = {
    where: ResumesResumeWhereUniqueInput
    data: XOR<ResumesResumeUpdateWithoutLocationInput, ResumesResumeUncheckedUpdateWithoutLocationInput>
  }

  export type ResumesResumeUpdateManyWithWhereWithoutLocationInput = {
    where: ResumesResumeScalarWhereInput
    data: XOR<ResumesResumeUpdateManyMutationInput, ResumesResumeUncheckedUpdateManyWithoutResumesResumeInput>
  }

  export type CityCreateWithoutStateInput = {
    id: string
    name: string
    ranking?: number | null
    questionsQuestionEncounters?: QuestionsQuestionEncounterCreateNestedManyWithoutCityInput
    OffersExperience?: OffersExperienceCreateNestedManyWithoutLocationInput
    OffersOffer?: OffersOfferCreateNestedManyWithoutLocationInput
  }

  export type CityUncheckedCreateWithoutStateInput = {
    id: string
    name: string
    ranking?: number | null
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutCityInput
    OffersExperience?: OffersExperienceUncheckedCreateNestedManyWithoutLocationInput
    OffersOffer?: OffersOfferUncheckedCreateNestedManyWithoutLocationInput
  }

  export type CityCreateOrConnectWithoutStateInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutStateInput, CityUncheckedCreateWithoutStateInput>
  }

  export type CityCreateManyStateInputEnvelope = {
    data: Enumerable<CityCreateManyStateInput>
    skipDuplicates?: boolean
  }

  export type CountryCreateWithoutStatesInput = {
    id: string
    name: string
    code: string
    ranking?: number | null
    questionsQuestionEncounters?: QuestionsQuestionEncounterCreateNestedManyWithoutCountryInput
    ResumesResume?: ResumesResumeCreateNestedManyWithoutLocationInput
  }

  export type CountryUncheckedCreateWithoutStatesInput = {
    id: string
    name: string
    code: string
    ranking?: number | null
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutCountryInput
    ResumesResume?: ResumesResumeUncheckedCreateNestedManyWithoutLocationInput
  }

  export type CountryCreateOrConnectWithoutStatesInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutStatesInput, CountryUncheckedCreateWithoutStatesInput>
  }

  export type QuestionsQuestionEncounterCreateWithoutStateInput = {
    id?: string
    role: string
    seenAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    country?: CountryCreateNestedOneWithoutQuestionsQuestionEncountersInput
    city?: CityCreateNestedOneWithoutQuestionsQuestionEncountersInput
    company?: CompanyCreateNestedOneWithoutQuestionsQuestionEncounterInput
    user?: UserCreateNestedOneWithoutQuestionsQuestionEncountersInput
    question: QuestionsQuestionCreateNestedOneWithoutEncountersInput
  }

  export type QuestionsQuestionEncounterUncheckedCreateWithoutStateInput = {
    id?: string
    questionId: string
    userId?: string | null
    companyId?: string | null
    countryId?: string | null
    cityId?: string | null
    role: string
    seenAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsQuestionEncounterCreateOrConnectWithoutStateInput = {
    where: QuestionsQuestionEncounterWhereUniqueInput
    create: XOR<QuestionsQuestionEncounterCreateWithoutStateInput, QuestionsQuestionEncounterUncheckedCreateWithoutStateInput>
  }

  export type QuestionsQuestionEncounterCreateManyStateInputEnvelope = {
    data: Enumerable<QuestionsQuestionEncounterCreateManyStateInput>
    skipDuplicates?: boolean
  }

  export type CityUpsertWithWhereUniqueWithoutStateInput = {
    where: CityWhereUniqueInput
    update: XOR<CityUpdateWithoutStateInput, CityUncheckedUpdateWithoutStateInput>
    create: XOR<CityCreateWithoutStateInput, CityUncheckedCreateWithoutStateInput>
  }

  export type CityUpdateWithWhereUniqueWithoutStateInput = {
    where: CityWhereUniqueInput
    data: XOR<CityUpdateWithoutStateInput, CityUncheckedUpdateWithoutStateInput>
  }

  export type CityUpdateManyWithWhereWithoutStateInput = {
    where: CityScalarWhereInput
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyWithoutCitiesInput>
  }

  export type CityScalarWhereInput = {
    AND?: Enumerable<CityScalarWhereInput>
    OR?: Enumerable<CityScalarWhereInput>
    NOT?: Enumerable<CityScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    stateId?: StringFilter | string
    ranking?: IntNullableFilter | number | null
  }

  export type CountryUpsertWithoutStatesInput = {
    update: XOR<CountryUpdateWithoutStatesInput, CountryUncheckedUpdateWithoutStatesInput>
    create: XOR<CountryCreateWithoutStatesInput, CountryUncheckedCreateWithoutStatesInput>
  }

  export type CountryUpdateWithoutStatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    questionsQuestionEncounters?: QuestionsQuestionEncounterUpdateManyWithoutCountryNestedInput
    ResumesResume?: ResumesResumeUpdateManyWithoutLocationNestedInput
  }

  export type CountryUncheckedUpdateWithoutStatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedUpdateManyWithoutCountryNestedInput
    ResumesResume?: ResumesResumeUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type QuestionsQuestionEncounterUpsertWithWhereUniqueWithoutStateInput = {
    where: QuestionsQuestionEncounterWhereUniqueInput
    update: XOR<QuestionsQuestionEncounterUpdateWithoutStateInput, QuestionsQuestionEncounterUncheckedUpdateWithoutStateInput>
    create: XOR<QuestionsQuestionEncounterCreateWithoutStateInput, QuestionsQuestionEncounterUncheckedCreateWithoutStateInput>
  }

  export type QuestionsQuestionEncounterUpdateWithWhereUniqueWithoutStateInput = {
    where: QuestionsQuestionEncounterWhereUniqueInput
    data: XOR<QuestionsQuestionEncounterUpdateWithoutStateInput, QuestionsQuestionEncounterUncheckedUpdateWithoutStateInput>
  }

  export type QuestionsQuestionEncounterUpdateManyWithWhereWithoutStateInput = {
    where: QuestionsQuestionEncounterScalarWhereInput
    data: XOR<QuestionsQuestionEncounterUpdateManyMutationInput, QuestionsQuestionEncounterUncheckedUpdateManyWithoutQuestionsQuestionEncountersInput>
  }

  export type StateCreateWithoutCitiesInput = {
    id: string
    name: string
    country: CountryCreateNestedOneWithoutStatesInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterCreateNestedManyWithoutStateInput
  }

  export type StateUncheckedCreateWithoutCitiesInput = {
    id: string
    name: string
    countryId: string
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutStateInput
  }

  export type StateCreateOrConnectWithoutCitiesInput = {
    where: StateWhereUniqueInput
    create: XOR<StateCreateWithoutCitiesInput, StateUncheckedCreateWithoutCitiesInput>
  }

  export type QuestionsQuestionEncounterCreateWithoutCityInput = {
    id?: string
    role: string
    seenAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    country?: CountryCreateNestedOneWithoutQuestionsQuestionEncountersInput
    state?: StateCreateNestedOneWithoutQuestionsQuestionEncountersInput
    company?: CompanyCreateNestedOneWithoutQuestionsQuestionEncounterInput
    user?: UserCreateNestedOneWithoutQuestionsQuestionEncountersInput
    question: QuestionsQuestionCreateNestedOneWithoutEncountersInput
  }

  export type QuestionsQuestionEncounterUncheckedCreateWithoutCityInput = {
    id?: string
    questionId: string
    userId?: string | null
    companyId?: string | null
    countryId?: string | null
    stateId?: string | null
    role: string
    seenAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsQuestionEncounterCreateOrConnectWithoutCityInput = {
    where: QuestionsQuestionEncounterWhereUniqueInput
    create: XOR<QuestionsQuestionEncounterCreateWithoutCityInput, QuestionsQuestionEncounterUncheckedCreateWithoutCityInput>
  }

  export type QuestionsQuestionEncounterCreateManyCityInputEnvelope = {
    data: Enumerable<QuestionsQuestionEncounterCreateManyCityInput>
    skipDuplicates?: boolean
  }

  export type OffersExperienceCreateWithoutLocationInput = {
    id?: string
    company?: CompanyCreateNestedOneWithoutOffersExperienceInput
    jobType?: JobType | null
    title?: string | null
    durationInMonths?: number | null
    level?: string | null
    totalCompensation?: OffersCurrencyCreateNestedOneWithoutOffersExperienceTotalCompensationInput
    monthlySalary?: OffersCurrencyCreateNestedOneWithoutOffersExperienceMonthlySalaryInput
    background: OffersBackgroundCreateNestedOneWithoutExperiencesInput
  }

  export type OffersExperienceUncheckedCreateWithoutLocationInput = {
    id?: string
    companyId?: string | null
    jobType?: JobType | null
    title?: string | null
    durationInMonths?: number | null
    level?: string | null
    totalCompensationId?: string | null
    monthlySalaryId?: string | null
    backgroundId: string
  }

  export type OffersExperienceCreateOrConnectWithoutLocationInput = {
    where: OffersExperienceWhereUniqueInput
    create: XOR<OffersExperienceCreateWithoutLocationInput, OffersExperienceUncheckedCreateWithoutLocationInput>
  }

  export type OffersExperienceCreateManyLocationInputEnvelope = {
    data: Enumerable<OffersExperienceCreateManyLocationInput>
    skipDuplicates?: boolean
  }

  export type OffersOfferCreateWithoutLocationInput = {
    id?: string
    profile: OffersProfileCreateNestedOneWithoutOffersInput
    company: CompanyCreateNestedOneWithoutOffersOfferInput
    monthYearReceived: Date | string
    negotiationStrategy: string
    comments: string
    jobType: JobType
    offersIntern?: OffersInternCreateNestedOneWithoutOffersOfferInput
    offersFullTime?: OffersFullTimeCreateNestedOneWithoutOffersOfferInput
    offersAnalysis?: OffersAnalysisCreateNestedOneWithoutOverallHighestOfferInput
    offersAnalysisUnit?: OffersAnalysisUnitCreateNestedManyWithoutTopSimilarOffersInput
    OffersAnalysisUnit?: OffersAnalysisUnitCreateNestedManyWithoutAnalysedOfferInput
  }

  export type OffersOfferUncheckedCreateWithoutLocationInput = {
    id?: string
    profileId: string
    companyId: string
    monthYearReceived: Date | string
    negotiationStrategy: string
    comments: string
    jobType: JobType
    offersInternId?: string | null
    offersFullTimeId?: string | null
    offersAnalysis?: OffersAnalysisUncheckedCreateNestedOneWithoutOverallHighestOfferInput
    offersAnalysisUnit?: OffersAnalysisUnitUncheckedCreateNestedManyWithoutTopSimilarOffersInput
    OffersAnalysisUnit?: OffersAnalysisUnitUncheckedCreateNestedManyWithoutAnalysedOfferInput
  }

  export type OffersOfferCreateOrConnectWithoutLocationInput = {
    where: OffersOfferWhereUniqueInput
    create: XOR<OffersOfferCreateWithoutLocationInput, OffersOfferUncheckedCreateWithoutLocationInput>
  }

  export type OffersOfferCreateManyLocationInputEnvelope = {
    data: Enumerable<OffersOfferCreateManyLocationInput>
    skipDuplicates?: boolean
  }

  export type StateUpsertWithoutCitiesInput = {
    update: XOR<StateUpdateWithoutCitiesInput, StateUncheckedUpdateWithoutCitiesInput>
    create: XOR<StateCreateWithoutCitiesInput, StateUncheckedCreateWithoutCitiesInput>
  }

  export type StateUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: CountryUpdateOneRequiredWithoutStatesNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUpdateManyWithoutStateNestedInput
  }

  export type StateUncheckedUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedUpdateManyWithoutStateNestedInput
  }

  export type QuestionsQuestionEncounterUpsertWithWhereUniqueWithoutCityInput = {
    where: QuestionsQuestionEncounterWhereUniqueInput
    update: XOR<QuestionsQuestionEncounterUpdateWithoutCityInput, QuestionsQuestionEncounterUncheckedUpdateWithoutCityInput>
    create: XOR<QuestionsQuestionEncounterCreateWithoutCityInput, QuestionsQuestionEncounterUncheckedCreateWithoutCityInput>
  }

  export type QuestionsQuestionEncounterUpdateWithWhereUniqueWithoutCityInput = {
    where: QuestionsQuestionEncounterWhereUniqueInput
    data: XOR<QuestionsQuestionEncounterUpdateWithoutCityInput, QuestionsQuestionEncounterUncheckedUpdateWithoutCityInput>
  }

  export type QuestionsQuestionEncounterUpdateManyWithWhereWithoutCityInput = {
    where: QuestionsQuestionEncounterScalarWhereInput
    data: XOR<QuestionsQuestionEncounterUpdateManyMutationInput, QuestionsQuestionEncounterUncheckedUpdateManyWithoutQuestionsQuestionEncountersInput>
  }

  export type OffersExperienceUpsertWithWhereUniqueWithoutLocationInput = {
    where: OffersExperienceWhereUniqueInput
    update: XOR<OffersExperienceUpdateWithoutLocationInput, OffersExperienceUncheckedUpdateWithoutLocationInput>
    create: XOR<OffersExperienceCreateWithoutLocationInput, OffersExperienceUncheckedCreateWithoutLocationInput>
  }

  export type OffersExperienceUpdateWithWhereUniqueWithoutLocationInput = {
    where: OffersExperienceWhereUniqueInput
    data: XOR<OffersExperienceUpdateWithoutLocationInput, OffersExperienceUncheckedUpdateWithoutLocationInput>
  }

  export type OffersExperienceUpdateManyWithWhereWithoutLocationInput = {
    where: OffersExperienceScalarWhereInput
    data: XOR<OffersExperienceUpdateManyMutationInput, OffersExperienceUncheckedUpdateManyWithoutOffersExperienceInput>
  }

  export type OffersOfferUpsertWithWhereUniqueWithoutLocationInput = {
    where: OffersOfferWhereUniqueInput
    update: XOR<OffersOfferUpdateWithoutLocationInput, OffersOfferUncheckedUpdateWithoutLocationInput>
    create: XOR<OffersOfferCreateWithoutLocationInput, OffersOfferUncheckedCreateWithoutLocationInput>
  }

  export type OffersOfferUpdateWithWhereUniqueWithoutLocationInput = {
    where: OffersOfferWhereUniqueInput
    data: XOR<OffersOfferUpdateWithoutLocationInput, OffersOfferUncheckedUpdateWithoutLocationInput>
  }

  export type OffersOfferUpdateManyWithWhereWithoutLocationInput = {
    where: OffersOfferScalarWhereInput
    data: XOR<OffersOfferUpdateManyMutationInput, OffersOfferUncheckedUpdateManyWithoutOffersOfferInput>
  }

  export type UserCreateWithoutResumesResumesInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    todos?: TodoCreateNestedManyWithoutUserInput
    resumesStars?: ResumesStarCreateNestedManyWithoutUserInput
    resumesComments?: ResumesCommentCreateNestedManyWithoutUserInput
    resumesCommentVotes?: ResumesCommentVoteCreateNestedManyWithoutUserInput
    questionsQuestions?: QuestionsQuestionCreateNestedManyWithoutUserInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterCreateNestedManyWithoutUserInput
    questionsQuestionVotes?: QuestionsQuestionVoteCreateNestedManyWithoutUserInput
    questionsQuestionComments?: QuestionsQuestionCommentCreateNestedManyWithoutUserInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteCreateNestedManyWithoutUserInput
    questionsAnswers?: QuestionsAnswerCreateNestedManyWithoutUserInput
    questionsAnswerVotes?: QuestionsAnswerVoteCreateNestedManyWithoutUserInput
    questionsAnswerComments?: QuestionsAnswerCommentCreateNestedManyWithoutUserInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteCreateNestedManyWithoutUserInput
    OffersProfile?: OffersProfileCreateNestedManyWithoutUsersInput
    offersDiscussion?: OffersReplyCreateNestedManyWithoutUserInput
    questionsLists?: QuestionsListCreateNestedManyWithoutUserInput
    OffersAdmin?: OffersAdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutResumesResumesInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
    resumesStars?: ResumesStarUncheckedCreateNestedManyWithoutUserInput
    resumesComments?: ResumesCommentUncheckedCreateNestedManyWithoutUserInput
    resumesCommentVotes?: ResumesCommentVoteUncheckedCreateNestedManyWithoutUserInput
    questionsQuestions?: QuestionsQuestionUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionVotes?: QuestionsQuestionVoteUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionComments?: QuestionsQuestionCommentUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUncheckedCreateNestedManyWithoutUserInput
    questionsAnswers?: QuestionsAnswerUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerVotes?: QuestionsAnswerVoteUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerComments?: QuestionsAnswerCommentUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUncheckedCreateNestedManyWithoutUserInput
    OffersProfile?: OffersProfileUncheckedCreateNestedManyWithoutUsersInput
    offersDiscussion?: OffersReplyUncheckedCreateNestedManyWithoutUserInput
    questionsLists?: QuestionsListUncheckedCreateNestedManyWithoutUserInput
    OffersAdmin?: OffersAdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutResumesResumesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResumesResumesInput, UserUncheckedCreateWithoutResumesResumesInput>
  }

  export type CountryCreateWithoutResumesResumeInput = {
    id: string
    name: string
    code: string
    ranking?: number | null
    states?: StateCreateNestedManyWithoutCountryInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateWithoutResumesResumeInput = {
    id: string
    name: string
    code: string
    ranking?: number | null
    states?: StateUncheckedCreateNestedManyWithoutCountryInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryCreateOrConnectWithoutResumesResumeInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutResumesResumeInput, CountryUncheckedCreateWithoutResumesResumeInput>
  }

  export type ResumesStarCreateWithoutResumeInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutResumesStarsInput
  }

  export type ResumesStarUncheckedCreateWithoutResumeInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type ResumesStarCreateOrConnectWithoutResumeInput = {
    where: ResumesStarWhereUniqueInput
    create: XOR<ResumesStarCreateWithoutResumeInput, ResumesStarUncheckedCreateWithoutResumeInput>
  }

  export type ResumesStarCreateManyResumeInputEnvelope = {
    data: Enumerable<ResumesStarCreateManyResumeInput>
    skipDuplicates?: boolean
  }

  export type ResumesCommentCreateWithoutResumeInput = {
    id?: string
    description: string
    section: ResumesSection
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: ResumesCommentVoteCreateNestedManyWithoutCommentInput
    user: UserCreateNestedOneWithoutResumesCommentsInput
    parent?: ResumesCommentCreateNestedOneWithoutChildrenInput
    children?: ResumesCommentCreateNestedManyWithoutParentInput
  }

  export type ResumesCommentUncheckedCreateWithoutResumeInput = {
    id?: string
    userId: string
    parentId?: string | null
    description: string
    section: ResumesSection
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: ResumesCommentVoteUncheckedCreateNestedManyWithoutCommentInput
    children?: ResumesCommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type ResumesCommentCreateOrConnectWithoutResumeInput = {
    where: ResumesCommentWhereUniqueInput
    create: XOR<ResumesCommentCreateWithoutResumeInput, ResumesCommentUncheckedCreateWithoutResumeInput>
  }

  export type ResumesCommentCreateManyResumeInputEnvelope = {
    data: Enumerable<ResumesCommentCreateManyResumeInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutResumesResumesInput = {
    update: XOR<UserUpdateWithoutResumesResumesInput, UserUncheckedUpdateWithoutResumesResumesInput>
    create: XOR<UserCreateWithoutResumesResumesInput, UserUncheckedCreateWithoutResumesResumesInput>
  }

  export type UserUpdateWithoutResumesResumesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
    resumesStars?: ResumesStarUpdateManyWithoutUserNestedInput
    resumesComments?: ResumesCommentUpdateManyWithoutUserNestedInput
    resumesCommentVotes?: ResumesCommentVoteUpdateManyWithoutUserNestedInput
    questionsQuestions?: QuestionsQuestionUpdateManyWithoutUserNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUpdateManyWithoutUserNestedInput
    questionsQuestionVotes?: QuestionsQuestionVoteUpdateManyWithoutUserNestedInput
    questionsQuestionComments?: QuestionsQuestionCommentUpdateManyWithoutUserNestedInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUpdateManyWithoutUserNestedInput
    questionsAnswers?: QuestionsAnswerUpdateManyWithoutUserNestedInput
    questionsAnswerVotes?: QuestionsAnswerVoteUpdateManyWithoutUserNestedInput
    questionsAnswerComments?: QuestionsAnswerCommentUpdateManyWithoutUserNestedInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUpdateManyWithoutUserNestedInput
    OffersProfile?: OffersProfileUpdateManyWithoutUsersNestedInput
    offersDiscussion?: OffersReplyUpdateManyWithoutUserNestedInput
    questionsLists?: QuestionsListUpdateManyWithoutUserNestedInput
    OffersAdmin?: OffersAdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutResumesResumesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
    resumesStars?: ResumesStarUncheckedUpdateManyWithoutUserNestedInput
    resumesComments?: ResumesCommentUncheckedUpdateManyWithoutUserNestedInput
    resumesCommentVotes?: ResumesCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestions?: QuestionsQuestionUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionVotes?: QuestionsQuestionVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionComments?: QuestionsQuestionCommentUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswers?: QuestionsAnswerUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerVotes?: QuestionsAnswerVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerComments?: QuestionsAnswerCommentUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    OffersProfile?: OffersProfileUncheckedUpdateManyWithoutUsersNestedInput
    offersDiscussion?: OffersReplyUncheckedUpdateManyWithoutUserNestedInput
    questionsLists?: QuestionsListUncheckedUpdateManyWithoutUserNestedInput
    OffersAdmin?: OffersAdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type CountryUpsertWithoutResumesResumeInput = {
    update: XOR<CountryUpdateWithoutResumesResumeInput, CountryUncheckedUpdateWithoutResumesResumeInput>
    create: XOR<CountryCreateWithoutResumesResumeInput, CountryUncheckedCreateWithoutResumesResumeInput>
  }

  export type CountryUpdateWithoutResumesResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    states?: StateUpdateManyWithoutCountryNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateWithoutResumesResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    states?: StateUncheckedUpdateManyWithoutCountryNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type ResumesStarUpsertWithWhereUniqueWithoutResumeInput = {
    where: ResumesStarWhereUniqueInput
    update: XOR<ResumesStarUpdateWithoutResumeInput, ResumesStarUncheckedUpdateWithoutResumeInput>
    create: XOR<ResumesStarCreateWithoutResumeInput, ResumesStarUncheckedCreateWithoutResumeInput>
  }

  export type ResumesStarUpdateWithWhereUniqueWithoutResumeInput = {
    where: ResumesStarWhereUniqueInput
    data: XOR<ResumesStarUpdateWithoutResumeInput, ResumesStarUncheckedUpdateWithoutResumeInput>
  }

  export type ResumesStarUpdateManyWithWhereWithoutResumeInput = {
    where: ResumesStarScalarWhereInput
    data: XOR<ResumesStarUpdateManyMutationInput, ResumesStarUncheckedUpdateManyWithoutStarsInput>
  }

  export type ResumesCommentUpsertWithWhereUniqueWithoutResumeInput = {
    where: ResumesCommentWhereUniqueInput
    update: XOR<ResumesCommentUpdateWithoutResumeInput, ResumesCommentUncheckedUpdateWithoutResumeInput>
    create: XOR<ResumesCommentCreateWithoutResumeInput, ResumesCommentUncheckedCreateWithoutResumeInput>
  }

  export type ResumesCommentUpdateWithWhereUniqueWithoutResumeInput = {
    where: ResumesCommentWhereUniqueInput
    data: XOR<ResumesCommentUpdateWithoutResumeInput, ResumesCommentUncheckedUpdateWithoutResumeInput>
  }

  export type ResumesCommentUpdateManyWithWhereWithoutResumeInput = {
    where: ResumesCommentScalarWhereInput
    data: XOR<ResumesCommentUpdateManyMutationInput, ResumesCommentUncheckedUpdateManyWithoutCommentsInput>
  }

  export type ResumesResumeCreateWithoutStarsInput = {
    id?: string
    title: string
    role: string
    experience: string
    url: string
    additionalInfo?: string | null
    isResolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutResumesResumesInput
    location: CountryCreateNestedOneWithoutResumesResumeInput
    comments?: ResumesCommentCreateNestedManyWithoutResumeInput
  }

  export type ResumesResumeUncheckedCreateWithoutStarsInput = {
    id?: string
    userId: string
    title: string
    role: string
    experience: string
    locationId: string
    url: string
    additionalInfo?: string | null
    isResolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ResumesCommentUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumesResumeCreateOrConnectWithoutStarsInput = {
    where: ResumesResumeWhereUniqueInput
    create: XOR<ResumesResumeCreateWithoutStarsInput, ResumesResumeUncheckedCreateWithoutStarsInput>
  }

  export type UserCreateWithoutResumesStarsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    todos?: TodoCreateNestedManyWithoutUserInput
    resumesResumes?: ResumesResumeCreateNestedManyWithoutUserInput
    resumesComments?: ResumesCommentCreateNestedManyWithoutUserInput
    resumesCommentVotes?: ResumesCommentVoteCreateNestedManyWithoutUserInput
    questionsQuestions?: QuestionsQuestionCreateNestedManyWithoutUserInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterCreateNestedManyWithoutUserInput
    questionsQuestionVotes?: QuestionsQuestionVoteCreateNestedManyWithoutUserInput
    questionsQuestionComments?: QuestionsQuestionCommentCreateNestedManyWithoutUserInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteCreateNestedManyWithoutUserInput
    questionsAnswers?: QuestionsAnswerCreateNestedManyWithoutUserInput
    questionsAnswerVotes?: QuestionsAnswerVoteCreateNestedManyWithoutUserInput
    questionsAnswerComments?: QuestionsAnswerCommentCreateNestedManyWithoutUserInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteCreateNestedManyWithoutUserInput
    OffersProfile?: OffersProfileCreateNestedManyWithoutUsersInput
    offersDiscussion?: OffersReplyCreateNestedManyWithoutUserInput
    questionsLists?: QuestionsListCreateNestedManyWithoutUserInput
    OffersAdmin?: OffersAdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutResumesStarsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
    resumesResumes?: ResumesResumeUncheckedCreateNestedManyWithoutUserInput
    resumesComments?: ResumesCommentUncheckedCreateNestedManyWithoutUserInput
    resumesCommentVotes?: ResumesCommentVoteUncheckedCreateNestedManyWithoutUserInput
    questionsQuestions?: QuestionsQuestionUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionVotes?: QuestionsQuestionVoteUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionComments?: QuestionsQuestionCommentUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUncheckedCreateNestedManyWithoutUserInput
    questionsAnswers?: QuestionsAnswerUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerVotes?: QuestionsAnswerVoteUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerComments?: QuestionsAnswerCommentUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUncheckedCreateNestedManyWithoutUserInput
    OffersProfile?: OffersProfileUncheckedCreateNestedManyWithoutUsersInput
    offersDiscussion?: OffersReplyUncheckedCreateNestedManyWithoutUserInput
    questionsLists?: QuestionsListUncheckedCreateNestedManyWithoutUserInput
    OffersAdmin?: OffersAdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutResumesStarsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResumesStarsInput, UserUncheckedCreateWithoutResumesStarsInput>
  }

  export type ResumesResumeUpsertWithoutStarsInput = {
    update: XOR<ResumesResumeUpdateWithoutStarsInput, ResumesResumeUncheckedUpdateWithoutStarsInput>
    create: XOR<ResumesResumeCreateWithoutStarsInput, ResumesResumeUncheckedCreateWithoutStarsInput>
  }

  export type ResumesResumeUpdateWithoutStarsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    experience?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutResumesResumesNestedInput
    location?: CountryUpdateOneRequiredWithoutResumesResumeNestedInput
    comments?: ResumesCommentUpdateManyWithoutResumeNestedInput
  }

  export type ResumesResumeUncheckedUpdateWithoutStarsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    experience?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ResumesCommentUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type UserUpsertWithoutResumesStarsInput = {
    update: XOR<UserUpdateWithoutResumesStarsInput, UserUncheckedUpdateWithoutResumesStarsInput>
    create: XOR<UserCreateWithoutResumesStarsInput, UserUncheckedCreateWithoutResumesStarsInput>
  }

  export type UserUpdateWithoutResumesStarsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
    resumesResumes?: ResumesResumeUpdateManyWithoutUserNestedInput
    resumesComments?: ResumesCommentUpdateManyWithoutUserNestedInput
    resumesCommentVotes?: ResumesCommentVoteUpdateManyWithoutUserNestedInput
    questionsQuestions?: QuestionsQuestionUpdateManyWithoutUserNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUpdateManyWithoutUserNestedInput
    questionsQuestionVotes?: QuestionsQuestionVoteUpdateManyWithoutUserNestedInput
    questionsQuestionComments?: QuestionsQuestionCommentUpdateManyWithoutUserNestedInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUpdateManyWithoutUserNestedInput
    questionsAnswers?: QuestionsAnswerUpdateManyWithoutUserNestedInput
    questionsAnswerVotes?: QuestionsAnswerVoteUpdateManyWithoutUserNestedInput
    questionsAnswerComments?: QuestionsAnswerCommentUpdateManyWithoutUserNestedInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUpdateManyWithoutUserNestedInput
    OffersProfile?: OffersProfileUpdateManyWithoutUsersNestedInput
    offersDiscussion?: OffersReplyUpdateManyWithoutUserNestedInput
    questionsLists?: QuestionsListUpdateManyWithoutUserNestedInput
    OffersAdmin?: OffersAdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutResumesStarsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
    resumesResumes?: ResumesResumeUncheckedUpdateManyWithoutUserNestedInput
    resumesComments?: ResumesCommentUncheckedUpdateManyWithoutUserNestedInput
    resumesCommentVotes?: ResumesCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestions?: QuestionsQuestionUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionVotes?: QuestionsQuestionVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionComments?: QuestionsQuestionCommentUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswers?: QuestionsAnswerUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerVotes?: QuestionsAnswerVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerComments?: QuestionsAnswerCommentUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    OffersProfile?: OffersProfileUncheckedUpdateManyWithoutUsersNestedInput
    offersDiscussion?: OffersReplyUncheckedUpdateManyWithoutUserNestedInput
    questionsLists?: QuestionsListUncheckedUpdateManyWithoutUserNestedInput
    OffersAdmin?: OffersAdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ResumesResumeCreateWithoutCommentsInput = {
    id?: string
    title: string
    role: string
    experience: string
    url: string
    additionalInfo?: string | null
    isResolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutResumesResumesInput
    location: CountryCreateNestedOneWithoutResumesResumeInput
    stars?: ResumesStarCreateNestedManyWithoutResumeInput
  }

  export type ResumesResumeUncheckedCreateWithoutCommentsInput = {
    id?: string
    userId: string
    title: string
    role: string
    experience: string
    locationId: string
    url: string
    additionalInfo?: string | null
    isResolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stars?: ResumesStarUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumesResumeCreateOrConnectWithoutCommentsInput = {
    where: ResumesResumeWhereUniqueInput
    create: XOR<ResumesResumeCreateWithoutCommentsInput, ResumesResumeUncheckedCreateWithoutCommentsInput>
  }

  export type ResumesCommentVoteCreateWithoutCommentInput = {
    id?: string
    value: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutResumesCommentVotesInput
  }

  export type ResumesCommentVoteUncheckedCreateWithoutCommentInput = {
    id?: string
    userId: string
    value: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResumesCommentVoteCreateOrConnectWithoutCommentInput = {
    where: ResumesCommentVoteWhereUniqueInput
    create: XOR<ResumesCommentVoteCreateWithoutCommentInput, ResumesCommentVoteUncheckedCreateWithoutCommentInput>
  }

  export type ResumesCommentVoteCreateManyCommentInputEnvelope = {
    data: Enumerable<ResumesCommentVoteCreateManyCommentInput>
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutResumesCommentsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    todos?: TodoCreateNestedManyWithoutUserInput
    resumesResumes?: ResumesResumeCreateNestedManyWithoutUserInput
    resumesStars?: ResumesStarCreateNestedManyWithoutUserInput
    resumesCommentVotes?: ResumesCommentVoteCreateNestedManyWithoutUserInput
    questionsQuestions?: QuestionsQuestionCreateNestedManyWithoutUserInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterCreateNestedManyWithoutUserInput
    questionsQuestionVotes?: QuestionsQuestionVoteCreateNestedManyWithoutUserInput
    questionsQuestionComments?: QuestionsQuestionCommentCreateNestedManyWithoutUserInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteCreateNestedManyWithoutUserInput
    questionsAnswers?: QuestionsAnswerCreateNestedManyWithoutUserInput
    questionsAnswerVotes?: QuestionsAnswerVoteCreateNestedManyWithoutUserInput
    questionsAnswerComments?: QuestionsAnswerCommentCreateNestedManyWithoutUserInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteCreateNestedManyWithoutUserInput
    OffersProfile?: OffersProfileCreateNestedManyWithoutUsersInput
    offersDiscussion?: OffersReplyCreateNestedManyWithoutUserInput
    questionsLists?: QuestionsListCreateNestedManyWithoutUserInput
    OffersAdmin?: OffersAdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutResumesCommentsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
    resumesResumes?: ResumesResumeUncheckedCreateNestedManyWithoutUserInput
    resumesStars?: ResumesStarUncheckedCreateNestedManyWithoutUserInput
    resumesCommentVotes?: ResumesCommentVoteUncheckedCreateNestedManyWithoutUserInput
    questionsQuestions?: QuestionsQuestionUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionVotes?: QuestionsQuestionVoteUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionComments?: QuestionsQuestionCommentUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUncheckedCreateNestedManyWithoutUserInput
    questionsAnswers?: QuestionsAnswerUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerVotes?: QuestionsAnswerVoteUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerComments?: QuestionsAnswerCommentUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUncheckedCreateNestedManyWithoutUserInput
    OffersProfile?: OffersProfileUncheckedCreateNestedManyWithoutUsersInput
    offersDiscussion?: OffersReplyUncheckedCreateNestedManyWithoutUserInput
    questionsLists?: QuestionsListUncheckedCreateNestedManyWithoutUserInput
    OffersAdmin?: OffersAdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutResumesCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResumesCommentsInput, UserUncheckedCreateWithoutResumesCommentsInput>
  }

  export type ResumesCommentCreateWithoutChildrenInput = {
    id?: string
    description: string
    section: ResumesSection
    createdAt?: Date | string
    updatedAt?: Date | string
    resume: ResumesResumeCreateNestedOneWithoutCommentsInput
    votes?: ResumesCommentVoteCreateNestedManyWithoutCommentInput
    user: UserCreateNestedOneWithoutResumesCommentsInput
    parent?: ResumesCommentCreateNestedOneWithoutChildrenInput
  }

  export type ResumesCommentUncheckedCreateWithoutChildrenInput = {
    id?: string
    userId: string
    resumeId: string
    parentId?: string | null
    description: string
    section: ResumesSection
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: ResumesCommentVoteUncheckedCreateNestedManyWithoutCommentInput
  }

  export type ResumesCommentCreateOrConnectWithoutChildrenInput = {
    where: ResumesCommentWhereUniqueInput
    create: XOR<ResumesCommentCreateWithoutChildrenInput, ResumesCommentUncheckedCreateWithoutChildrenInput>
  }

  export type ResumesCommentCreateWithoutParentInput = {
    id?: string
    description: string
    section: ResumesSection
    createdAt?: Date | string
    updatedAt?: Date | string
    resume: ResumesResumeCreateNestedOneWithoutCommentsInput
    votes?: ResumesCommentVoteCreateNestedManyWithoutCommentInput
    user: UserCreateNestedOneWithoutResumesCommentsInput
    children?: ResumesCommentCreateNestedManyWithoutParentInput
  }

  export type ResumesCommentUncheckedCreateWithoutParentInput = {
    id?: string
    userId: string
    resumeId: string
    description: string
    section: ResumesSection
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: ResumesCommentVoteUncheckedCreateNestedManyWithoutCommentInput
    children?: ResumesCommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type ResumesCommentCreateOrConnectWithoutParentInput = {
    where: ResumesCommentWhereUniqueInput
    create: XOR<ResumesCommentCreateWithoutParentInput, ResumesCommentUncheckedCreateWithoutParentInput>
  }

  export type ResumesCommentCreateManyParentInputEnvelope = {
    data: Enumerable<ResumesCommentCreateManyParentInput>
    skipDuplicates?: boolean
  }

  export type ResumesResumeUpsertWithoutCommentsInput = {
    update: XOR<ResumesResumeUpdateWithoutCommentsInput, ResumesResumeUncheckedUpdateWithoutCommentsInput>
    create: XOR<ResumesResumeCreateWithoutCommentsInput, ResumesResumeUncheckedCreateWithoutCommentsInput>
  }

  export type ResumesResumeUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    experience?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutResumesResumesNestedInput
    location?: CountryUpdateOneRequiredWithoutResumesResumeNestedInput
    stars?: ResumesStarUpdateManyWithoutResumeNestedInput
  }

  export type ResumesResumeUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    experience?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stars?: ResumesStarUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type ResumesCommentVoteUpsertWithWhereUniqueWithoutCommentInput = {
    where: ResumesCommentVoteWhereUniqueInput
    update: XOR<ResumesCommentVoteUpdateWithoutCommentInput, ResumesCommentVoteUncheckedUpdateWithoutCommentInput>
    create: XOR<ResumesCommentVoteCreateWithoutCommentInput, ResumesCommentVoteUncheckedCreateWithoutCommentInput>
  }

  export type ResumesCommentVoteUpdateWithWhereUniqueWithoutCommentInput = {
    where: ResumesCommentVoteWhereUniqueInput
    data: XOR<ResumesCommentVoteUpdateWithoutCommentInput, ResumesCommentVoteUncheckedUpdateWithoutCommentInput>
  }

  export type ResumesCommentVoteUpdateManyWithWhereWithoutCommentInput = {
    where: ResumesCommentVoteScalarWhereInput
    data: XOR<ResumesCommentVoteUpdateManyMutationInput, ResumesCommentVoteUncheckedUpdateManyWithoutVotesInput>
  }

  export type UserUpsertWithoutResumesCommentsInput = {
    update: XOR<UserUpdateWithoutResumesCommentsInput, UserUncheckedUpdateWithoutResumesCommentsInput>
    create: XOR<UserCreateWithoutResumesCommentsInput, UserUncheckedCreateWithoutResumesCommentsInput>
  }

  export type UserUpdateWithoutResumesCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
    resumesResumes?: ResumesResumeUpdateManyWithoutUserNestedInput
    resumesStars?: ResumesStarUpdateManyWithoutUserNestedInput
    resumesCommentVotes?: ResumesCommentVoteUpdateManyWithoutUserNestedInput
    questionsQuestions?: QuestionsQuestionUpdateManyWithoutUserNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUpdateManyWithoutUserNestedInput
    questionsQuestionVotes?: QuestionsQuestionVoteUpdateManyWithoutUserNestedInput
    questionsQuestionComments?: QuestionsQuestionCommentUpdateManyWithoutUserNestedInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUpdateManyWithoutUserNestedInput
    questionsAnswers?: QuestionsAnswerUpdateManyWithoutUserNestedInput
    questionsAnswerVotes?: QuestionsAnswerVoteUpdateManyWithoutUserNestedInput
    questionsAnswerComments?: QuestionsAnswerCommentUpdateManyWithoutUserNestedInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUpdateManyWithoutUserNestedInput
    OffersProfile?: OffersProfileUpdateManyWithoutUsersNestedInput
    offersDiscussion?: OffersReplyUpdateManyWithoutUserNestedInput
    questionsLists?: QuestionsListUpdateManyWithoutUserNestedInput
    OffersAdmin?: OffersAdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutResumesCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
    resumesResumes?: ResumesResumeUncheckedUpdateManyWithoutUserNestedInput
    resumesStars?: ResumesStarUncheckedUpdateManyWithoutUserNestedInput
    resumesCommentVotes?: ResumesCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestions?: QuestionsQuestionUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionVotes?: QuestionsQuestionVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionComments?: QuestionsQuestionCommentUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswers?: QuestionsAnswerUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerVotes?: QuestionsAnswerVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerComments?: QuestionsAnswerCommentUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    OffersProfile?: OffersProfileUncheckedUpdateManyWithoutUsersNestedInput
    offersDiscussion?: OffersReplyUncheckedUpdateManyWithoutUserNestedInput
    questionsLists?: QuestionsListUncheckedUpdateManyWithoutUserNestedInput
    OffersAdmin?: OffersAdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ResumesCommentUpsertWithoutChildrenInput = {
    update: XOR<ResumesCommentUpdateWithoutChildrenInput, ResumesCommentUncheckedUpdateWithoutChildrenInput>
    create: XOR<ResumesCommentCreateWithoutChildrenInput, ResumesCommentUncheckedCreateWithoutChildrenInput>
  }

  export type ResumesCommentUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    section?: EnumResumesSectionFieldUpdateOperationsInput | ResumesSection
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resume?: ResumesResumeUpdateOneRequiredWithoutCommentsNestedInput
    votes?: ResumesCommentVoteUpdateManyWithoutCommentNestedInput
    user?: UserUpdateOneRequiredWithoutResumesCommentsNestedInput
    parent?: ResumesCommentUpdateOneWithoutChildrenNestedInput
  }

  export type ResumesCommentUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    section?: EnumResumesSectionFieldUpdateOperationsInput | ResumesSection
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: ResumesCommentVoteUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type ResumesCommentUpsertWithWhereUniqueWithoutParentInput = {
    where: ResumesCommentWhereUniqueInput
    update: XOR<ResumesCommentUpdateWithoutParentInput, ResumesCommentUncheckedUpdateWithoutParentInput>
    create: XOR<ResumesCommentCreateWithoutParentInput, ResumesCommentUncheckedCreateWithoutParentInput>
  }

  export type ResumesCommentUpdateWithWhereUniqueWithoutParentInput = {
    where: ResumesCommentWhereUniqueInput
    data: XOR<ResumesCommentUpdateWithoutParentInput, ResumesCommentUncheckedUpdateWithoutParentInput>
  }

  export type ResumesCommentUpdateManyWithWhereWithoutParentInput = {
    where: ResumesCommentScalarWhereInput
    data: XOR<ResumesCommentUpdateManyMutationInput, ResumesCommentUncheckedUpdateManyWithoutChildrenInput>
  }

  export type ResumesCommentCreateWithoutVotesInput = {
    id?: string
    description: string
    section: ResumesSection
    createdAt?: Date | string
    updatedAt?: Date | string
    resume: ResumesResumeCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutResumesCommentsInput
    parent?: ResumesCommentCreateNestedOneWithoutChildrenInput
    children?: ResumesCommentCreateNestedManyWithoutParentInput
  }

  export type ResumesCommentUncheckedCreateWithoutVotesInput = {
    id?: string
    userId: string
    resumeId: string
    parentId?: string | null
    description: string
    section: ResumesSection
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ResumesCommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type ResumesCommentCreateOrConnectWithoutVotesInput = {
    where: ResumesCommentWhereUniqueInput
    create: XOR<ResumesCommentCreateWithoutVotesInput, ResumesCommentUncheckedCreateWithoutVotesInput>
  }

  export type UserCreateWithoutResumesCommentVotesInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    todos?: TodoCreateNestedManyWithoutUserInput
    resumesResumes?: ResumesResumeCreateNestedManyWithoutUserInput
    resumesStars?: ResumesStarCreateNestedManyWithoutUserInput
    resumesComments?: ResumesCommentCreateNestedManyWithoutUserInput
    questionsQuestions?: QuestionsQuestionCreateNestedManyWithoutUserInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterCreateNestedManyWithoutUserInput
    questionsQuestionVotes?: QuestionsQuestionVoteCreateNestedManyWithoutUserInput
    questionsQuestionComments?: QuestionsQuestionCommentCreateNestedManyWithoutUserInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteCreateNestedManyWithoutUserInput
    questionsAnswers?: QuestionsAnswerCreateNestedManyWithoutUserInput
    questionsAnswerVotes?: QuestionsAnswerVoteCreateNestedManyWithoutUserInput
    questionsAnswerComments?: QuestionsAnswerCommentCreateNestedManyWithoutUserInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteCreateNestedManyWithoutUserInput
    OffersProfile?: OffersProfileCreateNestedManyWithoutUsersInput
    offersDiscussion?: OffersReplyCreateNestedManyWithoutUserInput
    questionsLists?: QuestionsListCreateNestedManyWithoutUserInput
    OffersAdmin?: OffersAdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutResumesCommentVotesInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
    resumesResumes?: ResumesResumeUncheckedCreateNestedManyWithoutUserInput
    resumesStars?: ResumesStarUncheckedCreateNestedManyWithoutUserInput
    resumesComments?: ResumesCommentUncheckedCreateNestedManyWithoutUserInput
    questionsQuestions?: QuestionsQuestionUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionVotes?: QuestionsQuestionVoteUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionComments?: QuestionsQuestionCommentUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUncheckedCreateNestedManyWithoutUserInput
    questionsAnswers?: QuestionsAnswerUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerVotes?: QuestionsAnswerVoteUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerComments?: QuestionsAnswerCommentUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUncheckedCreateNestedManyWithoutUserInput
    OffersProfile?: OffersProfileUncheckedCreateNestedManyWithoutUsersInput
    offersDiscussion?: OffersReplyUncheckedCreateNestedManyWithoutUserInput
    questionsLists?: QuestionsListUncheckedCreateNestedManyWithoutUserInput
    OffersAdmin?: OffersAdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutResumesCommentVotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResumesCommentVotesInput, UserUncheckedCreateWithoutResumesCommentVotesInput>
  }

  export type ResumesCommentUpsertWithoutVotesInput = {
    update: XOR<ResumesCommentUpdateWithoutVotesInput, ResumesCommentUncheckedUpdateWithoutVotesInput>
    create: XOR<ResumesCommentCreateWithoutVotesInput, ResumesCommentUncheckedCreateWithoutVotesInput>
  }

  export type ResumesCommentUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    section?: EnumResumesSectionFieldUpdateOperationsInput | ResumesSection
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resume?: ResumesResumeUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutResumesCommentsNestedInput
    parent?: ResumesCommentUpdateOneWithoutChildrenNestedInput
    children?: ResumesCommentUpdateManyWithoutParentNestedInput
  }

  export type ResumesCommentUncheckedUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    section?: EnumResumesSectionFieldUpdateOperationsInput | ResumesSection
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ResumesCommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type UserUpsertWithoutResumesCommentVotesInput = {
    update: XOR<UserUpdateWithoutResumesCommentVotesInput, UserUncheckedUpdateWithoutResumesCommentVotesInput>
    create: XOR<UserCreateWithoutResumesCommentVotesInput, UserUncheckedCreateWithoutResumesCommentVotesInput>
  }

  export type UserUpdateWithoutResumesCommentVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
    resumesResumes?: ResumesResumeUpdateManyWithoutUserNestedInput
    resumesStars?: ResumesStarUpdateManyWithoutUserNestedInput
    resumesComments?: ResumesCommentUpdateManyWithoutUserNestedInput
    questionsQuestions?: QuestionsQuestionUpdateManyWithoutUserNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUpdateManyWithoutUserNestedInput
    questionsQuestionVotes?: QuestionsQuestionVoteUpdateManyWithoutUserNestedInput
    questionsQuestionComments?: QuestionsQuestionCommentUpdateManyWithoutUserNestedInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUpdateManyWithoutUserNestedInput
    questionsAnswers?: QuestionsAnswerUpdateManyWithoutUserNestedInput
    questionsAnswerVotes?: QuestionsAnswerVoteUpdateManyWithoutUserNestedInput
    questionsAnswerComments?: QuestionsAnswerCommentUpdateManyWithoutUserNestedInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUpdateManyWithoutUserNestedInput
    OffersProfile?: OffersProfileUpdateManyWithoutUsersNestedInput
    offersDiscussion?: OffersReplyUpdateManyWithoutUserNestedInput
    questionsLists?: QuestionsListUpdateManyWithoutUserNestedInput
    OffersAdmin?: OffersAdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutResumesCommentVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
    resumesResumes?: ResumesResumeUncheckedUpdateManyWithoutUserNestedInput
    resumesStars?: ResumesStarUncheckedUpdateManyWithoutUserNestedInput
    resumesComments?: ResumesCommentUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestions?: QuestionsQuestionUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionVotes?: QuestionsQuestionVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionComments?: QuestionsQuestionCommentUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswers?: QuestionsAnswerUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerVotes?: QuestionsAnswerVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerComments?: QuestionsAnswerCommentUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    OffersProfile?: OffersProfileUncheckedUpdateManyWithoutUsersNestedInput
    offersDiscussion?: OffersReplyUncheckedUpdateManyWithoutUserNestedInput
    questionsLists?: QuestionsListUncheckedUpdateManyWithoutUserNestedInput
    OffersAdmin?: OffersAdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type OffersBackgroundCreateWithoutProfileInput = {
    id?: string
    totalYoe?: number
    specificYoes?: OffersSpecificYoeCreateNestedManyWithoutBackgroundInput
    experiences?: OffersExperienceCreateNestedManyWithoutBackgroundInput
    educations?: OffersEducationCreateNestedManyWithoutBackgroundInput
  }

  export type OffersBackgroundUncheckedCreateWithoutProfileInput = {
    id?: string
    totalYoe?: number
    specificYoes?: OffersSpecificYoeUncheckedCreateNestedManyWithoutBackgroundInput
    experiences?: OffersExperienceUncheckedCreateNestedManyWithoutBackgroundInput
    educations?: OffersEducationUncheckedCreateNestedManyWithoutBackgroundInput
  }

  export type OffersBackgroundCreateOrConnectWithoutProfileInput = {
    where: OffersBackgroundWhereUniqueInput
    create: XOR<OffersBackgroundCreateWithoutProfileInput, OffersBackgroundUncheckedCreateWithoutProfileInput>
  }

  export type OffersReplyCreateWithoutProfileInput = {
    id?: string
    createdAt?: Date | string
    message: string
    replyingTo?: OffersReplyCreateNestedOneWithoutRepliesInput
    replies?: OffersReplyCreateNestedManyWithoutReplyingToInput
    user?: UserCreateNestedOneWithoutOffersDiscussionInput
  }

  export type OffersReplyUncheckedCreateWithoutProfileInput = {
    id?: string
    createdAt?: Date | string
    message: string
    replyingToId?: string | null
    replies?: OffersReplyUncheckedCreateNestedManyWithoutReplyingToInput
    userId?: string | null
  }

  export type OffersReplyCreateOrConnectWithoutProfileInput = {
    where: OffersReplyWhereUniqueInput
    create: XOR<OffersReplyCreateWithoutProfileInput, OffersReplyUncheckedCreateWithoutProfileInput>
  }

  export type OffersReplyCreateManyProfileInputEnvelope = {
    data: Enumerable<OffersReplyCreateManyProfileInput>
    skipDuplicates?: boolean
  }

  export type OffersOfferCreateWithoutProfileInput = {
    id?: string
    company: CompanyCreateNestedOneWithoutOffersOfferInput
    location: CityCreateNestedOneWithoutOffersOfferInput
    monthYearReceived: Date | string
    negotiationStrategy: string
    comments: string
    jobType: JobType
    offersIntern?: OffersInternCreateNestedOneWithoutOffersOfferInput
    offersFullTime?: OffersFullTimeCreateNestedOneWithoutOffersOfferInput
    offersAnalysis?: OffersAnalysisCreateNestedOneWithoutOverallHighestOfferInput
    offersAnalysisUnit?: OffersAnalysisUnitCreateNestedManyWithoutTopSimilarOffersInput
    OffersAnalysisUnit?: OffersAnalysisUnitCreateNestedManyWithoutAnalysedOfferInput
  }

  export type OffersOfferUncheckedCreateWithoutProfileInput = {
    id?: string
    companyId: string
    cityId: string
    monthYearReceived: Date | string
    negotiationStrategy: string
    comments: string
    jobType: JobType
    offersInternId?: string | null
    offersFullTimeId?: string | null
    offersAnalysis?: OffersAnalysisUncheckedCreateNestedOneWithoutOverallHighestOfferInput
    offersAnalysisUnit?: OffersAnalysisUnitUncheckedCreateNestedManyWithoutTopSimilarOffersInput
    OffersAnalysisUnit?: OffersAnalysisUnitUncheckedCreateNestedManyWithoutAnalysedOfferInput
  }

  export type OffersOfferCreateOrConnectWithoutProfileInput = {
    where: OffersOfferWhereUniqueInput
    create: XOR<OffersOfferCreateWithoutProfileInput, OffersOfferUncheckedCreateWithoutProfileInput>
  }

  export type OffersOfferCreateManyProfileInputEnvelope = {
    data: Enumerable<OffersOfferCreateManyProfileInput>
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutOffersProfileInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    todos?: TodoCreateNestedManyWithoutUserInput
    resumesResumes?: ResumesResumeCreateNestedManyWithoutUserInput
    resumesStars?: ResumesStarCreateNestedManyWithoutUserInput
    resumesComments?: ResumesCommentCreateNestedManyWithoutUserInput
    resumesCommentVotes?: ResumesCommentVoteCreateNestedManyWithoutUserInput
    questionsQuestions?: QuestionsQuestionCreateNestedManyWithoutUserInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterCreateNestedManyWithoutUserInput
    questionsQuestionVotes?: QuestionsQuestionVoteCreateNestedManyWithoutUserInput
    questionsQuestionComments?: QuestionsQuestionCommentCreateNestedManyWithoutUserInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteCreateNestedManyWithoutUserInput
    questionsAnswers?: QuestionsAnswerCreateNestedManyWithoutUserInput
    questionsAnswerVotes?: QuestionsAnswerVoteCreateNestedManyWithoutUserInput
    questionsAnswerComments?: QuestionsAnswerCommentCreateNestedManyWithoutUserInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteCreateNestedManyWithoutUserInput
    offersDiscussion?: OffersReplyCreateNestedManyWithoutUserInput
    questionsLists?: QuestionsListCreateNestedManyWithoutUserInput
    OffersAdmin?: OffersAdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOffersProfileInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
    resumesResumes?: ResumesResumeUncheckedCreateNestedManyWithoutUserInput
    resumesStars?: ResumesStarUncheckedCreateNestedManyWithoutUserInput
    resumesComments?: ResumesCommentUncheckedCreateNestedManyWithoutUserInput
    resumesCommentVotes?: ResumesCommentVoteUncheckedCreateNestedManyWithoutUserInput
    questionsQuestions?: QuestionsQuestionUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionVotes?: QuestionsQuestionVoteUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionComments?: QuestionsQuestionCommentUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUncheckedCreateNestedManyWithoutUserInput
    questionsAnswers?: QuestionsAnswerUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerVotes?: QuestionsAnswerVoteUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerComments?: QuestionsAnswerCommentUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUncheckedCreateNestedManyWithoutUserInput
    offersDiscussion?: OffersReplyUncheckedCreateNestedManyWithoutUserInput
    questionsLists?: QuestionsListUncheckedCreateNestedManyWithoutUserInput
    OffersAdmin?: OffersAdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOffersProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOffersProfileInput, UserUncheckedCreateWithoutOffersProfileInput>
  }

  export type OffersAnalysisCreateWithoutProfileInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    overallHighestOffer: OffersOfferCreateNestedOneWithoutOffersAnalysisInput
    overallAnalysis: OffersAnalysisUnitCreateNestedOneWithoutOffersAnalysisOverallInput
    companyAnalysis?: OffersAnalysisUnitCreateNestedManyWithoutOffersAnalysisCompanyInput
  }

  export type OffersAnalysisUncheckedCreateWithoutProfileInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    offerId: string
    overallAnalysisUnitId: string
    companyAnalysis?: OffersAnalysisUnitUncheckedCreateNestedManyWithoutOffersAnalysisCompanyInput
  }

  export type OffersAnalysisCreateOrConnectWithoutProfileInput = {
    where: OffersAnalysisWhereUniqueInput
    create: XOR<OffersAnalysisCreateWithoutProfileInput, OffersAnalysisUncheckedCreateWithoutProfileInput>
  }

  export type OffersBackgroundUpsertWithoutProfileInput = {
    update: XOR<OffersBackgroundUpdateWithoutProfileInput, OffersBackgroundUncheckedUpdateWithoutProfileInput>
    create: XOR<OffersBackgroundCreateWithoutProfileInput, OffersBackgroundUncheckedCreateWithoutProfileInput>
  }

  export type OffersBackgroundUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalYoe?: IntFieldUpdateOperationsInput | number
    specificYoes?: OffersSpecificYoeUpdateManyWithoutBackgroundNestedInput
    experiences?: OffersExperienceUpdateManyWithoutBackgroundNestedInput
    educations?: OffersEducationUpdateManyWithoutBackgroundNestedInput
  }

  export type OffersBackgroundUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalYoe?: IntFieldUpdateOperationsInput | number
    specificYoes?: OffersSpecificYoeUncheckedUpdateManyWithoutBackgroundNestedInput
    experiences?: OffersExperienceUncheckedUpdateManyWithoutBackgroundNestedInput
    educations?: OffersEducationUncheckedUpdateManyWithoutBackgroundNestedInput
  }

  export type OffersReplyUpsertWithWhereUniqueWithoutProfileInput = {
    where: OffersReplyWhereUniqueInput
    update: XOR<OffersReplyUpdateWithoutProfileInput, OffersReplyUncheckedUpdateWithoutProfileInput>
    create: XOR<OffersReplyCreateWithoutProfileInput, OffersReplyUncheckedCreateWithoutProfileInput>
  }

  export type OffersReplyUpdateWithWhereUniqueWithoutProfileInput = {
    where: OffersReplyWhereUniqueInput
    data: XOR<OffersReplyUpdateWithoutProfileInput, OffersReplyUncheckedUpdateWithoutProfileInput>
  }

  export type OffersReplyUpdateManyWithWhereWithoutProfileInput = {
    where: OffersReplyScalarWhereInput
    data: XOR<OffersReplyUpdateManyMutationInput, OffersReplyUncheckedUpdateManyWithoutDiscussionInput>
  }

  export type OffersOfferUpsertWithWhereUniqueWithoutProfileInput = {
    where: OffersOfferWhereUniqueInput
    update: XOR<OffersOfferUpdateWithoutProfileInput, OffersOfferUncheckedUpdateWithoutProfileInput>
    create: XOR<OffersOfferCreateWithoutProfileInput, OffersOfferUncheckedCreateWithoutProfileInput>
  }

  export type OffersOfferUpdateWithWhereUniqueWithoutProfileInput = {
    where: OffersOfferWhereUniqueInput
    data: XOR<OffersOfferUpdateWithoutProfileInput, OffersOfferUncheckedUpdateWithoutProfileInput>
  }

  export type OffersOfferUpdateManyWithWhereWithoutProfileInput = {
    where: OffersOfferScalarWhereInput
    data: XOR<OffersOfferUpdateManyMutationInput, OffersOfferUncheckedUpdateManyWithoutOffersInput>
  }

  export type UserUpsertWithWhereUniqueWithoutOffersProfileInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutOffersProfileInput, UserUncheckedUpdateWithoutOffersProfileInput>
    create: XOR<UserCreateWithoutOffersProfileInput, UserUncheckedCreateWithoutOffersProfileInput>
  }

  export type UserUpdateWithWhereUniqueWithoutOffersProfileInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutOffersProfileInput, UserUncheckedUpdateWithoutOffersProfileInput>
  }

  export type UserUpdateManyWithWhereWithoutOffersProfileInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUsersInput>
  }

  export type UserScalarWhereInput = {
    AND?: Enumerable<UserScalarWhereInput>
    OR?: Enumerable<UserScalarWhereInput>
    NOT?: Enumerable<UserScalarWhereInput>
    id?: StringFilter | string
    name?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    emailVerified?: DateTimeNullableFilter | Date | string | null
    image?: StringNullableFilter | string | null
  }

  export type OffersAnalysisUpsertWithoutProfileInput = {
    update: XOR<OffersAnalysisUpdateWithoutProfileInput, OffersAnalysisUncheckedUpdateWithoutProfileInput>
    create: XOR<OffersAnalysisCreateWithoutProfileInput, OffersAnalysisUncheckedCreateWithoutProfileInput>
  }

  export type OffersAnalysisUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overallHighestOffer?: OffersOfferUpdateOneRequiredWithoutOffersAnalysisNestedInput
    overallAnalysis?: OffersAnalysisUnitUpdateOneRequiredWithoutOffersAnalysisOverallNestedInput
    companyAnalysis?: OffersAnalysisUnitUpdateManyWithoutOffersAnalysisCompanyNestedInput
  }

  export type OffersAnalysisUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offerId?: StringFieldUpdateOperationsInput | string
    overallAnalysisUnitId?: StringFieldUpdateOperationsInput | string
    companyAnalysis?: OffersAnalysisUnitUncheckedUpdateManyWithoutOffersAnalysisCompanyNestedInput
  }

  export type UserCreateWithoutOffersAdminInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    todos?: TodoCreateNestedManyWithoutUserInput
    resumesResumes?: ResumesResumeCreateNestedManyWithoutUserInput
    resumesStars?: ResumesStarCreateNestedManyWithoutUserInput
    resumesComments?: ResumesCommentCreateNestedManyWithoutUserInput
    resumesCommentVotes?: ResumesCommentVoteCreateNestedManyWithoutUserInput
    questionsQuestions?: QuestionsQuestionCreateNestedManyWithoutUserInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterCreateNestedManyWithoutUserInput
    questionsQuestionVotes?: QuestionsQuestionVoteCreateNestedManyWithoutUserInput
    questionsQuestionComments?: QuestionsQuestionCommentCreateNestedManyWithoutUserInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteCreateNestedManyWithoutUserInput
    questionsAnswers?: QuestionsAnswerCreateNestedManyWithoutUserInput
    questionsAnswerVotes?: QuestionsAnswerVoteCreateNestedManyWithoutUserInput
    questionsAnswerComments?: QuestionsAnswerCommentCreateNestedManyWithoutUserInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteCreateNestedManyWithoutUserInput
    OffersProfile?: OffersProfileCreateNestedManyWithoutUsersInput
    offersDiscussion?: OffersReplyCreateNestedManyWithoutUserInput
    questionsLists?: QuestionsListCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOffersAdminInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
    resumesResumes?: ResumesResumeUncheckedCreateNestedManyWithoutUserInput
    resumesStars?: ResumesStarUncheckedCreateNestedManyWithoutUserInput
    resumesComments?: ResumesCommentUncheckedCreateNestedManyWithoutUserInput
    resumesCommentVotes?: ResumesCommentVoteUncheckedCreateNestedManyWithoutUserInput
    questionsQuestions?: QuestionsQuestionUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionVotes?: QuestionsQuestionVoteUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionComments?: QuestionsQuestionCommentUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUncheckedCreateNestedManyWithoutUserInput
    questionsAnswers?: QuestionsAnswerUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerVotes?: QuestionsAnswerVoteUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerComments?: QuestionsAnswerCommentUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUncheckedCreateNestedManyWithoutUserInput
    OffersProfile?: OffersProfileUncheckedCreateNestedManyWithoutUsersInput
    offersDiscussion?: OffersReplyUncheckedCreateNestedManyWithoutUserInput
    questionsLists?: QuestionsListUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOffersAdminInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOffersAdminInput, UserUncheckedCreateWithoutOffersAdminInput>
  }

  export type UserUpsertWithoutOffersAdminInput = {
    update: XOR<UserUpdateWithoutOffersAdminInput, UserUncheckedUpdateWithoutOffersAdminInput>
    create: XOR<UserCreateWithoutOffersAdminInput, UserUncheckedCreateWithoutOffersAdminInput>
  }

  export type UserUpdateWithoutOffersAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
    resumesResumes?: ResumesResumeUpdateManyWithoutUserNestedInput
    resumesStars?: ResumesStarUpdateManyWithoutUserNestedInput
    resumesComments?: ResumesCommentUpdateManyWithoutUserNestedInput
    resumesCommentVotes?: ResumesCommentVoteUpdateManyWithoutUserNestedInput
    questionsQuestions?: QuestionsQuestionUpdateManyWithoutUserNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUpdateManyWithoutUserNestedInput
    questionsQuestionVotes?: QuestionsQuestionVoteUpdateManyWithoutUserNestedInput
    questionsQuestionComments?: QuestionsQuestionCommentUpdateManyWithoutUserNestedInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUpdateManyWithoutUserNestedInput
    questionsAnswers?: QuestionsAnswerUpdateManyWithoutUserNestedInput
    questionsAnswerVotes?: QuestionsAnswerVoteUpdateManyWithoutUserNestedInput
    questionsAnswerComments?: QuestionsAnswerCommentUpdateManyWithoutUserNestedInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUpdateManyWithoutUserNestedInput
    OffersProfile?: OffersProfileUpdateManyWithoutUsersNestedInput
    offersDiscussion?: OffersReplyUpdateManyWithoutUserNestedInput
    questionsLists?: QuestionsListUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOffersAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
    resumesResumes?: ResumesResumeUncheckedUpdateManyWithoutUserNestedInput
    resumesStars?: ResumesStarUncheckedUpdateManyWithoutUserNestedInput
    resumesComments?: ResumesCommentUncheckedUpdateManyWithoutUserNestedInput
    resumesCommentVotes?: ResumesCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestions?: QuestionsQuestionUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionVotes?: QuestionsQuestionVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionComments?: QuestionsQuestionCommentUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswers?: QuestionsAnswerUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerVotes?: QuestionsAnswerVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerComments?: QuestionsAnswerCommentUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    OffersProfile?: OffersProfileUncheckedUpdateManyWithoutUsersNestedInput
    offersDiscussion?: OffersReplyUncheckedUpdateManyWithoutUserNestedInput
    questionsLists?: QuestionsListUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OffersSpecificYoeCreateWithoutBackgroundInput = {
    id?: string
    yoe: number
    domain: string
  }

  export type OffersSpecificYoeUncheckedCreateWithoutBackgroundInput = {
    id?: string
    yoe: number
    domain: string
  }

  export type OffersSpecificYoeCreateOrConnectWithoutBackgroundInput = {
    where: OffersSpecificYoeWhereUniqueInput
    create: XOR<OffersSpecificYoeCreateWithoutBackgroundInput, OffersSpecificYoeUncheckedCreateWithoutBackgroundInput>
  }

  export type OffersSpecificYoeCreateManyBackgroundInputEnvelope = {
    data: Enumerable<OffersSpecificYoeCreateManyBackgroundInput>
    skipDuplicates?: boolean
  }

  export type OffersExperienceCreateWithoutBackgroundInput = {
    id?: string
    company?: CompanyCreateNestedOneWithoutOffersExperienceInput
    jobType?: JobType | null
    title?: string | null
    durationInMonths?: number | null
    location?: CityCreateNestedOneWithoutOffersExperienceInput
    level?: string | null
    totalCompensation?: OffersCurrencyCreateNestedOneWithoutOffersExperienceTotalCompensationInput
    monthlySalary?: OffersCurrencyCreateNestedOneWithoutOffersExperienceMonthlySalaryInput
  }

  export type OffersExperienceUncheckedCreateWithoutBackgroundInput = {
    id?: string
    companyId?: string | null
    jobType?: JobType | null
    title?: string | null
    durationInMonths?: number | null
    cityId?: string | null
    level?: string | null
    totalCompensationId?: string | null
    monthlySalaryId?: string | null
  }

  export type OffersExperienceCreateOrConnectWithoutBackgroundInput = {
    where: OffersExperienceWhereUniqueInput
    create: XOR<OffersExperienceCreateWithoutBackgroundInput, OffersExperienceUncheckedCreateWithoutBackgroundInput>
  }

  export type OffersExperienceCreateManyBackgroundInputEnvelope = {
    data: Enumerable<OffersExperienceCreateManyBackgroundInput>
    skipDuplicates?: boolean
  }

  export type OffersEducationCreateWithoutBackgroundInput = {
    id?: string
    type?: string | null
    field?: string | null
    school?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
  }

  export type OffersEducationUncheckedCreateWithoutBackgroundInput = {
    id?: string
    type?: string | null
    field?: string | null
    school?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
  }

  export type OffersEducationCreateOrConnectWithoutBackgroundInput = {
    where: OffersEducationWhereUniqueInput
    create: XOR<OffersEducationCreateWithoutBackgroundInput, OffersEducationUncheckedCreateWithoutBackgroundInput>
  }

  export type OffersEducationCreateManyBackgroundInputEnvelope = {
    data: Enumerable<OffersEducationCreateManyBackgroundInput>
    skipDuplicates?: boolean
  }

  export type OffersProfileCreateWithoutBackgroundInput = {
    id?: string
    profileName: string
    createdAt?: Date | string
    editToken: string
    discussion?: OffersReplyCreateNestedManyWithoutProfileInput
    offers?: OffersOfferCreateNestedManyWithoutProfileInput
    users?: UserCreateNestedManyWithoutOffersProfileInput
    analysis?: OffersAnalysisCreateNestedOneWithoutProfileInput
  }

  export type OffersProfileUncheckedCreateWithoutBackgroundInput = {
    id?: string
    profileName: string
    createdAt?: Date | string
    editToken: string
    discussion?: OffersReplyUncheckedCreateNestedManyWithoutProfileInput
    offers?: OffersOfferUncheckedCreateNestedManyWithoutProfileInput
    users?: UserUncheckedCreateNestedManyWithoutOffersProfileInput
    analysis?: OffersAnalysisUncheckedCreateNestedOneWithoutProfileInput
  }

  export type OffersProfileCreateOrConnectWithoutBackgroundInput = {
    where: OffersProfileWhereUniqueInput
    create: XOR<OffersProfileCreateWithoutBackgroundInput, OffersProfileUncheckedCreateWithoutBackgroundInput>
  }

  export type OffersSpecificYoeUpsertWithWhereUniqueWithoutBackgroundInput = {
    where: OffersSpecificYoeWhereUniqueInput
    update: XOR<OffersSpecificYoeUpdateWithoutBackgroundInput, OffersSpecificYoeUncheckedUpdateWithoutBackgroundInput>
    create: XOR<OffersSpecificYoeCreateWithoutBackgroundInput, OffersSpecificYoeUncheckedCreateWithoutBackgroundInput>
  }

  export type OffersSpecificYoeUpdateWithWhereUniqueWithoutBackgroundInput = {
    where: OffersSpecificYoeWhereUniqueInput
    data: XOR<OffersSpecificYoeUpdateWithoutBackgroundInput, OffersSpecificYoeUncheckedUpdateWithoutBackgroundInput>
  }

  export type OffersSpecificYoeUpdateManyWithWhereWithoutBackgroundInput = {
    where: OffersSpecificYoeScalarWhereInput
    data: XOR<OffersSpecificYoeUpdateManyMutationInput, OffersSpecificYoeUncheckedUpdateManyWithoutSpecificYoesInput>
  }

  export type OffersSpecificYoeScalarWhereInput = {
    AND?: Enumerable<OffersSpecificYoeScalarWhereInput>
    OR?: Enumerable<OffersSpecificYoeScalarWhereInput>
    NOT?: Enumerable<OffersSpecificYoeScalarWhereInput>
    id?: StringFilter | string
    yoe?: IntFilter | number
    domain?: StringFilter | string
    backgroundId?: StringFilter | string
  }

  export type OffersExperienceUpsertWithWhereUniqueWithoutBackgroundInput = {
    where: OffersExperienceWhereUniqueInput
    update: XOR<OffersExperienceUpdateWithoutBackgroundInput, OffersExperienceUncheckedUpdateWithoutBackgroundInput>
    create: XOR<OffersExperienceCreateWithoutBackgroundInput, OffersExperienceUncheckedCreateWithoutBackgroundInput>
  }

  export type OffersExperienceUpdateWithWhereUniqueWithoutBackgroundInput = {
    where: OffersExperienceWhereUniqueInput
    data: XOR<OffersExperienceUpdateWithoutBackgroundInput, OffersExperienceUncheckedUpdateWithoutBackgroundInput>
  }

  export type OffersExperienceUpdateManyWithWhereWithoutBackgroundInput = {
    where: OffersExperienceScalarWhereInput
    data: XOR<OffersExperienceUpdateManyMutationInput, OffersExperienceUncheckedUpdateManyWithoutExperiencesInput>
  }

  export type OffersEducationUpsertWithWhereUniqueWithoutBackgroundInput = {
    where: OffersEducationWhereUniqueInput
    update: XOR<OffersEducationUpdateWithoutBackgroundInput, OffersEducationUncheckedUpdateWithoutBackgroundInput>
    create: XOR<OffersEducationCreateWithoutBackgroundInput, OffersEducationUncheckedCreateWithoutBackgroundInput>
  }

  export type OffersEducationUpdateWithWhereUniqueWithoutBackgroundInput = {
    where: OffersEducationWhereUniqueInput
    data: XOR<OffersEducationUpdateWithoutBackgroundInput, OffersEducationUncheckedUpdateWithoutBackgroundInput>
  }

  export type OffersEducationUpdateManyWithWhereWithoutBackgroundInput = {
    where: OffersEducationScalarWhereInput
    data: XOR<OffersEducationUpdateManyMutationInput, OffersEducationUncheckedUpdateManyWithoutEducationsInput>
  }

  export type OffersEducationScalarWhereInput = {
    AND?: Enumerable<OffersEducationScalarWhereInput>
    OR?: Enumerable<OffersEducationScalarWhereInput>
    NOT?: Enumerable<OffersEducationScalarWhereInput>
    id?: StringFilter | string
    type?: StringNullableFilter | string | null
    field?: StringNullableFilter | string | null
    school?: StringNullableFilter | string | null
    startDate?: DateTimeNullableFilter | Date | string | null
    endDate?: DateTimeNullableFilter | Date | string | null
    backgroundId?: StringFilter | string
  }

  export type OffersProfileUpsertWithoutBackgroundInput = {
    update: XOR<OffersProfileUpdateWithoutBackgroundInput, OffersProfileUncheckedUpdateWithoutBackgroundInput>
    create: XOR<OffersProfileCreateWithoutBackgroundInput, OffersProfileUncheckedCreateWithoutBackgroundInput>
  }

  export type OffersProfileUpdateWithoutBackgroundInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editToken?: StringFieldUpdateOperationsInput | string
    discussion?: OffersReplyUpdateManyWithoutProfileNestedInput
    offers?: OffersOfferUpdateManyWithoutProfileNestedInput
    users?: UserUpdateManyWithoutOffersProfileNestedInput
    analysis?: OffersAnalysisUpdateOneWithoutProfileNestedInput
  }

  export type OffersProfileUncheckedUpdateWithoutBackgroundInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editToken?: StringFieldUpdateOperationsInput | string
    discussion?: OffersReplyUncheckedUpdateManyWithoutProfileNestedInput
    offers?: OffersOfferUncheckedUpdateManyWithoutProfileNestedInput
    users?: UserUncheckedUpdateManyWithoutOffersProfileNestedInput
    analysis?: OffersAnalysisUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type OffersBackgroundCreateWithoutSpecificYoesInput = {
    id?: string
    totalYoe?: number
    experiences?: OffersExperienceCreateNestedManyWithoutBackgroundInput
    educations?: OffersEducationCreateNestedManyWithoutBackgroundInput
    profile: OffersProfileCreateNestedOneWithoutBackgroundInput
  }

  export type OffersBackgroundUncheckedCreateWithoutSpecificYoesInput = {
    id?: string
    totalYoe?: number
    experiences?: OffersExperienceUncheckedCreateNestedManyWithoutBackgroundInput
    educations?: OffersEducationUncheckedCreateNestedManyWithoutBackgroundInput
    offersProfileId: string
  }

  export type OffersBackgroundCreateOrConnectWithoutSpecificYoesInput = {
    where: OffersBackgroundWhereUniqueInput
    create: XOR<OffersBackgroundCreateWithoutSpecificYoesInput, OffersBackgroundUncheckedCreateWithoutSpecificYoesInput>
  }

  export type OffersBackgroundUpsertWithoutSpecificYoesInput = {
    update: XOR<OffersBackgroundUpdateWithoutSpecificYoesInput, OffersBackgroundUncheckedUpdateWithoutSpecificYoesInput>
    create: XOR<OffersBackgroundCreateWithoutSpecificYoesInput, OffersBackgroundUncheckedCreateWithoutSpecificYoesInput>
  }

  export type OffersBackgroundUpdateWithoutSpecificYoesInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalYoe?: IntFieldUpdateOperationsInput | number
    experiences?: OffersExperienceUpdateManyWithoutBackgroundNestedInput
    educations?: OffersEducationUpdateManyWithoutBackgroundNestedInput
    profile?: OffersProfileUpdateOneRequiredWithoutBackgroundNestedInput
  }

  export type OffersBackgroundUncheckedUpdateWithoutSpecificYoesInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalYoe?: IntFieldUpdateOperationsInput | number
    experiences?: OffersExperienceUncheckedUpdateManyWithoutBackgroundNestedInput
    educations?: OffersEducationUncheckedUpdateManyWithoutBackgroundNestedInput
    offersProfileId?: StringFieldUpdateOperationsInput | string
  }

  export type CompanyCreateWithoutOffersExperienceInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logoUrl?: string | null
    website?: string | null
    ranking?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questionsQuestionEncounter?: QuestionsQuestionEncounterCreateNestedManyWithoutCompanyInput
    OffersOffer?: OffersOfferCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutOffersExperienceInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logoUrl?: string | null
    website?: string | null
    ranking?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questionsQuestionEncounter?: QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutCompanyInput
    OffersOffer?: OffersOfferUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutOffersExperienceInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutOffersExperienceInput, CompanyUncheckedCreateWithoutOffersExperienceInput>
  }

  export type CityCreateWithoutOffersExperienceInput = {
    id: string
    name: string
    ranking?: number | null
    state: StateCreateNestedOneWithoutCitiesInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterCreateNestedManyWithoutCityInput
    OffersOffer?: OffersOfferCreateNestedManyWithoutLocationInput
  }

  export type CityUncheckedCreateWithoutOffersExperienceInput = {
    id: string
    name: string
    stateId: string
    ranking?: number | null
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutCityInput
    OffersOffer?: OffersOfferUncheckedCreateNestedManyWithoutLocationInput
  }

  export type CityCreateOrConnectWithoutOffersExperienceInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutOffersExperienceInput, CityUncheckedCreateWithoutOffersExperienceInput>
  }

  export type OffersCurrencyCreateWithoutOffersExperienceTotalCompensationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    value: number
    currency: string
    baseValue: number
    baseCurrency?: string
    OffersExperienceMonthlySalary?: OffersExperienceCreateNestedOneWithoutMonthlySalaryInput
    OffersTotalCompensation?: OffersFullTimeCreateNestedOneWithoutTotalCompensationInput
    OffersBaseSalary?: OffersFullTimeCreateNestedOneWithoutBaseSalaryInput
    OffersBonus?: OffersFullTimeCreateNestedOneWithoutBonusInput
    OffersStocks?: OffersFullTimeCreateNestedOneWithoutStocksInput
    OffersMonthlySalary?: OffersInternCreateNestedOneWithoutMonthlySalaryInput
  }

  export type OffersCurrencyUncheckedCreateWithoutOffersExperienceTotalCompensationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    value: number
    currency: string
    baseValue: number
    baseCurrency?: string
    OffersExperienceMonthlySalary?: OffersExperienceUncheckedCreateNestedOneWithoutMonthlySalaryInput
    OffersTotalCompensation?: OffersFullTimeUncheckedCreateNestedOneWithoutTotalCompensationInput
    OffersBaseSalary?: OffersFullTimeUncheckedCreateNestedOneWithoutBaseSalaryInput
    OffersBonus?: OffersFullTimeUncheckedCreateNestedOneWithoutBonusInput
    OffersStocks?: OffersFullTimeUncheckedCreateNestedOneWithoutStocksInput
    OffersMonthlySalary?: OffersInternUncheckedCreateNestedOneWithoutMonthlySalaryInput
  }

  export type OffersCurrencyCreateOrConnectWithoutOffersExperienceTotalCompensationInput = {
    where: OffersCurrencyWhereUniqueInput
    create: XOR<OffersCurrencyCreateWithoutOffersExperienceTotalCompensationInput, OffersCurrencyUncheckedCreateWithoutOffersExperienceTotalCompensationInput>
  }

  export type OffersCurrencyCreateWithoutOffersExperienceMonthlySalaryInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    value: number
    currency: string
    baseValue: number
    baseCurrency?: string
    OffersExperienceTotalCompensation?: OffersExperienceCreateNestedOneWithoutTotalCompensationInput
    OffersTotalCompensation?: OffersFullTimeCreateNestedOneWithoutTotalCompensationInput
    OffersBaseSalary?: OffersFullTimeCreateNestedOneWithoutBaseSalaryInput
    OffersBonus?: OffersFullTimeCreateNestedOneWithoutBonusInput
    OffersStocks?: OffersFullTimeCreateNestedOneWithoutStocksInput
    OffersMonthlySalary?: OffersInternCreateNestedOneWithoutMonthlySalaryInput
  }

  export type OffersCurrencyUncheckedCreateWithoutOffersExperienceMonthlySalaryInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    value: number
    currency: string
    baseValue: number
    baseCurrency?: string
    OffersExperienceTotalCompensation?: OffersExperienceUncheckedCreateNestedOneWithoutTotalCompensationInput
    OffersTotalCompensation?: OffersFullTimeUncheckedCreateNestedOneWithoutTotalCompensationInput
    OffersBaseSalary?: OffersFullTimeUncheckedCreateNestedOneWithoutBaseSalaryInput
    OffersBonus?: OffersFullTimeUncheckedCreateNestedOneWithoutBonusInput
    OffersStocks?: OffersFullTimeUncheckedCreateNestedOneWithoutStocksInput
    OffersMonthlySalary?: OffersInternUncheckedCreateNestedOneWithoutMonthlySalaryInput
  }

  export type OffersCurrencyCreateOrConnectWithoutOffersExperienceMonthlySalaryInput = {
    where: OffersCurrencyWhereUniqueInput
    create: XOR<OffersCurrencyCreateWithoutOffersExperienceMonthlySalaryInput, OffersCurrencyUncheckedCreateWithoutOffersExperienceMonthlySalaryInput>
  }

  export type OffersBackgroundCreateWithoutExperiencesInput = {
    id?: string
    totalYoe?: number
    specificYoes?: OffersSpecificYoeCreateNestedManyWithoutBackgroundInput
    educations?: OffersEducationCreateNestedManyWithoutBackgroundInput
    profile: OffersProfileCreateNestedOneWithoutBackgroundInput
  }

  export type OffersBackgroundUncheckedCreateWithoutExperiencesInput = {
    id?: string
    totalYoe?: number
    specificYoes?: OffersSpecificYoeUncheckedCreateNestedManyWithoutBackgroundInput
    educations?: OffersEducationUncheckedCreateNestedManyWithoutBackgroundInput
    offersProfileId: string
  }

  export type OffersBackgroundCreateOrConnectWithoutExperiencesInput = {
    where: OffersBackgroundWhereUniqueInput
    create: XOR<OffersBackgroundCreateWithoutExperiencesInput, OffersBackgroundUncheckedCreateWithoutExperiencesInput>
  }

  export type CompanyUpsertWithoutOffersExperienceInput = {
    update: XOR<CompanyUpdateWithoutOffersExperienceInput, CompanyUncheckedUpdateWithoutOffersExperienceInput>
    create: XOR<CompanyCreateWithoutOffersExperienceInput, CompanyUncheckedCreateWithoutOffersExperienceInput>
  }

  export type CompanyUpdateWithoutOffersExperienceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionsQuestionEncounter?: QuestionsQuestionEncounterUpdateManyWithoutCompanyNestedInput
    OffersOffer?: OffersOfferUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutOffersExperienceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionsQuestionEncounter?: QuestionsQuestionEncounterUncheckedUpdateManyWithoutCompanyNestedInput
    OffersOffer?: OffersOfferUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CityUpsertWithoutOffersExperienceInput = {
    update: XOR<CityUpdateWithoutOffersExperienceInput, CityUncheckedUpdateWithoutOffersExperienceInput>
    create: XOR<CityCreateWithoutOffersExperienceInput, CityUncheckedCreateWithoutOffersExperienceInput>
  }

  export type CityUpdateWithoutOffersExperienceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    state?: StateUpdateOneRequiredWithoutCitiesNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUpdateManyWithoutCityNestedInput
    OffersOffer?: OffersOfferUpdateManyWithoutLocationNestedInput
  }

  export type CityUncheckedUpdateWithoutOffersExperienceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stateId?: StringFieldUpdateOperationsInput | string
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedUpdateManyWithoutCityNestedInput
    OffersOffer?: OffersOfferUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type OffersCurrencyUpsertWithoutOffersExperienceTotalCompensationInput = {
    update: XOR<OffersCurrencyUpdateWithoutOffersExperienceTotalCompensationInput, OffersCurrencyUncheckedUpdateWithoutOffersExperienceTotalCompensationInput>
    create: XOR<OffersCurrencyCreateWithoutOffersExperienceTotalCompensationInput, OffersCurrencyUncheckedCreateWithoutOffersExperienceTotalCompensationInput>
  }

  export type OffersCurrencyUpdateWithoutOffersExperienceTotalCompensationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    baseValue?: FloatFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    OffersExperienceMonthlySalary?: OffersExperienceUpdateOneWithoutMonthlySalaryNestedInput
    OffersTotalCompensation?: OffersFullTimeUpdateOneWithoutTotalCompensationNestedInput
    OffersBaseSalary?: OffersFullTimeUpdateOneWithoutBaseSalaryNestedInput
    OffersBonus?: OffersFullTimeUpdateOneWithoutBonusNestedInput
    OffersStocks?: OffersFullTimeUpdateOneWithoutStocksNestedInput
    OffersMonthlySalary?: OffersInternUpdateOneWithoutMonthlySalaryNestedInput
  }

  export type OffersCurrencyUncheckedUpdateWithoutOffersExperienceTotalCompensationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    baseValue?: FloatFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    OffersExperienceMonthlySalary?: OffersExperienceUncheckedUpdateOneWithoutMonthlySalaryNestedInput
    OffersTotalCompensation?: OffersFullTimeUncheckedUpdateOneWithoutTotalCompensationNestedInput
    OffersBaseSalary?: OffersFullTimeUncheckedUpdateOneWithoutBaseSalaryNestedInput
    OffersBonus?: OffersFullTimeUncheckedUpdateOneWithoutBonusNestedInput
    OffersStocks?: OffersFullTimeUncheckedUpdateOneWithoutStocksNestedInput
    OffersMonthlySalary?: OffersInternUncheckedUpdateOneWithoutMonthlySalaryNestedInput
  }

  export type OffersCurrencyUpsertWithoutOffersExperienceMonthlySalaryInput = {
    update: XOR<OffersCurrencyUpdateWithoutOffersExperienceMonthlySalaryInput, OffersCurrencyUncheckedUpdateWithoutOffersExperienceMonthlySalaryInput>
    create: XOR<OffersCurrencyCreateWithoutOffersExperienceMonthlySalaryInput, OffersCurrencyUncheckedCreateWithoutOffersExperienceMonthlySalaryInput>
  }

  export type OffersCurrencyUpdateWithoutOffersExperienceMonthlySalaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    baseValue?: FloatFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    OffersExperienceTotalCompensation?: OffersExperienceUpdateOneWithoutTotalCompensationNestedInput
    OffersTotalCompensation?: OffersFullTimeUpdateOneWithoutTotalCompensationNestedInput
    OffersBaseSalary?: OffersFullTimeUpdateOneWithoutBaseSalaryNestedInput
    OffersBonus?: OffersFullTimeUpdateOneWithoutBonusNestedInput
    OffersStocks?: OffersFullTimeUpdateOneWithoutStocksNestedInput
    OffersMonthlySalary?: OffersInternUpdateOneWithoutMonthlySalaryNestedInput
  }

  export type OffersCurrencyUncheckedUpdateWithoutOffersExperienceMonthlySalaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    baseValue?: FloatFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    OffersExperienceTotalCompensation?: OffersExperienceUncheckedUpdateOneWithoutTotalCompensationNestedInput
    OffersTotalCompensation?: OffersFullTimeUncheckedUpdateOneWithoutTotalCompensationNestedInput
    OffersBaseSalary?: OffersFullTimeUncheckedUpdateOneWithoutBaseSalaryNestedInput
    OffersBonus?: OffersFullTimeUncheckedUpdateOneWithoutBonusNestedInput
    OffersStocks?: OffersFullTimeUncheckedUpdateOneWithoutStocksNestedInput
    OffersMonthlySalary?: OffersInternUncheckedUpdateOneWithoutMonthlySalaryNestedInput
  }

  export type OffersBackgroundUpsertWithoutExperiencesInput = {
    update: XOR<OffersBackgroundUpdateWithoutExperiencesInput, OffersBackgroundUncheckedUpdateWithoutExperiencesInput>
    create: XOR<OffersBackgroundCreateWithoutExperiencesInput, OffersBackgroundUncheckedCreateWithoutExperiencesInput>
  }

  export type OffersBackgroundUpdateWithoutExperiencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalYoe?: IntFieldUpdateOperationsInput | number
    specificYoes?: OffersSpecificYoeUpdateManyWithoutBackgroundNestedInput
    educations?: OffersEducationUpdateManyWithoutBackgroundNestedInput
    profile?: OffersProfileUpdateOneRequiredWithoutBackgroundNestedInput
  }

  export type OffersBackgroundUncheckedUpdateWithoutExperiencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalYoe?: IntFieldUpdateOperationsInput | number
    specificYoes?: OffersSpecificYoeUncheckedUpdateManyWithoutBackgroundNestedInput
    educations?: OffersEducationUncheckedUpdateManyWithoutBackgroundNestedInput
    offersProfileId?: StringFieldUpdateOperationsInput | string
  }

  export type OffersExperienceCreateWithoutTotalCompensationInput = {
    id?: string
    company?: CompanyCreateNestedOneWithoutOffersExperienceInput
    jobType?: JobType | null
    title?: string | null
    durationInMonths?: number | null
    location?: CityCreateNestedOneWithoutOffersExperienceInput
    level?: string | null
    monthlySalary?: OffersCurrencyCreateNestedOneWithoutOffersExperienceMonthlySalaryInput
    background: OffersBackgroundCreateNestedOneWithoutExperiencesInput
  }

  export type OffersExperienceUncheckedCreateWithoutTotalCompensationInput = {
    id?: string
    companyId?: string | null
    jobType?: JobType | null
    title?: string | null
    durationInMonths?: number | null
    cityId?: string | null
    level?: string | null
    monthlySalaryId?: string | null
    backgroundId: string
  }

  export type OffersExperienceCreateOrConnectWithoutTotalCompensationInput = {
    where: OffersExperienceWhereUniqueInput
    create: XOR<OffersExperienceCreateWithoutTotalCompensationInput, OffersExperienceUncheckedCreateWithoutTotalCompensationInput>
  }

  export type OffersExperienceCreateWithoutMonthlySalaryInput = {
    id?: string
    company?: CompanyCreateNestedOneWithoutOffersExperienceInput
    jobType?: JobType | null
    title?: string | null
    durationInMonths?: number | null
    location?: CityCreateNestedOneWithoutOffersExperienceInput
    level?: string | null
    totalCompensation?: OffersCurrencyCreateNestedOneWithoutOffersExperienceTotalCompensationInput
    background: OffersBackgroundCreateNestedOneWithoutExperiencesInput
  }

  export type OffersExperienceUncheckedCreateWithoutMonthlySalaryInput = {
    id?: string
    companyId?: string | null
    jobType?: JobType | null
    title?: string | null
    durationInMonths?: number | null
    cityId?: string | null
    level?: string | null
    totalCompensationId?: string | null
    backgroundId: string
  }

  export type OffersExperienceCreateOrConnectWithoutMonthlySalaryInput = {
    where: OffersExperienceWhereUniqueInput
    create: XOR<OffersExperienceCreateWithoutMonthlySalaryInput, OffersExperienceUncheckedCreateWithoutMonthlySalaryInput>
  }

  export type OffersFullTimeCreateWithoutTotalCompensationInput = {
    id?: string
    title: string
    level: string
    baseSalary?: OffersCurrencyCreateNestedOneWithoutOffersBaseSalaryInput
    bonus?: OffersCurrencyCreateNestedOneWithoutOffersBonusInput
    stocks?: OffersCurrencyCreateNestedOneWithoutOffersStocksInput
    OffersOffer?: OffersOfferCreateNestedOneWithoutOffersFullTimeInput
  }

  export type OffersFullTimeUncheckedCreateWithoutTotalCompensationInput = {
    id?: string
    title: string
    level: string
    baseSalaryId?: string | null
    bonusId?: string | null
    stocksId?: string | null
    OffersOffer?: OffersOfferUncheckedCreateNestedOneWithoutOffersFullTimeInput
  }

  export type OffersFullTimeCreateOrConnectWithoutTotalCompensationInput = {
    where: OffersFullTimeWhereUniqueInput
    create: XOR<OffersFullTimeCreateWithoutTotalCompensationInput, OffersFullTimeUncheckedCreateWithoutTotalCompensationInput>
  }

  export type OffersFullTimeCreateWithoutBaseSalaryInput = {
    id?: string
    title: string
    level: string
    totalCompensation: OffersCurrencyCreateNestedOneWithoutOffersTotalCompensationInput
    bonus?: OffersCurrencyCreateNestedOneWithoutOffersBonusInput
    stocks?: OffersCurrencyCreateNestedOneWithoutOffersStocksInput
    OffersOffer?: OffersOfferCreateNestedOneWithoutOffersFullTimeInput
  }

  export type OffersFullTimeUncheckedCreateWithoutBaseSalaryInput = {
    id?: string
    title: string
    level: string
    totalCompensationId: string
    bonusId?: string | null
    stocksId?: string | null
    OffersOffer?: OffersOfferUncheckedCreateNestedOneWithoutOffersFullTimeInput
  }

  export type OffersFullTimeCreateOrConnectWithoutBaseSalaryInput = {
    where: OffersFullTimeWhereUniqueInput
    create: XOR<OffersFullTimeCreateWithoutBaseSalaryInput, OffersFullTimeUncheckedCreateWithoutBaseSalaryInput>
  }

  export type OffersFullTimeCreateWithoutBonusInput = {
    id?: string
    title: string
    level: string
    totalCompensation: OffersCurrencyCreateNestedOneWithoutOffersTotalCompensationInput
    baseSalary?: OffersCurrencyCreateNestedOneWithoutOffersBaseSalaryInput
    stocks?: OffersCurrencyCreateNestedOneWithoutOffersStocksInput
    OffersOffer?: OffersOfferCreateNestedOneWithoutOffersFullTimeInput
  }

  export type OffersFullTimeUncheckedCreateWithoutBonusInput = {
    id?: string
    title: string
    level: string
    totalCompensationId: string
    baseSalaryId?: string | null
    stocksId?: string | null
    OffersOffer?: OffersOfferUncheckedCreateNestedOneWithoutOffersFullTimeInput
  }

  export type OffersFullTimeCreateOrConnectWithoutBonusInput = {
    where: OffersFullTimeWhereUniqueInput
    create: XOR<OffersFullTimeCreateWithoutBonusInput, OffersFullTimeUncheckedCreateWithoutBonusInput>
  }

  export type OffersFullTimeCreateWithoutStocksInput = {
    id?: string
    title: string
    level: string
    totalCompensation: OffersCurrencyCreateNestedOneWithoutOffersTotalCompensationInput
    baseSalary?: OffersCurrencyCreateNestedOneWithoutOffersBaseSalaryInput
    bonus?: OffersCurrencyCreateNestedOneWithoutOffersBonusInput
    OffersOffer?: OffersOfferCreateNestedOneWithoutOffersFullTimeInput
  }

  export type OffersFullTimeUncheckedCreateWithoutStocksInput = {
    id?: string
    title: string
    level: string
    totalCompensationId: string
    baseSalaryId?: string | null
    bonusId?: string | null
    OffersOffer?: OffersOfferUncheckedCreateNestedOneWithoutOffersFullTimeInput
  }

  export type OffersFullTimeCreateOrConnectWithoutStocksInput = {
    where: OffersFullTimeWhereUniqueInput
    create: XOR<OffersFullTimeCreateWithoutStocksInput, OffersFullTimeUncheckedCreateWithoutStocksInput>
  }

  export type OffersInternCreateWithoutMonthlySalaryInput = {
    id?: string
    title: string
    internshipCycle: string
    startYear: number
    OffersOffer?: OffersOfferCreateNestedOneWithoutOffersInternInput
  }

  export type OffersInternUncheckedCreateWithoutMonthlySalaryInput = {
    id?: string
    title: string
    internshipCycle: string
    startYear: number
    OffersOffer?: OffersOfferUncheckedCreateNestedOneWithoutOffersInternInput
  }

  export type OffersInternCreateOrConnectWithoutMonthlySalaryInput = {
    where: OffersInternWhereUniqueInput
    create: XOR<OffersInternCreateWithoutMonthlySalaryInput, OffersInternUncheckedCreateWithoutMonthlySalaryInput>
  }

  export type OffersExperienceUpsertWithoutTotalCompensationInput = {
    update: XOR<OffersExperienceUpdateWithoutTotalCompensationInput, OffersExperienceUncheckedUpdateWithoutTotalCompensationInput>
    create: XOR<OffersExperienceCreateWithoutTotalCompensationInput, OffersExperienceUncheckedCreateWithoutTotalCompensationInput>
  }

  export type OffersExperienceUpdateWithoutTotalCompensationInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: CompanyUpdateOneWithoutOffersExperienceNestedInput
    jobType?: NullableEnumJobTypeFieldUpdateOperationsInput | JobType | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    durationInMonths?: NullableIntFieldUpdateOperationsInput | number | null
    location?: CityUpdateOneWithoutOffersExperienceNestedInput
    level?: NullableStringFieldUpdateOperationsInput | string | null
    monthlySalary?: OffersCurrencyUpdateOneWithoutOffersExperienceMonthlySalaryNestedInput
    background?: OffersBackgroundUpdateOneRequiredWithoutExperiencesNestedInput
  }

  export type OffersExperienceUncheckedUpdateWithoutTotalCompensationInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    jobType?: NullableEnumJobTypeFieldUpdateOperationsInput | JobType | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    durationInMonths?: NullableIntFieldUpdateOperationsInput | number | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    monthlySalaryId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundId?: StringFieldUpdateOperationsInput | string
  }

  export type OffersExperienceUpsertWithoutMonthlySalaryInput = {
    update: XOR<OffersExperienceUpdateWithoutMonthlySalaryInput, OffersExperienceUncheckedUpdateWithoutMonthlySalaryInput>
    create: XOR<OffersExperienceCreateWithoutMonthlySalaryInput, OffersExperienceUncheckedCreateWithoutMonthlySalaryInput>
  }

  export type OffersExperienceUpdateWithoutMonthlySalaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: CompanyUpdateOneWithoutOffersExperienceNestedInput
    jobType?: NullableEnumJobTypeFieldUpdateOperationsInput | JobType | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    durationInMonths?: NullableIntFieldUpdateOperationsInput | number | null
    location?: CityUpdateOneWithoutOffersExperienceNestedInput
    level?: NullableStringFieldUpdateOperationsInput | string | null
    totalCompensation?: OffersCurrencyUpdateOneWithoutOffersExperienceTotalCompensationNestedInput
    background?: OffersBackgroundUpdateOneRequiredWithoutExperiencesNestedInput
  }

  export type OffersExperienceUncheckedUpdateWithoutMonthlySalaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    jobType?: NullableEnumJobTypeFieldUpdateOperationsInput | JobType | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    durationInMonths?: NullableIntFieldUpdateOperationsInput | number | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    totalCompensationId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundId?: StringFieldUpdateOperationsInput | string
  }

  export type OffersFullTimeUpsertWithoutTotalCompensationInput = {
    update: XOR<OffersFullTimeUpdateWithoutTotalCompensationInput, OffersFullTimeUncheckedUpdateWithoutTotalCompensationInput>
    create: XOR<OffersFullTimeCreateWithoutTotalCompensationInput, OffersFullTimeUncheckedCreateWithoutTotalCompensationInput>
  }

  export type OffersFullTimeUpdateWithoutTotalCompensationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    baseSalary?: OffersCurrencyUpdateOneWithoutOffersBaseSalaryNestedInput
    bonus?: OffersCurrencyUpdateOneWithoutOffersBonusNestedInput
    stocks?: OffersCurrencyUpdateOneWithoutOffersStocksNestedInput
    OffersOffer?: OffersOfferUpdateOneWithoutOffersFullTimeNestedInput
  }

  export type OffersFullTimeUncheckedUpdateWithoutTotalCompensationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    baseSalaryId?: NullableStringFieldUpdateOperationsInput | string | null
    bonusId?: NullableStringFieldUpdateOperationsInput | string | null
    stocksId?: NullableStringFieldUpdateOperationsInput | string | null
    OffersOffer?: OffersOfferUncheckedUpdateOneWithoutOffersFullTimeNestedInput
  }

  export type OffersFullTimeUpsertWithoutBaseSalaryInput = {
    update: XOR<OffersFullTimeUpdateWithoutBaseSalaryInput, OffersFullTimeUncheckedUpdateWithoutBaseSalaryInput>
    create: XOR<OffersFullTimeCreateWithoutBaseSalaryInput, OffersFullTimeUncheckedCreateWithoutBaseSalaryInput>
  }

  export type OffersFullTimeUpdateWithoutBaseSalaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    totalCompensation?: OffersCurrencyUpdateOneRequiredWithoutOffersTotalCompensationNestedInput
    bonus?: OffersCurrencyUpdateOneWithoutOffersBonusNestedInput
    stocks?: OffersCurrencyUpdateOneWithoutOffersStocksNestedInput
    OffersOffer?: OffersOfferUpdateOneWithoutOffersFullTimeNestedInput
  }

  export type OffersFullTimeUncheckedUpdateWithoutBaseSalaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    totalCompensationId?: StringFieldUpdateOperationsInput | string
    bonusId?: NullableStringFieldUpdateOperationsInput | string | null
    stocksId?: NullableStringFieldUpdateOperationsInput | string | null
    OffersOffer?: OffersOfferUncheckedUpdateOneWithoutOffersFullTimeNestedInput
  }

  export type OffersFullTimeUpsertWithoutBonusInput = {
    update: XOR<OffersFullTimeUpdateWithoutBonusInput, OffersFullTimeUncheckedUpdateWithoutBonusInput>
    create: XOR<OffersFullTimeCreateWithoutBonusInput, OffersFullTimeUncheckedCreateWithoutBonusInput>
  }

  export type OffersFullTimeUpdateWithoutBonusInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    totalCompensation?: OffersCurrencyUpdateOneRequiredWithoutOffersTotalCompensationNestedInput
    baseSalary?: OffersCurrencyUpdateOneWithoutOffersBaseSalaryNestedInput
    stocks?: OffersCurrencyUpdateOneWithoutOffersStocksNestedInput
    OffersOffer?: OffersOfferUpdateOneWithoutOffersFullTimeNestedInput
  }

  export type OffersFullTimeUncheckedUpdateWithoutBonusInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    totalCompensationId?: StringFieldUpdateOperationsInput | string
    baseSalaryId?: NullableStringFieldUpdateOperationsInput | string | null
    stocksId?: NullableStringFieldUpdateOperationsInput | string | null
    OffersOffer?: OffersOfferUncheckedUpdateOneWithoutOffersFullTimeNestedInput
  }

  export type OffersFullTimeUpsertWithoutStocksInput = {
    update: XOR<OffersFullTimeUpdateWithoutStocksInput, OffersFullTimeUncheckedUpdateWithoutStocksInput>
    create: XOR<OffersFullTimeCreateWithoutStocksInput, OffersFullTimeUncheckedCreateWithoutStocksInput>
  }

  export type OffersFullTimeUpdateWithoutStocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    totalCompensation?: OffersCurrencyUpdateOneRequiredWithoutOffersTotalCompensationNestedInput
    baseSalary?: OffersCurrencyUpdateOneWithoutOffersBaseSalaryNestedInput
    bonus?: OffersCurrencyUpdateOneWithoutOffersBonusNestedInput
    OffersOffer?: OffersOfferUpdateOneWithoutOffersFullTimeNestedInput
  }

  export type OffersFullTimeUncheckedUpdateWithoutStocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    totalCompensationId?: StringFieldUpdateOperationsInput | string
    baseSalaryId?: NullableStringFieldUpdateOperationsInput | string | null
    bonusId?: NullableStringFieldUpdateOperationsInput | string | null
    OffersOffer?: OffersOfferUncheckedUpdateOneWithoutOffersFullTimeNestedInput
  }

  export type OffersInternUpsertWithoutMonthlySalaryInput = {
    update: XOR<OffersInternUpdateWithoutMonthlySalaryInput, OffersInternUncheckedUpdateWithoutMonthlySalaryInput>
    create: XOR<OffersInternCreateWithoutMonthlySalaryInput, OffersInternUncheckedCreateWithoutMonthlySalaryInput>
  }

  export type OffersInternUpdateWithoutMonthlySalaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    internshipCycle?: StringFieldUpdateOperationsInput | string
    startYear?: IntFieldUpdateOperationsInput | number
    OffersOffer?: OffersOfferUpdateOneWithoutOffersInternNestedInput
  }

  export type OffersInternUncheckedUpdateWithoutMonthlySalaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    internshipCycle?: StringFieldUpdateOperationsInput | string
    startYear?: IntFieldUpdateOperationsInput | number
    OffersOffer?: OffersOfferUncheckedUpdateOneWithoutOffersInternNestedInput
  }

  export type OffersBackgroundCreateWithoutEducationsInput = {
    id?: string
    totalYoe?: number
    specificYoes?: OffersSpecificYoeCreateNestedManyWithoutBackgroundInput
    experiences?: OffersExperienceCreateNestedManyWithoutBackgroundInput
    profile: OffersProfileCreateNestedOneWithoutBackgroundInput
  }

  export type OffersBackgroundUncheckedCreateWithoutEducationsInput = {
    id?: string
    totalYoe?: number
    specificYoes?: OffersSpecificYoeUncheckedCreateNestedManyWithoutBackgroundInput
    experiences?: OffersExperienceUncheckedCreateNestedManyWithoutBackgroundInput
    offersProfileId: string
  }

  export type OffersBackgroundCreateOrConnectWithoutEducationsInput = {
    where: OffersBackgroundWhereUniqueInput
    create: XOR<OffersBackgroundCreateWithoutEducationsInput, OffersBackgroundUncheckedCreateWithoutEducationsInput>
  }

  export type OffersBackgroundUpsertWithoutEducationsInput = {
    update: XOR<OffersBackgroundUpdateWithoutEducationsInput, OffersBackgroundUncheckedUpdateWithoutEducationsInput>
    create: XOR<OffersBackgroundCreateWithoutEducationsInput, OffersBackgroundUncheckedCreateWithoutEducationsInput>
  }

  export type OffersBackgroundUpdateWithoutEducationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalYoe?: IntFieldUpdateOperationsInput | number
    specificYoes?: OffersSpecificYoeUpdateManyWithoutBackgroundNestedInput
    experiences?: OffersExperienceUpdateManyWithoutBackgroundNestedInput
    profile?: OffersProfileUpdateOneRequiredWithoutBackgroundNestedInput
  }

  export type OffersBackgroundUncheckedUpdateWithoutEducationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalYoe?: IntFieldUpdateOperationsInput | number
    specificYoes?: OffersSpecificYoeUncheckedUpdateManyWithoutBackgroundNestedInput
    experiences?: OffersExperienceUncheckedUpdateManyWithoutBackgroundNestedInput
    offersProfileId?: StringFieldUpdateOperationsInput | string
  }

  export type OffersReplyCreateWithoutRepliesInput = {
    id?: string
    createdAt?: Date | string
    message: string
    replyingTo?: OffersReplyCreateNestedOneWithoutRepliesInput
    profile: OffersProfileCreateNestedOneWithoutDiscussionInput
    user?: UserCreateNestedOneWithoutOffersDiscussionInput
  }

  export type OffersReplyUncheckedCreateWithoutRepliesInput = {
    id?: string
    createdAt?: Date | string
    message: string
    replyingToId?: string | null
    profileId: string
    userId?: string | null
  }

  export type OffersReplyCreateOrConnectWithoutRepliesInput = {
    where: OffersReplyWhereUniqueInput
    create: XOR<OffersReplyCreateWithoutRepliesInput, OffersReplyUncheckedCreateWithoutRepliesInput>
  }

  export type OffersReplyCreateWithoutReplyingToInput = {
    id?: string
    createdAt?: Date | string
    message: string
    replies?: OffersReplyCreateNestedManyWithoutReplyingToInput
    profile: OffersProfileCreateNestedOneWithoutDiscussionInput
    user?: UserCreateNestedOneWithoutOffersDiscussionInput
  }

  export type OffersReplyUncheckedCreateWithoutReplyingToInput = {
    id?: string
    createdAt?: Date | string
    message: string
    replies?: OffersReplyUncheckedCreateNestedManyWithoutReplyingToInput
    profileId: string
    userId?: string | null
  }

  export type OffersReplyCreateOrConnectWithoutReplyingToInput = {
    where: OffersReplyWhereUniqueInput
    create: XOR<OffersReplyCreateWithoutReplyingToInput, OffersReplyUncheckedCreateWithoutReplyingToInput>
  }

  export type OffersReplyCreateManyReplyingToInputEnvelope = {
    data: Enumerable<OffersReplyCreateManyReplyingToInput>
    skipDuplicates?: boolean
  }

  export type OffersProfileCreateWithoutDiscussionInput = {
    id?: string
    profileName: string
    createdAt?: Date | string
    background?: OffersBackgroundCreateNestedOneWithoutProfileInput
    editToken: string
    offers?: OffersOfferCreateNestedManyWithoutProfileInput
    users?: UserCreateNestedManyWithoutOffersProfileInput
    analysis?: OffersAnalysisCreateNestedOneWithoutProfileInput
  }

  export type OffersProfileUncheckedCreateWithoutDiscussionInput = {
    id?: string
    profileName: string
    createdAt?: Date | string
    background?: OffersBackgroundUncheckedCreateNestedOneWithoutProfileInput
    editToken: string
    offers?: OffersOfferUncheckedCreateNestedManyWithoutProfileInput
    users?: UserUncheckedCreateNestedManyWithoutOffersProfileInput
    analysis?: OffersAnalysisUncheckedCreateNestedOneWithoutProfileInput
  }

  export type OffersProfileCreateOrConnectWithoutDiscussionInput = {
    where: OffersProfileWhereUniqueInput
    create: XOR<OffersProfileCreateWithoutDiscussionInput, OffersProfileUncheckedCreateWithoutDiscussionInput>
  }

  export type UserCreateWithoutOffersDiscussionInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    todos?: TodoCreateNestedManyWithoutUserInput
    resumesResumes?: ResumesResumeCreateNestedManyWithoutUserInput
    resumesStars?: ResumesStarCreateNestedManyWithoutUserInput
    resumesComments?: ResumesCommentCreateNestedManyWithoutUserInput
    resumesCommentVotes?: ResumesCommentVoteCreateNestedManyWithoutUserInput
    questionsQuestions?: QuestionsQuestionCreateNestedManyWithoutUserInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterCreateNestedManyWithoutUserInput
    questionsQuestionVotes?: QuestionsQuestionVoteCreateNestedManyWithoutUserInput
    questionsQuestionComments?: QuestionsQuestionCommentCreateNestedManyWithoutUserInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteCreateNestedManyWithoutUserInput
    questionsAnswers?: QuestionsAnswerCreateNestedManyWithoutUserInput
    questionsAnswerVotes?: QuestionsAnswerVoteCreateNestedManyWithoutUserInput
    questionsAnswerComments?: QuestionsAnswerCommentCreateNestedManyWithoutUserInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteCreateNestedManyWithoutUserInput
    OffersProfile?: OffersProfileCreateNestedManyWithoutUsersInput
    questionsLists?: QuestionsListCreateNestedManyWithoutUserInput
    OffersAdmin?: OffersAdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOffersDiscussionInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
    resumesResumes?: ResumesResumeUncheckedCreateNestedManyWithoutUserInput
    resumesStars?: ResumesStarUncheckedCreateNestedManyWithoutUserInput
    resumesComments?: ResumesCommentUncheckedCreateNestedManyWithoutUserInput
    resumesCommentVotes?: ResumesCommentVoteUncheckedCreateNestedManyWithoutUserInput
    questionsQuestions?: QuestionsQuestionUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionVotes?: QuestionsQuestionVoteUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionComments?: QuestionsQuestionCommentUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUncheckedCreateNestedManyWithoutUserInput
    questionsAnswers?: QuestionsAnswerUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerVotes?: QuestionsAnswerVoteUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerComments?: QuestionsAnswerCommentUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUncheckedCreateNestedManyWithoutUserInput
    OffersProfile?: OffersProfileUncheckedCreateNestedManyWithoutUsersInput
    questionsLists?: QuestionsListUncheckedCreateNestedManyWithoutUserInput
    OffersAdmin?: OffersAdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOffersDiscussionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOffersDiscussionInput, UserUncheckedCreateWithoutOffersDiscussionInput>
  }

  export type OffersReplyUpsertWithoutRepliesInput = {
    update: XOR<OffersReplyUpdateWithoutRepliesInput, OffersReplyUncheckedUpdateWithoutRepliesInput>
    create: XOR<OffersReplyCreateWithoutRepliesInput, OffersReplyUncheckedCreateWithoutRepliesInput>
  }

  export type OffersReplyUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    replyingTo?: OffersReplyUpdateOneWithoutRepliesNestedInput
    profile?: OffersProfileUpdateOneRequiredWithoutDiscussionNestedInput
    user?: UserUpdateOneWithoutOffersDiscussionNestedInput
  }

  export type OffersReplyUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    replyingToId?: NullableStringFieldUpdateOperationsInput | string | null
    profileId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OffersReplyUpsertWithWhereUniqueWithoutReplyingToInput = {
    where: OffersReplyWhereUniqueInput
    update: XOR<OffersReplyUpdateWithoutReplyingToInput, OffersReplyUncheckedUpdateWithoutReplyingToInput>
    create: XOR<OffersReplyCreateWithoutReplyingToInput, OffersReplyUncheckedCreateWithoutReplyingToInput>
  }

  export type OffersReplyUpdateWithWhereUniqueWithoutReplyingToInput = {
    where: OffersReplyWhereUniqueInput
    data: XOR<OffersReplyUpdateWithoutReplyingToInput, OffersReplyUncheckedUpdateWithoutReplyingToInput>
  }

  export type OffersReplyUpdateManyWithWhereWithoutReplyingToInput = {
    where: OffersReplyScalarWhereInput
    data: XOR<OffersReplyUpdateManyMutationInput, OffersReplyUncheckedUpdateManyWithoutRepliesInput>
  }

  export type OffersProfileUpsertWithoutDiscussionInput = {
    update: XOR<OffersProfileUpdateWithoutDiscussionInput, OffersProfileUncheckedUpdateWithoutDiscussionInput>
    create: XOR<OffersProfileCreateWithoutDiscussionInput, OffersProfileUncheckedCreateWithoutDiscussionInput>
  }

  export type OffersProfileUpdateWithoutDiscussionInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    background?: OffersBackgroundUpdateOneWithoutProfileNestedInput
    editToken?: StringFieldUpdateOperationsInput | string
    offers?: OffersOfferUpdateManyWithoutProfileNestedInput
    users?: UserUpdateManyWithoutOffersProfileNestedInput
    analysis?: OffersAnalysisUpdateOneWithoutProfileNestedInput
  }

  export type OffersProfileUncheckedUpdateWithoutDiscussionInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    background?: OffersBackgroundUncheckedUpdateOneWithoutProfileNestedInput
    editToken?: StringFieldUpdateOperationsInput | string
    offers?: OffersOfferUncheckedUpdateManyWithoutProfileNestedInput
    users?: UserUncheckedUpdateManyWithoutOffersProfileNestedInput
    analysis?: OffersAnalysisUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type UserUpsertWithoutOffersDiscussionInput = {
    update: XOR<UserUpdateWithoutOffersDiscussionInput, UserUncheckedUpdateWithoutOffersDiscussionInput>
    create: XOR<UserCreateWithoutOffersDiscussionInput, UserUncheckedCreateWithoutOffersDiscussionInput>
  }

  export type UserUpdateWithoutOffersDiscussionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
    resumesResumes?: ResumesResumeUpdateManyWithoutUserNestedInput
    resumesStars?: ResumesStarUpdateManyWithoutUserNestedInput
    resumesComments?: ResumesCommentUpdateManyWithoutUserNestedInput
    resumesCommentVotes?: ResumesCommentVoteUpdateManyWithoutUserNestedInput
    questionsQuestions?: QuestionsQuestionUpdateManyWithoutUserNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUpdateManyWithoutUserNestedInput
    questionsQuestionVotes?: QuestionsQuestionVoteUpdateManyWithoutUserNestedInput
    questionsQuestionComments?: QuestionsQuestionCommentUpdateManyWithoutUserNestedInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUpdateManyWithoutUserNestedInput
    questionsAnswers?: QuestionsAnswerUpdateManyWithoutUserNestedInput
    questionsAnswerVotes?: QuestionsAnswerVoteUpdateManyWithoutUserNestedInput
    questionsAnswerComments?: QuestionsAnswerCommentUpdateManyWithoutUserNestedInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUpdateManyWithoutUserNestedInput
    OffersProfile?: OffersProfileUpdateManyWithoutUsersNestedInput
    questionsLists?: QuestionsListUpdateManyWithoutUserNestedInput
    OffersAdmin?: OffersAdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOffersDiscussionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
    resumesResumes?: ResumesResumeUncheckedUpdateManyWithoutUserNestedInput
    resumesStars?: ResumesStarUncheckedUpdateManyWithoutUserNestedInput
    resumesComments?: ResumesCommentUncheckedUpdateManyWithoutUserNestedInput
    resumesCommentVotes?: ResumesCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestions?: QuestionsQuestionUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionVotes?: QuestionsQuestionVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionComments?: QuestionsQuestionCommentUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswers?: QuestionsAnswerUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerVotes?: QuestionsAnswerVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerComments?: QuestionsAnswerCommentUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    OffersProfile?: OffersProfileUncheckedUpdateManyWithoutUsersNestedInput
    questionsLists?: QuestionsListUncheckedUpdateManyWithoutUserNestedInput
    OffersAdmin?: OffersAdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type OffersProfileCreateWithoutOffersInput = {
    id?: string
    profileName: string
    createdAt?: Date | string
    background?: OffersBackgroundCreateNestedOneWithoutProfileInput
    editToken: string
    discussion?: OffersReplyCreateNestedManyWithoutProfileInput
    users?: UserCreateNestedManyWithoutOffersProfileInput
    analysis?: OffersAnalysisCreateNestedOneWithoutProfileInput
  }

  export type OffersProfileUncheckedCreateWithoutOffersInput = {
    id?: string
    profileName: string
    createdAt?: Date | string
    background?: OffersBackgroundUncheckedCreateNestedOneWithoutProfileInput
    editToken: string
    discussion?: OffersReplyUncheckedCreateNestedManyWithoutProfileInput
    users?: UserUncheckedCreateNestedManyWithoutOffersProfileInput
    analysis?: OffersAnalysisUncheckedCreateNestedOneWithoutProfileInput
  }

  export type OffersProfileCreateOrConnectWithoutOffersInput = {
    where: OffersProfileWhereUniqueInput
    create: XOR<OffersProfileCreateWithoutOffersInput, OffersProfileUncheckedCreateWithoutOffersInput>
  }

  export type CompanyCreateWithoutOffersOfferInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logoUrl?: string | null
    website?: string | null
    ranking?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questionsQuestionEncounter?: QuestionsQuestionEncounterCreateNestedManyWithoutCompanyInput
    OffersExperience?: OffersExperienceCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutOffersOfferInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logoUrl?: string | null
    website?: string | null
    ranking?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questionsQuestionEncounter?: QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutCompanyInput
    OffersExperience?: OffersExperienceUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutOffersOfferInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutOffersOfferInput, CompanyUncheckedCreateWithoutOffersOfferInput>
  }

  export type CityCreateWithoutOffersOfferInput = {
    id: string
    name: string
    ranking?: number | null
    state: StateCreateNestedOneWithoutCitiesInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterCreateNestedManyWithoutCityInput
    OffersExperience?: OffersExperienceCreateNestedManyWithoutLocationInput
  }

  export type CityUncheckedCreateWithoutOffersOfferInput = {
    id: string
    name: string
    stateId: string
    ranking?: number | null
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutCityInput
    OffersExperience?: OffersExperienceUncheckedCreateNestedManyWithoutLocationInput
  }

  export type CityCreateOrConnectWithoutOffersOfferInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutOffersOfferInput, CityUncheckedCreateWithoutOffersOfferInput>
  }

  export type OffersInternCreateWithoutOffersOfferInput = {
    id?: string
    title: string
    internshipCycle: string
    startYear: number
    monthlySalary: OffersCurrencyCreateNestedOneWithoutOffersMonthlySalaryInput
  }

  export type OffersInternUncheckedCreateWithoutOffersOfferInput = {
    id?: string
    title: string
    internshipCycle: string
    startYear: number
    monthlySalaryId: string
  }

  export type OffersInternCreateOrConnectWithoutOffersOfferInput = {
    where: OffersInternWhereUniqueInput
    create: XOR<OffersInternCreateWithoutOffersOfferInput, OffersInternUncheckedCreateWithoutOffersOfferInput>
  }

  export type OffersFullTimeCreateWithoutOffersOfferInput = {
    id?: string
    title: string
    level: string
    totalCompensation: OffersCurrencyCreateNestedOneWithoutOffersTotalCompensationInput
    baseSalary?: OffersCurrencyCreateNestedOneWithoutOffersBaseSalaryInput
    bonus?: OffersCurrencyCreateNestedOneWithoutOffersBonusInput
    stocks?: OffersCurrencyCreateNestedOneWithoutOffersStocksInput
  }

  export type OffersFullTimeUncheckedCreateWithoutOffersOfferInput = {
    id?: string
    title: string
    level: string
    totalCompensationId: string
    baseSalaryId?: string | null
    bonusId?: string | null
    stocksId?: string | null
  }

  export type OffersFullTimeCreateOrConnectWithoutOffersOfferInput = {
    where: OffersFullTimeWhereUniqueInput
    create: XOR<OffersFullTimeCreateWithoutOffersOfferInput, OffersFullTimeUncheckedCreateWithoutOffersOfferInput>
  }

  export type OffersAnalysisCreateWithoutOverallHighestOfferInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: OffersProfileCreateNestedOneWithoutAnalysisInput
    overallAnalysis: OffersAnalysisUnitCreateNestedOneWithoutOffersAnalysisOverallInput
    companyAnalysis?: OffersAnalysisUnitCreateNestedManyWithoutOffersAnalysisCompanyInput
  }

  export type OffersAnalysisUncheckedCreateWithoutOverallHighestOfferInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId: string
    overallAnalysisUnitId: string
    companyAnalysis?: OffersAnalysisUnitUncheckedCreateNestedManyWithoutOffersAnalysisCompanyInput
  }

  export type OffersAnalysisCreateOrConnectWithoutOverallHighestOfferInput = {
    where: OffersAnalysisWhereUniqueInput
    create: XOR<OffersAnalysisCreateWithoutOverallHighestOfferInput, OffersAnalysisUncheckedCreateWithoutOverallHighestOfferInput>
  }

  export type OffersAnalysisUnitCreateWithoutTopSimilarOffersInput = {
    id?: string
    analysedOffer: OffersOfferCreateNestedOneWithoutOffersAnalysisUnitInput
    percentile: number
    noOfSimilarOffers: number
    offersAnalysisOverall?: OffersAnalysisCreateNestedManyWithoutOverallAnalysisInput
    offersAnalysisCompany?: OffersAnalysisCreateNestedManyWithoutCompanyAnalysisInput
  }

  export type OffersAnalysisUnitUncheckedCreateWithoutTopSimilarOffersInput = {
    id?: string
    analysedOfferId: string
    percentile: number
    noOfSimilarOffers: number
    offersAnalysisOverall?: OffersAnalysisUncheckedCreateNestedManyWithoutOverallAnalysisInput
    offersAnalysisCompany?: OffersAnalysisUncheckedCreateNestedManyWithoutCompanyAnalysisInput
  }

  export type OffersAnalysisUnitCreateOrConnectWithoutTopSimilarOffersInput = {
    where: OffersAnalysisUnitWhereUniqueInput
    create: XOR<OffersAnalysisUnitCreateWithoutTopSimilarOffersInput, OffersAnalysisUnitUncheckedCreateWithoutTopSimilarOffersInput>
  }

  export type OffersAnalysisUnitCreateWithoutAnalysedOfferInput = {
    id?: string
    percentile: number
    noOfSimilarOffers: number
    topSimilarOffers?: OffersOfferCreateNestedManyWithoutOffersAnalysisUnitInput
    offersAnalysisOverall?: OffersAnalysisCreateNestedManyWithoutOverallAnalysisInput
    offersAnalysisCompany?: OffersAnalysisCreateNestedManyWithoutCompanyAnalysisInput
  }

  export type OffersAnalysisUnitUncheckedCreateWithoutAnalysedOfferInput = {
    id?: string
    percentile: number
    noOfSimilarOffers: number
    topSimilarOffers?: OffersOfferUncheckedCreateNestedManyWithoutOffersAnalysisUnitInput
    offersAnalysisOverall?: OffersAnalysisUncheckedCreateNestedManyWithoutOverallAnalysisInput
    offersAnalysisCompany?: OffersAnalysisUncheckedCreateNestedManyWithoutCompanyAnalysisInput
  }

  export type OffersAnalysisUnitCreateOrConnectWithoutAnalysedOfferInput = {
    where: OffersAnalysisUnitWhereUniqueInput
    create: XOR<OffersAnalysisUnitCreateWithoutAnalysedOfferInput, OffersAnalysisUnitUncheckedCreateWithoutAnalysedOfferInput>
  }

  export type OffersAnalysisUnitCreateManyAnalysedOfferInputEnvelope = {
    data: Enumerable<OffersAnalysisUnitCreateManyAnalysedOfferInput>
    skipDuplicates?: boolean
  }

  export type OffersProfileUpsertWithoutOffersInput = {
    update: XOR<OffersProfileUpdateWithoutOffersInput, OffersProfileUncheckedUpdateWithoutOffersInput>
    create: XOR<OffersProfileCreateWithoutOffersInput, OffersProfileUncheckedCreateWithoutOffersInput>
  }

  export type OffersProfileUpdateWithoutOffersInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    background?: OffersBackgroundUpdateOneWithoutProfileNestedInput
    editToken?: StringFieldUpdateOperationsInput | string
    discussion?: OffersReplyUpdateManyWithoutProfileNestedInput
    users?: UserUpdateManyWithoutOffersProfileNestedInput
    analysis?: OffersAnalysisUpdateOneWithoutProfileNestedInput
  }

  export type OffersProfileUncheckedUpdateWithoutOffersInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    background?: OffersBackgroundUncheckedUpdateOneWithoutProfileNestedInput
    editToken?: StringFieldUpdateOperationsInput | string
    discussion?: OffersReplyUncheckedUpdateManyWithoutProfileNestedInput
    users?: UserUncheckedUpdateManyWithoutOffersProfileNestedInput
    analysis?: OffersAnalysisUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type CompanyUpsertWithoutOffersOfferInput = {
    update: XOR<CompanyUpdateWithoutOffersOfferInput, CompanyUncheckedUpdateWithoutOffersOfferInput>
    create: XOR<CompanyCreateWithoutOffersOfferInput, CompanyUncheckedCreateWithoutOffersOfferInput>
  }

  export type CompanyUpdateWithoutOffersOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionsQuestionEncounter?: QuestionsQuestionEncounterUpdateManyWithoutCompanyNestedInput
    OffersExperience?: OffersExperienceUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutOffersOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionsQuestionEncounter?: QuestionsQuestionEncounterUncheckedUpdateManyWithoutCompanyNestedInput
    OffersExperience?: OffersExperienceUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CityUpsertWithoutOffersOfferInput = {
    update: XOR<CityUpdateWithoutOffersOfferInput, CityUncheckedUpdateWithoutOffersOfferInput>
    create: XOR<CityCreateWithoutOffersOfferInput, CityUncheckedCreateWithoutOffersOfferInput>
  }

  export type CityUpdateWithoutOffersOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    state?: StateUpdateOneRequiredWithoutCitiesNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUpdateManyWithoutCityNestedInput
    OffersExperience?: OffersExperienceUpdateManyWithoutLocationNestedInput
  }

  export type CityUncheckedUpdateWithoutOffersOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stateId?: StringFieldUpdateOperationsInput | string
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedUpdateManyWithoutCityNestedInput
    OffersExperience?: OffersExperienceUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type OffersInternUpsertWithoutOffersOfferInput = {
    update: XOR<OffersInternUpdateWithoutOffersOfferInput, OffersInternUncheckedUpdateWithoutOffersOfferInput>
    create: XOR<OffersInternCreateWithoutOffersOfferInput, OffersInternUncheckedCreateWithoutOffersOfferInput>
  }

  export type OffersInternUpdateWithoutOffersOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    internshipCycle?: StringFieldUpdateOperationsInput | string
    startYear?: IntFieldUpdateOperationsInput | number
    monthlySalary?: OffersCurrencyUpdateOneRequiredWithoutOffersMonthlySalaryNestedInput
  }

  export type OffersInternUncheckedUpdateWithoutOffersOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    internshipCycle?: StringFieldUpdateOperationsInput | string
    startYear?: IntFieldUpdateOperationsInput | number
    monthlySalaryId?: StringFieldUpdateOperationsInput | string
  }

  export type OffersFullTimeUpsertWithoutOffersOfferInput = {
    update: XOR<OffersFullTimeUpdateWithoutOffersOfferInput, OffersFullTimeUncheckedUpdateWithoutOffersOfferInput>
    create: XOR<OffersFullTimeCreateWithoutOffersOfferInput, OffersFullTimeUncheckedCreateWithoutOffersOfferInput>
  }

  export type OffersFullTimeUpdateWithoutOffersOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    totalCompensation?: OffersCurrencyUpdateOneRequiredWithoutOffersTotalCompensationNestedInput
    baseSalary?: OffersCurrencyUpdateOneWithoutOffersBaseSalaryNestedInput
    bonus?: OffersCurrencyUpdateOneWithoutOffersBonusNestedInput
    stocks?: OffersCurrencyUpdateOneWithoutOffersStocksNestedInput
  }

  export type OffersFullTimeUncheckedUpdateWithoutOffersOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    totalCompensationId?: StringFieldUpdateOperationsInput | string
    baseSalaryId?: NullableStringFieldUpdateOperationsInput | string | null
    bonusId?: NullableStringFieldUpdateOperationsInput | string | null
    stocksId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OffersAnalysisUpsertWithoutOverallHighestOfferInput = {
    update: XOR<OffersAnalysisUpdateWithoutOverallHighestOfferInput, OffersAnalysisUncheckedUpdateWithoutOverallHighestOfferInput>
    create: XOR<OffersAnalysisCreateWithoutOverallHighestOfferInput, OffersAnalysisUncheckedCreateWithoutOverallHighestOfferInput>
  }

  export type OffersAnalysisUpdateWithoutOverallHighestOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: OffersProfileUpdateOneRequiredWithoutAnalysisNestedInput
    overallAnalysis?: OffersAnalysisUnitUpdateOneRequiredWithoutOffersAnalysisOverallNestedInput
    companyAnalysis?: OffersAnalysisUnitUpdateManyWithoutOffersAnalysisCompanyNestedInput
  }

  export type OffersAnalysisUncheckedUpdateWithoutOverallHighestOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: StringFieldUpdateOperationsInput | string
    overallAnalysisUnitId?: StringFieldUpdateOperationsInput | string
    companyAnalysis?: OffersAnalysisUnitUncheckedUpdateManyWithoutOffersAnalysisCompanyNestedInput
  }

  export type OffersAnalysisUnitUpsertWithWhereUniqueWithoutTopSimilarOffersInput = {
    where: OffersAnalysisUnitWhereUniqueInput
    update: XOR<OffersAnalysisUnitUpdateWithoutTopSimilarOffersInput, OffersAnalysisUnitUncheckedUpdateWithoutTopSimilarOffersInput>
    create: XOR<OffersAnalysisUnitCreateWithoutTopSimilarOffersInput, OffersAnalysisUnitUncheckedCreateWithoutTopSimilarOffersInput>
  }

  export type OffersAnalysisUnitUpdateWithWhereUniqueWithoutTopSimilarOffersInput = {
    where: OffersAnalysisUnitWhereUniqueInput
    data: XOR<OffersAnalysisUnitUpdateWithoutTopSimilarOffersInput, OffersAnalysisUnitUncheckedUpdateWithoutTopSimilarOffersInput>
  }

  export type OffersAnalysisUnitUpdateManyWithWhereWithoutTopSimilarOffersInput = {
    where: OffersAnalysisUnitScalarWhereInput
    data: XOR<OffersAnalysisUnitUpdateManyMutationInput, OffersAnalysisUnitUncheckedUpdateManyWithoutOffersAnalysisUnitInput>
  }

  export type OffersAnalysisUnitScalarWhereInput = {
    AND?: Enumerable<OffersAnalysisUnitScalarWhereInput>
    OR?: Enumerable<OffersAnalysisUnitScalarWhereInput>
    NOT?: Enumerable<OffersAnalysisUnitScalarWhereInput>
    id?: StringFilter | string
    analysedOfferId?: StringFilter | string
    percentile?: FloatFilter | number
    noOfSimilarOffers?: IntFilter | number
  }

  export type OffersAnalysisUnitUpsertWithWhereUniqueWithoutAnalysedOfferInput = {
    where: OffersAnalysisUnitWhereUniqueInput
    update: XOR<OffersAnalysisUnitUpdateWithoutAnalysedOfferInput, OffersAnalysisUnitUncheckedUpdateWithoutAnalysedOfferInput>
    create: XOR<OffersAnalysisUnitCreateWithoutAnalysedOfferInput, OffersAnalysisUnitUncheckedCreateWithoutAnalysedOfferInput>
  }

  export type OffersAnalysisUnitUpdateWithWhereUniqueWithoutAnalysedOfferInput = {
    where: OffersAnalysisUnitWhereUniqueInput
    data: XOR<OffersAnalysisUnitUpdateWithoutAnalysedOfferInput, OffersAnalysisUnitUncheckedUpdateWithoutAnalysedOfferInput>
  }

  export type OffersAnalysisUnitUpdateManyWithWhereWithoutAnalysedOfferInput = {
    where: OffersAnalysisUnitScalarWhereInput
    data: XOR<OffersAnalysisUnitUpdateManyMutationInput, OffersAnalysisUnitUncheckedUpdateManyWithoutOffersAnalysisUnitInput>
  }

  export type OffersCurrencyCreateWithoutOffersMonthlySalaryInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    value: number
    currency: string
    baseValue: number
    baseCurrency?: string
    OffersExperienceTotalCompensation?: OffersExperienceCreateNestedOneWithoutTotalCompensationInput
    OffersExperienceMonthlySalary?: OffersExperienceCreateNestedOneWithoutMonthlySalaryInput
    OffersTotalCompensation?: OffersFullTimeCreateNestedOneWithoutTotalCompensationInput
    OffersBaseSalary?: OffersFullTimeCreateNestedOneWithoutBaseSalaryInput
    OffersBonus?: OffersFullTimeCreateNestedOneWithoutBonusInput
    OffersStocks?: OffersFullTimeCreateNestedOneWithoutStocksInput
  }

  export type OffersCurrencyUncheckedCreateWithoutOffersMonthlySalaryInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    value: number
    currency: string
    baseValue: number
    baseCurrency?: string
    OffersExperienceTotalCompensation?: OffersExperienceUncheckedCreateNestedOneWithoutTotalCompensationInput
    OffersExperienceMonthlySalary?: OffersExperienceUncheckedCreateNestedOneWithoutMonthlySalaryInput
    OffersTotalCompensation?: OffersFullTimeUncheckedCreateNestedOneWithoutTotalCompensationInput
    OffersBaseSalary?: OffersFullTimeUncheckedCreateNestedOneWithoutBaseSalaryInput
    OffersBonus?: OffersFullTimeUncheckedCreateNestedOneWithoutBonusInput
    OffersStocks?: OffersFullTimeUncheckedCreateNestedOneWithoutStocksInput
  }

  export type OffersCurrencyCreateOrConnectWithoutOffersMonthlySalaryInput = {
    where: OffersCurrencyWhereUniqueInput
    create: XOR<OffersCurrencyCreateWithoutOffersMonthlySalaryInput, OffersCurrencyUncheckedCreateWithoutOffersMonthlySalaryInput>
  }

  export type OffersOfferCreateWithoutOffersInternInput = {
    id?: string
    profile: OffersProfileCreateNestedOneWithoutOffersInput
    company: CompanyCreateNestedOneWithoutOffersOfferInput
    location: CityCreateNestedOneWithoutOffersOfferInput
    monthYearReceived: Date | string
    negotiationStrategy: string
    comments: string
    jobType: JobType
    offersFullTime?: OffersFullTimeCreateNestedOneWithoutOffersOfferInput
    offersAnalysis?: OffersAnalysisCreateNestedOneWithoutOverallHighestOfferInput
    offersAnalysisUnit?: OffersAnalysisUnitCreateNestedManyWithoutTopSimilarOffersInput
    OffersAnalysisUnit?: OffersAnalysisUnitCreateNestedManyWithoutAnalysedOfferInput
  }

  export type OffersOfferUncheckedCreateWithoutOffersInternInput = {
    id?: string
    profileId: string
    companyId: string
    cityId: string
    monthYearReceived: Date | string
    negotiationStrategy: string
    comments: string
    jobType: JobType
    offersFullTimeId?: string | null
    offersAnalysis?: OffersAnalysisUncheckedCreateNestedOneWithoutOverallHighestOfferInput
    offersAnalysisUnit?: OffersAnalysisUnitUncheckedCreateNestedManyWithoutTopSimilarOffersInput
    OffersAnalysisUnit?: OffersAnalysisUnitUncheckedCreateNestedManyWithoutAnalysedOfferInput
  }

  export type OffersOfferCreateOrConnectWithoutOffersInternInput = {
    where: OffersOfferWhereUniqueInput
    create: XOR<OffersOfferCreateWithoutOffersInternInput, OffersOfferUncheckedCreateWithoutOffersInternInput>
  }

  export type OffersCurrencyUpsertWithoutOffersMonthlySalaryInput = {
    update: XOR<OffersCurrencyUpdateWithoutOffersMonthlySalaryInput, OffersCurrencyUncheckedUpdateWithoutOffersMonthlySalaryInput>
    create: XOR<OffersCurrencyCreateWithoutOffersMonthlySalaryInput, OffersCurrencyUncheckedCreateWithoutOffersMonthlySalaryInput>
  }

  export type OffersCurrencyUpdateWithoutOffersMonthlySalaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    baseValue?: FloatFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    OffersExperienceTotalCompensation?: OffersExperienceUpdateOneWithoutTotalCompensationNestedInput
    OffersExperienceMonthlySalary?: OffersExperienceUpdateOneWithoutMonthlySalaryNestedInput
    OffersTotalCompensation?: OffersFullTimeUpdateOneWithoutTotalCompensationNestedInput
    OffersBaseSalary?: OffersFullTimeUpdateOneWithoutBaseSalaryNestedInput
    OffersBonus?: OffersFullTimeUpdateOneWithoutBonusNestedInput
    OffersStocks?: OffersFullTimeUpdateOneWithoutStocksNestedInput
  }

  export type OffersCurrencyUncheckedUpdateWithoutOffersMonthlySalaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    baseValue?: FloatFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    OffersExperienceTotalCompensation?: OffersExperienceUncheckedUpdateOneWithoutTotalCompensationNestedInput
    OffersExperienceMonthlySalary?: OffersExperienceUncheckedUpdateOneWithoutMonthlySalaryNestedInput
    OffersTotalCompensation?: OffersFullTimeUncheckedUpdateOneWithoutTotalCompensationNestedInput
    OffersBaseSalary?: OffersFullTimeUncheckedUpdateOneWithoutBaseSalaryNestedInput
    OffersBonus?: OffersFullTimeUncheckedUpdateOneWithoutBonusNestedInput
    OffersStocks?: OffersFullTimeUncheckedUpdateOneWithoutStocksNestedInput
  }

  export type OffersOfferUpsertWithoutOffersInternInput = {
    update: XOR<OffersOfferUpdateWithoutOffersInternInput, OffersOfferUncheckedUpdateWithoutOffersInternInput>
    create: XOR<OffersOfferCreateWithoutOffersInternInput, OffersOfferUncheckedCreateWithoutOffersInternInput>
  }

  export type OffersOfferUpdateWithoutOffersInternInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile?: OffersProfileUpdateOneRequiredWithoutOffersNestedInput
    company?: CompanyUpdateOneRequiredWithoutOffersOfferNestedInput
    location?: CityUpdateOneRequiredWithoutOffersOfferNestedInput
    monthYearReceived?: DateTimeFieldUpdateOperationsInput | Date | string
    negotiationStrategy?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | JobType
    offersFullTime?: OffersFullTimeUpdateOneWithoutOffersOfferNestedInput
    offersAnalysis?: OffersAnalysisUpdateOneWithoutOverallHighestOfferNestedInput
    offersAnalysisUnit?: OffersAnalysisUnitUpdateManyWithoutTopSimilarOffersNestedInput
    OffersAnalysisUnit?: OffersAnalysisUnitUpdateManyWithoutAnalysedOfferNestedInput
  }

  export type OffersOfferUncheckedUpdateWithoutOffersInternInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    monthYearReceived?: DateTimeFieldUpdateOperationsInput | Date | string
    negotiationStrategy?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | JobType
    offersFullTimeId?: NullableStringFieldUpdateOperationsInput | string | null
    offersAnalysis?: OffersAnalysisUncheckedUpdateOneWithoutOverallHighestOfferNestedInput
    offersAnalysisUnit?: OffersAnalysisUnitUncheckedUpdateManyWithoutTopSimilarOffersNestedInput
    OffersAnalysisUnit?: OffersAnalysisUnitUncheckedUpdateManyWithoutAnalysedOfferNestedInput
  }

  export type OffersCurrencyCreateWithoutOffersTotalCompensationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    value: number
    currency: string
    baseValue: number
    baseCurrency?: string
    OffersExperienceTotalCompensation?: OffersExperienceCreateNestedOneWithoutTotalCompensationInput
    OffersExperienceMonthlySalary?: OffersExperienceCreateNestedOneWithoutMonthlySalaryInput
    OffersBaseSalary?: OffersFullTimeCreateNestedOneWithoutBaseSalaryInput
    OffersBonus?: OffersFullTimeCreateNestedOneWithoutBonusInput
    OffersStocks?: OffersFullTimeCreateNestedOneWithoutStocksInput
    OffersMonthlySalary?: OffersInternCreateNestedOneWithoutMonthlySalaryInput
  }

  export type OffersCurrencyUncheckedCreateWithoutOffersTotalCompensationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    value: number
    currency: string
    baseValue: number
    baseCurrency?: string
    OffersExperienceTotalCompensation?: OffersExperienceUncheckedCreateNestedOneWithoutTotalCompensationInput
    OffersExperienceMonthlySalary?: OffersExperienceUncheckedCreateNestedOneWithoutMonthlySalaryInput
    OffersBaseSalary?: OffersFullTimeUncheckedCreateNestedOneWithoutBaseSalaryInput
    OffersBonus?: OffersFullTimeUncheckedCreateNestedOneWithoutBonusInput
    OffersStocks?: OffersFullTimeUncheckedCreateNestedOneWithoutStocksInput
    OffersMonthlySalary?: OffersInternUncheckedCreateNestedOneWithoutMonthlySalaryInput
  }

  export type OffersCurrencyCreateOrConnectWithoutOffersTotalCompensationInput = {
    where: OffersCurrencyWhereUniqueInput
    create: XOR<OffersCurrencyCreateWithoutOffersTotalCompensationInput, OffersCurrencyUncheckedCreateWithoutOffersTotalCompensationInput>
  }

  export type OffersCurrencyCreateWithoutOffersBaseSalaryInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    value: number
    currency: string
    baseValue: number
    baseCurrency?: string
    OffersExperienceTotalCompensation?: OffersExperienceCreateNestedOneWithoutTotalCompensationInput
    OffersExperienceMonthlySalary?: OffersExperienceCreateNestedOneWithoutMonthlySalaryInput
    OffersTotalCompensation?: OffersFullTimeCreateNestedOneWithoutTotalCompensationInput
    OffersBonus?: OffersFullTimeCreateNestedOneWithoutBonusInput
    OffersStocks?: OffersFullTimeCreateNestedOneWithoutStocksInput
    OffersMonthlySalary?: OffersInternCreateNestedOneWithoutMonthlySalaryInput
  }

  export type OffersCurrencyUncheckedCreateWithoutOffersBaseSalaryInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    value: number
    currency: string
    baseValue: number
    baseCurrency?: string
    OffersExperienceTotalCompensation?: OffersExperienceUncheckedCreateNestedOneWithoutTotalCompensationInput
    OffersExperienceMonthlySalary?: OffersExperienceUncheckedCreateNestedOneWithoutMonthlySalaryInput
    OffersTotalCompensation?: OffersFullTimeUncheckedCreateNestedOneWithoutTotalCompensationInput
    OffersBonus?: OffersFullTimeUncheckedCreateNestedOneWithoutBonusInput
    OffersStocks?: OffersFullTimeUncheckedCreateNestedOneWithoutStocksInput
    OffersMonthlySalary?: OffersInternUncheckedCreateNestedOneWithoutMonthlySalaryInput
  }

  export type OffersCurrencyCreateOrConnectWithoutOffersBaseSalaryInput = {
    where: OffersCurrencyWhereUniqueInput
    create: XOR<OffersCurrencyCreateWithoutOffersBaseSalaryInput, OffersCurrencyUncheckedCreateWithoutOffersBaseSalaryInput>
  }

  export type OffersCurrencyCreateWithoutOffersBonusInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    value: number
    currency: string
    baseValue: number
    baseCurrency?: string
    OffersExperienceTotalCompensation?: OffersExperienceCreateNestedOneWithoutTotalCompensationInput
    OffersExperienceMonthlySalary?: OffersExperienceCreateNestedOneWithoutMonthlySalaryInput
    OffersTotalCompensation?: OffersFullTimeCreateNestedOneWithoutTotalCompensationInput
    OffersBaseSalary?: OffersFullTimeCreateNestedOneWithoutBaseSalaryInput
    OffersStocks?: OffersFullTimeCreateNestedOneWithoutStocksInput
    OffersMonthlySalary?: OffersInternCreateNestedOneWithoutMonthlySalaryInput
  }

  export type OffersCurrencyUncheckedCreateWithoutOffersBonusInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    value: number
    currency: string
    baseValue: number
    baseCurrency?: string
    OffersExperienceTotalCompensation?: OffersExperienceUncheckedCreateNestedOneWithoutTotalCompensationInput
    OffersExperienceMonthlySalary?: OffersExperienceUncheckedCreateNestedOneWithoutMonthlySalaryInput
    OffersTotalCompensation?: OffersFullTimeUncheckedCreateNestedOneWithoutTotalCompensationInput
    OffersBaseSalary?: OffersFullTimeUncheckedCreateNestedOneWithoutBaseSalaryInput
    OffersStocks?: OffersFullTimeUncheckedCreateNestedOneWithoutStocksInput
    OffersMonthlySalary?: OffersInternUncheckedCreateNestedOneWithoutMonthlySalaryInput
  }

  export type OffersCurrencyCreateOrConnectWithoutOffersBonusInput = {
    where: OffersCurrencyWhereUniqueInput
    create: XOR<OffersCurrencyCreateWithoutOffersBonusInput, OffersCurrencyUncheckedCreateWithoutOffersBonusInput>
  }

  export type OffersCurrencyCreateWithoutOffersStocksInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    value: number
    currency: string
    baseValue: number
    baseCurrency?: string
    OffersExperienceTotalCompensation?: OffersExperienceCreateNestedOneWithoutTotalCompensationInput
    OffersExperienceMonthlySalary?: OffersExperienceCreateNestedOneWithoutMonthlySalaryInput
    OffersTotalCompensation?: OffersFullTimeCreateNestedOneWithoutTotalCompensationInput
    OffersBaseSalary?: OffersFullTimeCreateNestedOneWithoutBaseSalaryInput
    OffersBonus?: OffersFullTimeCreateNestedOneWithoutBonusInput
    OffersMonthlySalary?: OffersInternCreateNestedOneWithoutMonthlySalaryInput
  }

  export type OffersCurrencyUncheckedCreateWithoutOffersStocksInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    value: number
    currency: string
    baseValue: number
    baseCurrency?: string
    OffersExperienceTotalCompensation?: OffersExperienceUncheckedCreateNestedOneWithoutTotalCompensationInput
    OffersExperienceMonthlySalary?: OffersExperienceUncheckedCreateNestedOneWithoutMonthlySalaryInput
    OffersTotalCompensation?: OffersFullTimeUncheckedCreateNestedOneWithoutTotalCompensationInput
    OffersBaseSalary?: OffersFullTimeUncheckedCreateNestedOneWithoutBaseSalaryInput
    OffersBonus?: OffersFullTimeUncheckedCreateNestedOneWithoutBonusInput
    OffersMonthlySalary?: OffersInternUncheckedCreateNestedOneWithoutMonthlySalaryInput
  }

  export type OffersCurrencyCreateOrConnectWithoutOffersStocksInput = {
    where: OffersCurrencyWhereUniqueInput
    create: XOR<OffersCurrencyCreateWithoutOffersStocksInput, OffersCurrencyUncheckedCreateWithoutOffersStocksInput>
  }

  export type OffersOfferCreateWithoutOffersFullTimeInput = {
    id?: string
    profile: OffersProfileCreateNestedOneWithoutOffersInput
    company: CompanyCreateNestedOneWithoutOffersOfferInput
    location: CityCreateNestedOneWithoutOffersOfferInput
    monthYearReceived: Date | string
    negotiationStrategy: string
    comments: string
    jobType: JobType
    offersIntern?: OffersInternCreateNestedOneWithoutOffersOfferInput
    offersAnalysis?: OffersAnalysisCreateNestedOneWithoutOverallHighestOfferInput
    offersAnalysisUnit?: OffersAnalysisUnitCreateNestedManyWithoutTopSimilarOffersInput
    OffersAnalysisUnit?: OffersAnalysisUnitCreateNestedManyWithoutAnalysedOfferInput
  }

  export type OffersOfferUncheckedCreateWithoutOffersFullTimeInput = {
    id?: string
    profileId: string
    companyId: string
    cityId: string
    monthYearReceived: Date | string
    negotiationStrategy: string
    comments: string
    jobType: JobType
    offersInternId?: string | null
    offersAnalysis?: OffersAnalysisUncheckedCreateNestedOneWithoutOverallHighestOfferInput
    offersAnalysisUnit?: OffersAnalysisUnitUncheckedCreateNestedManyWithoutTopSimilarOffersInput
    OffersAnalysisUnit?: OffersAnalysisUnitUncheckedCreateNestedManyWithoutAnalysedOfferInput
  }

  export type OffersOfferCreateOrConnectWithoutOffersFullTimeInput = {
    where: OffersOfferWhereUniqueInput
    create: XOR<OffersOfferCreateWithoutOffersFullTimeInput, OffersOfferUncheckedCreateWithoutOffersFullTimeInput>
  }

  export type OffersCurrencyUpsertWithoutOffersTotalCompensationInput = {
    update: XOR<OffersCurrencyUpdateWithoutOffersTotalCompensationInput, OffersCurrencyUncheckedUpdateWithoutOffersTotalCompensationInput>
    create: XOR<OffersCurrencyCreateWithoutOffersTotalCompensationInput, OffersCurrencyUncheckedCreateWithoutOffersTotalCompensationInput>
  }

  export type OffersCurrencyUpdateWithoutOffersTotalCompensationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    baseValue?: FloatFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    OffersExperienceTotalCompensation?: OffersExperienceUpdateOneWithoutTotalCompensationNestedInput
    OffersExperienceMonthlySalary?: OffersExperienceUpdateOneWithoutMonthlySalaryNestedInput
    OffersBaseSalary?: OffersFullTimeUpdateOneWithoutBaseSalaryNestedInput
    OffersBonus?: OffersFullTimeUpdateOneWithoutBonusNestedInput
    OffersStocks?: OffersFullTimeUpdateOneWithoutStocksNestedInput
    OffersMonthlySalary?: OffersInternUpdateOneWithoutMonthlySalaryNestedInput
  }

  export type OffersCurrencyUncheckedUpdateWithoutOffersTotalCompensationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    baseValue?: FloatFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    OffersExperienceTotalCompensation?: OffersExperienceUncheckedUpdateOneWithoutTotalCompensationNestedInput
    OffersExperienceMonthlySalary?: OffersExperienceUncheckedUpdateOneWithoutMonthlySalaryNestedInput
    OffersBaseSalary?: OffersFullTimeUncheckedUpdateOneWithoutBaseSalaryNestedInput
    OffersBonus?: OffersFullTimeUncheckedUpdateOneWithoutBonusNestedInput
    OffersStocks?: OffersFullTimeUncheckedUpdateOneWithoutStocksNestedInput
    OffersMonthlySalary?: OffersInternUncheckedUpdateOneWithoutMonthlySalaryNestedInput
  }

  export type OffersCurrencyUpsertWithoutOffersBaseSalaryInput = {
    update: XOR<OffersCurrencyUpdateWithoutOffersBaseSalaryInput, OffersCurrencyUncheckedUpdateWithoutOffersBaseSalaryInput>
    create: XOR<OffersCurrencyCreateWithoutOffersBaseSalaryInput, OffersCurrencyUncheckedCreateWithoutOffersBaseSalaryInput>
  }

  export type OffersCurrencyUpdateWithoutOffersBaseSalaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    baseValue?: FloatFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    OffersExperienceTotalCompensation?: OffersExperienceUpdateOneWithoutTotalCompensationNestedInput
    OffersExperienceMonthlySalary?: OffersExperienceUpdateOneWithoutMonthlySalaryNestedInput
    OffersTotalCompensation?: OffersFullTimeUpdateOneWithoutTotalCompensationNestedInput
    OffersBonus?: OffersFullTimeUpdateOneWithoutBonusNestedInput
    OffersStocks?: OffersFullTimeUpdateOneWithoutStocksNestedInput
    OffersMonthlySalary?: OffersInternUpdateOneWithoutMonthlySalaryNestedInput
  }

  export type OffersCurrencyUncheckedUpdateWithoutOffersBaseSalaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    baseValue?: FloatFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    OffersExperienceTotalCompensation?: OffersExperienceUncheckedUpdateOneWithoutTotalCompensationNestedInput
    OffersExperienceMonthlySalary?: OffersExperienceUncheckedUpdateOneWithoutMonthlySalaryNestedInput
    OffersTotalCompensation?: OffersFullTimeUncheckedUpdateOneWithoutTotalCompensationNestedInput
    OffersBonus?: OffersFullTimeUncheckedUpdateOneWithoutBonusNestedInput
    OffersStocks?: OffersFullTimeUncheckedUpdateOneWithoutStocksNestedInput
    OffersMonthlySalary?: OffersInternUncheckedUpdateOneWithoutMonthlySalaryNestedInput
  }

  export type OffersCurrencyUpsertWithoutOffersBonusInput = {
    update: XOR<OffersCurrencyUpdateWithoutOffersBonusInput, OffersCurrencyUncheckedUpdateWithoutOffersBonusInput>
    create: XOR<OffersCurrencyCreateWithoutOffersBonusInput, OffersCurrencyUncheckedCreateWithoutOffersBonusInput>
  }

  export type OffersCurrencyUpdateWithoutOffersBonusInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    baseValue?: FloatFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    OffersExperienceTotalCompensation?: OffersExperienceUpdateOneWithoutTotalCompensationNestedInput
    OffersExperienceMonthlySalary?: OffersExperienceUpdateOneWithoutMonthlySalaryNestedInput
    OffersTotalCompensation?: OffersFullTimeUpdateOneWithoutTotalCompensationNestedInput
    OffersBaseSalary?: OffersFullTimeUpdateOneWithoutBaseSalaryNestedInput
    OffersStocks?: OffersFullTimeUpdateOneWithoutStocksNestedInput
    OffersMonthlySalary?: OffersInternUpdateOneWithoutMonthlySalaryNestedInput
  }

  export type OffersCurrencyUncheckedUpdateWithoutOffersBonusInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    baseValue?: FloatFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    OffersExperienceTotalCompensation?: OffersExperienceUncheckedUpdateOneWithoutTotalCompensationNestedInput
    OffersExperienceMonthlySalary?: OffersExperienceUncheckedUpdateOneWithoutMonthlySalaryNestedInput
    OffersTotalCompensation?: OffersFullTimeUncheckedUpdateOneWithoutTotalCompensationNestedInput
    OffersBaseSalary?: OffersFullTimeUncheckedUpdateOneWithoutBaseSalaryNestedInput
    OffersStocks?: OffersFullTimeUncheckedUpdateOneWithoutStocksNestedInput
    OffersMonthlySalary?: OffersInternUncheckedUpdateOneWithoutMonthlySalaryNestedInput
  }

  export type OffersCurrencyUpsertWithoutOffersStocksInput = {
    update: XOR<OffersCurrencyUpdateWithoutOffersStocksInput, OffersCurrencyUncheckedUpdateWithoutOffersStocksInput>
    create: XOR<OffersCurrencyCreateWithoutOffersStocksInput, OffersCurrencyUncheckedCreateWithoutOffersStocksInput>
  }

  export type OffersCurrencyUpdateWithoutOffersStocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    baseValue?: FloatFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    OffersExperienceTotalCompensation?: OffersExperienceUpdateOneWithoutTotalCompensationNestedInput
    OffersExperienceMonthlySalary?: OffersExperienceUpdateOneWithoutMonthlySalaryNestedInput
    OffersTotalCompensation?: OffersFullTimeUpdateOneWithoutTotalCompensationNestedInput
    OffersBaseSalary?: OffersFullTimeUpdateOneWithoutBaseSalaryNestedInput
    OffersBonus?: OffersFullTimeUpdateOneWithoutBonusNestedInput
    OffersMonthlySalary?: OffersInternUpdateOneWithoutMonthlySalaryNestedInput
  }

  export type OffersCurrencyUncheckedUpdateWithoutOffersStocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    baseValue?: FloatFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    OffersExperienceTotalCompensation?: OffersExperienceUncheckedUpdateOneWithoutTotalCompensationNestedInput
    OffersExperienceMonthlySalary?: OffersExperienceUncheckedUpdateOneWithoutMonthlySalaryNestedInput
    OffersTotalCompensation?: OffersFullTimeUncheckedUpdateOneWithoutTotalCompensationNestedInput
    OffersBaseSalary?: OffersFullTimeUncheckedUpdateOneWithoutBaseSalaryNestedInput
    OffersBonus?: OffersFullTimeUncheckedUpdateOneWithoutBonusNestedInput
    OffersMonthlySalary?: OffersInternUncheckedUpdateOneWithoutMonthlySalaryNestedInput
  }

  export type OffersOfferUpsertWithoutOffersFullTimeInput = {
    update: XOR<OffersOfferUpdateWithoutOffersFullTimeInput, OffersOfferUncheckedUpdateWithoutOffersFullTimeInput>
    create: XOR<OffersOfferCreateWithoutOffersFullTimeInput, OffersOfferUncheckedCreateWithoutOffersFullTimeInput>
  }

  export type OffersOfferUpdateWithoutOffersFullTimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile?: OffersProfileUpdateOneRequiredWithoutOffersNestedInput
    company?: CompanyUpdateOneRequiredWithoutOffersOfferNestedInput
    location?: CityUpdateOneRequiredWithoutOffersOfferNestedInput
    monthYearReceived?: DateTimeFieldUpdateOperationsInput | Date | string
    negotiationStrategy?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | JobType
    offersIntern?: OffersInternUpdateOneWithoutOffersOfferNestedInput
    offersAnalysis?: OffersAnalysisUpdateOneWithoutOverallHighestOfferNestedInput
    offersAnalysisUnit?: OffersAnalysisUnitUpdateManyWithoutTopSimilarOffersNestedInput
    OffersAnalysisUnit?: OffersAnalysisUnitUpdateManyWithoutAnalysedOfferNestedInput
  }

  export type OffersOfferUncheckedUpdateWithoutOffersFullTimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    monthYearReceived?: DateTimeFieldUpdateOperationsInput | Date | string
    negotiationStrategy?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | JobType
    offersInternId?: NullableStringFieldUpdateOperationsInput | string | null
    offersAnalysis?: OffersAnalysisUncheckedUpdateOneWithoutOverallHighestOfferNestedInput
    offersAnalysisUnit?: OffersAnalysisUnitUncheckedUpdateManyWithoutTopSimilarOffersNestedInput
    OffersAnalysisUnit?: OffersAnalysisUnitUncheckedUpdateManyWithoutAnalysedOfferNestedInput
  }

  export type OffersProfileCreateWithoutAnalysisInput = {
    id?: string
    profileName: string
    createdAt?: Date | string
    background?: OffersBackgroundCreateNestedOneWithoutProfileInput
    editToken: string
    discussion?: OffersReplyCreateNestedManyWithoutProfileInput
    offers?: OffersOfferCreateNestedManyWithoutProfileInput
    users?: UserCreateNestedManyWithoutOffersProfileInput
  }

  export type OffersProfileUncheckedCreateWithoutAnalysisInput = {
    id?: string
    profileName: string
    createdAt?: Date | string
    background?: OffersBackgroundUncheckedCreateNestedOneWithoutProfileInput
    editToken: string
    discussion?: OffersReplyUncheckedCreateNestedManyWithoutProfileInput
    offers?: OffersOfferUncheckedCreateNestedManyWithoutProfileInput
    users?: UserUncheckedCreateNestedManyWithoutOffersProfileInput
  }

  export type OffersProfileCreateOrConnectWithoutAnalysisInput = {
    where: OffersProfileWhereUniqueInput
    create: XOR<OffersProfileCreateWithoutAnalysisInput, OffersProfileUncheckedCreateWithoutAnalysisInput>
  }

  export type OffersOfferCreateWithoutOffersAnalysisInput = {
    id?: string
    profile: OffersProfileCreateNestedOneWithoutOffersInput
    company: CompanyCreateNestedOneWithoutOffersOfferInput
    location: CityCreateNestedOneWithoutOffersOfferInput
    monthYearReceived: Date | string
    negotiationStrategy: string
    comments: string
    jobType: JobType
    offersIntern?: OffersInternCreateNestedOneWithoutOffersOfferInput
    offersFullTime?: OffersFullTimeCreateNestedOneWithoutOffersOfferInput
    offersAnalysisUnit?: OffersAnalysisUnitCreateNestedManyWithoutTopSimilarOffersInput
    OffersAnalysisUnit?: OffersAnalysisUnitCreateNestedManyWithoutAnalysedOfferInput
  }

  export type OffersOfferUncheckedCreateWithoutOffersAnalysisInput = {
    id?: string
    profileId: string
    companyId: string
    cityId: string
    monthYearReceived: Date | string
    negotiationStrategy: string
    comments: string
    jobType: JobType
    offersInternId?: string | null
    offersFullTimeId?: string | null
    offersAnalysisUnit?: OffersAnalysisUnitUncheckedCreateNestedManyWithoutTopSimilarOffersInput
    OffersAnalysisUnit?: OffersAnalysisUnitUncheckedCreateNestedManyWithoutAnalysedOfferInput
  }

  export type OffersOfferCreateOrConnectWithoutOffersAnalysisInput = {
    where: OffersOfferWhereUniqueInput
    create: XOR<OffersOfferCreateWithoutOffersAnalysisInput, OffersOfferUncheckedCreateWithoutOffersAnalysisInput>
  }

  export type OffersAnalysisUnitCreateWithoutOffersAnalysisOverallInput = {
    id?: string
    analysedOffer: OffersOfferCreateNestedOneWithoutOffersAnalysisUnitInput
    percentile: number
    noOfSimilarOffers: number
    topSimilarOffers?: OffersOfferCreateNestedManyWithoutOffersAnalysisUnitInput
    offersAnalysisCompany?: OffersAnalysisCreateNestedManyWithoutCompanyAnalysisInput
  }

  export type OffersAnalysisUnitUncheckedCreateWithoutOffersAnalysisOverallInput = {
    id?: string
    analysedOfferId: string
    percentile: number
    noOfSimilarOffers: number
    topSimilarOffers?: OffersOfferUncheckedCreateNestedManyWithoutOffersAnalysisUnitInput
    offersAnalysisCompany?: OffersAnalysisUncheckedCreateNestedManyWithoutCompanyAnalysisInput
  }

  export type OffersAnalysisUnitCreateOrConnectWithoutOffersAnalysisOverallInput = {
    where: OffersAnalysisUnitWhereUniqueInput
    create: XOR<OffersAnalysisUnitCreateWithoutOffersAnalysisOverallInput, OffersAnalysisUnitUncheckedCreateWithoutOffersAnalysisOverallInput>
  }

  export type OffersAnalysisUnitCreateWithoutOffersAnalysisCompanyInput = {
    id?: string
    analysedOffer: OffersOfferCreateNestedOneWithoutOffersAnalysisUnitInput
    percentile: number
    noOfSimilarOffers: number
    topSimilarOffers?: OffersOfferCreateNestedManyWithoutOffersAnalysisUnitInput
    offersAnalysisOverall?: OffersAnalysisCreateNestedManyWithoutOverallAnalysisInput
  }

  export type OffersAnalysisUnitUncheckedCreateWithoutOffersAnalysisCompanyInput = {
    id?: string
    analysedOfferId: string
    percentile: number
    noOfSimilarOffers: number
    topSimilarOffers?: OffersOfferUncheckedCreateNestedManyWithoutOffersAnalysisUnitInput
    offersAnalysisOverall?: OffersAnalysisUncheckedCreateNestedManyWithoutOverallAnalysisInput
  }

  export type OffersAnalysisUnitCreateOrConnectWithoutOffersAnalysisCompanyInput = {
    where: OffersAnalysisUnitWhereUniqueInput
    create: XOR<OffersAnalysisUnitCreateWithoutOffersAnalysisCompanyInput, OffersAnalysisUnitUncheckedCreateWithoutOffersAnalysisCompanyInput>
  }

  export type OffersProfileUpsertWithoutAnalysisInput = {
    update: XOR<OffersProfileUpdateWithoutAnalysisInput, OffersProfileUncheckedUpdateWithoutAnalysisInput>
    create: XOR<OffersProfileCreateWithoutAnalysisInput, OffersProfileUncheckedCreateWithoutAnalysisInput>
  }

  export type OffersProfileUpdateWithoutAnalysisInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    background?: OffersBackgroundUpdateOneWithoutProfileNestedInput
    editToken?: StringFieldUpdateOperationsInput | string
    discussion?: OffersReplyUpdateManyWithoutProfileNestedInput
    offers?: OffersOfferUpdateManyWithoutProfileNestedInput
    users?: UserUpdateManyWithoutOffersProfileNestedInput
  }

  export type OffersProfileUncheckedUpdateWithoutAnalysisInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    background?: OffersBackgroundUncheckedUpdateOneWithoutProfileNestedInput
    editToken?: StringFieldUpdateOperationsInput | string
    discussion?: OffersReplyUncheckedUpdateManyWithoutProfileNestedInput
    offers?: OffersOfferUncheckedUpdateManyWithoutProfileNestedInput
    users?: UserUncheckedUpdateManyWithoutOffersProfileNestedInput
  }

  export type OffersOfferUpsertWithoutOffersAnalysisInput = {
    update: XOR<OffersOfferUpdateWithoutOffersAnalysisInput, OffersOfferUncheckedUpdateWithoutOffersAnalysisInput>
    create: XOR<OffersOfferCreateWithoutOffersAnalysisInput, OffersOfferUncheckedCreateWithoutOffersAnalysisInput>
  }

  export type OffersOfferUpdateWithoutOffersAnalysisInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile?: OffersProfileUpdateOneRequiredWithoutOffersNestedInput
    company?: CompanyUpdateOneRequiredWithoutOffersOfferNestedInput
    location?: CityUpdateOneRequiredWithoutOffersOfferNestedInput
    monthYearReceived?: DateTimeFieldUpdateOperationsInput | Date | string
    negotiationStrategy?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | JobType
    offersIntern?: OffersInternUpdateOneWithoutOffersOfferNestedInput
    offersFullTime?: OffersFullTimeUpdateOneWithoutOffersOfferNestedInput
    offersAnalysisUnit?: OffersAnalysisUnitUpdateManyWithoutTopSimilarOffersNestedInput
    OffersAnalysisUnit?: OffersAnalysisUnitUpdateManyWithoutAnalysedOfferNestedInput
  }

  export type OffersOfferUncheckedUpdateWithoutOffersAnalysisInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    monthYearReceived?: DateTimeFieldUpdateOperationsInput | Date | string
    negotiationStrategy?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | JobType
    offersInternId?: NullableStringFieldUpdateOperationsInput | string | null
    offersFullTimeId?: NullableStringFieldUpdateOperationsInput | string | null
    offersAnalysisUnit?: OffersAnalysisUnitUncheckedUpdateManyWithoutTopSimilarOffersNestedInput
    OffersAnalysisUnit?: OffersAnalysisUnitUncheckedUpdateManyWithoutAnalysedOfferNestedInput
  }

  export type OffersAnalysisUnitUpsertWithoutOffersAnalysisOverallInput = {
    update: XOR<OffersAnalysisUnitUpdateWithoutOffersAnalysisOverallInput, OffersAnalysisUnitUncheckedUpdateWithoutOffersAnalysisOverallInput>
    create: XOR<OffersAnalysisUnitCreateWithoutOffersAnalysisOverallInput, OffersAnalysisUnitUncheckedCreateWithoutOffersAnalysisOverallInput>
  }

  export type OffersAnalysisUnitUpdateWithoutOffersAnalysisOverallInput = {
    id?: StringFieldUpdateOperationsInput | string
    analysedOffer?: OffersOfferUpdateOneRequiredWithoutOffersAnalysisUnitNestedInput
    percentile?: FloatFieldUpdateOperationsInput | number
    noOfSimilarOffers?: IntFieldUpdateOperationsInput | number
    topSimilarOffers?: OffersOfferUpdateManyWithoutOffersAnalysisUnitNestedInput
    offersAnalysisCompany?: OffersAnalysisUpdateManyWithoutCompanyAnalysisNestedInput
  }

  export type OffersAnalysisUnitUncheckedUpdateWithoutOffersAnalysisOverallInput = {
    id?: StringFieldUpdateOperationsInput | string
    analysedOfferId?: StringFieldUpdateOperationsInput | string
    percentile?: FloatFieldUpdateOperationsInput | number
    noOfSimilarOffers?: IntFieldUpdateOperationsInput | number
    topSimilarOffers?: OffersOfferUncheckedUpdateManyWithoutOffersAnalysisUnitNestedInput
    offersAnalysisCompany?: OffersAnalysisUncheckedUpdateManyWithoutCompanyAnalysisNestedInput
  }

  export type OffersAnalysisUnitUpsertWithWhereUniqueWithoutOffersAnalysisCompanyInput = {
    where: OffersAnalysisUnitWhereUniqueInput
    update: XOR<OffersAnalysisUnitUpdateWithoutOffersAnalysisCompanyInput, OffersAnalysisUnitUncheckedUpdateWithoutOffersAnalysisCompanyInput>
    create: XOR<OffersAnalysisUnitCreateWithoutOffersAnalysisCompanyInput, OffersAnalysisUnitUncheckedCreateWithoutOffersAnalysisCompanyInput>
  }

  export type OffersAnalysisUnitUpdateWithWhereUniqueWithoutOffersAnalysisCompanyInput = {
    where: OffersAnalysisUnitWhereUniqueInput
    data: XOR<OffersAnalysisUnitUpdateWithoutOffersAnalysisCompanyInput, OffersAnalysisUnitUncheckedUpdateWithoutOffersAnalysisCompanyInput>
  }

  export type OffersAnalysisUnitUpdateManyWithWhereWithoutOffersAnalysisCompanyInput = {
    where: OffersAnalysisUnitScalarWhereInput
    data: XOR<OffersAnalysisUnitUpdateManyMutationInput, OffersAnalysisUnitUncheckedUpdateManyWithoutCompanyAnalysisInput>
  }

  export type OffersOfferCreateWithoutOffersAnalysisUnitInput = {
    id?: string
    profile: OffersProfileCreateNestedOneWithoutOffersInput
    company: CompanyCreateNestedOneWithoutOffersOfferInput
    location: CityCreateNestedOneWithoutOffersOfferInput
    monthYearReceived: Date | string
    negotiationStrategy: string
    comments: string
    jobType: JobType
    offersIntern?: OffersInternCreateNestedOneWithoutOffersOfferInput
    offersFullTime?: OffersFullTimeCreateNestedOneWithoutOffersOfferInput
    offersAnalysis?: OffersAnalysisCreateNestedOneWithoutOverallHighestOfferInput
    offersAnalysisUnit?: OffersAnalysisUnitCreateNestedManyWithoutTopSimilarOffersInput
  }

  export type OffersOfferUncheckedCreateWithoutOffersAnalysisUnitInput = {
    id?: string
    profileId: string
    companyId: string
    cityId: string
    monthYearReceived: Date | string
    negotiationStrategy: string
    comments: string
    jobType: JobType
    offersInternId?: string | null
    offersFullTimeId?: string | null
    offersAnalysis?: OffersAnalysisUncheckedCreateNestedOneWithoutOverallHighestOfferInput
    offersAnalysisUnit?: OffersAnalysisUnitUncheckedCreateNestedManyWithoutTopSimilarOffersInput
  }

  export type OffersOfferCreateOrConnectWithoutOffersAnalysisUnitInput = {
    where: OffersOfferWhereUniqueInput
    create: XOR<OffersOfferCreateWithoutOffersAnalysisUnitInput, OffersOfferUncheckedCreateWithoutOffersAnalysisUnitInput>
  }

  export type OffersAnalysisCreateWithoutOverallAnalysisInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: OffersProfileCreateNestedOneWithoutAnalysisInput
    overallHighestOffer: OffersOfferCreateNestedOneWithoutOffersAnalysisInput
    companyAnalysis?: OffersAnalysisUnitCreateNestedManyWithoutOffersAnalysisCompanyInput
  }

  export type OffersAnalysisUncheckedCreateWithoutOverallAnalysisInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId: string
    offerId: string
    companyAnalysis?: OffersAnalysisUnitUncheckedCreateNestedManyWithoutOffersAnalysisCompanyInput
  }

  export type OffersAnalysisCreateOrConnectWithoutOverallAnalysisInput = {
    where: OffersAnalysisWhereUniqueInput
    create: XOR<OffersAnalysisCreateWithoutOverallAnalysisInput, OffersAnalysisUncheckedCreateWithoutOverallAnalysisInput>
  }

  export type OffersAnalysisCreateManyOverallAnalysisInputEnvelope = {
    data: Enumerable<OffersAnalysisCreateManyOverallAnalysisInput>
    skipDuplicates?: boolean
  }

  export type OffersAnalysisCreateWithoutCompanyAnalysisInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: OffersProfileCreateNestedOneWithoutAnalysisInput
    overallHighestOffer: OffersOfferCreateNestedOneWithoutOffersAnalysisInput
    overallAnalysis: OffersAnalysisUnitCreateNestedOneWithoutOffersAnalysisOverallInput
  }

  export type OffersAnalysisUncheckedCreateWithoutCompanyAnalysisInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId: string
    offerId: string
    overallAnalysisUnitId: string
  }

  export type OffersAnalysisCreateOrConnectWithoutCompanyAnalysisInput = {
    where: OffersAnalysisWhereUniqueInput
    create: XOR<OffersAnalysisCreateWithoutCompanyAnalysisInput, OffersAnalysisUncheckedCreateWithoutCompanyAnalysisInput>
  }

  export type OffersOfferUpsertWithoutOffersAnalysisUnitInput = {
    update: XOR<OffersOfferUpdateWithoutOffersAnalysisUnitInput, OffersOfferUncheckedUpdateWithoutOffersAnalysisUnitInput>
    create: XOR<OffersOfferCreateWithoutOffersAnalysisUnitInput, OffersOfferUncheckedCreateWithoutOffersAnalysisUnitInput>
  }

  export type OffersOfferUpdateWithoutOffersAnalysisUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile?: OffersProfileUpdateOneRequiredWithoutOffersNestedInput
    company?: CompanyUpdateOneRequiredWithoutOffersOfferNestedInput
    location?: CityUpdateOneRequiredWithoutOffersOfferNestedInput
    monthYearReceived?: DateTimeFieldUpdateOperationsInput | Date | string
    negotiationStrategy?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | JobType
    offersIntern?: OffersInternUpdateOneWithoutOffersOfferNestedInput
    offersFullTime?: OffersFullTimeUpdateOneWithoutOffersOfferNestedInput
    offersAnalysis?: OffersAnalysisUpdateOneWithoutOverallHighestOfferNestedInput
    offersAnalysisUnit?: OffersAnalysisUnitUpdateManyWithoutTopSimilarOffersNestedInput
  }

  export type OffersOfferUncheckedUpdateWithoutOffersAnalysisUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    monthYearReceived?: DateTimeFieldUpdateOperationsInput | Date | string
    negotiationStrategy?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | JobType
    offersInternId?: NullableStringFieldUpdateOperationsInput | string | null
    offersFullTimeId?: NullableStringFieldUpdateOperationsInput | string | null
    offersAnalysis?: OffersAnalysisUncheckedUpdateOneWithoutOverallHighestOfferNestedInput
    offersAnalysisUnit?: OffersAnalysisUnitUncheckedUpdateManyWithoutTopSimilarOffersNestedInput
  }

  export type OffersOfferUpsertWithWhereUniqueWithoutOffersAnalysisUnitInput = {
    where: OffersOfferWhereUniqueInput
    update: XOR<OffersOfferUpdateWithoutOffersAnalysisUnitInput, OffersOfferUncheckedUpdateWithoutOffersAnalysisUnitInput>
    create: XOR<OffersOfferCreateWithoutOffersAnalysisUnitInput, OffersOfferUncheckedCreateWithoutOffersAnalysisUnitInput>
  }

  export type OffersOfferUpdateWithWhereUniqueWithoutOffersAnalysisUnitInput = {
    where: OffersOfferWhereUniqueInput
    data: XOR<OffersOfferUpdateWithoutOffersAnalysisUnitInput, OffersOfferUncheckedUpdateWithoutOffersAnalysisUnitInput>
  }

  export type OffersOfferUpdateManyWithWhereWithoutOffersAnalysisUnitInput = {
    where: OffersOfferScalarWhereInput
    data: XOR<OffersOfferUpdateManyMutationInput, OffersOfferUncheckedUpdateManyWithoutTopSimilarOffersInput>
  }

  export type OffersAnalysisUpsertWithWhereUniqueWithoutOverallAnalysisInput = {
    where: OffersAnalysisWhereUniqueInput
    update: XOR<OffersAnalysisUpdateWithoutOverallAnalysisInput, OffersAnalysisUncheckedUpdateWithoutOverallAnalysisInput>
    create: XOR<OffersAnalysisCreateWithoutOverallAnalysisInput, OffersAnalysisUncheckedCreateWithoutOverallAnalysisInput>
  }

  export type OffersAnalysisUpdateWithWhereUniqueWithoutOverallAnalysisInput = {
    where: OffersAnalysisWhereUniqueInput
    data: XOR<OffersAnalysisUpdateWithoutOverallAnalysisInput, OffersAnalysisUncheckedUpdateWithoutOverallAnalysisInput>
  }

  export type OffersAnalysisUpdateManyWithWhereWithoutOverallAnalysisInput = {
    where: OffersAnalysisScalarWhereInput
    data: XOR<OffersAnalysisUpdateManyMutationInput, OffersAnalysisUncheckedUpdateManyWithoutOffersAnalysisOverallInput>
  }

  export type OffersAnalysisScalarWhereInput = {
    AND?: Enumerable<OffersAnalysisScalarWhereInput>
    OR?: Enumerable<OffersAnalysisScalarWhereInput>
    NOT?: Enumerable<OffersAnalysisScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    profileId?: StringFilter | string
    offerId?: StringFilter | string
    overallAnalysisUnitId?: StringFilter | string
  }

  export type OffersAnalysisUpsertWithWhereUniqueWithoutCompanyAnalysisInput = {
    where: OffersAnalysisWhereUniqueInput
    update: XOR<OffersAnalysisUpdateWithoutCompanyAnalysisInput, OffersAnalysisUncheckedUpdateWithoutCompanyAnalysisInput>
    create: XOR<OffersAnalysisCreateWithoutCompanyAnalysisInput, OffersAnalysisUncheckedCreateWithoutCompanyAnalysisInput>
  }

  export type OffersAnalysisUpdateWithWhereUniqueWithoutCompanyAnalysisInput = {
    where: OffersAnalysisWhereUniqueInput
    data: XOR<OffersAnalysisUpdateWithoutCompanyAnalysisInput, OffersAnalysisUncheckedUpdateWithoutCompanyAnalysisInput>
  }

  export type OffersAnalysisUpdateManyWithWhereWithoutCompanyAnalysisInput = {
    where: OffersAnalysisScalarWhereInput
    data: XOR<OffersAnalysisUpdateManyMutationInput, OffersAnalysisUncheckedUpdateManyWithoutOffersAnalysisCompanyInput>
  }

  export type UserCreateWithoutQuestionsQuestionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    todos?: TodoCreateNestedManyWithoutUserInput
    resumesResumes?: ResumesResumeCreateNestedManyWithoutUserInput
    resumesStars?: ResumesStarCreateNestedManyWithoutUserInput
    resumesComments?: ResumesCommentCreateNestedManyWithoutUserInput
    resumesCommentVotes?: ResumesCommentVoteCreateNestedManyWithoutUserInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterCreateNestedManyWithoutUserInput
    questionsQuestionVotes?: QuestionsQuestionVoteCreateNestedManyWithoutUserInput
    questionsQuestionComments?: QuestionsQuestionCommentCreateNestedManyWithoutUserInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteCreateNestedManyWithoutUserInput
    questionsAnswers?: QuestionsAnswerCreateNestedManyWithoutUserInput
    questionsAnswerVotes?: QuestionsAnswerVoteCreateNestedManyWithoutUserInput
    questionsAnswerComments?: QuestionsAnswerCommentCreateNestedManyWithoutUserInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteCreateNestedManyWithoutUserInput
    OffersProfile?: OffersProfileCreateNestedManyWithoutUsersInput
    offersDiscussion?: OffersReplyCreateNestedManyWithoutUserInput
    questionsLists?: QuestionsListCreateNestedManyWithoutUserInput
    OffersAdmin?: OffersAdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutQuestionsQuestionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
    resumesResumes?: ResumesResumeUncheckedCreateNestedManyWithoutUserInput
    resumesStars?: ResumesStarUncheckedCreateNestedManyWithoutUserInput
    resumesComments?: ResumesCommentUncheckedCreateNestedManyWithoutUserInput
    resumesCommentVotes?: ResumesCommentVoteUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionVotes?: QuestionsQuestionVoteUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionComments?: QuestionsQuestionCommentUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUncheckedCreateNestedManyWithoutUserInput
    questionsAnswers?: QuestionsAnswerUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerVotes?: QuestionsAnswerVoteUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerComments?: QuestionsAnswerCommentUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUncheckedCreateNestedManyWithoutUserInput
    OffersProfile?: OffersProfileUncheckedCreateNestedManyWithoutUsersInput
    offersDiscussion?: OffersReplyUncheckedCreateNestedManyWithoutUserInput
    questionsLists?: QuestionsListUncheckedCreateNestedManyWithoutUserInput
    OffersAdmin?: OffersAdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutQuestionsQuestionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuestionsQuestionsInput, UserUncheckedCreateWithoutQuestionsQuestionsInput>
  }

  export type QuestionsQuestionEncounterCreateWithoutQuestionInput = {
    id?: string
    role: string
    seenAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    country?: CountryCreateNestedOneWithoutQuestionsQuestionEncountersInput
    state?: StateCreateNestedOneWithoutQuestionsQuestionEncountersInput
    city?: CityCreateNestedOneWithoutQuestionsQuestionEncountersInput
    company?: CompanyCreateNestedOneWithoutQuestionsQuestionEncounterInput
    user?: UserCreateNestedOneWithoutQuestionsQuestionEncountersInput
  }

  export type QuestionsQuestionEncounterUncheckedCreateWithoutQuestionInput = {
    id?: string
    userId?: string | null
    companyId?: string | null
    countryId?: string | null
    stateId?: string | null
    cityId?: string | null
    role: string
    seenAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsQuestionEncounterCreateOrConnectWithoutQuestionInput = {
    where: QuestionsQuestionEncounterWhereUniqueInput
    create: XOR<QuestionsQuestionEncounterCreateWithoutQuestionInput, QuestionsQuestionEncounterUncheckedCreateWithoutQuestionInput>
  }

  export type QuestionsQuestionEncounterCreateManyQuestionInputEnvelope = {
    data: Enumerable<QuestionsQuestionEncounterCreateManyQuestionInput>
    skipDuplicates?: boolean
  }

  export type QuestionsQuestionVoteCreateWithoutQuestionInput = {
    id?: string
    vote: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutQuestionsQuestionVotesInput
  }

  export type QuestionsQuestionVoteUncheckedCreateWithoutQuestionInput = {
    id?: string
    userId?: string | null
    vote: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsQuestionVoteCreateOrConnectWithoutQuestionInput = {
    where: QuestionsQuestionVoteWhereUniqueInput
    create: XOR<QuestionsQuestionVoteCreateWithoutQuestionInput, QuestionsQuestionVoteUncheckedCreateWithoutQuestionInput>
  }

  export type QuestionsQuestionVoteCreateManyQuestionInputEnvelope = {
    data: Enumerable<QuestionsQuestionVoteCreateManyQuestionInput>
    skipDuplicates?: boolean
  }

  export type QuestionsQuestionCommentCreateWithoutQuestionInput = {
    id?: string
    upvotes?: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutQuestionsQuestionCommentsInput
    votes?: QuestionsQuestionCommentVoteCreateNestedManyWithoutCommentInput
  }

  export type QuestionsQuestionCommentUncheckedCreateWithoutQuestionInput = {
    id?: string
    userId?: string | null
    upvotes?: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: QuestionsQuestionCommentVoteUncheckedCreateNestedManyWithoutCommentInput
  }

  export type QuestionsQuestionCommentCreateOrConnectWithoutQuestionInput = {
    where: QuestionsQuestionCommentWhereUniqueInput
    create: XOR<QuestionsQuestionCommentCreateWithoutQuestionInput, QuestionsQuestionCommentUncheckedCreateWithoutQuestionInput>
  }

  export type QuestionsQuestionCommentCreateManyQuestionInputEnvelope = {
    data: Enumerable<QuestionsQuestionCommentCreateManyQuestionInput>
    skipDuplicates?: boolean
  }

  export type QuestionsAnswerCreateWithoutQuestionInput = {
    id?: string
    content: string
    upvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutQuestionsAnswersInput
    votes?: QuestionsAnswerVoteCreateNestedManyWithoutAnswerInput
    comments?: QuestionsAnswerCommentCreateNestedManyWithoutAnswerInput
  }

  export type QuestionsAnswerUncheckedCreateWithoutQuestionInput = {
    id?: string
    userId?: string | null
    content: string
    upvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: QuestionsAnswerVoteUncheckedCreateNestedManyWithoutAnswerInput
    comments?: QuestionsAnswerCommentUncheckedCreateNestedManyWithoutAnswerInput
  }

  export type QuestionsAnswerCreateOrConnectWithoutQuestionInput = {
    where: QuestionsAnswerWhereUniqueInput
    create: XOR<QuestionsAnswerCreateWithoutQuestionInput, QuestionsAnswerUncheckedCreateWithoutQuestionInput>
  }

  export type QuestionsAnswerCreateManyQuestionInputEnvelope = {
    data: Enumerable<QuestionsAnswerCreateManyQuestionInput>
    skipDuplicates?: boolean
  }

  export type QuestionsListQuestionEntryCreateWithoutQuestionInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    list: QuestionsListCreateNestedOneWithoutQuestionEntriesInput
  }

  export type QuestionsListQuestionEntryUncheckedCreateWithoutQuestionInput = {
    id?: string
    listId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsListQuestionEntryCreateOrConnectWithoutQuestionInput = {
    where: QuestionsListQuestionEntryWhereUniqueInput
    create: XOR<QuestionsListQuestionEntryCreateWithoutQuestionInput, QuestionsListQuestionEntryUncheckedCreateWithoutQuestionInput>
  }

  export type QuestionsListQuestionEntryCreateManyQuestionInputEnvelope = {
    data: Enumerable<QuestionsListQuestionEntryCreateManyQuestionInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutQuestionsQuestionsInput = {
    update: XOR<UserUpdateWithoutQuestionsQuestionsInput, UserUncheckedUpdateWithoutQuestionsQuestionsInput>
    create: XOR<UserCreateWithoutQuestionsQuestionsInput, UserUncheckedCreateWithoutQuestionsQuestionsInput>
  }

  export type UserUpdateWithoutQuestionsQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
    resumesResumes?: ResumesResumeUpdateManyWithoutUserNestedInput
    resumesStars?: ResumesStarUpdateManyWithoutUserNestedInput
    resumesComments?: ResumesCommentUpdateManyWithoutUserNestedInput
    resumesCommentVotes?: ResumesCommentVoteUpdateManyWithoutUserNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUpdateManyWithoutUserNestedInput
    questionsQuestionVotes?: QuestionsQuestionVoteUpdateManyWithoutUserNestedInput
    questionsQuestionComments?: QuestionsQuestionCommentUpdateManyWithoutUserNestedInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUpdateManyWithoutUserNestedInput
    questionsAnswers?: QuestionsAnswerUpdateManyWithoutUserNestedInput
    questionsAnswerVotes?: QuestionsAnswerVoteUpdateManyWithoutUserNestedInput
    questionsAnswerComments?: QuestionsAnswerCommentUpdateManyWithoutUserNestedInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUpdateManyWithoutUserNestedInput
    OffersProfile?: OffersProfileUpdateManyWithoutUsersNestedInput
    offersDiscussion?: OffersReplyUpdateManyWithoutUserNestedInput
    questionsLists?: QuestionsListUpdateManyWithoutUserNestedInput
    OffersAdmin?: OffersAdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutQuestionsQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
    resumesResumes?: ResumesResumeUncheckedUpdateManyWithoutUserNestedInput
    resumesStars?: ResumesStarUncheckedUpdateManyWithoutUserNestedInput
    resumesComments?: ResumesCommentUncheckedUpdateManyWithoutUserNestedInput
    resumesCommentVotes?: ResumesCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionVotes?: QuestionsQuestionVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionComments?: QuestionsQuestionCommentUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswers?: QuestionsAnswerUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerVotes?: QuestionsAnswerVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerComments?: QuestionsAnswerCommentUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    OffersProfile?: OffersProfileUncheckedUpdateManyWithoutUsersNestedInput
    offersDiscussion?: OffersReplyUncheckedUpdateManyWithoutUserNestedInput
    questionsLists?: QuestionsListUncheckedUpdateManyWithoutUserNestedInput
    OffersAdmin?: OffersAdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type QuestionsQuestionEncounterUpsertWithWhereUniqueWithoutQuestionInput = {
    where: QuestionsQuestionEncounterWhereUniqueInput
    update: XOR<QuestionsQuestionEncounterUpdateWithoutQuestionInput, QuestionsQuestionEncounterUncheckedUpdateWithoutQuestionInput>
    create: XOR<QuestionsQuestionEncounterCreateWithoutQuestionInput, QuestionsQuestionEncounterUncheckedCreateWithoutQuestionInput>
  }

  export type QuestionsQuestionEncounterUpdateWithWhereUniqueWithoutQuestionInput = {
    where: QuestionsQuestionEncounterWhereUniqueInput
    data: XOR<QuestionsQuestionEncounterUpdateWithoutQuestionInput, QuestionsQuestionEncounterUncheckedUpdateWithoutQuestionInput>
  }

  export type QuestionsQuestionEncounterUpdateManyWithWhereWithoutQuestionInput = {
    where: QuestionsQuestionEncounterScalarWhereInput
    data: XOR<QuestionsQuestionEncounterUpdateManyMutationInput, QuestionsQuestionEncounterUncheckedUpdateManyWithoutEncountersInput>
  }

  export type QuestionsQuestionVoteUpsertWithWhereUniqueWithoutQuestionInput = {
    where: QuestionsQuestionVoteWhereUniqueInput
    update: XOR<QuestionsQuestionVoteUpdateWithoutQuestionInput, QuestionsQuestionVoteUncheckedUpdateWithoutQuestionInput>
    create: XOR<QuestionsQuestionVoteCreateWithoutQuestionInput, QuestionsQuestionVoteUncheckedCreateWithoutQuestionInput>
  }

  export type QuestionsQuestionVoteUpdateWithWhereUniqueWithoutQuestionInput = {
    where: QuestionsQuestionVoteWhereUniqueInput
    data: XOR<QuestionsQuestionVoteUpdateWithoutQuestionInput, QuestionsQuestionVoteUncheckedUpdateWithoutQuestionInput>
  }

  export type QuestionsQuestionVoteUpdateManyWithWhereWithoutQuestionInput = {
    where: QuestionsQuestionVoteScalarWhereInput
    data: XOR<QuestionsQuestionVoteUpdateManyMutationInput, QuestionsQuestionVoteUncheckedUpdateManyWithoutVotesInput>
  }

  export type QuestionsQuestionCommentUpsertWithWhereUniqueWithoutQuestionInput = {
    where: QuestionsQuestionCommentWhereUniqueInput
    update: XOR<QuestionsQuestionCommentUpdateWithoutQuestionInput, QuestionsQuestionCommentUncheckedUpdateWithoutQuestionInput>
    create: XOR<QuestionsQuestionCommentCreateWithoutQuestionInput, QuestionsQuestionCommentUncheckedCreateWithoutQuestionInput>
  }

  export type QuestionsQuestionCommentUpdateWithWhereUniqueWithoutQuestionInput = {
    where: QuestionsQuestionCommentWhereUniqueInput
    data: XOR<QuestionsQuestionCommentUpdateWithoutQuestionInput, QuestionsQuestionCommentUncheckedUpdateWithoutQuestionInput>
  }

  export type QuestionsQuestionCommentUpdateManyWithWhereWithoutQuestionInput = {
    where: QuestionsQuestionCommentScalarWhereInput
    data: XOR<QuestionsQuestionCommentUpdateManyMutationInput, QuestionsQuestionCommentUncheckedUpdateManyWithoutCommentsInput>
  }

  export type QuestionsAnswerUpsertWithWhereUniqueWithoutQuestionInput = {
    where: QuestionsAnswerWhereUniqueInput
    update: XOR<QuestionsAnswerUpdateWithoutQuestionInput, QuestionsAnswerUncheckedUpdateWithoutQuestionInput>
    create: XOR<QuestionsAnswerCreateWithoutQuestionInput, QuestionsAnswerUncheckedCreateWithoutQuestionInput>
  }

  export type QuestionsAnswerUpdateWithWhereUniqueWithoutQuestionInput = {
    where: QuestionsAnswerWhereUniqueInput
    data: XOR<QuestionsAnswerUpdateWithoutQuestionInput, QuestionsAnswerUncheckedUpdateWithoutQuestionInput>
  }

  export type QuestionsAnswerUpdateManyWithWhereWithoutQuestionInput = {
    where: QuestionsAnswerScalarWhereInput
    data: XOR<QuestionsAnswerUpdateManyMutationInput, QuestionsAnswerUncheckedUpdateManyWithoutAnswersInput>
  }

  export type QuestionsListQuestionEntryUpsertWithWhereUniqueWithoutQuestionInput = {
    where: QuestionsListQuestionEntryWhereUniqueInput
    update: XOR<QuestionsListQuestionEntryUpdateWithoutQuestionInput, QuestionsListQuestionEntryUncheckedUpdateWithoutQuestionInput>
    create: XOR<QuestionsListQuestionEntryCreateWithoutQuestionInput, QuestionsListQuestionEntryUncheckedCreateWithoutQuestionInput>
  }

  export type QuestionsListQuestionEntryUpdateWithWhereUniqueWithoutQuestionInput = {
    where: QuestionsListQuestionEntryWhereUniqueInput
    data: XOR<QuestionsListQuestionEntryUpdateWithoutQuestionInput, QuestionsListQuestionEntryUncheckedUpdateWithoutQuestionInput>
  }

  export type QuestionsListQuestionEntryUpdateManyWithWhereWithoutQuestionInput = {
    where: QuestionsListQuestionEntryScalarWhereInput
    data: XOR<QuestionsListQuestionEntryUpdateManyMutationInput, QuestionsListQuestionEntryUncheckedUpdateManyWithoutQuestionsListQuestionEntriesInput>
  }

  export type QuestionsListQuestionEntryScalarWhereInput = {
    AND?: Enumerable<QuestionsListQuestionEntryScalarWhereInput>
    OR?: Enumerable<QuestionsListQuestionEntryScalarWhereInput>
    NOT?: Enumerable<QuestionsListQuestionEntryScalarWhereInput>
    id?: StringFilter | string
    listId?: StringFilter | string
    questionId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type CountryCreateWithoutQuestionsQuestionEncountersInput = {
    id: string
    name: string
    code: string
    ranking?: number | null
    states?: StateCreateNestedManyWithoutCountryInput
    ResumesResume?: ResumesResumeCreateNestedManyWithoutLocationInput
  }

  export type CountryUncheckedCreateWithoutQuestionsQuestionEncountersInput = {
    id: string
    name: string
    code: string
    ranking?: number | null
    states?: StateUncheckedCreateNestedManyWithoutCountryInput
    ResumesResume?: ResumesResumeUncheckedCreateNestedManyWithoutLocationInput
  }

  export type CountryCreateOrConnectWithoutQuestionsQuestionEncountersInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutQuestionsQuestionEncountersInput, CountryUncheckedCreateWithoutQuestionsQuestionEncountersInput>
  }

  export type StateCreateWithoutQuestionsQuestionEncountersInput = {
    id: string
    name: string
    cities?: CityCreateNestedManyWithoutStateInput
    country: CountryCreateNestedOneWithoutStatesInput
  }

  export type StateUncheckedCreateWithoutQuestionsQuestionEncountersInput = {
    id: string
    name: string
    countryId: string
    cities?: CityUncheckedCreateNestedManyWithoutStateInput
  }

  export type StateCreateOrConnectWithoutQuestionsQuestionEncountersInput = {
    where: StateWhereUniqueInput
    create: XOR<StateCreateWithoutQuestionsQuestionEncountersInput, StateUncheckedCreateWithoutQuestionsQuestionEncountersInput>
  }

  export type CityCreateWithoutQuestionsQuestionEncountersInput = {
    id: string
    name: string
    ranking?: number | null
    state: StateCreateNestedOneWithoutCitiesInput
    OffersExperience?: OffersExperienceCreateNestedManyWithoutLocationInput
    OffersOffer?: OffersOfferCreateNestedManyWithoutLocationInput
  }

  export type CityUncheckedCreateWithoutQuestionsQuestionEncountersInput = {
    id: string
    name: string
    stateId: string
    ranking?: number | null
    OffersExperience?: OffersExperienceUncheckedCreateNestedManyWithoutLocationInput
    OffersOffer?: OffersOfferUncheckedCreateNestedManyWithoutLocationInput
  }

  export type CityCreateOrConnectWithoutQuestionsQuestionEncountersInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutQuestionsQuestionEncountersInput, CityUncheckedCreateWithoutQuestionsQuestionEncountersInput>
  }

  export type CompanyCreateWithoutQuestionsQuestionEncounterInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logoUrl?: string | null
    website?: string | null
    ranking?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    OffersExperience?: OffersExperienceCreateNestedManyWithoutCompanyInput
    OffersOffer?: OffersOfferCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutQuestionsQuestionEncounterInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logoUrl?: string | null
    website?: string | null
    ranking?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    OffersExperience?: OffersExperienceUncheckedCreateNestedManyWithoutCompanyInput
    OffersOffer?: OffersOfferUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutQuestionsQuestionEncounterInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutQuestionsQuestionEncounterInput, CompanyUncheckedCreateWithoutQuestionsQuestionEncounterInput>
  }

  export type UserCreateWithoutQuestionsQuestionEncountersInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    todos?: TodoCreateNestedManyWithoutUserInput
    resumesResumes?: ResumesResumeCreateNestedManyWithoutUserInput
    resumesStars?: ResumesStarCreateNestedManyWithoutUserInput
    resumesComments?: ResumesCommentCreateNestedManyWithoutUserInput
    resumesCommentVotes?: ResumesCommentVoteCreateNestedManyWithoutUserInput
    questionsQuestions?: QuestionsQuestionCreateNestedManyWithoutUserInput
    questionsQuestionVotes?: QuestionsQuestionVoteCreateNestedManyWithoutUserInput
    questionsQuestionComments?: QuestionsQuestionCommentCreateNestedManyWithoutUserInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteCreateNestedManyWithoutUserInput
    questionsAnswers?: QuestionsAnswerCreateNestedManyWithoutUserInput
    questionsAnswerVotes?: QuestionsAnswerVoteCreateNestedManyWithoutUserInput
    questionsAnswerComments?: QuestionsAnswerCommentCreateNestedManyWithoutUserInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteCreateNestedManyWithoutUserInput
    OffersProfile?: OffersProfileCreateNestedManyWithoutUsersInput
    offersDiscussion?: OffersReplyCreateNestedManyWithoutUserInput
    questionsLists?: QuestionsListCreateNestedManyWithoutUserInput
    OffersAdmin?: OffersAdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutQuestionsQuestionEncountersInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
    resumesResumes?: ResumesResumeUncheckedCreateNestedManyWithoutUserInput
    resumesStars?: ResumesStarUncheckedCreateNestedManyWithoutUserInput
    resumesComments?: ResumesCommentUncheckedCreateNestedManyWithoutUserInput
    resumesCommentVotes?: ResumesCommentVoteUncheckedCreateNestedManyWithoutUserInput
    questionsQuestions?: QuestionsQuestionUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionVotes?: QuestionsQuestionVoteUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionComments?: QuestionsQuestionCommentUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUncheckedCreateNestedManyWithoutUserInput
    questionsAnswers?: QuestionsAnswerUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerVotes?: QuestionsAnswerVoteUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerComments?: QuestionsAnswerCommentUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUncheckedCreateNestedManyWithoutUserInput
    OffersProfile?: OffersProfileUncheckedCreateNestedManyWithoutUsersInput
    offersDiscussion?: OffersReplyUncheckedCreateNestedManyWithoutUserInput
    questionsLists?: QuestionsListUncheckedCreateNestedManyWithoutUserInput
    OffersAdmin?: OffersAdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutQuestionsQuestionEncountersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuestionsQuestionEncountersInput, UserUncheckedCreateWithoutQuestionsQuestionEncountersInput>
  }

  export type QuestionsQuestionCreateWithoutEncountersInput = {
    id?: string
    content: string
    questionType: QuestionsQuestionType
    lastSeenAt?: Date | string | null
    upvotes?: number
    numEncounters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutQuestionsQuestionsInput
    votes?: QuestionsQuestionVoteCreateNestedManyWithoutQuestionInput
    comments?: QuestionsQuestionCommentCreateNestedManyWithoutQuestionInput
    answers?: QuestionsAnswerCreateNestedManyWithoutQuestionInput
    questionsListQuestionEntries?: QuestionsListQuestionEntryCreateNestedManyWithoutQuestionInput
  }

  export type QuestionsQuestionUncheckedCreateWithoutEncountersInput = {
    id?: string
    userId?: string | null
    content: string
    questionType: QuestionsQuestionType
    lastSeenAt?: Date | string | null
    upvotes?: number
    numEncounters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: QuestionsQuestionVoteUncheckedCreateNestedManyWithoutQuestionInput
    comments?: QuestionsQuestionCommentUncheckedCreateNestedManyWithoutQuestionInput
    answers?: QuestionsAnswerUncheckedCreateNestedManyWithoutQuestionInput
    questionsListQuestionEntries?: QuestionsListQuestionEntryUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionsQuestionCreateOrConnectWithoutEncountersInput = {
    where: QuestionsQuestionWhereUniqueInput
    create: XOR<QuestionsQuestionCreateWithoutEncountersInput, QuestionsQuestionUncheckedCreateWithoutEncountersInput>
  }

  export type CountryUpsertWithoutQuestionsQuestionEncountersInput = {
    update: XOR<CountryUpdateWithoutQuestionsQuestionEncountersInput, CountryUncheckedUpdateWithoutQuestionsQuestionEncountersInput>
    create: XOR<CountryCreateWithoutQuestionsQuestionEncountersInput, CountryUncheckedCreateWithoutQuestionsQuestionEncountersInput>
  }

  export type CountryUpdateWithoutQuestionsQuestionEncountersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    states?: StateUpdateManyWithoutCountryNestedInput
    ResumesResume?: ResumesResumeUpdateManyWithoutLocationNestedInput
  }

  export type CountryUncheckedUpdateWithoutQuestionsQuestionEncountersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    states?: StateUncheckedUpdateManyWithoutCountryNestedInput
    ResumesResume?: ResumesResumeUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type StateUpsertWithoutQuestionsQuestionEncountersInput = {
    update: XOR<StateUpdateWithoutQuestionsQuestionEncountersInput, StateUncheckedUpdateWithoutQuestionsQuestionEncountersInput>
    create: XOR<StateCreateWithoutQuestionsQuestionEncountersInput, StateUncheckedCreateWithoutQuestionsQuestionEncountersInput>
  }

  export type StateUpdateWithoutQuestionsQuestionEncountersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cities?: CityUpdateManyWithoutStateNestedInput
    country?: CountryUpdateOneRequiredWithoutStatesNestedInput
  }

  export type StateUncheckedUpdateWithoutQuestionsQuestionEncountersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    cities?: CityUncheckedUpdateManyWithoutStateNestedInput
  }

  export type CityUpsertWithoutQuestionsQuestionEncountersInput = {
    update: XOR<CityUpdateWithoutQuestionsQuestionEncountersInput, CityUncheckedUpdateWithoutQuestionsQuestionEncountersInput>
    create: XOR<CityCreateWithoutQuestionsQuestionEncountersInput, CityUncheckedCreateWithoutQuestionsQuestionEncountersInput>
  }

  export type CityUpdateWithoutQuestionsQuestionEncountersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    state?: StateUpdateOneRequiredWithoutCitiesNestedInput
    OffersExperience?: OffersExperienceUpdateManyWithoutLocationNestedInput
    OffersOffer?: OffersOfferUpdateManyWithoutLocationNestedInput
  }

  export type CityUncheckedUpdateWithoutQuestionsQuestionEncountersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stateId?: StringFieldUpdateOperationsInput | string
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    OffersExperience?: OffersExperienceUncheckedUpdateManyWithoutLocationNestedInput
    OffersOffer?: OffersOfferUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type CompanyUpsertWithoutQuestionsQuestionEncounterInput = {
    update: XOR<CompanyUpdateWithoutQuestionsQuestionEncounterInput, CompanyUncheckedUpdateWithoutQuestionsQuestionEncounterInput>
    create: XOR<CompanyCreateWithoutQuestionsQuestionEncounterInput, CompanyUncheckedCreateWithoutQuestionsQuestionEncounterInput>
  }

  export type CompanyUpdateWithoutQuestionsQuestionEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    OffersExperience?: OffersExperienceUpdateManyWithoutCompanyNestedInput
    OffersOffer?: OffersOfferUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutQuestionsQuestionEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    OffersExperience?: OffersExperienceUncheckedUpdateManyWithoutCompanyNestedInput
    OffersOffer?: OffersOfferUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutQuestionsQuestionEncountersInput = {
    update: XOR<UserUpdateWithoutQuestionsQuestionEncountersInput, UserUncheckedUpdateWithoutQuestionsQuestionEncountersInput>
    create: XOR<UserCreateWithoutQuestionsQuestionEncountersInput, UserUncheckedCreateWithoutQuestionsQuestionEncountersInput>
  }

  export type UserUpdateWithoutQuestionsQuestionEncountersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
    resumesResumes?: ResumesResumeUpdateManyWithoutUserNestedInput
    resumesStars?: ResumesStarUpdateManyWithoutUserNestedInput
    resumesComments?: ResumesCommentUpdateManyWithoutUserNestedInput
    resumesCommentVotes?: ResumesCommentVoteUpdateManyWithoutUserNestedInput
    questionsQuestions?: QuestionsQuestionUpdateManyWithoutUserNestedInput
    questionsQuestionVotes?: QuestionsQuestionVoteUpdateManyWithoutUserNestedInput
    questionsQuestionComments?: QuestionsQuestionCommentUpdateManyWithoutUserNestedInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUpdateManyWithoutUserNestedInput
    questionsAnswers?: QuestionsAnswerUpdateManyWithoutUserNestedInput
    questionsAnswerVotes?: QuestionsAnswerVoteUpdateManyWithoutUserNestedInput
    questionsAnswerComments?: QuestionsAnswerCommentUpdateManyWithoutUserNestedInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUpdateManyWithoutUserNestedInput
    OffersProfile?: OffersProfileUpdateManyWithoutUsersNestedInput
    offersDiscussion?: OffersReplyUpdateManyWithoutUserNestedInput
    questionsLists?: QuestionsListUpdateManyWithoutUserNestedInput
    OffersAdmin?: OffersAdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutQuestionsQuestionEncountersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
    resumesResumes?: ResumesResumeUncheckedUpdateManyWithoutUserNestedInput
    resumesStars?: ResumesStarUncheckedUpdateManyWithoutUserNestedInput
    resumesComments?: ResumesCommentUncheckedUpdateManyWithoutUserNestedInput
    resumesCommentVotes?: ResumesCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestions?: QuestionsQuestionUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionVotes?: QuestionsQuestionVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionComments?: QuestionsQuestionCommentUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswers?: QuestionsAnswerUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerVotes?: QuestionsAnswerVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerComments?: QuestionsAnswerCommentUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    OffersProfile?: OffersProfileUncheckedUpdateManyWithoutUsersNestedInput
    offersDiscussion?: OffersReplyUncheckedUpdateManyWithoutUserNestedInput
    questionsLists?: QuestionsListUncheckedUpdateManyWithoutUserNestedInput
    OffersAdmin?: OffersAdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type QuestionsQuestionUpsertWithoutEncountersInput = {
    update: XOR<QuestionsQuestionUpdateWithoutEncountersInput, QuestionsQuestionUncheckedUpdateWithoutEncountersInput>
    create: XOR<QuestionsQuestionCreateWithoutEncountersInput, QuestionsQuestionUncheckedCreateWithoutEncountersInput>
  }

  export type QuestionsQuestionUpdateWithoutEncountersInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionsQuestionTypeFieldUpdateOperationsInput | QuestionsQuestionType
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    numEncounters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutQuestionsQuestionsNestedInput
    votes?: QuestionsQuestionVoteUpdateManyWithoutQuestionNestedInput
    comments?: QuestionsQuestionCommentUpdateManyWithoutQuestionNestedInput
    answers?: QuestionsAnswerUpdateManyWithoutQuestionNestedInput
    questionsListQuestionEntries?: QuestionsListQuestionEntryUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionsQuestionUncheckedUpdateWithoutEncountersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionsQuestionTypeFieldUpdateOperationsInput | QuestionsQuestionType
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    numEncounters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: QuestionsQuestionVoteUncheckedUpdateManyWithoutQuestionNestedInput
    comments?: QuestionsQuestionCommentUncheckedUpdateManyWithoutQuestionNestedInput
    answers?: QuestionsAnswerUncheckedUpdateManyWithoutQuestionNestedInput
    questionsListQuestionEntries?: QuestionsListQuestionEntryUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type UserCreateWithoutQuestionsQuestionVotesInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    todos?: TodoCreateNestedManyWithoutUserInput
    resumesResumes?: ResumesResumeCreateNestedManyWithoutUserInput
    resumesStars?: ResumesStarCreateNestedManyWithoutUserInput
    resumesComments?: ResumesCommentCreateNestedManyWithoutUserInput
    resumesCommentVotes?: ResumesCommentVoteCreateNestedManyWithoutUserInput
    questionsQuestions?: QuestionsQuestionCreateNestedManyWithoutUserInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterCreateNestedManyWithoutUserInput
    questionsQuestionComments?: QuestionsQuestionCommentCreateNestedManyWithoutUserInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteCreateNestedManyWithoutUserInput
    questionsAnswers?: QuestionsAnswerCreateNestedManyWithoutUserInput
    questionsAnswerVotes?: QuestionsAnswerVoteCreateNestedManyWithoutUserInput
    questionsAnswerComments?: QuestionsAnswerCommentCreateNestedManyWithoutUserInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteCreateNestedManyWithoutUserInput
    OffersProfile?: OffersProfileCreateNestedManyWithoutUsersInput
    offersDiscussion?: OffersReplyCreateNestedManyWithoutUserInput
    questionsLists?: QuestionsListCreateNestedManyWithoutUserInput
    OffersAdmin?: OffersAdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutQuestionsQuestionVotesInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
    resumesResumes?: ResumesResumeUncheckedCreateNestedManyWithoutUserInput
    resumesStars?: ResumesStarUncheckedCreateNestedManyWithoutUserInput
    resumesComments?: ResumesCommentUncheckedCreateNestedManyWithoutUserInput
    resumesCommentVotes?: ResumesCommentVoteUncheckedCreateNestedManyWithoutUserInput
    questionsQuestions?: QuestionsQuestionUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionComments?: QuestionsQuestionCommentUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUncheckedCreateNestedManyWithoutUserInput
    questionsAnswers?: QuestionsAnswerUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerVotes?: QuestionsAnswerVoteUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerComments?: QuestionsAnswerCommentUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUncheckedCreateNestedManyWithoutUserInput
    OffersProfile?: OffersProfileUncheckedCreateNestedManyWithoutUsersInput
    offersDiscussion?: OffersReplyUncheckedCreateNestedManyWithoutUserInput
    questionsLists?: QuestionsListUncheckedCreateNestedManyWithoutUserInput
    OffersAdmin?: OffersAdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutQuestionsQuestionVotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuestionsQuestionVotesInput, UserUncheckedCreateWithoutQuestionsQuestionVotesInput>
  }

  export type QuestionsQuestionCreateWithoutVotesInput = {
    id?: string
    content: string
    questionType: QuestionsQuestionType
    lastSeenAt?: Date | string | null
    upvotes?: number
    numEncounters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutQuestionsQuestionsInput
    encounters?: QuestionsQuestionEncounterCreateNestedManyWithoutQuestionInput
    comments?: QuestionsQuestionCommentCreateNestedManyWithoutQuestionInput
    answers?: QuestionsAnswerCreateNestedManyWithoutQuestionInput
    questionsListQuestionEntries?: QuestionsListQuestionEntryCreateNestedManyWithoutQuestionInput
  }

  export type QuestionsQuestionUncheckedCreateWithoutVotesInput = {
    id?: string
    userId?: string | null
    content: string
    questionType: QuestionsQuestionType
    lastSeenAt?: Date | string | null
    upvotes?: number
    numEncounters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    encounters?: QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutQuestionInput
    comments?: QuestionsQuestionCommentUncheckedCreateNestedManyWithoutQuestionInput
    answers?: QuestionsAnswerUncheckedCreateNestedManyWithoutQuestionInput
    questionsListQuestionEntries?: QuestionsListQuestionEntryUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionsQuestionCreateOrConnectWithoutVotesInput = {
    where: QuestionsQuestionWhereUniqueInput
    create: XOR<QuestionsQuestionCreateWithoutVotesInput, QuestionsQuestionUncheckedCreateWithoutVotesInput>
  }

  export type UserUpsertWithoutQuestionsQuestionVotesInput = {
    update: XOR<UserUpdateWithoutQuestionsQuestionVotesInput, UserUncheckedUpdateWithoutQuestionsQuestionVotesInput>
    create: XOR<UserCreateWithoutQuestionsQuestionVotesInput, UserUncheckedCreateWithoutQuestionsQuestionVotesInput>
  }

  export type UserUpdateWithoutQuestionsQuestionVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
    resumesResumes?: ResumesResumeUpdateManyWithoutUserNestedInput
    resumesStars?: ResumesStarUpdateManyWithoutUserNestedInput
    resumesComments?: ResumesCommentUpdateManyWithoutUserNestedInput
    resumesCommentVotes?: ResumesCommentVoteUpdateManyWithoutUserNestedInput
    questionsQuestions?: QuestionsQuestionUpdateManyWithoutUserNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUpdateManyWithoutUserNestedInput
    questionsQuestionComments?: QuestionsQuestionCommentUpdateManyWithoutUserNestedInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUpdateManyWithoutUserNestedInput
    questionsAnswers?: QuestionsAnswerUpdateManyWithoutUserNestedInput
    questionsAnswerVotes?: QuestionsAnswerVoteUpdateManyWithoutUserNestedInput
    questionsAnswerComments?: QuestionsAnswerCommentUpdateManyWithoutUserNestedInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUpdateManyWithoutUserNestedInput
    OffersProfile?: OffersProfileUpdateManyWithoutUsersNestedInput
    offersDiscussion?: OffersReplyUpdateManyWithoutUserNestedInput
    questionsLists?: QuestionsListUpdateManyWithoutUserNestedInput
    OffersAdmin?: OffersAdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutQuestionsQuestionVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
    resumesResumes?: ResumesResumeUncheckedUpdateManyWithoutUserNestedInput
    resumesStars?: ResumesStarUncheckedUpdateManyWithoutUserNestedInput
    resumesComments?: ResumesCommentUncheckedUpdateManyWithoutUserNestedInput
    resumesCommentVotes?: ResumesCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestions?: QuestionsQuestionUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionComments?: QuestionsQuestionCommentUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswers?: QuestionsAnswerUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerVotes?: QuestionsAnswerVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerComments?: QuestionsAnswerCommentUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    OffersProfile?: OffersProfileUncheckedUpdateManyWithoutUsersNestedInput
    offersDiscussion?: OffersReplyUncheckedUpdateManyWithoutUserNestedInput
    questionsLists?: QuestionsListUncheckedUpdateManyWithoutUserNestedInput
    OffersAdmin?: OffersAdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type QuestionsQuestionUpsertWithoutVotesInput = {
    update: XOR<QuestionsQuestionUpdateWithoutVotesInput, QuestionsQuestionUncheckedUpdateWithoutVotesInput>
    create: XOR<QuestionsQuestionCreateWithoutVotesInput, QuestionsQuestionUncheckedCreateWithoutVotesInput>
  }

  export type QuestionsQuestionUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionsQuestionTypeFieldUpdateOperationsInput | QuestionsQuestionType
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    numEncounters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutQuestionsQuestionsNestedInput
    encounters?: QuestionsQuestionEncounterUpdateManyWithoutQuestionNestedInput
    comments?: QuestionsQuestionCommentUpdateManyWithoutQuestionNestedInput
    answers?: QuestionsAnswerUpdateManyWithoutQuestionNestedInput
    questionsListQuestionEntries?: QuestionsListQuestionEntryUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionsQuestionUncheckedUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionsQuestionTypeFieldUpdateOperationsInput | QuestionsQuestionType
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    numEncounters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounters?: QuestionsQuestionEncounterUncheckedUpdateManyWithoutQuestionNestedInput
    comments?: QuestionsQuestionCommentUncheckedUpdateManyWithoutQuestionNestedInput
    answers?: QuestionsAnswerUncheckedUpdateManyWithoutQuestionNestedInput
    questionsListQuestionEntries?: QuestionsListQuestionEntryUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type UserCreateWithoutQuestionsQuestionCommentsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    todos?: TodoCreateNestedManyWithoutUserInput
    resumesResumes?: ResumesResumeCreateNestedManyWithoutUserInput
    resumesStars?: ResumesStarCreateNestedManyWithoutUserInput
    resumesComments?: ResumesCommentCreateNestedManyWithoutUserInput
    resumesCommentVotes?: ResumesCommentVoteCreateNestedManyWithoutUserInput
    questionsQuestions?: QuestionsQuestionCreateNestedManyWithoutUserInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterCreateNestedManyWithoutUserInput
    questionsQuestionVotes?: QuestionsQuestionVoteCreateNestedManyWithoutUserInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteCreateNestedManyWithoutUserInput
    questionsAnswers?: QuestionsAnswerCreateNestedManyWithoutUserInput
    questionsAnswerVotes?: QuestionsAnswerVoteCreateNestedManyWithoutUserInput
    questionsAnswerComments?: QuestionsAnswerCommentCreateNestedManyWithoutUserInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteCreateNestedManyWithoutUserInput
    OffersProfile?: OffersProfileCreateNestedManyWithoutUsersInput
    offersDiscussion?: OffersReplyCreateNestedManyWithoutUserInput
    questionsLists?: QuestionsListCreateNestedManyWithoutUserInput
    OffersAdmin?: OffersAdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutQuestionsQuestionCommentsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
    resumesResumes?: ResumesResumeUncheckedCreateNestedManyWithoutUserInput
    resumesStars?: ResumesStarUncheckedCreateNestedManyWithoutUserInput
    resumesComments?: ResumesCommentUncheckedCreateNestedManyWithoutUserInput
    resumesCommentVotes?: ResumesCommentVoteUncheckedCreateNestedManyWithoutUserInput
    questionsQuestions?: QuestionsQuestionUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionVotes?: QuestionsQuestionVoteUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUncheckedCreateNestedManyWithoutUserInput
    questionsAnswers?: QuestionsAnswerUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerVotes?: QuestionsAnswerVoteUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerComments?: QuestionsAnswerCommentUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUncheckedCreateNestedManyWithoutUserInput
    OffersProfile?: OffersProfileUncheckedCreateNestedManyWithoutUsersInput
    offersDiscussion?: OffersReplyUncheckedCreateNestedManyWithoutUserInput
    questionsLists?: QuestionsListUncheckedCreateNestedManyWithoutUserInput
    OffersAdmin?: OffersAdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutQuestionsQuestionCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuestionsQuestionCommentsInput, UserUncheckedCreateWithoutQuestionsQuestionCommentsInput>
  }

  export type QuestionsQuestionCreateWithoutCommentsInput = {
    id?: string
    content: string
    questionType: QuestionsQuestionType
    lastSeenAt?: Date | string | null
    upvotes?: number
    numEncounters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutQuestionsQuestionsInput
    encounters?: QuestionsQuestionEncounterCreateNestedManyWithoutQuestionInput
    votes?: QuestionsQuestionVoteCreateNestedManyWithoutQuestionInput
    answers?: QuestionsAnswerCreateNestedManyWithoutQuestionInput
    questionsListQuestionEntries?: QuestionsListQuestionEntryCreateNestedManyWithoutQuestionInput
  }

  export type QuestionsQuestionUncheckedCreateWithoutCommentsInput = {
    id?: string
    userId?: string | null
    content: string
    questionType: QuestionsQuestionType
    lastSeenAt?: Date | string | null
    upvotes?: number
    numEncounters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    encounters?: QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutQuestionInput
    votes?: QuestionsQuestionVoteUncheckedCreateNestedManyWithoutQuestionInput
    answers?: QuestionsAnswerUncheckedCreateNestedManyWithoutQuestionInput
    questionsListQuestionEntries?: QuestionsListQuestionEntryUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionsQuestionCreateOrConnectWithoutCommentsInput = {
    where: QuestionsQuestionWhereUniqueInput
    create: XOR<QuestionsQuestionCreateWithoutCommentsInput, QuestionsQuestionUncheckedCreateWithoutCommentsInput>
  }

  export type QuestionsQuestionCommentVoteCreateWithoutCommentInput = {
    id?: string
    vote: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutQuestionsQuestionCommentVotesInput
  }

  export type QuestionsQuestionCommentVoteUncheckedCreateWithoutCommentInput = {
    id?: string
    userId?: string | null
    vote: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsQuestionCommentVoteCreateOrConnectWithoutCommentInput = {
    where: QuestionsQuestionCommentVoteWhereUniqueInput
    create: XOR<QuestionsQuestionCommentVoteCreateWithoutCommentInput, QuestionsQuestionCommentVoteUncheckedCreateWithoutCommentInput>
  }

  export type QuestionsQuestionCommentVoteCreateManyCommentInputEnvelope = {
    data: Enumerable<QuestionsQuestionCommentVoteCreateManyCommentInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutQuestionsQuestionCommentsInput = {
    update: XOR<UserUpdateWithoutQuestionsQuestionCommentsInput, UserUncheckedUpdateWithoutQuestionsQuestionCommentsInput>
    create: XOR<UserCreateWithoutQuestionsQuestionCommentsInput, UserUncheckedCreateWithoutQuestionsQuestionCommentsInput>
  }

  export type UserUpdateWithoutQuestionsQuestionCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
    resumesResumes?: ResumesResumeUpdateManyWithoutUserNestedInput
    resumesStars?: ResumesStarUpdateManyWithoutUserNestedInput
    resumesComments?: ResumesCommentUpdateManyWithoutUserNestedInput
    resumesCommentVotes?: ResumesCommentVoteUpdateManyWithoutUserNestedInput
    questionsQuestions?: QuestionsQuestionUpdateManyWithoutUserNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUpdateManyWithoutUserNestedInput
    questionsQuestionVotes?: QuestionsQuestionVoteUpdateManyWithoutUserNestedInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUpdateManyWithoutUserNestedInput
    questionsAnswers?: QuestionsAnswerUpdateManyWithoutUserNestedInput
    questionsAnswerVotes?: QuestionsAnswerVoteUpdateManyWithoutUserNestedInput
    questionsAnswerComments?: QuestionsAnswerCommentUpdateManyWithoutUserNestedInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUpdateManyWithoutUserNestedInput
    OffersProfile?: OffersProfileUpdateManyWithoutUsersNestedInput
    offersDiscussion?: OffersReplyUpdateManyWithoutUserNestedInput
    questionsLists?: QuestionsListUpdateManyWithoutUserNestedInput
    OffersAdmin?: OffersAdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutQuestionsQuestionCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
    resumesResumes?: ResumesResumeUncheckedUpdateManyWithoutUserNestedInput
    resumesStars?: ResumesStarUncheckedUpdateManyWithoutUserNestedInput
    resumesComments?: ResumesCommentUncheckedUpdateManyWithoutUserNestedInput
    resumesCommentVotes?: ResumesCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestions?: QuestionsQuestionUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionVotes?: QuestionsQuestionVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswers?: QuestionsAnswerUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerVotes?: QuestionsAnswerVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerComments?: QuestionsAnswerCommentUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    OffersProfile?: OffersProfileUncheckedUpdateManyWithoutUsersNestedInput
    offersDiscussion?: OffersReplyUncheckedUpdateManyWithoutUserNestedInput
    questionsLists?: QuestionsListUncheckedUpdateManyWithoutUserNestedInput
    OffersAdmin?: OffersAdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type QuestionsQuestionUpsertWithoutCommentsInput = {
    update: XOR<QuestionsQuestionUpdateWithoutCommentsInput, QuestionsQuestionUncheckedUpdateWithoutCommentsInput>
    create: XOR<QuestionsQuestionCreateWithoutCommentsInput, QuestionsQuestionUncheckedCreateWithoutCommentsInput>
  }

  export type QuestionsQuestionUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionsQuestionTypeFieldUpdateOperationsInput | QuestionsQuestionType
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    numEncounters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutQuestionsQuestionsNestedInput
    encounters?: QuestionsQuestionEncounterUpdateManyWithoutQuestionNestedInput
    votes?: QuestionsQuestionVoteUpdateManyWithoutQuestionNestedInput
    answers?: QuestionsAnswerUpdateManyWithoutQuestionNestedInput
    questionsListQuestionEntries?: QuestionsListQuestionEntryUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionsQuestionUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionsQuestionTypeFieldUpdateOperationsInput | QuestionsQuestionType
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    numEncounters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounters?: QuestionsQuestionEncounterUncheckedUpdateManyWithoutQuestionNestedInput
    votes?: QuestionsQuestionVoteUncheckedUpdateManyWithoutQuestionNestedInput
    answers?: QuestionsAnswerUncheckedUpdateManyWithoutQuestionNestedInput
    questionsListQuestionEntries?: QuestionsListQuestionEntryUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionsQuestionCommentVoteUpsertWithWhereUniqueWithoutCommentInput = {
    where: QuestionsQuestionCommentVoteWhereUniqueInput
    update: XOR<QuestionsQuestionCommentVoteUpdateWithoutCommentInput, QuestionsQuestionCommentVoteUncheckedUpdateWithoutCommentInput>
    create: XOR<QuestionsQuestionCommentVoteCreateWithoutCommentInput, QuestionsQuestionCommentVoteUncheckedCreateWithoutCommentInput>
  }

  export type QuestionsQuestionCommentVoteUpdateWithWhereUniqueWithoutCommentInput = {
    where: QuestionsQuestionCommentVoteWhereUniqueInput
    data: XOR<QuestionsQuestionCommentVoteUpdateWithoutCommentInput, QuestionsQuestionCommentVoteUncheckedUpdateWithoutCommentInput>
  }

  export type QuestionsQuestionCommentVoteUpdateManyWithWhereWithoutCommentInput = {
    where: QuestionsQuestionCommentVoteScalarWhereInput
    data: XOR<QuestionsQuestionCommentVoteUpdateManyMutationInput, QuestionsQuestionCommentVoteUncheckedUpdateManyWithoutVotesInput>
  }

  export type UserCreateWithoutQuestionsQuestionCommentVotesInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    todos?: TodoCreateNestedManyWithoutUserInput
    resumesResumes?: ResumesResumeCreateNestedManyWithoutUserInput
    resumesStars?: ResumesStarCreateNestedManyWithoutUserInput
    resumesComments?: ResumesCommentCreateNestedManyWithoutUserInput
    resumesCommentVotes?: ResumesCommentVoteCreateNestedManyWithoutUserInput
    questionsQuestions?: QuestionsQuestionCreateNestedManyWithoutUserInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterCreateNestedManyWithoutUserInput
    questionsQuestionVotes?: QuestionsQuestionVoteCreateNestedManyWithoutUserInput
    questionsQuestionComments?: QuestionsQuestionCommentCreateNestedManyWithoutUserInput
    questionsAnswers?: QuestionsAnswerCreateNestedManyWithoutUserInput
    questionsAnswerVotes?: QuestionsAnswerVoteCreateNestedManyWithoutUserInput
    questionsAnswerComments?: QuestionsAnswerCommentCreateNestedManyWithoutUserInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteCreateNestedManyWithoutUserInput
    OffersProfile?: OffersProfileCreateNestedManyWithoutUsersInput
    offersDiscussion?: OffersReplyCreateNestedManyWithoutUserInput
    questionsLists?: QuestionsListCreateNestedManyWithoutUserInput
    OffersAdmin?: OffersAdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutQuestionsQuestionCommentVotesInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
    resumesResumes?: ResumesResumeUncheckedCreateNestedManyWithoutUserInput
    resumesStars?: ResumesStarUncheckedCreateNestedManyWithoutUserInput
    resumesComments?: ResumesCommentUncheckedCreateNestedManyWithoutUserInput
    resumesCommentVotes?: ResumesCommentVoteUncheckedCreateNestedManyWithoutUserInput
    questionsQuestions?: QuestionsQuestionUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionVotes?: QuestionsQuestionVoteUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionComments?: QuestionsQuestionCommentUncheckedCreateNestedManyWithoutUserInput
    questionsAnswers?: QuestionsAnswerUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerVotes?: QuestionsAnswerVoteUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerComments?: QuestionsAnswerCommentUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUncheckedCreateNestedManyWithoutUserInput
    OffersProfile?: OffersProfileUncheckedCreateNestedManyWithoutUsersInput
    offersDiscussion?: OffersReplyUncheckedCreateNestedManyWithoutUserInput
    questionsLists?: QuestionsListUncheckedCreateNestedManyWithoutUserInput
    OffersAdmin?: OffersAdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutQuestionsQuestionCommentVotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuestionsQuestionCommentVotesInput, UserUncheckedCreateWithoutQuestionsQuestionCommentVotesInput>
  }

  export type QuestionsQuestionCommentCreateWithoutVotesInput = {
    id?: string
    upvotes?: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutQuestionsQuestionCommentsInput
    question: QuestionsQuestionCreateNestedOneWithoutCommentsInput
  }

  export type QuestionsQuestionCommentUncheckedCreateWithoutVotesInput = {
    id?: string
    questionId: string
    userId?: string | null
    upvotes?: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsQuestionCommentCreateOrConnectWithoutVotesInput = {
    where: QuestionsQuestionCommentWhereUniqueInput
    create: XOR<QuestionsQuestionCommentCreateWithoutVotesInput, QuestionsQuestionCommentUncheckedCreateWithoutVotesInput>
  }

  export type UserUpsertWithoutQuestionsQuestionCommentVotesInput = {
    update: XOR<UserUpdateWithoutQuestionsQuestionCommentVotesInput, UserUncheckedUpdateWithoutQuestionsQuestionCommentVotesInput>
    create: XOR<UserCreateWithoutQuestionsQuestionCommentVotesInput, UserUncheckedCreateWithoutQuestionsQuestionCommentVotesInput>
  }

  export type UserUpdateWithoutQuestionsQuestionCommentVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
    resumesResumes?: ResumesResumeUpdateManyWithoutUserNestedInput
    resumesStars?: ResumesStarUpdateManyWithoutUserNestedInput
    resumesComments?: ResumesCommentUpdateManyWithoutUserNestedInput
    resumesCommentVotes?: ResumesCommentVoteUpdateManyWithoutUserNestedInput
    questionsQuestions?: QuestionsQuestionUpdateManyWithoutUserNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUpdateManyWithoutUserNestedInput
    questionsQuestionVotes?: QuestionsQuestionVoteUpdateManyWithoutUserNestedInput
    questionsQuestionComments?: QuestionsQuestionCommentUpdateManyWithoutUserNestedInput
    questionsAnswers?: QuestionsAnswerUpdateManyWithoutUserNestedInput
    questionsAnswerVotes?: QuestionsAnswerVoteUpdateManyWithoutUserNestedInput
    questionsAnswerComments?: QuestionsAnswerCommentUpdateManyWithoutUserNestedInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUpdateManyWithoutUserNestedInput
    OffersProfile?: OffersProfileUpdateManyWithoutUsersNestedInput
    offersDiscussion?: OffersReplyUpdateManyWithoutUserNestedInput
    questionsLists?: QuestionsListUpdateManyWithoutUserNestedInput
    OffersAdmin?: OffersAdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutQuestionsQuestionCommentVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
    resumesResumes?: ResumesResumeUncheckedUpdateManyWithoutUserNestedInput
    resumesStars?: ResumesStarUncheckedUpdateManyWithoutUserNestedInput
    resumesComments?: ResumesCommentUncheckedUpdateManyWithoutUserNestedInput
    resumesCommentVotes?: ResumesCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestions?: QuestionsQuestionUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionVotes?: QuestionsQuestionVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionComments?: QuestionsQuestionCommentUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswers?: QuestionsAnswerUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerVotes?: QuestionsAnswerVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerComments?: QuestionsAnswerCommentUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    OffersProfile?: OffersProfileUncheckedUpdateManyWithoutUsersNestedInput
    offersDiscussion?: OffersReplyUncheckedUpdateManyWithoutUserNestedInput
    questionsLists?: QuestionsListUncheckedUpdateManyWithoutUserNestedInput
    OffersAdmin?: OffersAdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type QuestionsQuestionCommentUpsertWithoutVotesInput = {
    update: XOR<QuestionsQuestionCommentUpdateWithoutVotesInput, QuestionsQuestionCommentUncheckedUpdateWithoutVotesInput>
    create: XOR<QuestionsQuestionCommentCreateWithoutVotesInput, QuestionsQuestionCommentUncheckedCreateWithoutVotesInput>
  }

  export type QuestionsQuestionCommentUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutQuestionsQuestionCommentsNestedInput
    question?: QuestionsQuestionUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type QuestionsQuestionCommentUncheckedUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutQuestionsAnswersInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    todos?: TodoCreateNestedManyWithoutUserInput
    resumesResumes?: ResumesResumeCreateNestedManyWithoutUserInput
    resumesStars?: ResumesStarCreateNestedManyWithoutUserInput
    resumesComments?: ResumesCommentCreateNestedManyWithoutUserInput
    resumesCommentVotes?: ResumesCommentVoteCreateNestedManyWithoutUserInput
    questionsQuestions?: QuestionsQuestionCreateNestedManyWithoutUserInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterCreateNestedManyWithoutUserInput
    questionsQuestionVotes?: QuestionsQuestionVoteCreateNestedManyWithoutUserInput
    questionsQuestionComments?: QuestionsQuestionCommentCreateNestedManyWithoutUserInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteCreateNestedManyWithoutUserInput
    questionsAnswerVotes?: QuestionsAnswerVoteCreateNestedManyWithoutUserInput
    questionsAnswerComments?: QuestionsAnswerCommentCreateNestedManyWithoutUserInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteCreateNestedManyWithoutUserInput
    OffersProfile?: OffersProfileCreateNestedManyWithoutUsersInput
    offersDiscussion?: OffersReplyCreateNestedManyWithoutUserInput
    questionsLists?: QuestionsListCreateNestedManyWithoutUserInput
    OffersAdmin?: OffersAdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutQuestionsAnswersInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
    resumesResumes?: ResumesResumeUncheckedCreateNestedManyWithoutUserInput
    resumesStars?: ResumesStarUncheckedCreateNestedManyWithoutUserInput
    resumesComments?: ResumesCommentUncheckedCreateNestedManyWithoutUserInput
    resumesCommentVotes?: ResumesCommentVoteUncheckedCreateNestedManyWithoutUserInput
    questionsQuestions?: QuestionsQuestionUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionVotes?: QuestionsQuestionVoteUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionComments?: QuestionsQuestionCommentUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerVotes?: QuestionsAnswerVoteUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerComments?: QuestionsAnswerCommentUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUncheckedCreateNestedManyWithoutUserInput
    OffersProfile?: OffersProfileUncheckedCreateNestedManyWithoutUsersInput
    offersDiscussion?: OffersReplyUncheckedCreateNestedManyWithoutUserInput
    questionsLists?: QuestionsListUncheckedCreateNestedManyWithoutUserInput
    OffersAdmin?: OffersAdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutQuestionsAnswersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuestionsAnswersInput, UserUncheckedCreateWithoutQuestionsAnswersInput>
  }

  export type QuestionsQuestionCreateWithoutAnswersInput = {
    id?: string
    content: string
    questionType: QuestionsQuestionType
    lastSeenAt?: Date | string | null
    upvotes?: number
    numEncounters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutQuestionsQuestionsInput
    encounters?: QuestionsQuestionEncounterCreateNestedManyWithoutQuestionInput
    votes?: QuestionsQuestionVoteCreateNestedManyWithoutQuestionInput
    comments?: QuestionsQuestionCommentCreateNestedManyWithoutQuestionInput
    questionsListQuestionEntries?: QuestionsListQuestionEntryCreateNestedManyWithoutQuestionInput
  }

  export type QuestionsQuestionUncheckedCreateWithoutAnswersInput = {
    id?: string
    userId?: string | null
    content: string
    questionType: QuestionsQuestionType
    lastSeenAt?: Date | string | null
    upvotes?: number
    numEncounters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    encounters?: QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutQuestionInput
    votes?: QuestionsQuestionVoteUncheckedCreateNestedManyWithoutQuestionInput
    comments?: QuestionsQuestionCommentUncheckedCreateNestedManyWithoutQuestionInput
    questionsListQuestionEntries?: QuestionsListQuestionEntryUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionsQuestionCreateOrConnectWithoutAnswersInput = {
    where: QuestionsQuestionWhereUniqueInput
    create: XOR<QuestionsQuestionCreateWithoutAnswersInput, QuestionsQuestionUncheckedCreateWithoutAnswersInput>
  }

  export type QuestionsAnswerVoteCreateWithoutAnswerInput = {
    id?: string
    vote: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutQuestionsAnswerVotesInput
  }

  export type QuestionsAnswerVoteUncheckedCreateWithoutAnswerInput = {
    id?: string
    userId?: string | null
    vote: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsAnswerVoteCreateOrConnectWithoutAnswerInput = {
    where: QuestionsAnswerVoteWhereUniqueInput
    create: XOR<QuestionsAnswerVoteCreateWithoutAnswerInput, QuestionsAnswerVoteUncheckedCreateWithoutAnswerInput>
  }

  export type QuestionsAnswerVoteCreateManyAnswerInputEnvelope = {
    data: Enumerable<QuestionsAnswerVoteCreateManyAnswerInput>
    skipDuplicates?: boolean
  }

  export type QuestionsAnswerCommentCreateWithoutAnswerInput = {
    id?: string
    content: string
    upvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutQuestionsAnswerCommentsInput
    votes?: QuestionsAnswerCommentVoteCreateNestedManyWithoutCommentInput
  }

  export type QuestionsAnswerCommentUncheckedCreateWithoutAnswerInput = {
    id?: string
    userId?: string | null
    content: string
    upvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: QuestionsAnswerCommentVoteUncheckedCreateNestedManyWithoutCommentInput
  }

  export type QuestionsAnswerCommentCreateOrConnectWithoutAnswerInput = {
    where: QuestionsAnswerCommentWhereUniqueInput
    create: XOR<QuestionsAnswerCommentCreateWithoutAnswerInput, QuestionsAnswerCommentUncheckedCreateWithoutAnswerInput>
  }

  export type QuestionsAnswerCommentCreateManyAnswerInputEnvelope = {
    data: Enumerable<QuestionsAnswerCommentCreateManyAnswerInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutQuestionsAnswersInput = {
    update: XOR<UserUpdateWithoutQuestionsAnswersInput, UserUncheckedUpdateWithoutQuestionsAnswersInput>
    create: XOR<UserCreateWithoutQuestionsAnswersInput, UserUncheckedCreateWithoutQuestionsAnswersInput>
  }

  export type UserUpdateWithoutQuestionsAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
    resumesResumes?: ResumesResumeUpdateManyWithoutUserNestedInput
    resumesStars?: ResumesStarUpdateManyWithoutUserNestedInput
    resumesComments?: ResumesCommentUpdateManyWithoutUserNestedInput
    resumesCommentVotes?: ResumesCommentVoteUpdateManyWithoutUserNestedInput
    questionsQuestions?: QuestionsQuestionUpdateManyWithoutUserNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUpdateManyWithoutUserNestedInput
    questionsQuestionVotes?: QuestionsQuestionVoteUpdateManyWithoutUserNestedInput
    questionsQuestionComments?: QuestionsQuestionCommentUpdateManyWithoutUserNestedInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUpdateManyWithoutUserNestedInput
    questionsAnswerVotes?: QuestionsAnswerVoteUpdateManyWithoutUserNestedInput
    questionsAnswerComments?: QuestionsAnswerCommentUpdateManyWithoutUserNestedInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUpdateManyWithoutUserNestedInput
    OffersProfile?: OffersProfileUpdateManyWithoutUsersNestedInput
    offersDiscussion?: OffersReplyUpdateManyWithoutUserNestedInput
    questionsLists?: QuestionsListUpdateManyWithoutUserNestedInput
    OffersAdmin?: OffersAdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutQuestionsAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
    resumesResumes?: ResumesResumeUncheckedUpdateManyWithoutUserNestedInput
    resumesStars?: ResumesStarUncheckedUpdateManyWithoutUserNestedInput
    resumesComments?: ResumesCommentUncheckedUpdateManyWithoutUserNestedInput
    resumesCommentVotes?: ResumesCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestions?: QuestionsQuestionUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionVotes?: QuestionsQuestionVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionComments?: QuestionsQuestionCommentUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerVotes?: QuestionsAnswerVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerComments?: QuestionsAnswerCommentUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    OffersProfile?: OffersProfileUncheckedUpdateManyWithoutUsersNestedInput
    offersDiscussion?: OffersReplyUncheckedUpdateManyWithoutUserNestedInput
    questionsLists?: QuestionsListUncheckedUpdateManyWithoutUserNestedInput
    OffersAdmin?: OffersAdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type QuestionsQuestionUpsertWithoutAnswersInput = {
    update: XOR<QuestionsQuestionUpdateWithoutAnswersInput, QuestionsQuestionUncheckedUpdateWithoutAnswersInput>
    create: XOR<QuestionsQuestionCreateWithoutAnswersInput, QuestionsQuestionUncheckedCreateWithoutAnswersInput>
  }

  export type QuestionsQuestionUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionsQuestionTypeFieldUpdateOperationsInput | QuestionsQuestionType
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    numEncounters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutQuestionsQuestionsNestedInput
    encounters?: QuestionsQuestionEncounterUpdateManyWithoutQuestionNestedInput
    votes?: QuestionsQuestionVoteUpdateManyWithoutQuestionNestedInput
    comments?: QuestionsQuestionCommentUpdateManyWithoutQuestionNestedInput
    questionsListQuestionEntries?: QuestionsListQuestionEntryUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionsQuestionUncheckedUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionsQuestionTypeFieldUpdateOperationsInput | QuestionsQuestionType
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    numEncounters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounters?: QuestionsQuestionEncounterUncheckedUpdateManyWithoutQuestionNestedInput
    votes?: QuestionsQuestionVoteUncheckedUpdateManyWithoutQuestionNestedInput
    comments?: QuestionsQuestionCommentUncheckedUpdateManyWithoutQuestionNestedInput
    questionsListQuestionEntries?: QuestionsListQuestionEntryUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionsAnswerVoteUpsertWithWhereUniqueWithoutAnswerInput = {
    where: QuestionsAnswerVoteWhereUniqueInput
    update: XOR<QuestionsAnswerVoteUpdateWithoutAnswerInput, QuestionsAnswerVoteUncheckedUpdateWithoutAnswerInput>
    create: XOR<QuestionsAnswerVoteCreateWithoutAnswerInput, QuestionsAnswerVoteUncheckedCreateWithoutAnswerInput>
  }

  export type QuestionsAnswerVoteUpdateWithWhereUniqueWithoutAnswerInput = {
    where: QuestionsAnswerVoteWhereUniqueInput
    data: XOR<QuestionsAnswerVoteUpdateWithoutAnswerInput, QuestionsAnswerVoteUncheckedUpdateWithoutAnswerInput>
  }

  export type QuestionsAnswerVoteUpdateManyWithWhereWithoutAnswerInput = {
    where: QuestionsAnswerVoteScalarWhereInput
    data: XOR<QuestionsAnswerVoteUpdateManyMutationInput, QuestionsAnswerVoteUncheckedUpdateManyWithoutVotesInput>
  }

  export type QuestionsAnswerCommentUpsertWithWhereUniqueWithoutAnswerInput = {
    where: QuestionsAnswerCommentWhereUniqueInput
    update: XOR<QuestionsAnswerCommentUpdateWithoutAnswerInput, QuestionsAnswerCommentUncheckedUpdateWithoutAnswerInput>
    create: XOR<QuestionsAnswerCommentCreateWithoutAnswerInput, QuestionsAnswerCommentUncheckedCreateWithoutAnswerInput>
  }

  export type QuestionsAnswerCommentUpdateWithWhereUniqueWithoutAnswerInput = {
    where: QuestionsAnswerCommentWhereUniqueInput
    data: XOR<QuestionsAnswerCommentUpdateWithoutAnswerInput, QuestionsAnswerCommentUncheckedUpdateWithoutAnswerInput>
  }

  export type QuestionsAnswerCommentUpdateManyWithWhereWithoutAnswerInput = {
    where: QuestionsAnswerCommentScalarWhereInput
    data: XOR<QuestionsAnswerCommentUpdateManyMutationInput, QuestionsAnswerCommentUncheckedUpdateManyWithoutCommentsInput>
  }

  export type UserCreateWithoutQuestionsAnswerVotesInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    todos?: TodoCreateNestedManyWithoutUserInput
    resumesResumes?: ResumesResumeCreateNestedManyWithoutUserInput
    resumesStars?: ResumesStarCreateNestedManyWithoutUserInput
    resumesComments?: ResumesCommentCreateNestedManyWithoutUserInput
    resumesCommentVotes?: ResumesCommentVoteCreateNestedManyWithoutUserInput
    questionsQuestions?: QuestionsQuestionCreateNestedManyWithoutUserInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterCreateNestedManyWithoutUserInput
    questionsQuestionVotes?: QuestionsQuestionVoteCreateNestedManyWithoutUserInput
    questionsQuestionComments?: QuestionsQuestionCommentCreateNestedManyWithoutUserInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteCreateNestedManyWithoutUserInput
    questionsAnswers?: QuestionsAnswerCreateNestedManyWithoutUserInput
    questionsAnswerComments?: QuestionsAnswerCommentCreateNestedManyWithoutUserInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteCreateNestedManyWithoutUserInput
    OffersProfile?: OffersProfileCreateNestedManyWithoutUsersInput
    offersDiscussion?: OffersReplyCreateNestedManyWithoutUserInput
    questionsLists?: QuestionsListCreateNestedManyWithoutUserInput
    OffersAdmin?: OffersAdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutQuestionsAnswerVotesInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
    resumesResumes?: ResumesResumeUncheckedCreateNestedManyWithoutUserInput
    resumesStars?: ResumesStarUncheckedCreateNestedManyWithoutUserInput
    resumesComments?: ResumesCommentUncheckedCreateNestedManyWithoutUserInput
    resumesCommentVotes?: ResumesCommentVoteUncheckedCreateNestedManyWithoutUserInput
    questionsQuestions?: QuestionsQuestionUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionVotes?: QuestionsQuestionVoteUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionComments?: QuestionsQuestionCommentUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUncheckedCreateNestedManyWithoutUserInput
    questionsAnswers?: QuestionsAnswerUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerComments?: QuestionsAnswerCommentUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUncheckedCreateNestedManyWithoutUserInput
    OffersProfile?: OffersProfileUncheckedCreateNestedManyWithoutUsersInput
    offersDiscussion?: OffersReplyUncheckedCreateNestedManyWithoutUserInput
    questionsLists?: QuestionsListUncheckedCreateNestedManyWithoutUserInput
    OffersAdmin?: OffersAdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutQuestionsAnswerVotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuestionsAnswerVotesInput, UserUncheckedCreateWithoutQuestionsAnswerVotesInput>
  }

  export type QuestionsAnswerCreateWithoutVotesInput = {
    id?: string
    content: string
    upvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutQuestionsAnswersInput
    question: QuestionsQuestionCreateNestedOneWithoutAnswersInput
    comments?: QuestionsAnswerCommentCreateNestedManyWithoutAnswerInput
  }

  export type QuestionsAnswerUncheckedCreateWithoutVotesInput = {
    id?: string
    questionId: string
    userId?: string | null
    content: string
    upvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: QuestionsAnswerCommentUncheckedCreateNestedManyWithoutAnswerInput
  }

  export type QuestionsAnswerCreateOrConnectWithoutVotesInput = {
    where: QuestionsAnswerWhereUniqueInput
    create: XOR<QuestionsAnswerCreateWithoutVotesInput, QuestionsAnswerUncheckedCreateWithoutVotesInput>
  }

  export type UserUpsertWithoutQuestionsAnswerVotesInput = {
    update: XOR<UserUpdateWithoutQuestionsAnswerVotesInput, UserUncheckedUpdateWithoutQuestionsAnswerVotesInput>
    create: XOR<UserCreateWithoutQuestionsAnswerVotesInput, UserUncheckedCreateWithoutQuestionsAnswerVotesInput>
  }

  export type UserUpdateWithoutQuestionsAnswerVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
    resumesResumes?: ResumesResumeUpdateManyWithoutUserNestedInput
    resumesStars?: ResumesStarUpdateManyWithoutUserNestedInput
    resumesComments?: ResumesCommentUpdateManyWithoutUserNestedInput
    resumesCommentVotes?: ResumesCommentVoteUpdateManyWithoutUserNestedInput
    questionsQuestions?: QuestionsQuestionUpdateManyWithoutUserNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUpdateManyWithoutUserNestedInput
    questionsQuestionVotes?: QuestionsQuestionVoteUpdateManyWithoutUserNestedInput
    questionsQuestionComments?: QuestionsQuestionCommentUpdateManyWithoutUserNestedInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUpdateManyWithoutUserNestedInput
    questionsAnswers?: QuestionsAnswerUpdateManyWithoutUserNestedInput
    questionsAnswerComments?: QuestionsAnswerCommentUpdateManyWithoutUserNestedInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUpdateManyWithoutUserNestedInput
    OffersProfile?: OffersProfileUpdateManyWithoutUsersNestedInput
    offersDiscussion?: OffersReplyUpdateManyWithoutUserNestedInput
    questionsLists?: QuestionsListUpdateManyWithoutUserNestedInput
    OffersAdmin?: OffersAdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutQuestionsAnswerVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
    resumesResumes?: ResumesResumeUncheckedUpdateManyWithoutUserNestedInput
    resumesStars?: ResumesStarUncheckedUpdateManyWithoutUserNestedInput
    resumesComments?: ResumesCommentUncheckedUpdateManyWithoutUserNestedInput
    resumesCommentVotes?: ResumesCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestions?: QuestionsQuestionUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionVotes?: QuestionsQuestionVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionComments?: QuestionsQuestionCommentUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswers?: QuestionsAnswerUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerComments?: QuestionsAnswerCommentUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    OffersProfile?: OffersProfileUncheckedUpdateManyWithoutUsersNestedInput
    offersDiscussion?: OffersReplyUncheckedUpdateManyWithoutUserNestedInput
    questionsLists?: QuestionsListUncheckedUpdateManyWithoutUserNestedInput
    OffersAdmin?: OffersAdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type QuestionsAnswerUpsertWithoutVotesInput = {
    update: XOR<QuestionsAnswerUpdateWithoutVotesInput, QuestionsAnswerUncheckedUpdateWithoutVotesInput>
    create: XOR<QuestionsAnswerCreateWithoutVotesInput, QuestionsAnswerUncheckedCreateWithoutVotesInput>
  }

  export type QuestionsAnswerUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutQuestionsAnswersNestedInput
    question?: QuestionsQuestionUpdateOneRequiredWithoutAnswersNestedInput
    comments?: QuestionsAnswerCommentUpdateManyWithoutAnswerNestedInput
  }

  export type QuestionsAnswerUncheckedUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: QuestionsAnswerCommentUncheckedUpdateManyWithoutAnswerNestedInput
  }

  export type UserCreateWithoutQuestionsAnswerCommentsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    todos?: TodoCreateNestedManyWithoutUserInput
    resumesResumes?: ResumesResumeCreateNestedManyWithoutUserInput
    resumesStars?: ResumesStarCreateNestedManyWithoutUserInput
    resumesComments?: ResumesCommentCreateNestedManyWithoutUserInput
    resumesCommentVotes?: ResumesCommentVoteCreateNestedManyWithoutUserInput
    questionsQuestions?: QuestionsQuestionCreateNestedManyWithoutUserInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterCreateNestedManyWithoutUserInput
    questionsQuestionVotes?: QuestionsQuestionVoteCreateNestedManyWithoutUserInput
    questionsQuestionComments?: QuestionsQuestionCommentCreateNestedManyWithoutUserInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteCreateNestedManyWithoutUserInput
    questionsAnswers?: QuestionsAnswerCreateNestedManyWithoutUserInput
    questionsAnswerVotes?: QuestionsAnswerVoteCreateNestedManyWithoutUserInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteCreateNestedManyWithoutUserInput
    OffersProfile?: OffersProfileCreateNestedManyWithoutUsersInput
    offersDiscussion?: OffersReplyCreateNestedManyWithoutUserInput
    questionsLists?: QuestionsListCreateNestedManyWithoutUserInput
    OffersAdmin?: OffersAdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutQuestionsAnswerCommentsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
    resumesResumes?: ResumesResumeUncheckedCreateNestedManyWithoutUserInput
    resumesStars?: ResumesStarUncheckedCreateNestedManyWithoutUserInput
    resumesComments?: ResumesCommentUncheckedCreateNestedManyWithoutUserInput
    resumesCommentVotes?: ResumesCommentVoteUncheckedCreateNestedManyWithoutUserInput
    questionsQuestions?: QuestionsQuestionUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionVotes?: QuestionsQuestionVoteUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionComments?: QuestionsQuestionCommentUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUncheckedCreateNestedManyWithoutUserInput
    questionsAnswers?: QuestionsAnswerUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerVotes?: QuestionsAnswerVoteUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUncheckedCreateNestedManyWithoutUserInput
    OffersProfile?: OffersProfileUncheckedCreateNestedManyWithoutUsersInput
    offersDiscussion?: OffersReplyUncheckedCreateNestedManyWithoutUserInput
    questionsLists?: QuestionsListUncheckedCreateNestedManyWithoutUserInput
    OffersAdmin?: OffersAdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutQuestionsAnswerCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuestionsAnswerCommentsInput, UserUncheckedCreateWithoutQuestionsAnswerCommentsInput>
  }

  export type QuestionsAnswerCreateWithoutCommentsInput = {
    id?: string
    content: string
    upvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutQuestionsAnswersInput
    question: QuestionsQuestionCreateNestedOneWithoutAnswersInput
    votes?: QuestionsAnswerVoteCreateNestedManyWithoutAnswerInput
  }

  export type QuestionsAnswerUncheckedCreateWithoutCommentsInput = {
    id?: string
    questionId: string
    userId?: string | null
    content: string
    upvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: QuestionsAnswerVoteUncheckedCreateNestedManyWithoutAnswerInput
  }

  export type QuestionsAnswerCreateOrConnectWithoutCommentsInput = {
    where: QuestionsAnswerWhereUniqueInput
    create: XOR<QuestionsAnswerCreateWithoutCommentsInput, QuestionsAnswerUncheckedCreateWithoutCommentsInput>
  }

  export type QuestionsAnswerCommentVoteCreateWithoutCommentInput = {
    id?: string
    vote: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutQuestionsAnswerCommentVotesInput
  }

  export type QuestionsAnswerCommentVoteUncheckedCreateWithoutCommentInput = {
    id?: string
    userId?: string | null
    vote: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsAnswerCommentVoteCreateOrConnectWithoutCommentInput = {
    where: QuestionsAnswerCommentVoteWhereUniqueInput
    create: XOR<QuestionsAnswerCommentVoteCreateWithoutCommentInput, QuestionsAnswerCommentVoteUncheckedCreateWithoutCommentInput>
  }

  export type QuestionsAnswerCommentVoteCreateManyCommentInputEnvelope = {
    data: Enumerable<QuestionsAnswerCommentVoteCreateManyCommentInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutQuestionsAnswerCommentsInput = {
    update: XOR<UserUpdateWithoutQuestionsAnswerCommentsInput, UserUncheckedUpdateWithoutQuestionsAnswerCommentsInput>
    create: XOR<UserCreateWithoutQuestionsAnswerCommentsInput, UserUncheckedCreateWithoutQuestionsAnswerCommentsInput>
  }

  export type UserUpdateWithoutQuestionsAnswerCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
    resumesResumes?: ResumesResumeUpdateManyWithoutUserNestedInput
    resumesStars?: ResumesStarUpdateManyWithoutUserNestedInput
    resumesComments?: ResumesCommentUpdateManyWithoutUserNestedInput
    resumesCommentVotes?: ResumesCommentVoteUpdateManyWithoutUserNestedInput
    questionsQuestions?: QuestionsQuestionUpdateManyWithoutUserNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUpdateManyWithoutUserNestedInput
    questionsQuestionVotes?: QuestionsQuestionVoteUpdateManyWithoutUserNestedInput
    questionsQuestionComments?: QuestionsQuestionCommentUpdateManyWithoutUserNestedInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUpdateManyWithoutUserNestedInput
    questionsAnswers?: QuestionsAnswerUpdateManyWithoutUserNestedInput
    questionsAnswerVotes?: QuestionsAnswerVoteUpdateManyWithoutUserNestedInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUpdateManyWithoutUserNestedInput
    OffersProfile?: OffersProfileUpdateManyWithoutUsersNestedInput
    offersDiscussion?: OffersReplyUpdateManyWithoutUserNestedInput
    questionsLists?: QuestionsListUpdateManyWithoutUserNestedInput
    OffersAdmin?: OffersAdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutQuestionsAnswerCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
    resumesResumes?: ResumesResumeUncheckedUpdateManyWithoutUserNestedInput
    resumesStars?: ResumesStarUncheckedUpdateManyWithoutUserNestedInput
    resumesComments?: ResumesCommentUncheckedUpdateManyWithoutUserNestedInput
    resumesCommentVotes?: ResumesCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestions?: QuestionsQuestionUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionVotes?: QuestionsQuestionVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionComments?: QuestionsQuestionCommentUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswers?: QuestionsAnswerUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerVotes?: QuestionsAnswerVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    OffersProfile?: OffersProfileUncheckedUpdateManyWithoutUsersNestedInput
    offersDiscussion?: OffersReplyUncheckedUpdateManyWithoutUserNestedInput
    questionsLists?: QuestionsListUncheckedUpdateManyWithoutUserNestedInput
    OffersAdmin?: OffersAdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type QuestionsAnswerUpsertWithoutCommentsInput = {
    update: XOR<QuestionsAnswerUpdateWithoutCommentsInput, QuestionsAnswerUncheckedUpdateWithoutCommentsInput>
    create: XOR<QuestionsAnswerCreateWithoutCommentsInput, QuestionsAnswerUncheckedCreateWithoutCommentsInput>
  }

  export type QuestionsAnswerUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutQuestionsAnswersNestedInput
    question?: QuestionsQuestionUpdateOneRequiredWithoutAnswersNestedInput
    votes?: QuestionsAnswerVoteUpdateManyWithoutAnswerNestedInput
  }

  export type QuestionsAnswerUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: QuestionsAnswerVoteUncheckedUpdateManyWithoutAnswerNestedInput
  }

  export type QuestionsAnswerCommentVoteUpsertWithWhereUniqueWithoutCommentInput = {
    where: QuestionsAnswerCommentVoteWhereUniqueInput
    update: XOR<QuestionsAnswerCommentVoteUpdateWithoutCommentInput, QuestionsAnswerCommentVoteUncheckedUpdateWithoutCommentInput>
    create: XOR<QuestionsAnswerCommentVoteCreateWithoutCommentInput, QuestionsAnswerCommentVoteUncheckedCreateWithoutCommentInput>
  }

  export type QuestionsAnswerCommentVoteUpdateWithWhereUniqueWithoutCommentInput = {
    where: QuestionsAnswerCommentVoteWhereUniqueInput
    data: XOR<QuestionsAnswerCommentVoteUpdateWithoutCommentInput, QuestionsAnswerCommentVoteUncheckedUpdateWithoutCommentInput>
  }

  export type QuestionsAnswerCommentVoteUpdateManyWithWhereWithoutCommentInput = {
    where: QuestionsAnswerCommentVoteScalarWhereInput
    data: XOR<QuestionsAnswerCommentVoteUpdateManyMutationInput, QuestionsAnswerCommentVoteUncheckedUpdateManyWithoutVotesInput>
  }

  export type UserCreateWithoutQuestionsAnswerCommentVotesInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    todos?: TodoCreateNestedManyWithoutUserInput
    resumesResumes?: ResumesResumeCreateNestedManyWithoutUserInput
    resumesStars?: ResumesStarCreateNestedManyWithoutUserInput
    resumesComments?: ResumesCommentCreateNestedManyWithoutUserInput
    resumesCommentVotes?: ResumesCommentVoteCreateNestedManyWithoutUserInput
    questionsQuestions?: QuestionsQuestionCreateNestedManyWithoutUserInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterCreateNestedManyWithoutUserInput
    questionsQuestionVotes?: QuestionsQuestionVoteCreateNestedManyWithoutUserInput
    questionsQuestionComments?: QuestionsQuestionCommentCreateNestedManyWithoutUserInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteCreateNestedManyWithoutUserInput
    questionsAnswers?: QuestionsAnswerCreateNestedManyWithoutUserInput
    questionsAnswerVotes?: QuestionsAnswerVoteCreateNestedManyWithoutUserInput
    questionsAnswerComments?: QuestionsAnswerCommentCreateNestedManyWithoutUserInput
    OffersProfile?: OffersProfileCreateNestedManyWithoutUsersInput
    offersDiscussion?: OffersReplyCreateNestedManyWithoutUserInput
    questionsLists?: QuestionsListCreateNestedManyWithoutUserInput
    OffersAdmin?: OffersAdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutQuestionsAnswerCommentVotesInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
    resumesResumes?: ResumesResumeUncheckedCreateNestedManyWithoutUserInput
    resumesStars?: ResumesStarUncheckedCreateNestedManyWithoutUserInput
    resumesComments?: ResumesCommentUncheckedCreateNestedManyWithoutUserInput
    resumesCommentVotes?: ResumesCommentVoteUncheckedCreateNestedManyWithoutUserInput
    questionsQuestions?: QuestionsQuestionUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionVotes?: QuestionsQuestionVoteUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionComments?: QuestionsQuestionCommentUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUncheckedCreateNestedManyWithoutUserInput
    questionsAnswers?: QuestionsAnswerUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerVotes?: QuestionsAnswerVoteUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerComments?: QuestionsAnswerCommentUncheckedCreateNestedManyWithoutUserInput
    OffersProfile?: OffersProfileUncheckedCreateNestedManyWithoutUsersInput
    offersDiscussion?: OffersReplyUncheckedCreateNestedManyWithoutUserInput
    questionsLists?: QuestionsListUncheckedCreateNestedManyWithoutUserInput
    OffersAdmin?: OffersAdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutQuestionsAnswerCommentVotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuestionsAnswerCommentVotesInput, UserUncheckedCreateWithoutQuestionsAnswerCommentVotesInput>
  }

  export type QuestionsAnswerCommentCreateWithoutVotesInput = {
    id?: string
    content: string
    upvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutQuestionsAnswerCommentsInput
    answer: QuestionsAnswerCreateNestedOneWithoutCommentsInput
  }

  export type QuestionsAnswerCommentUncheckedCreateWithoutVotesInput = {
    id?: string
    answerId: string
    userId?: string | null
    content: string
    upvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsAnswerCommentCreateOrConnectWithoutVotesInput = {
    where: QuestionsAnswerCommentWhereUniqueInput
    create: XOR<QuestionsAnswerCommentCreateWithoutVotesInput, QuestionsAnswerCommentUncheckedCreateWithoutVotesInput>
  }

  export type UserUpsertWithoutQuestionsAnswerCommentVotesInput = {
    update: XOR<UserUpdateWithoutQuestionsAnswerCommentVotesInput, UserUncheckedUpdateWithoutQuestionsAnswerCommentVotesInput>
    create: XOR<UserCreateWithoutQuestionsAnswerCommentVotesInput, UserUncheckedCreateWithoutQuestionsAnswerCommentVotesInput>
  }

  export type UserUpdateWithoutQuestionsAnswerCommentVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
    resumesResumes?: ResumesResumeUpdateManyWithoutUserNestedInput
    resumesStars?: ResumesStarUpdateManyWithoutUserNestedInput
    resumesComments?: ResumesCommentUpdateManyWithoutUserNestedInput
    resumesCommentVotes?: ResumesCommentVoteUpdateManyWithoutUserNestedInput
    questionsQuestions?: QuestionsQuestionUpdateManyWithoutUserNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUpdateManyWithoutUserNestedInput
    questionsQuestionVotes?: QuestionsQuestionVoteUpdateManyWithoutUserNestedInput
    questionsQuestionComments?: QuestionsQuestionCommentUpdateManyWithoutUserNestedInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUpdateManyWithoutUserNestedInput
    questionsAnswers?: QuestionsAnswerUpdateManyWithoutUserNestedInput
    questionsAnswerVotes?: QuestionsAnswerVoteUpdateManyWithoutUserNestedInput
    questionsAnswerComments?: QuestionsAnswerCommentUpdateManyWithoutUserNestedInput
    OffersProfile?: OffersProfileUpdateManyWithoutUsersNestedInput
    offersDiscussion?: OffersReplyUpdateManyWithoutUserNestedInput
    questionsLists?: QuestionsListUpdateManyWithoutUserNestedInput
    OffersAdmin?: OffersAdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutQuestionsAnswerCommentVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
    resumesResumes?: ResumesResumeUncheckedUpdateManyWithoutUserNestedInput
    resumesStars?: ResumesStarUncheckedUpdateManyWithoutUserNestedInput
    resumesComments?: ResumesCommentUncheckedUpdateManyWithoutUserNestedInput
    resumesCommentVotes?: ResumesCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestions?: QuestionsQuestionUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionVotes?: QuestionsQuestionVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionComments?: QuestionsQuestionCommentUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswers?: QuestionsAnswerUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerVotes?: QuestionsAnswerVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerComments?: QuestionsAnswerCommentUncheckedUpdateManyWithoutUserNestedInput
    OffersProfile?: OffersProfileUncheckedUpdateManyWithoutUsersNestedInput
    offersDiscussion?: OffersReplyUncheckedUpdateManyWithoutUserNestedInput
    questionsLists?: QuestionsListUncheckedUpdateManyWithoutUserNestedInput
    OffersAdmin?: OffersAdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type QuestionsAnswerCommentUpsertWithoutVotesInput = {
    update: XOR<QuestionsAnswerCommentUpdateWithoutVotesInput, QuestionsAnswerCommentUncheckedUpdateWithoutVotesInput>
    create: XOR<QuestionsAnswerCommentCreateWithoutVotesInput, QuestionsAnswerCommentUncheckedCreateWithoutVotesInput>
  }

  export type QuestionsAnswerCommentUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutQuestionsAnswerCommentsNestedInput
    answer?: QuestionsAnswerUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type QuestionsAnswerCommentUncheckedUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    answerId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutQuestionsListsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    todos?: TodoCreateNestedManyWithoutUserInput
    resumesResumes?: ResumesResumeCreateNestedManyWithoutUserInput
    resumesStars?: ResumesStarCreateNestedManyWithoutUserInput
    resumesComments?: ResumesCommentCreateNestedManyWithoutUserInput
    resumesCommentVotes?: ResumesCommentVoteCreateNestedManyWithoutUserInput
    questionsQuestions?: QuestionsQuestionCreateNestedManyWithoutUserInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterCreateNestedManyWithoutUserInput
    questionsQuestionVotes?: QuestionsQuestionVoteCreateNestedManyWithoutUserInput
    questionsQuestionComments?: QuestionsQuestionCommentCreateNestedManyWithoutUserInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteCreateNestedManyWithoutUserInput
    questionsAnswers?: QuestionsAnswerCreateNestedManyWithoutUserInput
    questionsAnswerVotes?: QuestionsAnswerVoteCreateNestedManyWithoutUserInput
    questionsAnswerComments?: QuestionsAnswerCommentCreateNestedManyWithoutUserInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteCreateNestedManyWithoutUserInput
    OffersProfile?: OffersProfileCreateNestedManyWithoutUsersInput
    offersDiscussion?: OffersReplyCreateNestedManyWithoutUserInput
    OffersAdmin?: OffersAdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutQuestionsListsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
    resumesResumes?: ResumesResumeUncheckedCreateNestedManyWithoutUserInput
    resumesStars?: ResumesStarUncheckedCreateNestedManyWithoutUserInput
    resumesComments?: ResumesCommentUncheckedCreateNestedManyWithoutUserInput
    resumesCommentVotes?: ResumesCommentVoteUncheckedCreateNestedManyWithoutUserInput
    questionsQuestions?: QuestionsQuestionUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionVotes?: QuestionsQuestionVoteUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionComments?: QuestionsQuestionCommentUncheckedCreateNestedManyWithoutUserInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUncheckedCreateNestedManyWithoutUserInput
    questionsAnswers?: QuestionsAnswerUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerVotes?: QuestionsAnswerVoteUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerComments?: QuestionsAnswerCommentUncheckedCreateNestedManyWithoutUserInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUncheckedCreateNestedManyWithoutUserInput
    OffersProfile?: OffersProfileUncheckedCreateNestedManyWithoutUsersInput
    offersDiscussion?: OffersReplyUncheckedCreateNestedManyWithoutUserInput
    OffersAdmin?: OffersAdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutQuestionsListsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuestionsListsInput, UserUncheckedCreateWithoutQuestionsListsInput>
  }

  export type QuestionsListQuestionEntryCreateWithoutListInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    question: QuestionsQuestionCreateNestedOneWithoutQuestionsListQuestionEntriesInput
  }

  export type QuestionsListQuestionEntryUncheckedCreateWithoutListInput = {
    id?: string
    questionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsListQuestionEntryCreateOrConnectWithoutListInput = {
    where: QuestionsListQuestionEntryWhereUniqueInput
    create: XOR<QuestionsListQuestionEntryCreateWithoutListInput, QuestionsListQuestionEntryUncheckedCreateWithoutListInput>
  }

  export type QuestionsListQuestionEntryCreateManyListInputEnvelope = {
    data: Enumerable<QuestionsListQuestionEntryCreateManyListInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutQuestionsListsInput = {
    update: XOR<UserUpdateWithoutQuestionsListsInput, UserUncheckedUpdateWithoutQuestionsListsInput>
    create: XOR<UserCreateWithoutQuestionsListsInput, UserUncheckedCreateWithoutQuestionsListsInput>
  }

  export type UserUpdateWithoutQuestionsListsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
    resumesResumes?: ResumesResumeUpdateManyWithoutUserNestedInput
    resumesStars?: ResumesStarUpdateManyWithoutUserNestedInput
    resumesComments?: ResumesCommentUpdateManyWithoutUserNestedInput
    resumesCommentVotes?: ResumesCommentVoteUpdateManyWithoutUserNestedInput
    questionsQuestions?: QuestionsQuestionUpdateManyWithoutUserNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUpdateManyWithoutUserNestedInput
    questionsQuestionVotes?: QuestionsQuestionVoteUpdateManyWithoutUserNestedInput
    questionsQuestionComments?: QuestionsQuestionCommentUpdateManyWithoutUserNestedInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUpdateManyWithoutUserNestedInput
    questionsAnswers?: QuestionsAnswerUpdateManyWithoutUserNestedInput
    questionsAnswerVotes?: QuestionsAnswerVoteUpdateManyWithoutUserNestedInput
    questionsAnswerComments?: QuestionsAnswerCommentUpdateManyWithoutUserNestedInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUpdateManyWithoutUserNestedInput
    OffersProfile?: OffersProfileUpdateManyWithoutUsersNestedInput
    offersDiscussion?: OffersReplyUpdateManyWithoutUserNestedInput
    OffersAdmin?: OffersAdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutQuestionsListsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
    resumesResumes?: ResumesResumeUncheckedUpdateManyWithoutUserNestedInput
    resumesStars?: ResumesStarUncheckedUpdateManyWithoutUserNestedInput
    resumesComments?: ResumesCommentUncheckedUpdateManyWithoutUserNestedInput
    resumesCommentVotes?: ResumesCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestions?: QuestionsQuestionUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionVotes?: QuestionsQuestionVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionComments?: QuestionsQuestionCommentUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswers?: QuestionsAnswerUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerVotes?: QuestionsAnswerVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerComments?: QuestionsAnswerCommentUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    OffersProfile?: OffersProfileUncheckedUpdateManyWithoutUsersNestedInput
    offersDiscussion?: OffersReplyUncheckedUpdateManyWithoutUserNestedInput
    OffersAdmin?: OffersAdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type QuestionsListQuestionEntryUpsertWithWhereUniqueWithoutListInput = {
    where: QuestionsListQuestionEntryWhereUniqueInput
    update: XOR<QuestionsListQuestionEntryUpdateWithoutListInput, QuestionsListQuestionEntryUncheckedUpdateWithoutListInput>
    create: XOR<QuestionsListQuestionEntryCreateWithoutListInput, QuestionsListQuestionEntryUncheckedCreateWithoutListInput>
  }

  export type QuestionsListQuestionEntryUpdateWithWhereUniqueWithoutListInput = {
    where: QuestionsListQuestionEntryWhereUniqueInput
    data: XOR<QuestionsListQuestionEntryUpdateWithoutListInput, QuestionsListQuestionEntryUncheckedUpdateWithoutListInput>
  }

  export type QuestionsListQuestionEntryUpdateManyWithWhereWithoutListInput = {
    where: QuestionsListQuestionEntryScalarWhereInput
    data: XOR<QuestionsListQuestionEntryUpdateManyMutationInput, QuestionsListQuestionEntryUncheckedUpdateManyWithoutQuestionEntriesInput>
  }

  export type QuestionsListCreateWithoutQuestionEntriesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutQuestionsListsInput
  }

  export type QuestionsListUncheckedCreateWithoutQuestionEntriesInput = {
    id?: string
    userId: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsListCreateOrConnectWithoutQuestionEntriesInput = {
    where: QuestionsListWhereUniqueInput
    create: XOR<QuestionsListCreateWithoutQuestionEntriesInput, QuestionsListUncheckedCreateWithoutQuestionEntriesInput>
  }

  export type QuestionsQuestionCreateWithoutQuestionsListQuestionEntriesInput = {
    id?: string
    content: string
    questionType: QuestionsQuestionType
    lastSeenAt?: Date | string | null
    upvotes?: number
    numEncounters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutQuestionsQuestionsInput
    encounters?: QuestionsQuestionEncounterCreateNestedManyWithoutQuestionInput
    votes?: QuestionsQuestionVoteCreateNestedManyWithoutQuestionInput
    comments?: QuestionsQuestionCommentCreateNestedManyWithoutQuestionInput
    answers?: QuestionsAnswerCreateNestedManyWithoutQuestionInput
  }

  export type QuestionsQuestionUncheckedCreateWithoutQuestionsListQuestionEntriesInput = {
    id?: string
    userId?: string | null
    content: string
    questionType: QuestionsQuestionType
    lastSeenAt?: Date | string | null
    upvotes?: number
    numEncounters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    encounters?: QuestionsQuestionEncounterUncheckedCreateNestedManyWithoutQuestionInput
    votes?: QuestionsQuestionVoteUncheckedCreateNestedManyWithoutQuestionInput
    comments?: QuestionsQuestionCommentUncheckedCreateNestedManyWithoutQuestionInput
    answers?: QuestionsAnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionsQuestionCreateOrConnectWithoutQuestionsListQuestionEntriesInput = {
    where: QuestionsQuestionWhereUniqueInput
    create: XOR<QuestionsQuestionCreateWithoutQuestionsListQuestionEntriesInput, QuestionsQuestionUncheckedCreateWithoutQuestionsListQuestionEntriesInput>
  }

  export type QuestionsListUpsertWithoutQuestionEntriesInput = {
    update: XOR<QuestionsListUpdateWithoutQuestionEntriesInput, QuestionsListUncheckedUpdateWithoutQuestionEntriesInput>
    create: XOR<QuestionsListCreateWithoutQuestionEntriesInput, QuestionsListUncheckedCreateWithoutQuestionEntriesInput>
  }

  export type QuestionsListUpdateWithoutQuestionEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutQuestionsListsNestedInput
  }

  export type QuestionsListUncheckedUpdateWithoutQuestionEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsQuestionUpsertWithoutQuestionsListQuestionEntriesInput = {
    update: XOR<QuestionsQuestionUpdateWithoutQuestionsListQuestionEntriesInput, QuestionsQuestionUncheckedUpdateWithoutQuestionsListQuestionEntriesInput>
    create: XOR<QuestionsQuestionCreateWithoutQuestionsListQuestionEntriesInput, QuestionsQuestionUncheckedCreateWithoutQuestionsListQuestionEntriesInput>
  }

  export type QuestionsQuestionUpdateWithoutQuestionsListQuestionEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionsQuestionTypeFieldUpdateOperationsInput | QuestionsQuestionType
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    numEncounters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutQuestionsQuestionsNestedInput
    encounters?: QuestionsQuestionEncounterUpdateManyWithoutQuestionNestedInput
    votes?: QuestionsQuestionVoteUpdateManyWithoutQuestionNestedInput
    comments?: QuestionsQuestionCommentUpdateManyWithoutQuestionNestedInput
    answers?: QuestionsAnswerUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionsQuestionUncheckedUpdateWithoutQuestionsListQuestionEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionsQuestionTypeFieldUpdateOperationsInput | QuestionsQuestionType
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    numEncounters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounters?: QuestionsQuestionEncounterUncheckedUpdateManyWithoutQuestionNestedInput
    votes?: QuestionsQuestionVoteUncheckedUpdateManyWithoutQuestionNestedInput
    comments?: QuestionsQuestionCommentUncheckedUpdateManyWithoutQuestionNestedInput
    answers?: QuestionsAnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type TodoCreateManyUserInput = {
    id?: string
    text: string
    status?: TodoStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResumesResumeCreateManyUserInput = {
    id?: string
    title: string
    role: string
    experience: string
    locationId: string
    url: string
    additionalInfo?: string | null
    isResolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResumesStarCreateManyUserInput = {
    id?: string
    resumeId: string
    createdAt?: Date | string
  }

  export type ResumesCommentCreateManyUserInput = {
    id?: string
    resumeId: string
    parentId?: string | null
    description: string
    section: ResumesSection
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResumesCommentVoteCreateManyUserInput = {
    id?: string
    commentId: string
    value: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsQuestionCreateManyUserInput = {
    id?: string
    content: string
    questionType: QuestionsQuestionType
    lastSeenAt?: Date | string | null
    upvotes?: number
    numEncounters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsQuestionEncounterCreateManyUserInput = {
    id?: string
    questionId: string
    companyId?: string | null
    countryId?: string | null
    stateId?: string | null
    cityId?: string | null
    role: string
    seenAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsQuestionVoteCreateManyUserInput = {
    id?: string
    questionId: string
    vote: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsQuestionCommentCreateManyUserInput = {
    id?: string
    questionId: string
    upvotes?: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsQuestionCommentVoteCreateManyUserInput = {
    id?: string
    questionCommentId: string
    vote: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsAnswerCreateManyUserInput = {
    id?: string
    questionId: string
    content: string
    upvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsAnswerVoteCreateManyUserInput = {
    id?: string
    answerId: string
    vote: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsAnswerCommentCreateManyUserInput = {
    id?: string
    answerId: string
    content: string
    upvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsAnswerCommentVoteCreateManyUserInput = {
    id?: string
    answerCommentId: string
    vote: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OffersReplyCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    message: string
    replyingToId?: string | null
    profileId: string
  }

  export type QuestionsListCreateManyUserInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodoUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    status?: EnumTodoStatusFieldUpdateOperationsInput | TodoStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodoUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    status?: EnumTodoStatusFieldUpdateOperationsInput | TodoStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodoUncheckedUpdateManyWithoutTodosInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    status?: EnumTodoStatusFieldUpdateOperationsInput | TodoStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumesResumeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    experience?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: CountryUpdateOneRequiredWithoutResumesResumeNestedInput
    stars?: ResumesStarUpdateManyWithoutResumeNestedInput
    comments?: ResumesCommentUpdateManyWithoutResumeNestedInput
  }

  export type ResumesResumeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    experience?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stars?: ResumesStarUncheckedUpdateManyWithoutResumeNestedInput
    comments?: ResumesCommentUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type ResumesResumeUncheckedUpdateManyWithoutResumesResumesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    experience?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumesStarUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resume?: ResumesResumeUpdateOneRequiredWithoutStarsNestedInput
  }

  export type ResumesStarUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumesStarUncheckedUpdateManyWithoutResumesStarsInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumesCommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    section?: EnumResumesSectionFieldUpdateOperationsInput | ResumesSection
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resume?: ResumesResumeUpdateOneRequiredWithoutCommentsNestedInput
    votes?: ResumesCommentVoteUpdateManyWithoutCommentNestedInput
    parent?: ResumesCommentUpdateOneWithoutChildrenNestedInput
    children?: ResumesCommentUpdateManyWithoutParentNestedInput
  }

  export type ResumesCommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    section?: EnumResumesSectionFieldUpdateOperationsInput | ResumesSection
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: ResumesCommentVoteUncheckedUpdateManyWithoutCommentNestedInput
    children?: ResumesCommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type ResumesCommentUncheckedUpdateManyWithoutResumesCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    section?: EnumResumesSectionFieldUpdateOperationsInput | ResumesSection
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumesCommentVoteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: ResumesCommentUpdateOneRequiredWithoutVotesNestedInput
  }

  export type ResumesCommentVoteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    value?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumesCommentVoteUncheckedUpdateManyWithoutResumesCommentVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    value?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsQuestionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionsQuestionTypeFieldUpdateOperationsInput | QuestionsQuestionType
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    numEncounters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounters?: QuestionsQuestionEncounterUpdateManyWithoutQuestionNestedInput
    votes?: QuestionsQuestionVoteUpdateManyWithoutQuestionNestedInput
    comments?: QuestionsQuestionCommentUpdateManyWithoutQuestionNestedInput
    answers?: QuestionsAnswerUpdateManyWithoutQuestionNestedInput
    questionsListQuestionEntries?: QuestionsListQuestionEntryUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionsQuestionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionsQuestionTypeFieldUpdateOperationsInput | QuestionsQuestionType
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    numEncounters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounters?: QuestionsQuestionEncounterUncheckedUpdateManyWithoutQuestionNestedInput
    votes?: QuestionsQuestionVoteUncheckedUpdateManyWithoutQuestionNestedInput
    comments?: QuestionsQuestionCommentUncheckedUpdateManyWithoutQuestionNestedInput
    answers?: QuestionsAnswerUncheckedUpdateManyWithoutQuestionNestedInput
    questionsListQuestionEntries?: QuestionsListQuestionEntryUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionsQuestionUncheckedUpdateManyWithoutQuestionsQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionsQuestionTypeFieldUpdateOperationsInput | QuestionsQuestionType
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    numEncounters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsQuestionEncounterUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    seenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: CountryUpdateOneWithoutQuestionsQuestionEncountersNestedInput
    state?: StateUpdateOneWithoutQuestionsQuestionEncountersNestedInput
    city?: CityUpdateOneWithoutQuestionsQuestionEncountersNestedInput
    company?: CompanyUpdateOneWithoutQuestionsQuestionEncounterNestedInput
    question?: QuestionsQuestionUpdateOneRequiredWithoutEncountersNestedInput
  }

  export type QuestionsQuestionEncounterUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    countryId?: NullableStringFieldUpdateOperationsInput | string | null
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    seenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsQuestionEncounterUncheckedUpdateManyWithoutQuestionsQuestionEncountersInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    countryId?: NullableStringFieldUpdateOperationsInput | string | null
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    seenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsQuestionVoteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    vote?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: QuestionsQuestionUpdateOneRequiredWithoutVotesNestedInput
  }

  export type QuestionsQuestionVoteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    vote?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsQuestionVoteUncheckedUpdateManyWithoutQuestionsQuestionVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    vote?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsQuestionCommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: QuestionsQuestionUpdateOneRequiredWithoutCommentsNestedInput
    votes?: QuestionsQuestionCommentVoteUpdateManyWithoutCommentNestedInput
  }

  export type QuestionsQuestionCommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: QuestionsQuestionCommentVoteUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type QuestionsQuestionCommentUncheckedUpdateManyWithoutQuestionsQuestionCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsQuestionCommentVoteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    vote?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: QuestionsQuestionCommentUpdateOneRequiredWithoutVotesNestedInput
  }

  export type QuestionsQuestionCommentVoteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionCommentId?: StringFieldUpdateOperationsInput | string
    vote?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsQuestionCommentVoteUncheckedUpdateManyWithoutQuestionsQuestionCommentVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionCommentId?: StringFieldUpdateOperationsInput | string
    vote?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsAnswerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: QuestionsQuestionUpdateOneRequiredWithoutAnswersNestedInput
    votes?: QuestionsAnswerVoteUpdateManyWithoutAnswerNestedInput
    comments?: QuestionsAnswerCommentUpdateManyWithoutAnswerNestedInput
  }

  export type QuestionsAnswerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: QuestionsAnswerVoteUncheckedUpdateManyWithoutAnswerNestedInput
    comments?: QuestionsAnswerCommentUncheckedUpdateManyWithoutAnswerNestedInput
  }

  export type QuestionsAnswerUncheckedUpdateManyWithoutQuestionsAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsAnswerVoteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    vote?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: QuestionsAnswerUpdateOneRequiredWithoutVotesNestedInput
  }

  export type QuestionsAnswerVoteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    answerId?: StringFieldUpdateOperationsInput | string
    vote?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsAnswerVoteUncheckedUpdateManyWithoutQuestionsAnswerVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    answerId?: StringFieldUpdateOperationsInput | string
    vote?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsAnswerCommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: QuestionsAnswerUpdateOneRequiredWithoutCommentsNestedInput
    votes?: QuestionsAnswerCommentVoteUpdateManyWithoutCommentNestedInput
  }

  export type QuestionsAnswerCommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    answerId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: QuestionsAnswerCommentVoteUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type QuestionsAnswerCommentUncheckedUpdateManyWithoutQuestionsAnswerCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    answerId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsAnswerCommentVoteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    vote?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: QuestionsAnswerCommentUpdateOneRequiredWithoutVotesNestedInput
  }

  export type QuestionsAnswerCommentVoteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    answerCommentId?: StringFieldUpdateOperationsInput | string
    vote?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsAnswerCommentVoteUncheckedUpdateManyWithoutQuestionsAnswerCommentVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    answerCommentId?: StringFieldUpdateOperationsInput | string
    vote?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OffersProfileUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    background?: OffersBackgroundUpdateOneWithoutProfileNestedInput
    editToken?: StringFieldUpdateOperationsInput | string
    discussion?: OffersReplyUpdateManyWithoutProfileNestedInput
    offers?: OffersOfferUpdateManyWithoutProfileNestedInput
    analysis?: OffersAnalysisUpdateOneWithoutProfileNestedInput
  }

  export type OffersProfileUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    background?: OffersBackgroundUncheckedUpdateOneWithoutProfileNestedInput
    editToken?: StringFieldUpdateOperationsInput | string
    discussion?: OffersReplyUncheckedUpdateManyWithoutProfileNestedInput
    offers?: OffersOfferUncheckedUpdateManyWithoutProfileNestedInput
    analysis?: OffersAnalysisUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type OffersProfileUncheckedUpdateManyWithoutOffersProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editToken?: StringFieldUpdateOperationsInput | string
  }

  export type OffersReplyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    replyingTo?: OffersReplyUpdateOneWithoutRepliesNestedInput
    replies?: OffersReplyUpdateManyWithoutReplyingToNestedInput
    profile?: OffersProfileUpdateOneRequiredWithoutDiscussionNestedInput
  }

  export type OffersReplyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    replyingToId?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: OffersReplyUncheckedUpdateManyWithoutReplyingToNestedInput
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type OffersReplyUncheckedUpdateManyWithoutOffersDiscussionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    replyingToId?: NullableStringFieldUpdateOperationsInput | string | null
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type QuestionsListUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionEntries?: QuestionsListQuestionEntryUpdateManyWithoutListNestedInput
  }

  export type QuestionsListUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionEntries?: QuestionsListQuestionEntryUncheckedUpdateManyWithoutListNestedInput
  }

  export type QuestionsListUncheckedUpdateManyWithoutQuestionsListsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsQuestionEncounterCreateManyCompanyInput = {
    id?: string
    questionId: string
    userId?: string | null
    countryId?: string | null
    stateId?: string | null
    cityId?: string | null
    role: string
    seenAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OffersExperienceCreateManyCompanyInput = {
    id?: string
    jobType?: JobType | null
    title?: string | null
    durationInMonths?: number | null
    cityId?: string | null
    level?: string | null
    totalCompensationId?: string | null
    monthlySalaryId?: string | null
    backgroundId: string
  }

  export type OffersOfferCreateManyCompanyInput = {
    id?: string
    profileId: string
    cityId: string
    monthYearReceived: Date | string
    negotiationStrategy: string
    comments: string
    jobType: JobType
    offersInternId?: string | null
    offersFullTimeId?: string | null
  }

  export type QuestionsQuestionEncounterUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    seenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: CountryUpdateOneWithoutQuestionsQuestionEncountersNestedInput
    state?: StateUpdateOneWithoutQuestionsQuestionEncountersNestedInput
    city?: CityUpdateOneWithoutQuestionsQuestionEncountersNestedInput
    user?: UserUpdateOneWithoutQuestionsQuestionEncountersNestedInput
    question?: QuestionsQuestionUpdateOneRequiredWithoutEncountersNestedInput
  }

  export type QuestionsQuestionEncounterUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    countryId?: NullableStringFieldUpdateOperationsInput | string | null
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    seenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsQuestionEncounterUncheckedUpdateManyWithoutQuestionsQuestionEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    countryId?: NullableStringFieldUpdateOperationsInput | string | null
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    seenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OffersExperienceUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobType?: NullableEnumJobTypeFieldUpdateOperationsInput | JobType | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    durationInMonths?: NullableIntFieldUpdateOperationsInput | number | null
    location?: CityUpdateOneWithoutOffersExperienceNestedInput
    level?: NullableStringFieldUpdateOperationsInput | string | null
    totalCompensation?: OffersCurrencyUpdateOneWithoutOffersExperienceTotalCompensationNestedInput
    monthlySalary?: OffersCurrencyUpdateOneWithoutOffersExperienceMonthlySalaryNestedInput
    background?: OffersBackgroundUpdateOneRequiredWithoutExperiencesNestedInput
  }

  export type OffersExperienceUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobType?: NullableEnumJobTypeFieldUpdateOperationsInput | JobType | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    durationInMonths?: NullableIntFieldUpdateOperationsInput | number | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    totalCompensationId?: NullableStringFieldUpdateOperationsInput | string | null
    monthlySalaryId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundId?: StringFieldUpdateOperationsInput | string
  }

  export type OffersExperienceUncheckedUpdateManyWithoutOffersExperienceInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobType?: NullableEnumJobTypeFieldUpdateOperationsInput | JobType | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    durationInMonths?: NullableIntFieldUpdateOperationsInput | number | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    totalCompensationId?: NullableStringFieldUpdateOperationsInput | string | null
    monthlySalaryId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundId?: StringFieldUpdateOperationsInput | string
  }

  export type OffersOfferUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile?: OffersProfileUpdateOneRequiredWithoutOffersNestedInput
    location?: CityUpdateOneRequiredWithoutOffersOfferNestedInput
    monthYearReceived?: DateTimeFieldUpdateOperationsInput | Date | string
    negotiationStrategy?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | JobType
    offersIntern?: OffersInternUpdateOneWithoutOffersOfferNestedInput
    offersFullTime?: OffersFullTimeUpdateOneWithoutOffersOfferNestedInput
    offersAnalysis?: OffersAnalysisUpdateOneWithoutOverallHighestOfferNestedInput
    offersAnalysisUnit?: OffersAnalysisUnitUpdateManyWithoutTopSimilarOffersNestedInput
    OffersAnalysisUnit?: OffersAnalysisUnitUpdateManyWithoutAnalysedOfferNestedInput
  }

  export type OffersOfferUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    monthYearReceived?: DateTimeFieldUpdateOperationsInput | Date | string
    negotiationStrategy?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | JobType
    offersInternId?: NullableStringFieldUpdateOperationsInput | string | null
    offersFullTimeId?: NullableStringFieldUpdateOperationsInput | string | null
    offersAnalysis?: OffersAnalysisUncheckedUpdateOneWithoutOverallHighestOfferNestedInput
    offersAnalysisUnit?: OffersAnalysisUnitUncheckedUpdateManyWithoutTopSimilarOffersNestedInput
    OffersAnalysisUnit?: OffersAnalysisUnitUncheckedUpdateManyWithoutAnalysedOfferNestedInput
  }

  export type OffersOfferUncheckedUpdateManyWithoutOffersOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    monthYearReceived?: DateTimeFieldUpdateOperationsInput | Date | string
    negotiationStrategy?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | JobType
    offersInternId?: NullableStringFieldUpdateOperationsInput | string | null
    offersFullTimeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StateCreateManyCountryInput = {
    id: string
    name: string
  }

  export type QuestionsQuestionEncounterCreateManyCountryInput = {
    id?: string
    questionId: string
    userId?: string | null
    companyId?: string | null
    stateId?: string | null
    cityId?: string | null
    role: string
    seenAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResumesResumeCreateManyLocationInput = {
    id?: string
    userId: string
    title: string
    role: string
    experience: string
    url: string
    additionalInfo?: string | null
    isResolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StateUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cities?: CityUpdateManyWithoutStateNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUpdateManyWithoutStateNestedInput
  }

  export type StateUncheckedUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cities?: CityUncheckedUpdateManyWithoutStateNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedUpdateManyWithoutStateNestedInput
  }

  export type StateUncheckedUpdateManyWithoutStatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type QuestionsQuestionEncounterUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    seenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: StateUpdateOneWithoutQuestionsQuestionEncountersNestedInput
    city?: CityUpdateOneWithoutQuestionsQuestionEncountersNestedInput
    company?: CompanyUpdateOneWithoutQuestionsQuestionEncounterNestedInput
    user?: UserUpdateOneWithoutQuestionsQuestionEncountersNestedInput
    question?: QuestionsQuestionUpdateOneRequiredWithoutEncountersNestedInput
  }

  export type QuestionsQuestionEncounterUncheckedUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    seenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumesResumeUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    experience?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutResumesResumesNestedInput
    stars?: ResumesStarUpdateManyWithoutResumeNestedInput
    comments?: ResumesCommentUpdateManyWithoutResumeNestedInput
  }

  export type ResumesResumeUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    experience?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stars?: ResumesStarUncheckedUpdateManyWithoutResumeNestedInput
    comments?: ResumesCommentUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type ResumesResumeUncheckedUpdateManyWithoutResumesResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    experience?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityCreateManyStateInput = {
    id: string
    name: string
    ranking?: number | null
  }

  export type QuestionsQuestionEncounterCreateManyStateInput = {
    id?: string
    questionId: string
    userId?: string | null
    companyId?: string | null
    countryId?: string | null
    cityId?: string | null
    role: string
    seenAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CityUpdateWithoutStateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    questionsQuestionEncounters?: QuestionsQuestionEncounterUpdateManyWithoutCityNestedInput
    OffersExperience?: OffersExperienceUpdateManyWithoutLocationNestedInput
    OffersOffer?: OffersOfferUpdateManyWithoutLocationNestedInput
  }

  export type CityUncheckedUpdateWithoutStateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedUpdateManyWithoutCityNestedInput
    OffersExperience?: OffersExperienceUncheckedUpdateManyWithoutLocationNestedInput
    OffersOffer?: OffersOfferUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type CityUncheckedUpdateManyWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuestionsQuestionEncounterUpdateWithoutStateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    seenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: CountryUpdateOneWithoutQuestionsQuestionEncountersNestedInput
    city?: CityUpdateOneWithoutQuestionsQuestionEncountersNestedInput
    company?: CompanyUpdateOneWithoutQuestionsQuestionEncounterNestedInput
    user?: UserUpdateOneWithoutQuestionsQuestionEncountersNestedInput
    question?: QuestionsQuestionUpdateOneRequiredWithoutEncountersNestedInput
  }

  export type QuestionsQuestionEncounterUncheckedUpdateWithoutStateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    countryId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    seenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsQuestionEncounterCreateManyCityInput = {
    id?: string
    questionId: string
    userId?: string | null
    companyId?: string | null
    countryId?: string | null
    stateId?: string | null
    role: string
    seenAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OffersExperienceCreateManyLocationInput = {
    id?: string
    companyId?: string | null
    jobType?: JobType | null
    title?: string | null
    durationInMonths?: number | null
    level?: string | null
    totalCompensationId?: string | null
    monthlySalaryId?: string | null
    backgroundId: string
  }

  export type OffersOfferCreateManyLocationInput = {
    id?: string
    profileId: string
    companyId: string
    monthYearReceived: Date | string
    negotiationStrategy: string
    comments: string
    jobType: JobType
    offersInternId?: string | null
    offersFullTimeId?: string | null
  }

  export type QuestionsQuestionEncounterUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    seenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: CountryUpdateOneWithoutQuestionsQuestionEncountersNestedInput
    state?: StateUpdateOneWithoutQuestionsQuestionEncountersNestedInput
    company?: CompanyUpdateOneWithoutQuestionsQuestionEncounterNestedInput
    user?: UserUpdateOneWithoutQuestionsQuestionEncountersNestedInput
    question?: QuestionsQuestionUpdateOneRequiredWithoutEncountersNestedInput
  }

  export type QuestionsQuestionEncounterUncheckedUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    countryId?: NullableStringFieldUpdateOperationsInput | string | null
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    seenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OffersExperienceUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: CompanyUpdateOneWithoutOffersExperienceNestedInput
    jobType?: NullableEnumJobTypeFieldUpdateOperationsInput | JobType | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    durationInMonths?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    totalCompensation?: OffersCurrencyUpdateOneWithoutOffersExperienceTotalCompensationNestedInput
    monthlySalary?: OffersCurrencyUpdateOneWithoutOffersExperienceMonthlySalaryNestedInput
    background?: OffersBackgroundUpdateOneRequiredWithoutExperiencesNestedInput
  }

  export type OffersExperienceUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    jobType?: NullableEnumJobTypeFieldUpdateOperationsInput | JobType | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    durationInMonths?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    totalCompensationId?: NullableStringFieldUpdateOperationsInput | string | null
    monthlySalaryId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundId?: StringFieldUpdateOperationsInput | string
  }

  export type OffersOfferUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile?: OffersProfileUpdateOneRequiredWithoutOffersNestedInput
    company?: CompanyUpdateOneRequiredWithoutOffersOfferNestedInput
    monthYearReceived?: DateTimeFieldUpdateOperationsInput | Date | string
    negotiationStrategy?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | JobType
    offersIntern?: OffersInternUpdateOneWithoutOffersOfferNestedInput
    offersFullTime?: OffersFullTimeUpdateOneWithoutOffersOfferNestedInput
    offersAnalysis?: OffersAnalysisUpdateOneWithoutOverallHighestOfferNestedInput
    offersAnalysisUnit?: OffersAnalysisUnitUpdateManyWithoutTopSimilarOffersNestedInput
    OffersAnalysisUnit?: OffersAnalysisUnitUpdateManyWithoutAnalysedOfferNestedInput
  }

  export type OffersOfferUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    monthYearReceived?: DateTimeFieldUpdateOperationsInput | Date | string
    negotiationStrategy?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | JobType
    offersInternId?: NullableStringFieldUpdateOperationsInput | string | null
    offersFullTimeId?: NullableStringFieldUpdateOperationsInput | string | null
    offersAnalysis?: OffersAnalysisUncheckedUpdateOneWithoutOverallHighestOfferNestedInput
    offersAnalysisUnit?: OffersAnalysisUnitUncheckedUpdateManyWithoutTopSimilarOffersNestedInput
    OffersAnalysisUnit?: OffersAnalysisUnitUncheckedUpdateManyWithoutAnalysedOfferNestedInput
  }

  export type ResumesStarCreateManyResumeInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type ResumesCommentCreateManyResumeInput = {
    id?: string
    userId: string
    parentId?: string | null
    description: string
    section: ResumesSection
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResumesStarUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutResumesStarsNestedInput
  }

  export type ResumesStarUncheckedUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumesStarUncheckedUpdateManyWithoutStarsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumesCommentUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    section?: EnumResumesSectionFieldUpdateOperationsInput | ResumesSection
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: ResumesCommentVoteUpdateManyWithoutCommentNestedInput
    user?: UserUpdateOneRequiredWithoutResumesCommentsNestedInput
    parent?: ResumesCommentUpdateOneWithoutChildrenNestedInput
    children?: ResumesCommentUpdateManyWithoutParentNestedInput
  }

  export type ResumesCommentUncheckedUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    section?: EnumResumesSectionFieldUpdateOperationsInput | ResumesSection
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: ResumesCommentVoteUncheckedUpdateManyWithoutCommentNestedInput
    children?: ResumesCommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type ResumesCommentUncheckedUpdateManyWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    section?: EnumResumesSectionFieldUpdateOperationsInput | ResumesSection
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumesCommentVoteCreateManyCommentInput = {
    id?: string
    userId: string
    value: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResumesCommentCreateManyParentInput = {
    id?: string
    userId: string
    resumeId: string
    description: string
    section: ResumesSection
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResumesCommentVoteUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutResumesCommentVotesNestedInput
  }

  export type ResumesCommentVoteUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    value?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumesCommentVoteUncheckedUpdateManyWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    value?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumesCommentUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    section?: EnumResumesSectionFieldUpdateOperationsInput | ResumesSection
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resume?: ResumesResumeUpdateOneRequiredWithoutCommentsNestedInput
    votes?: ResumesCommentVoteUpdateManyWithoutCommentNestedInput
    user?: UserUpdateOneRequiredWithoutResumesCommentsNestedInput
    children?: ResumesCommentUpdateManyWithoutParentNestedInput
  }

  export type ResumesCommentUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    section?: EnumResumesSectionFieldUpdateOperationsInput | ResumesSection
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: ResumesCommentVoteUncheckedUpdateManyWithoutCommentNestedInput
    children?: ResumesCommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type ResumesCommentUncheckedUpdateManyWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    section?: EnumResumesSectionFieldUpdateOperationsInput | ResumesSection
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OffersReplyCreateManyProfileInput = {
    id?: string
    createdAt?: Date | string
    message: string
    replyingToId?: string | null
    userId?: string | null
  }

  export type OffersOfferCreateManyProfileInput = {
    id?: string
    companyId: string
    cityId: string
    monthYearReceived: Date | string
    negotiationStrategy: string
    comments: string
    jobType: JobType
    offersInternId?: string | null
    offersFullTimeId?: string | null
  }

  export type OffersReplyUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    replyingTo?: OffersReplyUpdateOneWithoutRepliesNestedInput
    replies?: OffersReplyUpdateManyWithoutReplyingToNestedInput
    user?: UserUpdateOneWithoutOffersDiscussionNestedInput
  }

  export type OffersReplyUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    replyingToId?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: OffersReplyUncheckedUpdateManyWithoutReplyingToNestedInput
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OffersReplyUncheckedUpdateManyWithoutDiscussionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    replyingToId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OffersOfferUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: CompanyUpdateOneRequiredWithoutOffersOfferNestedInput
    location?: CityUpdateOneRequiredWithoutOffersOfferNestedInput
    monthYearReceived?: DateTimeFieldUpdateOperationsInput | Date | string
    negotiationStrategy?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | JobType
    offersIntern?: OffersInternUpdateOneWithoutOffersOfferNestedInput
    offersFullTime?: OffersFullTimeUpdateOneWithoutOffersOfferNestedInput
    offersAnalysis?: OffersAnalysisUpdateOneWithoutOverallHighestOfferNestedInput
    offersAnalysisUnit?: OffersAnalysisUnitUpdateManyWithoutTopSimilarOffersNestedInput
    OffersAnalysisUnit?: OffersAnalysisUnitUpdateManyWithoutAnalysedOfferNestedInput
  }

  export type OffersOfferUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    monthYearReceived?: DateTimeFieldUpdateOperationsInput | Date | string
    negotiationStrategy?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | JobType
    offersInternId?: NullableStringFieldUpdateOperationsInput | string | null
    offersFullTimeId?: NullableStringFieldUpdateOperationsInput | string | null
    offersAnalysis?: OffersAnalysisUncheckedUpdateOneWithoutOverallHighestOfferNestedInput
    offersAnalysisUnit?: OffersAnalysisUnitUncheckedUpdateManyWithoutTopSimilarOffersNestedInput
    OffersAnalysisUnit?: OffersAnalysisUnitUncheckedUpdateManyWithoutAnalysedOfferNestedInput
  }

  export type OffersOfferUncheckedUpdateManyWithoutOffersInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    monthYearReceived?: DateTimeFieldUpdateOperationsInput | Date | string
    negotiationStrategy?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | JobType
    offersInternId?: NullableStringFieldUpdateOperationsInput | string | null
    offersFullTimeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpdateWithoutOffersProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
    resumesResumes?: ResumesResumeUpdateManyWithoutUserNestedInput
    resumesStars?: ResumesStarUpdateManyWithoutUserNestedInput
    resumesComments?: ResumesCommentUpdateManyWithoutUserNestedInput
    resumesCommentVotes?: ResumesCommentVoteUpdateManyWithoutUserNestedInput
    questionsQuestions?: QuestionsQuestionUpdateManyWithoutUserNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUpdateManyWithoutUserNestedInput
    questionsQuestionVotes?: QuestionsQuestionVoteUpdateManyWithoutUserNestedInput
    questionsQuestionComments?: QuestionsQuestionCommentUpdateManyWithoutUserNestedInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUpdateManyWithoutUserNestedInput
    questionsAnswers?: QuestionsAnswerUpdateManyWithoutUserNestedInput
    questionsAnswerVotes?: QuestionsAnswerVoteUpdateManyWithoutUserNestedInput
    questionsAnswerComments?: QuestionsAnswerCommentUpdateManyWithoutUserNestedInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUpdateManyWithoutUserNestedInput
    offersDiscussion?: OffersReplyUpdateManyWithoutUserNestedInput
    questionsLists?: QuestionsListUpdateManyWithoutUserNestedInput
    OffersAdmin?: OffersAdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOffersProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
    resumesResumes?: ResumesResumeUncheckedUpdateManyWithoutUserNestedInput
    resumesStars?: ResumesStarUncheckedUpdateManyWithoutUserNestedInput
    resumesComments?: ResumesCommentUncheckedUpdateManyWithoutUserNestedInput
    resumesCommentVotes?: ResumesCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestions?: QuestionsQuestionUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionEncounters?: QuestionsQuestionEncounterUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionVotes?: QuestionsQuestionVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionComments?: QuestionsQuestionCommentUncheckedUpdateManyWithoutUserNestedInput
    questionsQuestionCommentVotes?: QuestionsQuestionCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswers?: QuestionsAnswerUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerVotes?: QuestionsAnswerVoteUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerComments?: QuestionsAnswerCommentUncheckedUpdateManyWithoutUserNestedInput
    questionsAnswerCommentVotes?: QuestionsAnswerCommentVoteUncheckedUpdateManyWithoutUserNestedInput
    offersDiscussion?: OffersReplyUncheckedUpdateManyWithoutUserNestedInput
    questionsLists?: QuestionsListUncheckedUpdateManyWithoutUserNestedInput
    OffersAdmin?: OffersAdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OffersSpecificYoeCreateManyBackgroundInput = {
    id?: string
    yoe: number
    domain: string
  }

  export type OffersExperienceCreateManyBackgroundInput = {
    id?: string
    companyId?: string | null
    jobType?: JobType | null
    title?: string | null
    durationInMonths?: number | null
    cityId?: string | null
    level?: string | null
    totalCompensationId?: string | null
    monthlySalaryId?: string | null
  }

  export type OffersEducationCreateManyBackgroundInput = {
    id?: string
    type?: string | null
    field?: string | null
    school?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
  }

  export type OffersSpecificYoeUpdateWithoutBackgroundInput = {
    id?: StringFieldUpdateOperationsInput | string
    yoe?: IntFieldUpdateOperationsInput | number
    domain?: StringFieldUpdateOperationsInput | string
  }

  export type OffersSpecificYoeUncheckedUpdateWithoutBackgroundInput = {
    id?: StringFieldUpdateOperationsInput | string
    yoe?: IntFieldUpdateOperationsInput | number
    domain?: StringFieldUpdateOperationsInput | string
  }

  export type OffersSpecificYoeUncheckedUpdateManyWithoutSpecificYoesInput = {
    id?: StringFieldUpdateOperationsInput | string
    yoe?: IntFieldUpdateOperationsInput | number
    domain?: StringFieldUpdateOperationsInput | string
  }

  export type OffersExperienceUpdateWithoutBackgroundInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: CompanyUpdateOneWithoutOffersExperienceNestedInput
    jobType?: NullableEnumJobTypeFieldUpdateOperationsInput | JobType | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    durationInMonths?: NullableIntFieldUpdateOperationsInput | number | null
    location?: CityUpdateOneWithoutOffersExperienceNestedInput
    level?: NullableStringFieldUpdateOperationsInput | string | null
    totalCompensation?: OffersCurrencyUpdateOneWithoutOffersExperienceTotalCompensationNestedInput
    monthlySalary?: OffersCurrencyUpdateOneWithoutOffersExperienceMonthlySalaryNestedInput
  }

  export type OffersExperienceUncheckedUpdateWithoutBackgroundInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    jobType?: NullableEnumJobTypeFieldUpdateOperationsInput | JobType | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    durationInMonths?: NullableIntFieldUpdateOperationsInput | number | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    totalCompensationId?: NullableStringFieldUpdateOperationsInput | string | null
    monthlySalaryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OffersExperienceUncheckedUpdateManyWithoutExperiencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    jobType?: NullableEnumJobTypeFieldUpdateOperationsInput | JobType | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    durationInMonths?: NullableIntFieldUpdateOperationsInput | number | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    totalCompensationId?: NullableStringFieldUpdateOperationsInput | string | null
    monthlySalaryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OffersEducationUpdateWithoutBackgroundInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    field?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OffersEducationUncheckedUpdateWithoutBackgroundInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    field?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OffersEducationUncheckedUpdateManyWithoutEducationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    field?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OffersReplyCreateManyReplyingToInput = {
    id?: string
    createdAt?: Date | string
    message: string
    profileId: string
    userId?: string | null
  }

  export type OffersReplyUpdateWithoutReplyingToInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    replies?: OffersReplyUpdateManyWithoutReplyingToNestedInput
    profile?: OffersProfileUpdateOneRequiredWithoutDiscussionNestedInput
    user?: UserUpdateOneWithoutOffersDiscussionNestedInput
  }

  export type OffersReplyUncheckedUpdateWithoutReplyingToInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    replies?: OffersReplyUncheckedUpdateManyWithoutReplyingToNestedInput
    profileId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OffersReplyUncheckedUpdateManyWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OffersAnalysisUnitCreateManyAnalysedOfferInput = {
    id?: string
    percentile: number
    noOfSimilarOffers: number
  }

  export type OffersAnalysisUnitUpdateWithoutTopSimilarOffersInput = {
    id?: StringFieldUpdateOperationsInput | string
    analysedOffer?: OffersOfferUpdateOneRequiredWithoutOffersAnalysisUnitNestedInput
    percentile?: FloatFieldUpdateOperationsInput | number
    noOfSimilarOffers?: IntFieldUpdateOperationsInput | number
    offersAnalysisOverall?: OffersAnalysisUpdateManyWithoutOverallAnalysisNestedInput
    offersAnalysisCompany?: OffersAnalysisUpdateManyWithoutCompanyAnalysisNestedInput
  }

  export type OffersAnalysisUnitUncheckedUpdateWithoutTopSimilarOffersInput = {
    id?: StringFieldUpdateOperationsInput | string
    analysedOfferId?: StringFieldUpdateOperationsInput | string
    percentile?: FloatFieldUpdateOperationsInput | number
    noOfSimilarOffers?: IntFieldUpdateOperationsInput | number
    offersAnalysisOverall?: OffersAnalysisUncheckedUpdateManyWithoutOverallAnalysisNestedInput
    offersAnalysisCompany?: OffersAnalysisUncheckedUpdateManyWithoutCompanyAnalysisNestedInput
  }

  export type OffersAnalysisUnitUncheckedUpdateManyWithoutOffersAnalysisUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    analysedOfferId?: StringFieldUpdateOperationsInput | string
    percentile?: FloatFieldUpdateOperationsInput | number
    noOfSimilarOffers?: IntFieldUpdateOperationsInput | number
  }

  export type OffersAnalysisUnitUpdateWithoutAnalysedOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    percentile?: FloatFieldUpdateOperationsInput | number
    noOfSimilarOffers?: IntFieldUpdateOperationsInput | number
    topSimilarOffers?: OffersOfferUpdateManyWithoutOffersAnalysisUnitNestedInput
    offersAnalysisOverall?: OffersAnalysisUpdateManyWithoutOverallAnalysisNestedInput
    offersAnalysisCompany?: OffersAnalysisUpdateManyWithoutCompanyAnalysisNestedInput
  }

  export type OffersAnalysisUnitUncheckedUpdateWithoutAnalysedOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    percentile?: FloatFieldUpdateOperationsInput | number
    noOfSimilarOffers?: IntFieldUpdateOperationsInput | number
    topSimilarOffers?: OffersOfferUncheckedUpdateManyWithoutOffersAnalysisUnitNestedInput
    offersAnalysisOverall?: OffersAnalysisUncheckedUpdateManyWithoutOverallAnalysisNestedInput
    offersAnalysisCompany?: OffersAnalysisUncheckedUpdateManyWithoutCompanyAnalysisNestedInput
  }

  export type OffersAnalysisUnitUpdateWithoutOffersAnalysisCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    analysedOffer?: OffersOfferUpdateOneRequiredWithoutOffersAnalysisUnitNestedInput
    percentile?: FloatFieldUpdateOperationsInput | number
    noOfSimilarOffers?: IntFieldUpdateOperationsInput | number
    topSimilarOffers?: OffersOfferUpdateManyWithoutOffersAnalysisUnitNestedInput
    offersAnalysisOverall?: OffersAnalysisUpdateManyWithoutOverallAnalysisNestedInput
  }

  export type OffersAnalysisUnitUncheckedUpdateWithoutOffersAnalysisCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    analysedOfferId?: StringFieldUpdateOperationsInput | string
    percentile?: FloatFieldUpdateOperationsInput | number
    noOfSimilarOffers?: IntFieldUpdateOperationsInput | number
    topSimilarOffers?: OffersOfferUncheckedUpdateManyWithoutOffersAnalysisUnitNestedInput
    offersAnalysisOverall?: OffersAnalysisUncheckedUpdateManyWithoutOverallAnalysisNestedInput
  }

  export type OffersAnalysisUnitUncheckedUpdateManyWithoutCompanyAnalysisInput = {
    id?: StringFieldUpdateOperationsInput | string
    analysedOfferId?: StringFieldUpdateOperationsInput | string
    percentile?: FloatFieldUpdateOperationsInput | number
    noOfSimilarOffers?: IntFieldUpdateOperationsInput | number
  }

  export type OffersAnalysisCreateManyOverallAnalysisInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId: string
    offerId: string
  }

  export type OffersOfferUncheckedUpdateManyWithoutTopSimilarOffersInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    monthYearReceived?: DateTimeFieldUpdateOperationsInput | Date | string
    negotiationStrategy?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | JobType
    offersInternId?: NullableStringFieldUpdateOperationsInput | string | null
    offersFullTimeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OffersAnalysisUpdateWithoutOverallAnalysisInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: OffersProfileUpdateOneRequiredWithoutAnalysisNestedInput
    overallHighestOffer?: OffersOfferUpdateOneRequiredWithoutOffersAnalysisNestedInput
    companyAnalysis?: OffersAnalysisUnitUpdateManyWithoutOffersAnalysisCompanyNestedInput
  }

  export type OffersAnalysisUncheckedUpdateWithoutOverallAnalysisInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: StringFieldUpdateOperationsInput | string
    offerId?: StringFieldUpdateOperationsInput | string
    companyAnalysis?: OffersAnalysisUnitUncheckedUpdateManyWithoutOffersAnalysisCompanyNestedInput
  }

  export type OffersAnalysisUncheckedUpdateManyWithoutOffersAnalysisOverallInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: StringFieldUpdateOperationsInput | string
    offerId?: StringFieldUpdateOperationsInput | string
  }

  export type OffersAnalysisUpdateWithoutCompanyAnalysisInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: OffersProfileUpdateOneRequiredWithoutAnalysisNestedInput
    overallHighestOffer?: OffersOfferUpdateOneRequiredWithoutOffersAnalysisNestedInput
    overallAnalysis?: OffersAnalysisUnitUpdateOneRequiredWithoutOffersAnalysisOverallNestedInput
  }

  export type OffersAnalysisUncheckedUpdateWithoutCompanyAnalysisInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: StringFieldUpdateOperationsInput | string
    offerId?: StringFieldUpdateOperationsInput | string
    overallAnalysisUnitId?: StringFieldUpdateOperationsInput | string
  }

  export type OffersAnalysisUncheckedUpdateManyWithoutOffersAnalysisCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: StringFieldUpdateOperationsInput | string
    offerId?: StringFieldUpdateOperationsInput | string
    overallAnalysisUnitId?: StringFieldUpdateOperationsInput | string
  }

  export type QuestionsQuestionEncounterCreateManyQuestionInput = {
    id?: string
    userId?: string | null
    companyId?: string | null
    countryId?: string | null
    stateId?: string | null
    cityId?: string | null
    role: string
    seenAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsQuestionVoteCreateManyQuestionInput = {
    id?: string
    userId?: string | null
    vote: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsQuestionCommentCreateManyQuestionInput = {
    id?: string
    userId?: string | null
    upvotes?: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsAnswerCreateManyQuestionInput = {
    id?: string
    userId?: string | null
    content: string
    upvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsListQuestionEntryCreateManyQuestionInput = {
    id?: string
    listId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsQuestionEncounterUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    seenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: CountryUpdateOneWithoutQuestionsQuestionEncountersNestedInput
    state?: StateUpdateOneWithoutQuestionsQuestionEncountersNestedInput
    city?: CityUpdateOneWithoutQuestionsQuestionEncountersNestedInput
    company?: CompanyUpdateOneWithoutQuestionsQuestionEncounterNestedInput
    user?: UserUpdateOneWithoutQuestionsQuestionEncountersNestedInput
  }

  export type QuestionsQuestionEncounterUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    countryId?: NullableStringFieldUpdateOperationsInput | string | null
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    seenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsQuestionEncounterUncheckedUpdateManyWithoutEncountersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    countryId?: NullableStringFieldUpdateOperationsInput | string | null
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    seenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsQuestionVoteUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    vote?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutQuestionsQuestionVotesNestedInput
  }

  export type QuestionsQuestionVoteUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    vote?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsQuestionVoteUncheckedUpdateManyWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    vote?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsQuestionCommentUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutQuestionsQuestionCommentsNestedInput
    votes?: QuestionsQuestionCommentVoteUpdateManyWithoutCommentNestedInput
  }

  export type QuestionsQuestionCommentUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: QuestionsQuestionCommentVoteUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type QuestionsQuestionCommentUncheckedUpdateManyWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsAnswerUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutQuestionsAnswersNestedInput
    votes?: QuestionsAnswerVoteUpdateManyWithoutAnswerNestedInput
    comments?: QuestionsAnswerCommentUpdateManyWithoutAnswerNestedInput
  }

  export type QuestionsAnswerUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: QuestionsAnswerVoteUncheckedUpdateManyWithoutAnswerNestedInput
    comments?: QuestionsAnswerCommentUncheckedUpdateManyWithoutAnswerNestedInput
  }

  export type QuestionsAnswerUncheckedUpdateManyWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsListQuestionEntryUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    list?: QuestionsListUpdateOneRequiredWithoutQuestionEntriesNestedInput
  }

  export type QuestionsListQuestionEntryUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    listId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsListQuestionEntryUncheckedUpdateManyWithoutQuestionsListQuestionEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    listId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsQuestionCommentVoteCreateManyCommentInput = {
    id?: string
    userId?: string | null
    vote: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsQuestionCommentVoteUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    vote?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutQuestionsQuestionCommentVotesNestedInput
  }

  export type QuestionsQuestionCommentVoteUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    vote?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsQuestionCommentVoteUncheckedUpdateManyWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    vote?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsAnswerVoteCreateManyAnswerInput = {
    id?: string
    userId?: string | null
    vote: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsAnswerCommentCreateManyAnswerInput = {
    id?: string
    userId?: string | null
    content: string
    upvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsAnswerVoteUpdateWithoutAnswerInput = {
    id?: StringFieldUpdateOperationsInput | string
    vote?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutQuestionsAnswerVotesNestedInput
  }

  export type QuestionsAnswerVoteUncheckedUpdateWithoutAnswerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    vote?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsAnswerVoteUncheckedUpdateManyWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    vote?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsAnswerCommentUpdateWithoutAnswerInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutQuestionsAnswerCommentsNestedInput
    votes?: QuestionsAnswerCommentVoteUpdateManyWithoutCommentNestedInput
  }

  export type QuestionsAnswerCommentUncheckedUpdateWithoutAnswerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: QuestionsAnswerCommentVoteUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type QuestionsAnswerCommentUncheckedUpdateManyWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsAnswerCommentVoteCreateManyCommentInput = {
    id?: string
    userId?: string | null
    vote: Vote
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsAnswerCommentVoteUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    vote?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutQuestionsAnswerCommentVotesNestedInput
  }

  export type QuestionsAnswerCommentVoteUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    vote?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsAnswerCommentVoteUncheckedUpdateManyWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    vote?: EnumVoteFieldUpdateOperationsInput | Vote
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsListQuestionEntryCreateManyListInput = {
    id?: string
    questionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionsListQuestionEntryUpdateWithoutListInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: QuestionsQuestionUpdateOneRequiredWithoutQuestionsListQuestionEntriesNestedInput
  }

  export type QuestionsListQuestionEntryUncheckedUpdateWithoutListInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsListQuestionEntryUncheckedUpdateManyWithoutQuestionEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}